토비의스프링
3.1

1Vol. 11 스프링의 이해와 원리


Copyright @ acorn publishing Co., 2012. All rights reserved

이 책은 에이콘출판(주)가 저작권자 이일민과 정식 계약하여 발행한 책이므로
이 책의 일부나 전체 내용을 무단으로 복사， 복제 전재하는 것은 저작권법에 저촉됩니다
저자와의 협의에 의해 인지는 불이지 않습니다


토비의스프링
3.1

1Vol. 11 스프림의 이해와 원리

이일민지음

i!i

여‘
01훌


:E첸갖
:r토비의 스프링 3.1 Jl 출간을 축:01하며

최근 들어 공공， 금융과 같은 SI 영역에서 스프링이 사실상의 표준으로 채택되기 시작
하면서. SI업체나 예비 개발지들 싸l에서 스프링을 제대로 공부하자는 분위기가 확산
되고 있습니다. 스프링에 관심을 가졌던 개발자라면 스프링 전도사인 토비님과 그의 오
랜 경험이 그대로 녹아 있는 이 책을 잘 알고 있을 댄데요. 그래서인지 곳곳에서 스프
링 스터디가 아닌 r토비의 스프링 3J 스터디 모임 공지를 흔히 보게 됩니다. 저 또한 주
변에서 스프링을 공부하겠노라며 책을 추천해달라고 하면 이 책 한 권으로 충분하다고
100%자신 있게 권합니다.

스프링 활용법뿐 아니라 그 원리까지 쉽게 이해할 수 있도록 풀어서 설명하는 이 책
은 대규모 프로젝트에서 정형화된 업무 로직의 반복된 구현에 지친 SI 개발자들에게
학습의 즐거움과 더 나은 코드를 만들어가는 과정에서 실력이 늘어가는 개발의 재미를
다시금 느끼게 해줄 것입니다. 최근 들어서는 3.0에서 3.1，
3.2로 발전해나가는 스프링
의 발전 방향을 눈여겨보는 분들도 많을 것입니다. 이처럼 매우 적절한 시기에 스프링

3.1
을다루는증보판까지 나온다니， 클라우드， 빅데이터 등점점 복잡해지는
IT
환경의
변화를 수용하기 위해 스프링이 어떻게 변해가는지도 이 책을 통해 엿볼 수 있을 것입
니다.
-김승권 / 금융 분야 독립 컨설턴트

국내에는 능력이 출중한 개발자들이 많습니다. 하지만 이들이 각자의 개발 특성에 따라
개벌하기 때문에， 통합과 재활용의 어려움이 많았지요. 그래서 개발을 더 펀안하고， 정
확하게 할 수 있는 개발 프레임워크가 필요했습니다. 그중 가장 많이 활용되는 스프링
은 개발 프레임워크의 길을 인도해주었습니다. 스프링은 많은 개발자가 함께 만들어가
는 오픈소스 커뮤니티를 기반으로 만들어진 훌륭한 작품으로 앞으로도 지속적으로 발
전해 개발자를 이롭게 할 것입니다. 특히 저자인 이일민 씨는 국내의 많은 개발자를 위
해 커뮤티니 활동과 강연을 통해 활동히는 적극적인 개발자 벤토로， 이 책을 통해 다양
한 지식과 경험을 나눌 것입니다. 이 책을 기반으로 많은 개발자가 글로벌 개발자로 발
전해가기를바랍니다.

-송상효 / 효백공개소프트웨어협회 회장


r토비의 스프링 3
J
을만난지 벌써 l
년이 훨씬 넘었습니다. 이 책은스프링의 사용법이
라는 지식뿐만 아니라 어떻게 하면 엔터프라이즈 자바 프로그래밍을 더 유연하게 할 수
있는지， 스프링을 샤용하다가 봉착한 문제에 당황하지 않고 어떻게 대처할지 등에 대한
지혜도 전해주는 전 세계에서 가장독보적인 스프링 책입니다.

이 책을 통해 제가 전수받은 지식은 우리 프로젝트의 수많은 부분에 코드로 독아 들
어갔으며， 이 책에 담긴 지혜는 책에 없는 막막한 상횡을 만났을 때 부드렵게 문제를 해
결할 수 있는 통찰력이 되어줬습니다. 저뿐만 아니라 우리나라의 많은 자바 프로그래머
에게도， 또한 프로그래밍 언어와 무관하게 객체지향 프로그래밍을 하는 모든 사람에게
이 책은 지식의 보고이자 지혜의 샘이 되어줄 것이라 믿습니다.

-손권남 / 엑스엘게임즈 웹서비스팀

토비님의 블로그를 통해 r토비의 스프링 3.1 책의 집펼 소식을 알게 되었고， 책이 나오기
를 오랫동안 기다렸다. 인쇄 사고로 배송이 지연되는 애태우는 일정 끝에 책을 받이들
었을 때는 비싼 전자기기를 샀을 때보다 더 뿌듯했다. 바로 다음 날부터 무거운 책을 출
퇴근길에 들고 다니며 완독을 했다. 고뇌해서 풀어 쓰고 다듬었음이 분명한， 매끄러운
문장과 친절한 설명에서 저자의 헌신이 느껴졌다. 저자의 열정을 잘 표현한 책이었다.
기대한 만큼 이 책의 열풍은 대단했다. 회사에서 파견 나간 곳에서， 곳곳의 책상에 r토
비의 스프링 3.1 책이 놓여 있었고， 스프링과 이 책이 포탈업계와 SI
업계의 개발자를 이
어주는 주제라는 생각까지도 들었다.TDD 교육 과정의 사내 강사를 하면서도 이 책을
줄곧추천했다.

스프링의 아버지 로드 존슨은 “객체지향 설계는 특정 구현 기술보다， 심지어 자바보
다도 더 중요하다”고 말했다
r토비의 스프링 3
.1은 그 가치를 잘 담아냈다. 테스트하기
쉬운 묘드， 구성요소의 역할과 책임을 섬세하게 나누는 설계 등 이 책에서 강조하는 기
법은 프로그래밍을 하는 사람이면 누구나 새겨볼 만한 내용이다. 그에 비해 어쩌면 최
신 기술의 소개라는측면은부차적일지도모른다. 그럼에도 최신 스프링 3.1
에 맞춰 개
정판이 나옹다는 소식은 반갑기 그지없다. 이제 이 책이 단순히 흘러기는 트렌드를 잡
는 책이 아니라 「수학의 정석」처럼 꾸준히 개정되며 늘 우리에게 지식과 통찰을 주는 스
태디셀러로 자리 잡기를 기원한다.

-정상혁 / NHN Technology Service 신규서비스 개발텀 차장


얼마 전 모 공공기관의 ISP 결과에 대해 조언을 하는 자리에 초청을 받은 일이 있다. 기
반 프레임워크 후보로 스프링과 전자정부 프레임워크를 선정하고 해당 조직과 업무에
맞는 적용 방법을 논하는 자리였다. 전자정부 프레임워크도 스프링에 기반을 둔 것이기
때문에 KSUG를 통해 보급하려고 애쓴 우리의 노력이 결실을 보는 듯해 흐뭇했다.

로드 존슨이 직접 쓴 책을 제외하면 스프링에 대해 r토비의 스프링 3
J만큼 고민한 내
용을 담은 책은 없다. 이미 많은 개발자에게 안내자 역할과 함께 영감을 준 책이 다시

3.1
의 새로운기능을다루는증보판으로돌아온것은흡사
3D가없던 시절의 흥행 대작
을 3D로 다시 개봉할 때 만나는 기쁨과 비교할 수 있지 않을까? 모쪼록 저자의 각고의
노력을 통해 나온 책인 만큼 많은 분에게 잘 쓰이길 바란다.
-안영회 / 개발자콘서트(htlp:μgaecon.com/) 만든 이. 아이티와이즈컨설팅 이사


:펄『토비의 스프링 3
J
추천의 골

한국스프링사용자모임
KSUG 활동이나 프레임워크 전문가로 일하는 탓에 많은 사람에
게 스프링 프레임워크 서적 추천 요구를 받아왔지만 그때마다 기대히는 명쾌한 답
을 줄 수 없었다. 대답은 늘 이런 식이었다. “설계 시상을 이해하시려면 로드 존슨Rod
Johnson이 쓴 세 권의 빨간 표지 책이 가장 좋습니다
. 다만， 영문으로 써 있고 설명이 쉽
지 않습니다. 한글로 쓰인 책 중에서는 。。。는 개념 설명은 좋은데 실제 상뺑서 문

제 푸는 데 도움을 받기에는 부족합니다!:::，.!:::，.!:::，.는 웹에 있는 공식 참조 문서
Relerence

Documentation를 기준으로 개괄적인 내용을 정리한 책입니다. 처음 따라 할 의도라면
xxx가 좋습니다 구구절절히 설명한 까닭은 자신 있게 추천할 수 있는 한글 책이 없
기 때문이었다. 그러나 앞으로는 자신 있게 이 책을 추천할 수 있어 흐뭇하다.

저자인 이일민 씨를 아는 사람에게는 긴 설명이 필요 없겠지만， 잘 모르는 분을 위해
이 책의 고유한 가치를 몇 가지 떠올려봤다.

첫째， 뛰어난 강사이기도 한 저자의 효과적인 강의 스타일을 담。}낸 책의 이야기 전
개다. 저지는 대뜸 스프링이 가진 기술을 나열하기보단 친숙한 자바 코드(초난감 DAO)를
내밀었다. 책을 읽어가면 점차 독자는 흔히 쓰이던 코드의 문제점에 공감하고， 여러 가
지 방식으로 개선해가는 여정을 함께한다. 책과 함께 고민한 독자라면 여정의 끝에서
스프링을 쓰는 이유와 어떤 게 올바른 사용법인지 배울 수 있다. 사실 이런 전개는 정말
뛰어난 외국 서적에서는 종종 볼 수 있는 방식이지만 한글 기술서로 한정하면 가히 독
보적이라할수었다.

둘째， 사상과 활용법을 모두 담은 넓은 효용정이다. 시중에 두꺼운 기술서는 드물지
않지만， 이 책은 API 설명이나 화면 캡처로 지변을 할애하지 않았다. 책 전반부는 객체
지향 프로그래밍 관점에서 어떤 코드가 좋은 코드인지를 다루면서 왜 스프링을 써야 하
는지를 설명하고， 후반부는 스프링을 구성하는 요소 기술을 올바르게 사용하는 방법을
빠짐없이 설명하고 있음을 상기하면 책의 두께는 놀랍도록 짧.j-m. 학습과제에만 초점
을 맞출 수 있도록 구성한 장의 구성과 단계별 예제는 SoCSeparation 01 Concerns를 통해
방대한 내용을 모두 담아내기 위해 저자가 각고해 노력한 결괴물이다.

셋째， 책의 내용과 예제 묘드의 정확함어다. 프로그래밍 서적으로 공부할 때 예제가
작동하지 않아시간을허비한경험이 있는개발자는드물지 않다. 1
부는테스트주도로
진행하고，
2부도 예제 전부가 테스트 코드 형태로 만들어져 결함을 막았다. 한편 개념
설명을 위해 다이어그랩을 활용하고 묘드에도 충분한 부연 설명을 붙인 결과， 섬세하고
정확한내용이 만들어졌다.

8


나름대로 객관적인 시각으로 책의 가치를 정리했더니 책을 볼 때 느낀 감동은 잘 드
러나지 않아 개인적인 소회를 덧붙인다. 변변한 책이 없던 시절 스프링을 이해하기 위
해 어쩔 수 없이 스프링 소스코드를 봤다. 스프링 소스코드는 객체를 조직화하는 설계
에 대한 모범답안과도 같았다. 하지만 방대한 코드만 보고 의도를 모두 익힐 수는 없었
다. 그 후에 로드 존슨의 책을 반복해 읽으면서 스프링을 이해할수록 감탄하고 또 감탄
했다. 다행스럽게도 지금 스프링을 공부하는 여러분에게는 더 나은 방법을 제시할 수
있다. 로드 존슨이 했던 이야기를 로드 존슨은 할 수 없는 우리말로 읽을 수 있다. 그리
고 진정한 고수 개발자로 꾸준히 노력해온 이일민 씨의 노하우를 함께 배울 수 있다.

이일민 씨는 한국스프링시용자모임의 공동 설립자다.2007년 우리는 수차례 공개 세
미나를 통해 스프링을 알렸다. 이 책은 그의 수많은 고민과 생각을 그러모아 담아낸 결
정체다. 지금보다 많은 자바 개발자가 이 책을 읽고 진정한 설계에 대해 고민을 함께 하
는모습을상%빼본다. 그리고이일민씨의 다음행보를기대한다. :)

-안영회
(htlp
://younghoe.inf이
한국스프링사용자모임공동설립자. (주)아이티와01즈컨설팅 컨설턴트

엔터프라이즈 애플리케이션의 업무 난이도는 증가하고 있으며 시용자의 눈높이는 지속
적으로 높아지고 있다. 하지만 자바 기술〈특히 JEE)은 이 같은 요구사항을 만족시키기에
기술적으로 점점 더 복잡해져 가고 있는 것이 현실이다. 자바를 기반으로 엔터프라이즈
애플리케이션을 개벌하려면 많은 학습 시간과 경험을 필요로 한다. 스프링은 2008년
SpringOne에서 자비를 기반으로 한 엔터프라이즈 애플리케이션 개발에 대한 복잡도와
의전쟁을선포했다.

스프령이 자바 복잡도와의 전쟁을 선포할 수 있었던 가장 큰 이유는 스프링의 단순
함과 유연성 때문이다. 스프링은 이 같은 단순함과 유연성을 기반으로 개발자에게 점점
더 많은 편의를 제공하고 있으며， 엔터프라이즈 애플리케이션 개발에 필요한 여러 개의
하위 프로젝트까지 발전하고 있는 상태다. 이 같은 스프링의 발전은 오히려 자바 개발
자에게 또 하나의 복잡함으로 인식되고 있다. 하지만 스프령의 핵심 가치를 이해한다면

복잡함으로 인식됐던 부분이 단순함과 유연성 때문임을 느찔 수 있을 것이다.

이 책은 스프링의 핵심 가치를 전달하는 데 집중하고 있다. 로드 존슨이 쓴 η2EE


Development without EJBJ 이후로 지금까지 출간된 스프링 서적 중에서 이 책만큼 스
프링의 핵심 가치를 제대로 전달한 책은 보지 못했다. 이 책은 스프링을 사용하지 않더
라도 자바를 기반으로 애플리케이션을 개발하는 모든 개발자가 읽어야 하는 책이다. 그
만큼 자바가 추구하도l자 하는 핵심 가치에 집중하고 있는 책이다. 특히 이 책의 모든 소
스코드에는 태스트 코드가 함께 들어 있다. 이는 태스트하기 쉬운 코드를 만들도록 유
도하는 스프령의 강점을 보여주면서 테스트의 중요성을 자연스럽게 이야기하려는 저자
의의도이리라.

자바 기반의 엔터프라이즈 개발은 지금까지 많은 우여곡절을 겪으면서 먼 길을 돌아
왔다. 이 책으로 인해 자바가 추구하그l자 했던 초심으로 돌아갈 수 있는 계기가 됐으면
하는바람이다.

-박재성 / XLGames 웹 서비스 개발자

지난 10회 한국 스프링 사용자 모임 세미나 도입부 때 개회사를 겸한 간단한 발표를 하
면서 저는 두 가지를 말했습니다. 스프링이 단순한 프레임워크가 아닌 플랫폼으로 발
전했다는 사실과， 그럼에도 초기 스프링의 철학은 여전히 유효하고 더욱 강조돼야 하며
스프링 자체보다 중요하다는 점입니다.

스프링 사이트의 스프링 소개About Spring에서 확인할 수 있는 이 철학을 지금까지 로
드 존스의 책을 제외한 어떤 스프링 관련 책에서도 충분히 다루지 않았습니다. 그래서
많은사람이 스프링이 주는 이점과즐거움을누리지 못하면서 스프링을쓰고 있습니다.
고맙게도 이일민 씨는 스프링이 무엇인지 명시적으로 설명하기를 8장으로 미루고 그보
다 먼저， 친절하고 쉽게 그리고 감동적으로 스프링의 배경
(뽑 객체지향 기법과 우수 실천법
)을
설명합니다.

이 책의 l
징F에서 초난감 DAO 객체에 객체지향 원리를 적용해 개선하면서 자연스럽
게 스프링으로 넘어가는 과정은 마치 마틴 따울러의 r리팩토링
J 1
장을 보는 듯합니다.
그리고 풍부한 객체지향 원리와 기법 설명을 접할 때는 로버트 C. 마틴의 'lJML, 실전
에서는 이것만쓴다J를 읽었을 때의 감동이 다시 생각났습니다.

이일민 씨는 뛰어난 개발자이고 완벽주의자인 동시에 타고난 이야기문입니다. 전 이
책을 눈으로 읽으면서도 어떻게 이렇게 다OJ"하고 방대한 내용이 한 책으로 엮일 수 있
는지 이해할 수가 없습니다. 스프링을 닮은 책입니다.

-박성철 / 한국 스프링 사용자 모임 큰일문


스프링을 처음 본 게 2003
년이었는데 그때만 해도 아무도 지금처럼 스프링이 전 세계
애플리케이션 개발 시7.J에서 가장 영향력 있는 프레입워크로 성장하리라고 예측하지는
못했던 것 같다. 스프링이 성공할 수 있었던 가장 큰 요인 중 하나는 객체지향 원칙을
충실히 지켜내면서도 더 나G까 개발자의 지율성과 창의성을 극대화할 수 있는 유연한
구조를 지니고 있기 때문이다. 이 책은 스프령이 추구했던 이러한 내면의 원칙을 현실
과 잘 맞추어 풀어낸 한 편의 흥미진진한 소설과도 같다. 이 시대의 아키텍트나 개발자
라면 반드시 한 번은 목 읽어봐야 할 책이다.

-김창제 / 삼성 SDS 수석. Anyframe Java 기획 -개발 층궐

스프링은 이제 자바 개발의 펼수 프레임워크로 자리 잡았다. 스프링은 자바의 객체지향
적 사과+ 애자일한 가치를 구현한 프레임워크이지만 대부분 개발지는 펼요한 댐플릿
을 수정하기만 할 뿐 스프링 프레임워크가 지향히는 가치와 동작원리를 충분히 이해하
지 못한 채로 시용하고 있다. 이 책은 스프링을 배우는 데 필요한 DAO, AOP 같은 중
요 개념의 이해를 시작으로 실전 프로젝트에 적용히는 방법까지 체계적으로 다루고 있
다. 그리고 스프링의 학습법까지 친절히 다루는 등 곳곳에 저자 이일민 씨의 숨은 노력
과 배려가 깃든 책으로 자바 개발자라면 꼭 읽어보길 권한다.

-옥상훈 / 저
14대 효팩자바개발자 협의회 회장. 현 한국SW아키텍트 연합 공동회장

그동안 구글 버즈를 통해 토비님의 스프링 책 집필 소식을 접해오던 차에 출판사인 에
이콘으로부터 추천사 요청을 받고 만감이 교차했습니다.

먼저， 저는 스프링을 전혀 모릅니다. J2EE 1,4, JavaEE 5, 그리고 JavaEE 6까지， 기
술 표준과 구현에 참여하고 관심을 둬왔던 저로서는， JavaEE
<특히 EJB
)의 안티태제로 시
작한 스프링에 어느 정도 반감이 있었고 그래서 의도적으로 알려 하기를 꺼렸습니다.

하지만 티맥스를 떠나 오픈마루에서 웹 서비스 개발을 하게 되자 스프링은 당면한
과제가 돼버렸습니다. 루비온레일스로 비켜가 보기도 했지만 결국 자바 플랫폼으로 가
게 됐습니다. 제가 아무리 JavaEE만으로 개발하자고 주장해도， 결국 스프링을 채택하
기에이르렀습니다.


토비님의 블로그 또한 자바와 비자바를 떠나 많은 개발자에게 감명을 췄습니다. 그
리고 그 이변에 담긴 JavaEE의 한계와 문제점은 실은 저를 부끄럽게 만들기 충분했지
요. 무엇보다도 그 갚이， 토비님이 보여주신 그 갚이가 저는 한없이 부러웠고 존경스러
웠습니다. 저는 이 책의 l
장을 읽었습니다. 이제서야 스프링이 뭔지를 겨우 알아가게
되다니， 마치 요새 “맥주 맛도 모르면서”의 광고 카피처럼 말입니다.

저는 솔직히， 추천사를 쓸 자격이 없습니다. 그런데도 이렇게 졸필을 남기는 이유는，
거절을 잘 못하는 성정 탓이기도 하지만， 그동안 품어왔던 경외를 표하는 것이 이 공전
절후할 책의 출간에 있어 제가 할 수 있는 유일한 이바지라고 여기기 때문입니다.

이 책이 독자에게 영감과 격려를 주리라 믿습니다.

-이창신 / ias(jNDIE aPPLlCATION sOFTWARE) 대표

먼저， 기다려온 스프링 3 서적의 출간을 축하합니다. 스프링 2.5 버전을 경험했던 사람
으로 달라진 기능은 무엇인지， 하위 벼전과의 호환성 보장을 위해 어떻게 확장되고 발
전됐는지， 새로운 버전이 나올 때마다 갖게 되는 궁금증에 대해 명쾌한 해답을 얻을 수
있는 좋은 기회가 됐습니다. 또한 스프링의 각 개념이 예제 중심으로 잘 설명되어 있어
스프링을 처음 접하는 분들도 쉽게 다가갈 수 있으리라 생각되며， 이전 벼전 경험자 분
들에게는 스프링이 확장 포인트를 어떻게 웅용하면서 업그레이드됐는지 배울 수 있는
좋은 기회가 되리라 생각합니다. 다시 한 번 r토비의 스프링 3J 출간을 축하하며， 스프
링을 도입하거나 스프링 3
.
0으로 버전 업그레이드를 고려하고 있는 많은 개발자의 고민
을 조금이나마 덜어줄 수 있기를 기대합니다.

-이봉옥 책임 / 전자정부 표준프레임원크 커미터 삼성SDS

언젠가 토비님과 대화를 나누며， 스프링이 주는 많은 자유도로 인해 개발자들이 어떻게
해야 할지 길을 잃게 되지는 않을까 우려 섞인 이야기를 한 적이 있다. 처음 시작하는
사람들， 그리고 스프링을 좀 더 잘 써보고자 하는 개발자에게 이 책은 스프링이 제공하
는 진정한 가치를 같이 누릴 수 있도록 안내하는 어두운 밤바다의 등대 같은 이정표가
될것이라확신한다.


이 책을 통해 개발자들은 리팩토령과 디자인 패턴 객체지향 핵심 원칙도 자연스럽
게 접하면서， 책에 담긴 내용을 자신의 것으로 받이들일 것이라고 생각한다. 원칙과 코
드를 잘 어울리게 설명한 대목에서는 누구나 내공을 느끼게 할 만큼 쉽고 깊이 있게 풀
어낸 책이기에， 초보 개발자는 물론 연차가 오래됐지만 기초가 부족하다고 느끼는 개발
자에게 적극적으로 권해주고 싶다.

독자들이 이 책을 마칠 즈음엔 스프링을 배우러 왔다가 객체지향이라는 월척을 낚았
다고 웃으며 책장을 덮게 될 것이라고 확신한다. 아울러 지금까지 써왔던 방식과 달리
스프링에서 주고자 했던 핵심 가치를 느끼며 코딩하고 있는 자신을 발견하리라고 조심
스럽게상상해본다.

-앙수열 / 인피언컨설팅 연구소장，
JCO 3대회장 · 현 고문

한국은 좋은 IT 저서가 출간되기에 그다지 좋은 환경이 아닙니다. 해외 주요 국가들에
비해 시장이 적은 것은 물론이고 책 값 또한 낮은 탓입니다. 경제적인 이익만 고려한다
면 애당초 가능하지 않은 일입니다. 그럼에도 불구하고 뭇있는 개발자와 출판사들의 노
력으로 이처럼 좋은 책들이 끊임없이 출간됨에 늘 감사합니다.

집필 기간 3
년， 1400페이지에 달히는 방대한 분량은 잘 팔리는 책보다는 쪽 필요한
책을 만들겠다는 에이콘의 출판 철학과 토비 형님의 열정이 있었기에 가능했습니다. 사
실 이 책의 계약에 어느 정도 가담한 저 또한 중간에 책이 잘못될까 봐 얼마나 마음을 졸
였는지 모릅니다. 에이콘 출판사와 토비 형님의 열정과 노고에 응원기를 불러드립니다.

저는 스프링은 잘 모르지만 토비 형님과 에이콘 출판시를 잘 알기에 이 책을 자신 있
게 권해드릴 수 있습니다. 토비 형님은 어려운 내용을 쉽게 설명하는 마력을 가진 사람입
니다. 사실 쉬운 내용도 어렵게 설명하는 분들이 워낙 많기에 그의 글이 더욱 빛납니다.

두개의 부로구성된 이 책의 l
부는그의 그런장점을잘녹여내어 처음시작하는자
바 개발자도 쉽게 내용을 이해할 수 있습니다，
2부는 실제 프로젝트에 적용하는 데 필요
한 내용을 담고 있습니다. 또한 고심에 고심을 거듭하여 만든 예제들은 프로젝트를 진
행하는데 적잖은도움을드릴 것입니다.

이 책을 구입한 모든 분들이 한 단계 더 발전히는 좋은 계기가 되길 뻐+겠습니다.

대한민국개발자따이팅!

-정희용 / 월간 마이크로소프트웨어 발행인


나는 이 책을， 기술적 검증 리뷰를 위해 한 번， 강의를 준비하며 또 한 번， 처음부터 끝
까지 두 번 완독했다. 읽을 때마다 느낌은 모두 새로웠지만， 이 책으로 스프링 공부를
시작하는 분들이 정말 부렵다는 생각은 한결같았다.

책을 펴기도 전에，
1400페이지가 넘는 이 책의 두께와 무게에 지레 겁을 먹은 독자분
도 있을 것이다. 하지만 걱정하지 말자. 이 책이 이토록 두껍고 무거워진 건 모두 다 우
리를 위한 배려 때문이고， 그 방대한 %면f큼이나 매우 친절한 책이다. 스프링을 학습하
는 데 있어 중요한 내용을 이렇게까지 차근치근 그리고 점진적으로 쉽게 설명해주는 책
은 여태 없었다. 진작에 이런 책으로 스프링 공부를 시작했다면 내가 스프링에 쏟아온
학습 시간이 한층줄어들었을 게 분명하다.

이 책의 가치는 여러 번 반복해 읽었을 때 더욱 빛을 발한다. 저자의 의도는 단순히
스프링을 설명하는 데 그치지 않는다. 이 책에서는 객체지향적인 코드， 프레임워크의
개념 정립， 태스트가 주는 장점 등을 고스란히 엿볼 수 있다. 물론 우리가 스프링만 가
지고서는 아무것도 할 수 없다. 결국은 다른 코드와 버무려 맛있는 코드를 만들어야 한
다. 이를 간파한 저지는 바로 그때 어떻게 하면 개발자들이 좀 더 가치 있고 유익한 코
드를 작성할 수 있는지 이 책에서 잘 설명한다. 탑을 하나 더 드리자면， 부록 CD에 들
어 있는 소스코드는 목 확인하기 바란다. 니중에 기회가 되면 봄싹 모임에서 스터디로
진행하고 싶을 정도로 멋지고 유용한 코드가 독자를 기다린다. 마치 잠자는 책 속의 코

드처럼 ...

-백기선 / 봄싹 커뮤니
EI(htlp://springsproul.org) 대표， 스프링프레임워크 강사


.. 했저자소개

이 일민 tobyilee@gmail.com

호주의 IT 서비스 기업인 이프릴의 대표 컨설턴트다. 엔터프라이즈 오푼소스 커뮤니
티인 오픈시드의 대표이며 한국스프링시용자모임
KSUG
의 공동설립자이기도 하다. 8
비
트 컴퓨터 시절 프로그래밍의 매력에 빠져 10
여 년간 취미로 프로그래밍을 즐겨오다 전
문 개발자의 길로 들어서서 19년째 소프트웨어 개발과 교육 컨설팅 일을 해오고 있다.
2004년부터 스프링을 이용해서 기업과 학교， 인터넷 서비스 업체의 시스탬을 개발해왔
고 스프링을 기반으로 한 애플리케이션 프레임워크 제작 컨설팅과 스프링 개발자 교육
을 해오고 었다. JCO 컨퍼런스에서 세 차례 스프링을 주제로 발표했고 기묘， 이프릴，
KSUG 등을 통해 스프링 세미나를 진행하기도 했다. 스프링과 오픈소스 기술에 관련된
정보와 경험을 공유하는 블로그(toby
.
epril
.
com
)를 운영하고 있다.



첸객:11"토비의 스프링 3.1..0 출간에 부쳐

r토비의 스프링 3
.1은 원래 3부로 기획했던 책이다. 핵심 기술의 이해， 기술의 선택， 프레
임워크 확장이라는 세 단계를 통해 스프링을 설명하는 책을 쓰기 시작했다. 하지만 원
래 간결하게 설명하는 능력이 부족한 탓인지， 친절하고 자세히 설명해야 한다는 강박관
념 때문인지 2부까지만 쓰고 마무리했는데도 처음 생각했던 것보다 훨씬 많은 분량의
글이 나와 제법 묵직하고 두꺼운 책을 발간하게 되었다. 독자분들은 두꺼운 책이라 휴
대하기 힘들어하시기는 했지만 그래도 1
부 2부 두 단계로 스프링을 학습하도록 구성

한 방식에 많은 분이 만족해주셨다.
개정판을 준비하면서 스프링 3.1
의 새로운 기능을 소개하려고 내용을 추가하니 책

분량은 훨씬 더 늘어났고 더 이상은 한 권으로 책을 내기가 어려워졌다. 그래서 스프링
의 원리와 이해를 다룬 l
부의 내용을 중심으로 한 권을， 또 스프링의 기술과 활용 전략
을 다룬 내용을 중심으로 다른 한 권을 만들어 두 권으로 분리하게 됐다. 지금까지 가장
많이 받은 독자 피드백이 휴대성이 좋도록 책을 분권해달라고 하는 것이었는데 그 요청

을들어드릴 수 있게도 되었다.

스프링 3.1
이 나온 지도 제법 시간이 흐르긴 했지만 아직도 현징L에서는 스프링 3.0
을 이용하는 경우가 대부분이고， 이제야 스프링 2.5
에서 3
.
0으로 이전하는 곳도 많다고
한다. 그래서 이 책에서는 전체 내용을 스프링 3.1
을 기준으로 바꾸는 대신， 스프링 3.0
과 스프링 3.1 내용을 함께 담아냈다. Vol. 1에서는 스프링 3
.0을 기준으로 예제를 작
성하는기존내용을그대로두고후반부에 이 예제를스프링 3.1
의 새로운기술을적용
해서 업그레이드하는방법을설명한다.Vi이.2에서는스프링 3.0과스프링 3.1에 동일
하게 적용되는 내용은 그대로 두고 각 장 마지막에 스프링 3.1 의 새로운 기술이나 변경
사헝을 집중적으로 다뤘다. 그래서 당장 스프링 3.0으로 프로젝트를 진행하면서 필요한
내용을 참조하시려는 분은 물론 기존 프로젝트를 스프링 3.1
로 업그레이드하거나 3.1
로 새로운 프로젝트를 작성하실 분까지 모두 참고할 수 있게 만들었다.

스프링이 이제는 자바 개발자들의 필수 기술이 되었다는 이야기가 들린다. 스프링의
위상이 높아지고 가치가 인정받는 것 같아 기쁘다. 그저 스프링에 대한 지식을 많이 쌓
은 스프링 전문가보다는 스프링의 도움으로 애플리케이션 개발을 잘 히는 개발X까 점
점 더 많아지기를 기대한다.

이일민

16


.. 헬띈『토비의 스프링 3
.n
저자으l 말

나는 스프링에게 고n뽑을 느낀다. 스프링을 통해 이전보다 좀 더 나은 개발자가 됐다
고 생각하기 때문이다. 스프링은 그저 폼 나는 최신 기술을 사용해서 고객이 원히는 기
능만 적당히 빠르게 만들어내면 충분하다고 생각해옹 나에게 기본으로 돌아가서 원칙
에 충실하려고 노력하는 일이 얼마나 중요한지， 그것이 개발자인 나 자신과 고객에게
얼마나 유익을 줄 수 있는지 깨닫게 해췄다. 전문 개발자로서의 17년을 포함해 지금까
지 27
년간 다양한 언어와 기술을 사용해서 프로그래밍을 해왔지만 스프링만름 다른 사
람들에게 알려주고 싶고， 가르쳐주고 싶은 기술은 없었던 것 같다. 그동안 블로그와 세
미나， 컨퍼런스， 개발팀 교육， 공개 강의 등을 통해 틈나는 대로 스프링에 대한 지식을
나누려고 노력해왔지만 항상 제한된 시간과 공유 방법의 한계 때문에 아쉬움을 느껄 수
밖에 없었다. 이 책은 그동안 나누고 싶었지만 기회를 얻지 못했던 생각과 이야기들을
꺼내서 얼기설기 늘어놓은 것이다.

막상 책으로 엮고 나니 후련한 미음과 함께 부끄러운 마음이 든다. 책을 쓰는 동안
정확하고 완벽한 내용을 작성해야 한다는 부담 때문에 적지 않은 날을 썼던 내용을 지
우고 다시 써가며 고민 속에서 지내기도 했다. 나는 책을 쓸 만한 실력이 없다는 화절감
에 포기하려고 마음먹은 적도 있다. 하지만 그럴 때마다 이 책은 내 실력을 사람들에게
증명하고 뽕내려고 쓰는 것이 아니라 부족한 지식과 경험이라도 이를 나누면 누군가에
게 도움이 되리라는 작은 희망이 있기 때문이라는 생각으로 마음을 잡으면서 여기까지
올 수 있었다. 다른 것은 몰라도 이 책을 쓴 덕분에 내가 조금은 겸손해지지 않았을까
싶다.

처음 계획하고 약속했던 시간을 훌쩍 넘어서 책이 나오게 되어 많은 분들께 죄송하
다. 동시에 이 책이 나오기까지 힘써주시고 격려해주신 분들에게 고맙다. 무엇보다도
오랜 시간을 기대하며 기다려주셨던 독자 여러분께 감사드리고 싶다.

스프링 책을 쓰게 되기까지， 그리고 책을 마무리하기까지 도움을 주셨던 많은 분들
이있다.

가장 먼저 마이크 캐논-브룩스가 떠오른다. 아직 베타버전이었던 스프링을 제품 개
발에 사용해보고 그 경험을 나눠준 덕분에 스프링의 존재와 가치를 처음 알게 되고 1.0
버전부터 실전 프로젝트에 적용할 용기를 얻게 됐다. 스프링을 기업의 전산 시스랩 개
발에 과감히 도입하게 허락해주고 프로젝트 기간 내내 적극적으로 지원해줬던 민호와
권회현 회장님께 고마운 마음을 전하고 싶다. 이후에도 여러 차례 스프링을 이용한 기


업용 솔루션 개발의 기회를 제공해주고 미국과 유럽의 스프링 컨퍼런스에 참석하도록
지원해준 것은 내게 정말 큰 도움이 됐다. 스프링을 이용한 새로운 기술 연구와 실제 적
용을 해볼 수 있는 즐거운 기회를 만들어줬던 카이스트의 임범희 연구원과 연구소 분들
께도고맙다.

한국을 떠난 뒤로는 호주와 미국에서 주로 일을 해와서 한국의 자바 커뮤니티와는
전혀 교류가 없었던 나를 오푼소스 커뮤니티인 오픈시드의 기술고문으로 초빙해주고
여러 좋은분들을소개해췄던 승권이에게 고맙다. 승권이가아니었다면 나는한국의 자
바 개발자를 알게 될 기회조차 없었을 것이고， 당연히 이 책도 나오지 없t을 것이다.
마소 인터래티브의 정희용 사장은 이 책이 나오는 데 가장 큰 역할을 한 사람이다. 한
국에서 거의 알려져 있지 않던 나를 과감히 출판사에 소개해주고 책을 내도록 격려해준
덕분에 처음으로 스프링 책을 써야겠다는 마음을 먹게 되었다. 그때 만났던 에이콘의
김희정 부사장님은 이 책이 출판되는 데 가장 큰 역할을 해준 분이다. 김 부사장님께는
고마운 마음과 함께 미안한 마음도 크다. 번번히 원고 약속을 지키지 못하고 허언을 남
발하는 저자인데도 포기하지 않고 핀잔 한 번 없이 끝까지 믿고 기다려주시고 격려해주
신 덕분에 이 책이 나올 수 있었다. 에이콘의 권성준 사장님께도 감사드린다. 저술이 늦
어지는 것을 용납해주시고 항상 자신감을 가질 수 있도록 격려해주시고 많이 배려해주
시는 모습에 적지 않게 감동했다. 불량 저자를 관리하느라 여러모로 고생하셨던 황영주
차장님과황지영 과장님， 양많고 거친 원고를깔끔하게 편집해주시느라수고하신 김경
희님， 그리고 산뭇한 표지를 디자인해주신 김다희님과 본문 편집을 맡아주신 박진희님
께도 감사의 말씀을 드리고 싶다.

나와 함께 KSUG를 만들어 스프링 개발자들의 교류와 지식의 나눔에 많은 공헌을
해왔고， 책을 쓰는 과정과 마무리까지 여러 방면으로 기여해준 영회와 바쁜 와중에도
책의 모든 내용을 빠짐없이 살펴보고 기술적인 검증에 힘써준 봄싹 기선이에게도 고맙
다는 말을 전하고 싶다. 부족한 책에 귀한 추천시를 써주신 김창제님， 박성철님， 박재성
님， 양수열님， 옥상훈님， 이봉옥님， 이창신님， 정희용님께도 감사드린다. 책의 예제에
자신의 이름을 시용하도록 허락해주신 다섯 분을 포함해서 책이 나오기까지 많은 웅원
을 해주신 KSUG 회원과 운영진에게도 감사드린다.

이 책은 사실 연변과학기술대학의 IT 교육원 l
기 졸업생들에게 스프링을 가르쳐준다


면 어떻게 해야할까라는 고민을하며 쓴 것이다. 그들이 아니었다면 이 책을 어떤 식으
로써야할지 감을잡지도못했을것이다. 나에게 세계 여러 곳을다니면서 지식을나누
고 사람들에게 희망과 용기를 주고 싶은 꿈이 있다는 사실을 알게 해준， 그리고 그 행복
을 처음으로 느끼게 해준 향화， 려영， 설련， 향미
， 동국， 동철， 룡길， 봉춘， 호남， 상길，
서향， 설령， 수란， 영매， 성학， 윤호， 은화， 소강， 성화， 한천， 원일， 진승， 김성， 금철， 보
옥이와 병국， 승훈， 한수 형을 포함한 YUST 교수님틀께 고마운 마음을 전하고 싶다.
항상 듬직하게 힘이 돼주는 원혁이 형과 석빈이 형 그리고 친구 정은이에게도 고맙다고
하고싶다.

내게 가장 소중한 사람인 아내 은성이에게 고맙고 사랑한다는 말을 전한다. 아내는
내가 지치지 않고 끝까지 책을 쓰도록 옆에서 가장 많은 지원과 격려를 해준 사람이고
가장 오랜 시간 동안 함께 스프링으로 개발해온 동료이며 내가 처음으로 스프링을 가르
쳐준 사람이기도 하다. 사향}는 아들 평화에게도 고마운 마음뿐이다. 원고 쓴다고 책상
앞에만 붙어 있고 함께 많은 시간을 보내주지 못해서 정말 미안했는데， 그래도 항상 밝
게 웃는 모습으로 나를 기쁘게 해주고， 행복을 느끼게 해주고， 종종 커보드를 만지다 원
고 일부를 날려버려서 원고 저장과 백업의 중요성을 일깨워 주어서 고맙다.8월에 태어
날 히늘이에게도 미리 고맙다고 하고 싶다. 엄마 뱃속에 있는 동안 원고 마무리에 매달
린다고 거의 신경도 못 써줬는데 태어나면 좋은 아빠가 되도록 노력하겠다고 약속.

항상 나를 자랑스럽게 여기시고 믿어주시고 힘을 주시는 아버지， 어머니께도 감사의
말을 전하고 싶다. 항상 따듯하게 대해주시고 칭찬과 격려를 보내주신 장모님과 장인어
른께도 감사드린다. 쉽지 않은 시기를 보내는 동안 위로해주시고 우리 가족을 위해서
매일 기도해주시는 Terry와 Anne 선교사님， 그리고 Leigh와 Wen에게도 감사한다.

무엇보다도 나에게 생명과 지혜 살아갈 힘을 주시는 하나님께 감사드린다.

-브리즈번에서 토비 이일민


센꾀:Ir토비의 스프링 3
.1
J
목차


장
장
장
장
장
장
장
장
장
부록
A
부록
B

오브젝트와의존관계 53
테스트 145
탬플릿 2(f)
예외 279
서비스추상화 317
AOP 401
스프링핵심기술의웅용 557
스프링이란무엇인가? 713
스프링 프로젝트 시작하기 753
스프링모률 829
스프링의존라이브러리 839


장 IoC컨테이너와
DI 51
장 데이터액세스기술 237
장 스프링 웰 기술과 스프링 MVC 349
장 스프링
@MVC 465
장 AOP와
L1W 671
장 테스트 컨텍스트프레임워크 711
장 스프링의 기타기술과효과적인 학습방법 733
부록
A 스프링모률 789
부록
B 스프링의존라이브러리 799


웰1r〈Vol.1 스프링의 이해와원리〉세부목차

。니

‘---
」


FS

r토비의 스프링 3.1 J 출간을 축하하며

r

토비의 스프링 3J 추천의 글
4
nC저자소개 •••

CU

r토비의 스프링 3.1 J 출간에 부쳐

?I

r

토비의 스프링 3J 저자의 말

들어가며

1

，‘끼니


1l


nu

1장 오브젝트와 의존관계

1.1 초난감
DAO 54
1.1.1 User 54
1.1.2 UserDao 56
1.1.3 main( )을 이용한 DAO 테
AE 코드 58
1.2 DAO의분리 60
1.2.1 관심사의분리 60
1.2.2 커넥션만들기의추출 62
UserDao의 관심사항 62
중복코드의메소드추출 63
변경사항에 대한 검증: 리팩토링과 테스트 64

1.2.3 DB 커넥션 만들기의 독립 65
상속을통한확장 65
1.3 DAO의확장 71

1.3.1 클래人의분리 72

1.3.2 인터페
01A의 도입 74

1.3.3 관계설정 책임의분리 77
1.3.4 원칙과때턴 83
개방폐쇄원칙 83
높은 응집도와 낮은 결합도 85
전략때턴 87

1.4 제어의 역전(IoC) 88

1.4.1 오브젝
E 팩토리 88
팩토리 88
설계도로서의팩토리 90

1.4.2 오브젝
E
팩토리의활용 91

1.4.3 제어권의 이전을 통한 제어관계 역전 92

1.5 AII
링의 loC 95

1.5.1 오브젝
E 팩토리를 이용한 A끄링 loC 95
애플리케이션 컨텍스트와 설정정보 95
DaoFactory를 사용하는 애플리케이션 컨텍A.
E 96

1.5.2 애플리케이션 컨텍
AE
의 동작방식 99

1.5.3 A.1I링 loC의 용어 정리 101

1.6 싱글톤 레지AE리와 오브젝E 스코프 102

1.6.1 싱글톤 레지
AE
리로서의 애플리케이션 컨텍
AE 105
서버 애플리케이션과 싱글톤 105
싱글톤패턴의 한계 106
싱글톤레지A.
E
리 108

1.6.2 싱글톤과 오브젝E의 상태 109

1.6.3 A
끄링 빈의스코프 111

1.7 의존관계주입(미) 111

1.7.1 제어의 역전(loC)과 의존관계 주입 111


1.7.2 런타임 의존관계설정 112
의존관계 112
UserDao의 의존관계 113
UserDao의 의존관계 주입 115

1.7.3 의존관계검색과주입 117
1.7.4 의존관계주입의응용 120
기능구현의교환 120
부가기능추가 122

1.7.5 메소드를 이용한 의존관계 주입 126

1.8 XML을이용한설정 128

1.8.1 XML
설정 129
connectionMaker( ) 전환 129
userDao() 전환 130
XML의 의존관계 주입 정보 131

1.8.2 XML을 이용하는 애플리케이션 컨텍
AE 134

1.8.3 DataSource 인터페이스로 변환 136
DataSource 인터페이스 적용 136
자바코드설정방식 138
XML
설정 방식 139

1.8.4 프로퍼티 값의주입 139

7aA} -?「I
。닙l 139

value 값의 자동 변환 140

1.9 정리 142

2장테스트 145

2.1 USERDAOTEST 다시 보기

2.1.1 테스트의 유용성

2.1.2 Use
rDaoTest의 특징
|
웹을 통한 DAO 테스트 방법의 문제점
1
작은단위의 테스트
1
자동수행테스트코드
1
1

얘 얘 쩌 얘 던ω

-|
%

지속적인 개선과 점진적인 개발을 위한 테스트

mι


2.1.3 UserDao T est의 문제점 153

2.2 USERDAOTEST 개선 154

2.2.1 터|人
E 검증의자동화 154

2.2.2 테스트의 효율적인 수행과 결과 관리 157
JUnit 테스트로 전환 157
테스트메소드전환 157
검증코드전환 158
JUnit 테스트실행 160

2.3 개발자를 위한 터|A팅 E레임워크 JUNIT 161

2.3.1 JUnit 테스트 실행 방법 162
IDE 162
빌드툴 163

2.3.2 테스트결과의 일관성 164
deleteAII()의 getCount() 추가 164
deleteAII()과 getCount( )의 테스트 165
동일한 결과를 보ε「하는 테스트 167

2.3.3 포괄적인 테
AE 168
getCount() 테
AE 168
addAndGet( ) 테
AE 보완 170
get() 예외조건에 대한 테스트 171
테스트를 성공시키기 위한 코드의 수정 173
포괄적인 테人드 174

2.3.4 터
|
AE
가이끄는개발 175
기능설계를위한테스트 175
터|λE
주도개발 176

2.3.5 터|AE 코드개선 179
@Before 180
픽스처 182

2.4 스프링 테스트적용 183

2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리 184
스프링테스트컨텍스트프레임워크적용 184
테스트 메소드의 건텍스트 공유 186
터|AE 클래스의 컨텍AE 공유 187
@Autowired 187

2.4.2 미와 터|AE 189
테
AE 코드에 의한미 190


테스트를 위한 별도의 미 설정 193

컨테이너 없는미 테스트 194

미를 이용한 테AE 방법 선택 196

2.5 학습 테AE굳 배우는 An링 197

2.5.1 학습테
AE
의장점 197

2.5.2 학습테λ
드 예제 200
JUnit 테스트 오브젝트 테스트 200
스프링 테
AE 컨텍스트 테스트 202

2.5.3 버그테
AE 205

2.6 정리 207

3장템플릿 2(f)

3.1 다시보는초난감
OAO 209

3.1.1 예외처리 기능을 갖춘 DAO 210
JDBC 수정 기능의 예외처리 코드 210
JDBC 조회 기능의 예외처리 213

3.2 변하는 것과 변하지 않는 것 214

3.2.1 JDBC try/catch/finally 코드의 문제접 214

3.2.2 분리와 재사용을 위한 디자인 때턴 적용 216
메소드추출 217
템플릿 메소드 꽤턴의 적용 218
전략때턴의적용 219
미 적용을 위한 클라이언트/컨텍
AE 분리 221

3.3 JOBC 전략 때턴의 최적화 224
3.3.1 전략클래人의추가정보 225

3.3.2 전략과 클라이언E의 동거 226
로컬클래스 227
익영 내부클래스 229

3.4 컨텍스트와
01 231

3.4.1 JdbcContext의 분리 231
클래스분리 232


빈의존관계변경 233

3.4.2 JdbcContext의 특별한 DI 235
스프링 빈으로미 235
코드를이용하는수동미 237

3.5 템플릿과콜백 240

3.5.1 템플릿/콜백의 동작원리 241
탱플릿/콜백의특징 241
JdbcContext에 적용된 템플릿/콜백 243

3.5.2 편리한콜백의재활용 243
콜백의분리와재활용 244
콜백과템플릿의결합 245

3.5.3 템플릿/콜백의응용 247
터|AE
와 try/catch/finally 248
중복의 제거와 템플릿/콜백 설계 251
템플릿/콜백의 재설계 254
제네릭스를 이용한 콜백 인터페이스 257

3.6 AII
링의 JDBCTEMPLATE 259

3.6.1 update( ) 260

3.6.2 queryForlnt( ) 262

3.6.3 queryForObject( ) 264

3.6.4 query( ) 266
기능정의와테
AE 작성 266
query( ) 텀플릿을 이용하는 getAlI() 구현 268
터|λE 보완 269

3.6.5 재사용 가능한 콜백의 분리 271
미를위한코드정리 271
중복제거 272
템플릿/콜백 때턴과 UserDa。
273

3.7 정리 276


4장 예외 279

4.1 사라진 SQLEXCEPTION 279
4.1.1 초난감예외처리 280
예외블랙홀 280
무의미하고 무책임한 throws 282

4.1.2 예외의종류와특징 283

4.1.3 예외처리 방법 285
예외복구 285
예외처리 회띠 286
예외전환 288

4.1.4 예외처리 전략 291
런타임 예외의보편화 291
add() 메소드의 예외처리 292
애플리케이션예외 294

4.1.5 SQLException은 어떻게 됐나? 296

4.2 예외전환 297

4.2.1 JDBC의 한계 298
비표준
SOL 298
호환성 없는 SOLException의 DB 에러정보 299

4.2.2 DB 에러 코드 매핑을 통한 전환 300

4.2.3 DAO 인터페
01A와 DataAccessException 계충구조 303
DAO 인터페이스와 구현의 분리 304
데이터 액세스 예외 추상화와 DataAccessException 계층구조 306

4.2.4 기술에 독립적인 UserDao 만들기 308
인터페이스적용 308
터|AE 보완 310
DataAccessException 활용 시 주의사항 312

4.3 정리 315


5장서비스추상화 317

5.1 사용자 레벨 관리 기능 추가 317

5.1.1 필I
추가 318
LevelOI늄 318
User
팔드추가 320
UserDaoTest 테
AE 수정 321
UserDaoJdbc 수정 323
5.1.2 사용자수정기능추가 325
수정기능테스트추가 325
UserDao와 UserDaoJdbc 수정 326
수정 테AE 보완 327

5.1.3 UserService.upgradeLevels( ) 329
UserService 클래스와 빈 등록 330
UserServiceTest 테스트 클래스 331
upgradeLevels( ) 메소드 332
upgradeLevels( ) 테스트 333

5.1.4 UserService.add( ) 334
5.1.5 코드개선 337
upgradeLevels( ) 메소드 코드의 문제점 337
upgradeLevels( ) 리팩토링 338
User 테스트 344
UserServiceTest 개선 345

5.2 E
랜잭션서비
A
추상화 349
5.2.1 모아니면도 349
테스트용 UserService 대역 349
강제 예외 발생을 통한 테스트 351
테스트실때의원인 353

5.2.2 E
랜잭션 경계설정 353
JDBC 트랜잭션의 트랜잭션 경계설정 354
UserService와 UserDao의 트랜잭션 문제 355
비즈니스 로직 내의 트랜잭션 경계실정 357
UserService 트랜잭션 경계설정의 문제점 360

5.2.3 E
랜잭선동기화 360
Connection 따라미터 저|거 361
트랜잭션동기화적용 362
트랜잭션테스트보완 364


JdbcTemplate과 트랜잭션 동기화 365

5.2.4 E
랜잭션서비
A
추상화 366
기술과 환경에 종속되는 트랜잭션 경계설정 코드 366
트랜잭션 API
으| 의존관계 문제와 해결책 368
A
끄링의 트랜잭션 서비스 추상화 369
트랜잭션 기술 설정의 분리 372

5.3 서비A 추상화와 단일 책임 원칙 375
수직， 수펑 계층구조와 의존관계 375
단일책임원칙 377
단일책임 원칙의장점 377

5.4 메일서비
A
추상화 380

5.4.1 JavaMail을 이용한 메일 발송 기능 380
JavaMail 메일 발송 380

5.4.2 JavaMail이 포함된 코드의 터|A 드 382

5.4.3 테스트를 위한 서비
A 추상화 384
JavaMail을 이용한 테
AE
의 문제점 384
메일발송기능추상화 385
터|AE
용 메일 발송 오브젝트 387
터
|λE
와 서비스 추상화 389
5.4.4 테스트대역 391
의존 오브젝트의 변경을 통한 테
AE 방법 391
터
|AE 대역의 종류와특징 393
목 오브젝트를 이용한 터lAE 395

5.5 정리 398

6장
AOP 401

6.1 트랜잭션 코드의 분리

6.1.1 메소드 분리

6.1.2 미를 이용한 클래스의 분리
DI 적용을 이용한 트랜잭션 분리
UserService 인터페이스 도입
분리된트랜잭션 기능

째 짜뼈째뼈뻐


트랜잭션 적용을 위한 미 설정 409

트랜잭선 분리에 따른 테AE 수정 410

트랜잭션 경계설정 코드 분리의 장점 412

6.2 고립된 단위 테AE 413

6.2.1 복잡한 의존관계 속의 테
AE 414

6.2.2 터|AE 대상오브젝
E 고립시키기 415
테스트를 위한 UserServicelmpl 고립 415
고립된 단위 테스트활용 417
UserDao 목 오브젝트 418
테스트수행성능의향상 422

6.2.3 단위 테스트와 통합 테스트 423

6.2.4 목 n
러|임워크 425
Mockito 프레임원크 426

6.3 다이내믹 프록시와 팩토리 민 429

6.3.1 프록시와 프록시 때턴， 데코레이터 때턴 429
데코레이터 때턴 431
프록시때턴 433
6.3.2 다이내믹프록시 435
프록시의 구성과 프록시 작성의 문제점 435
리를렉션 437
프록시클래스 439
다이내믹프록시 적용 441
다이내믹프록시의확장 444

6.3.3 다이내믹 프록시를 이용한 E
랜잭션 부가기능 446
트랜잭션 InvocationHandler 446
TransactionHandler와 다이내믹 프록시를 이용하는 테
AE 448

6.3.4 다이내믹 프록시를 위한 팩토리 빈 449
팩토리빈 449
팩토리 번의설정 방법 452
다이내믹 프록시를 만들어주는 팩토리 빈 453
트랜잭션 프록시 팩토리 빈 454
트랜잭선 프록시 팩토리 빈 테스트 456

6.3.5 프록시 팩토리 빈 방식의 장점과 한계 458
프록시 팩토리 빈의 재사용 458
프록시 팩토리 빈 방식의 장접 460
프록시팩토리 빈의한계 461


6.4 A
끄링의 프록시 팩토리 민 462
6.4.1 ProxyFactoryBean 462
어드바이스: 타깃이 필요 없는 순수한 부가기능 464
포인트컷: 부가기능 적용 대상 메소드 선정 방법 466

6.4.2 ProxyFactoryBean 적용 470
TransactionAdvice 470
스프링 XML
설정파일 471
테
AE 473
어드바이스와 포인트컷의 재사용 474

6.5 스프링
AOP 475
6.5.1 자동프록시생성 475
중복문제의 접근방법 476
빈 후처리기를 이용한 자동 프록시 생성기 477
확장된포인트컷 478
포인트컷 테
λE 479

6.5.2 DefaultAdvisorAutoProxyCreator의 적용 481
클래스 필터를 적용한 포인트컷 작성 481
어드바이저를 이용하는 자동 프록시 생성기 등록 482
포인트컷등록 483
어드바이스와 어드바이저 483
ProxyFactoryBean 제거와 서비스 빈의 원상복구 483
자동 프록시 생성기를 사용하는 테스트 484
자동생성프록시확인 487

6.5.3 포인E컷 표현식을 이용한 포인E컷 489
포인트컷표현식 489
포인트컷표현식문법 490
포인트컷표현식 테스트 493
포인트컷 표현식을 이용하는 포인트컷 적용 498
타입 때턴과 클래스 이름 때턴 499

6.5.4 AOP란무엇인가? 500
트랜잭션서비스추상화 501
프록시와 데코레이터 때턴 501
다이내믹 프록시와 프록시 팩토리 빈 502
자동 프록시 생성 방법과 포인트컷 502
부가기능의모률화 503
AOP: 애스펙트 지향 프로그래밍 504

6.5.5 AOP
적용기술 506
프록시를이용한
AOP 506


바이트코드 생성과 조작을 통한 AOP 506

6.5.6 AOP의용어 508

6.5.7 AOP 네임A떼
01A 509
AOP
네임스페이스 510
어드바이저 내장 포인트컷 512

6.6 E
랜잭션속성 512

6.6.1 드랜잭션 정의 513
트랜잭션전파 513
격리수준 515
제한시간 516
읽기전용 516

6.6.2 E
랜잭션 인터셉터와 E
랜잭션 속성 516
Transactionlnterceptor 517
메소드 이름 패턴을 이용한 트랜잭션 속성 지정 518
tx 네임스페이스를 이용한 설정 방법 520

6.6.3 포인E컷과
E랜잭선속성의적용전략 521
트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다 522
공통된 메소드 이름 큐칙을 통해 최소한의 트랜잭션
어드바이스와 속성을 정의한다 523
프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를
호출할 때는 적용되지 않는다 524

6.6.4 E
랜잭션속성 적용 526
트랜잭션 경계설정의 일원화 526
서비스 빈에 적용되는 포인트컷 표현식 등록 528
트랜잭션 속성을 가진 트랜잭션 어드바이스 등록 528
트랜잭션속성 테스트 529

6.7 애노테이션 E랜잭션 속성과 포인E컷 532

6.7.1 E
랜잭션애노테이션 532
@Transactional 532
트랜잭션 속성을 이용하는 포인트컷 533
대체정책 534
트랜잭션 애노테이선 사용을 위한 설정 536

6.7.2 E
랜잭션 애노테이션 적용 536

6.8 E
랜잭션지원 테스트 539

6.8.1 선언적
E
랜잭션과
E
랜잭션전파속성 539

6.8.2 E
랜잭션 동기화와 테스트 541


트랜잭션 매니저와 트랜잭션 동기화 542
트랜잭션 매니저를 이용한 테스트용 트랜잭션 제어 543
트랜잭션동기화검증 545
롤백테스트 547

6.8.3 테스트를 위한 E
랜잭션 애노테이션 549
@Transactional 549
@Rollback 551
@TransactionConfiguration 552
NotTransactional과 Propagation.NEVER 553
효과적인
DB
테스트 553

6.9 정리 554

7장 스프링 핵심 기술의 응용 557

7.1 SQ봐
DAO의분리 557

7.1.1 XML 설정을 이용한 분리 559
개별 SOL 프로퍼티 방식 559
SOL
업 프로퍼티 방식 560

7.1.2 SOL
제공서비人 562
SOL 서비스 인터페이스 563
스프링 설정을 사용하는 단순 SOL 서비스 566

7.2 인터페이A의 분리와 자기참조 빈 568

7.2.1 XML
파일 매핑 568
JAXB 568
SOL 업을 위한 스키마 작성과 컴파일 569
언마살링 572

7.2.2 XML 파일을 이용하는 SOL 서비人 573
SOL 법 XML
파일 573
XML SOL
서비스 574
7.2.3 빈의초기화작업 576

7.2.4 변화를 위한 준비: 인터페이人 분리 580
책임에 따른 인터페이스 정의 580
SqIRegistry 인터페이스 584
SqlReader 인터페이스 584


7.2.5 자기참조 빈으로 시작하기 585
다중 인터페이스 구현과 간접 참조 585
인터페이스를 이용한 분리 586
자기참조빈설정 589

7.2.6 디폴
E 의존관계
확장가능한기반클래스 591
디폴트 의존관계를 갖는 빈 만들기 593

7.3 서비
A
추상화적용 597

7.3.1 OXM
서비A
추상화 597
OXM 서비
A 인터페이스 598
JAXB
구현 테AE 598
Castor 구현 테스트

7.3.2 OXM 서비A 추상화 적용 602
엠버 클래스를 참조하는 통합 클래스 602
위임을 이용한 BaseSqlService의 재사용 608

7.3.3 리소스추상화
리소스 611
리소스로더 612
Resource를 이용해 XML 파일 가져오기 614

7.4 인터페이
A 상속을 통한 안전한 기능확장 616
7.4.1 미와기능의확장 617
미를의식하는설계 617
DI와 인터페이스 프로그래밍 618

7.4.2 인터페
01A
상속

7.5 이를 이용해 다양한 구현 방법 적용하기 625

7.5.1 ConcurrentHashMap을 이용한 수정 가능
SOL 러|지A
드리 625
수정 가능 SQL 레지人E리 테스트 625
수정 가능 SQL 레지AE
리 구현 627

7.5.2 내장형 데이터베이스를이용한
SOL
레지
AE
리 만들기 629
스프링의 내장형 DB 지원 기능
내장형 DB 빌더 학습 테AE 631
내장형 DB를 이용한 SqlRegistry 만들기 634
UpdatableSqlRegistry 테
λE 코드의 재사용 636
XML 설정을 통한 내장형 DB의 생성과 적용 639

7.5.3 E
랜잭션적용 641


다중 SQL 수정에 대한 트랜잭션 테스트 642
코드를 이용한 트랜잭션 적용 643

7.6 A끄링 3.1의 미 645
자바 언어의 변화와 A끄링 646

7.6.1 자바 코드를 이용한 빈 설정 652
테스트컨텍
AE
의 변경 653
(context:annotation-config f) 제거 655
(bean)
의 전환 657
전용태그전환 666

7.6.2 민 人캐닝과 자동와이어링 671
@Autowired를 이용한 자동와이어링 671
@Component를 이용한 자동 빈 등록 675

7.6.3 컨텍
AE 분리와@lmport 682
테스트용컨텍
A
드 분리 682
@l
mpoη 685
7.6.4 프로파일 687
@Profile과 @ActiveProfiles 689
컨테이너의 빈 등록 정보 확인 692
중접 클래스를 이용한 프로파일 적용 693
7.6.5 프로퍼티소스 696
@PropertySource 696
PropertySourcesPlaceholderConfigurer 699

7.6.6 빈 설정의 재사용과 @Enable* 701
빈설정자 701
@Enable* 애노테이션 707

7.7 정리 710

8장 스프링이란무엇인가? 713

8.1 스프링의 정의

8.2 스프링의목적

8.2.1 엔터프라이즈 개발의 복잡함
복잡함의근본적인이유

낌 낌꼈


복잡함을 가중시키는 원인 724

8.2.2 복잡함을 해결하려는 도전 725
제거될 수 없는 근본적인 복잡함 725
실때한해결책
: EJB 726
비침투적인 방식을 통한 효과적인 해결책: A
끄링 727

8.2.3 복잡함을 상대하는 A
끄링의 전략 728
기술적 복잡함을 상대하는 전략 728
비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략 729
핵심 도구. 객체지향과 미 731

8.3 POJO
프로그래밍 732

8.3.1 스프링의 핵심: POJO 733

8.3.2 POJO란무엇인가? 734

8.3.3 POJO의 조건 734

8.3.4 POJO의 장점 737

8.3.5 POJO E
레임워크 738

8.4 스프링의기술 739

8.4.1 제어의 역전(loC)/ 의존관계 주입(DI) 740
미의활용방법 741

8.4.2 OH
人펙
E 지향 프로그래밍
(AOP) 746
AOP의적용기법 746
AOP의적용단계 747

8.4.3 포터블 서비人 추상호KPSA) 749

8.5 정리 751

9장 스프링 프로젝 E 시작하기 753

9.1 자바 엔터
II라01I 플랫폼과 스프링 애플리케이션 753

9.1.1 클라이언E와 백엔E 시A템 754
9.1.2 애플리케이션서버 755
스프링소스 tcServer 756

9.1.3 A
묘링 애플리케이션의 배포 단위 756

9.2 개발도구와환경 758


9.2.1 JavaSE와 JavaEE 758
JavaSE/JDK 758
JavaEE/J2EE 758
9.2.2 IDE 758

9.2.3 SpringSoruce T∞IS미te 759
SpringlDE 플러그인 761
STS
플러그인 769
기타플러그인 769

9.2.4 라이닙러리 관리와 빌I 툴 770
라이브러리 관리의 어려움 770
라이브러리 선정 773
빌드 툴과 라이브러리 관리 775
AII
링 모률의 두 가지 이름과 리포지토리 780

9.3 애플리케이션아키텍처 782

9.3.1 계층형 아키텍처 782
아키텍처와
SoC 782
3겨|층 아키텍처와 수직 계층 784
계층형 아키텍처 설계의 원칙 788

9.3.2 애플리케이선 정보 아키텍처 791
DB/SQL 중심의 로직 구현 방식 792
거대한서비스계층방식 795

9.3.3 오브젝
E 중심 아키텍처 797
데이터와오브젝트 798
도메인 오브젝트를 사용하는 코드 802
도메인 오브젝
E 사용의 문제점 803
빈약한 도메인 오브젝트 방식 805
풍성한 도메인 오브젝트 방식 807
도메인 계층방식 811
DTO와리포트쿼리 816

9.3.4 A
끄링 애플리케이션을 위한 아키텍처 설계 816
계층형 아키텍처 817
정보전송아키텍처 819
상태관리와빈스코프 820
서드파티 프레임워크， 라이브러리 적용 821

9.4 정리 826


부록A
스프링모률

A.1 An링 모률의 종류와 특징

A.1.1 AII링 모률 이름

A.1.2 스프링모둘추가

A.1.3 AII
링 모률목록

A.2 스프링모률의의존관계

A.2.1 모률별의존관계

부록B 스프링 의존 라이브러리

8.1 의존 라이닙러리의 종류와 특징

B.1.1 의존 라이닙러리 이름

B.1.2 의존 라01님러리 추가

8.2 모둘벌 의존 라이닙러리 의존관계

B.2.1 필수라이닙러리

B.2.2 모둘별 선택 라이님러리

찾아보기

부록
CD소개

829
829
830
832

833
834

839

839
839
840

843
843
843

858
880


스프링이란 무엇인가? 체 l

스프링은 자바 엔터프라이즈 애플리케이션 개발에 사용되는 애플리케이션 프레임워크
다. 애플리케이션 프레임워크는 애플리케이션 개발을 빠르고 효율적으로 할 수 있도록
애플리케이션의 바탕이 되는 틀과 공통 프로그래밍 모댈 기술 API 등을 제공해준다.

애풀리케이션의 기본 훌 -스프링 컨테이너

스프링은 스프링 컨테이너 또는 애플리케이션 컨텍스트라고 불리는 스프링 런타임

엔진을 제공한다. 스프링 컨테이너는 설정정보를 참고로 해서 애플리케이션을 구성

히는 오브젝트를 생성하고 관리한다. 스프링 컨테이너는 독립적으로 동작할 수도 있

지만 보통 웹 모률에서 동작하는 서비
스나 서블릿으로 등록해서 사용한다.

스프링을 시용하려면 먼저 스프링 컨테이너를 다루는 방법과 스프링 컨테이너가 애

플라케이션 오브젝트를 이용할 수 있도록 설정정보를 작성하는 방법을 일。}야 한다.

• 공통 프로그래밍 모델 -loC/DI. 서비스 추응탤t.AOP
프레임워크는 애플리케이션을 구성히는 오브젝트가 생성되고 동작하는 방식에 대한
틀을 제공해줄 뿐만 아니라， 애플리케이션 코드가 어떻게 작성돼야 하는지에 대한
기준도 제시해준다. 이런 틀을 보통 프로그래밍 모댈이라고 한다. 스프링은 세 가지
핵심 프로그래밍 모델을 지원한다.

첫 번째는 IoC/DI라고 불리는 오브젝트의 생명주기와 의존관계에 대한 프로그래
밍 모댈이다. 스프링은 유연하고 확장성이 뛰어난 코드를 만들 수 있게 도와주는 객
체지향 설계 원칙과 디자인 패턴의 핵심 원리를 담고 있는 IoC/DI를 프레임워크의


근간으로 삼고 있다. 스프링 프레임워크에서 동작하는 코드는 IoC/ DI 방식을 따라
서 작성돼야 스프링이 제공하는 가치를 제대로 누릴 수 있다. 스프링이 직접 제공하
는 모든 기술과 API, 심지어 컨테이너도 IoC/ DI 방식으로 작성되어 있다. 스프링을
바르게 이해하고 효율적으로 사용히는 데 기본이 되며 가장 중요한 기술이다.

두 번째는 서비스 추상화다. 스프링을 사용하면 환경이나 서버， 특정 기술에 종속
되지 않고 이식성이 뛰어나며 유연한 애플리케이션을 만들 수 있는데， 이를 가능하
게 해주는것이 바로서비스추상화다. 구체적인 기술과환경에 종속되지 않도록유
연한추상계층을두는방법이다.

세 번째는 AOP
다. AOP는 애플리케이션 코드에 산재해서 나타나는 부가적인 기
능을 독립적으로 모률화하는 프로그래밍 모델이다. 스프링은 AOP를 이용해서， 다
%댄f 엔터프라이즈 서비스를 적용하고도 깔끔한 코드를 유지할 수 있게 해준다.

스프링을 사용해서 애플리케이션을 개발하는 개발자라면 반드시 이 세 가지 프로
그래밍 모텔을 잘 이해해야 하고 자유롭게 응용할 수 있어야 한다.

• 71슐
API
스프링은 엔터프라이즈 애플리케이션을 개발의 다양한 영역에 바로 활용할 수 있는
방대한 양의 기술 API를 제공한다. UI 작성은 물론이고 웹 프레젠테이션 계층， 비
즈니스 서비스 계층， 기반 서비스 계층 도메인 계층， 데이터 액세스 계층 등에서 필
요한 주요 기술을 스프링에서 일관된 방식으로 사용할 수 있도록 지원해주는 기능과
전략 클래스 등을 제공한다. 스프링이 제공히는 API와 지원 기술은 모두 스프링의
프로그래밍 모댈에 따라 작성되어 있기 때문에 이를 가져다 쓰는 것만으로도 스프
령의 프로그래밍 모댈을 코드에 자연스럽게 적용할 수 있다. 스프링의 모든 기술은
표준 자바 엔터프라이즈 플랫폼JavaEE에 기반을 두고 있다. 표준 기술과 더불어 유명
오픈소스 기술과 주요 상용 기술에 대한 지원 기능도 다ÚJ=하게 제공된다.

스프링을 시용한다는 것은 바로 이 세 가지 요소를 적극적으로 활용해서 애플리케이
션을 개발한다는 뭇이다. 클래스는 스프링 컨테이너 위에서 오브젝트로 만들어져 동작
하게 만들고， 코드는 스프링의 프로그래밍 모댈을 따라서 작성하고， 엔터프라이즈 기술
을 시용할 때는 스프링이 제공하는 기술 API와 서비스를 활용하도록 해주변 된다.


; 스프링의 성공요인 料|


스프링은 어떤 한두 사람에 의해 어느 날 갑자기 만들어진 것이 아니다. 오히려 스프링
은 자비를 통해 엔터프라이즈 시스댐을 개발하는 데 좀 더 나은 방법과 전략을 찾으려
고 고민하고 연구한 많은 개발자의 수고가 오랜 시간에 걸쳐서 집약된 결정체다. 스프
령은 많은 개발자가 제안했던 아이디어를 구체화된 프레임워크로 만들어내고， 만들어
진 프레임워크를 오픈소스 생태계를 통해 효과적으로 검증하고 발전시킨 결과물이다.
이제는 유비쿼터스 스프링이라고 불릴 만큼 다양한 영역에서 폭넓게 쓰이고 있다. 대한
민국 전자정부 표준 프레임워크의 핵심 기술로도 채택됐다. 스프링은 사실상의 자바 엔

터프라이즈 표준 기술이라고 여겨진다.

그렇다면 스프링이 이렇게까지 성공한 이유는 무엇일까? 단지 최첨단의 화려한 기

능을 제공해주기 때문만은 아니다. 오히려 견고하고 건전한 자바와 엔터프라이즈 개발
의 핵심 가치에 충실했기 때문이다. 스프링을 사용하는 개발지들은 자연스럽게 자바와
엔터프라이즈 개발의 기본에 충실한 베스트 프랙티스를 적용할 수 있고， 이상적인 개발
철학과 프로그래밍 모댈을 이해하게 되고， 좋은 개발 습관을 체득하게 된다.

스프링을 사용히는 개발지들이 스프링을 통해 얻게 되는 두 가지 중요한 가치가 있

다면 그것은 단순함과 유연성이다.

• 단순함simplicity
스프링은 EJB라는 강한 권위를 가졌던 표준 기술을 비판하면서 등장했다. EJB는 불
필요하게 복잡한 기술이었기 때문이다. 스프링이 지향히는 것은 목적을 이룰 수 있

는 가장 단순하고 명쾌한 접근 방법이다. 스프링은 자바라는 언어의 근본에서 기존
엔터프라이즈 기술의 문제에 대한 해법을 찾았다
. 자바는 이상적인 객체지향 언어라
는 캐치프레이즈를 내세우며 등장했다. 이 때문에 학계와 업계에서 모두 큰 주목을
받았고 빠르게 보급됐다. 하지만 시간이 지
나고 자바의 기술이 복잡해져 가면서 자
바의 본질인 객체지향 언어라는 특정을 점점 잃어버렸다. 스프링은 이 잃어버린 객
체지향 언어의 장점을 다시 개발자들이 살릴 수 있도록 도와주는 도구다. 그래서 스
프링이 강력히 주장하는 것은 가장 단순한 객체지향적인 개발 모델인 POJO 프로그
래밍이다.

。여A엔lexibility

"TT'‘':0

스프링은 또 유연성을 중요한 가치로 내세운다. 스프링은 유연성과 확장성이 매우
뛰어나다. 스프링의 유연성으로 인해 스프링은 다른 많은 프레임워크와 편리하게 접


목돼서 사용될 수 있다. 스프링만큼 많은 서드파티 프레임워크의 지원을 받는 기술
도 없다. 스프링은 프레임워크를 위한 프레입워크 또는 여러 프레임워크를 함께 사
용하게 해주는 접칙.g
lue 프레임워크라고도 불린다.

스프링은스스로발전히는프레임워크다. 스프링 개발철학중하나는“항상프레
임워크 기반의 접근 방법을 사용하라”이다. 스프링 기능의 대부분은 핵심 기능을 확
장해서 발전시킨 결괴물이다. 스프링은 개발자들에게 스프링을 확장해서 사용하도
록 권장한다. 프레임워크를 확장해서 시용한 뒤 시간이 지남에 따라 경험하게 되는
벼전 호환성 문제가 스프링에는 거의 없다. 스프링은 지난 9년간 단 한 번도 코드 베
이스를 흔들거나 새로 만드는 일 없이 기존 아커텍처와 설계， 코드를 유지하면서 안
정적으로 발전해왔다. 그러니 안심하고 스프링을 확장해서 사용해도 좋다. 스프링을
제대로 사용하려면 스프링을 펼요에 맞게 확장해서 자신만의 프레임워크를 만들어
서 사용할 줄 알이야 한다.

I스프링 학습과활용의 어려움 렐
l

스프링이 공개된 지 이미 9년째이고 이미 많은 개발자가 스프링을 사용해 애플리케이션
을 개빨뻐고 있다. 그럼에도 적지 않은 수의 개발자들은 스프링의 핵심 가치와 혜택
을 충분히 누리지 못하고 있는 듯하다. 유행을 따라서 스프링을 도입하기는 했으나 스
프링을 사용함으로써 어떤 장점이 있는지 파악할 기회도 없이 책의 예제나 인터넷에 떠
도는 샘플을 구해서 기계적으로 적용히는 경우도 적지 않다. 스프링의 프로그래밍 모댈
이 무엇인지， 스프링에는 어떤 다OJ=한 기능이 있으며 이를 잘 활용해서 편리하고 유연
하게 개발히는 방법이 무엇인지 모른 채 스프링을 사용하기도 한다. 그러다 보니 “스프
링도 별게 아니네”라고 실망하는 경우도 있을 것이다.

스프링의 가치를 제대로 누리며 사용하려면 스프링을 제대로 공부해야 한다. 여타
프레임워크도 그렇겠지만 스프링은 특히 프레임워크가 지향하는 가치와 프로그래밍 모
댈을 충분히 이해하지 못하고는 제대로 활용할 수 없다. 반면에 한번 스프링의 원리와
개발 시상을 확실히 이해하고 나면 그 이후에 새로운 기능이 아무리 많이 추가되더라도
빠르고 쉽게 학습하고 사용할 수 있다.

스프링을 효과적으로 익히려면 다음의 세 가지 단계를 통해 스프링을 학습해보자.


• 스프링의 핵심 가치와 원리에 대한 이해
첫 번째 단계는 스프링의 핵심 가치를 이해하고 스프링 스스로가 그 가치를 어떻게
적용해서 만들어져 있는지를 이해히는 것이다. 스프링에는 가장 중요한 핵심 가치와
그것이 가능하도록도외주는세 가지 핵심 기술이 있다. 또한스프링이 강조하는중
요한 프로그래밍 모댈이 있다. 이를 먼저 자세히 공부하고 스프링을 일관된 방식으
로이해할수있는눈을갖는것이 첫 번째 단계다.
-스프링의 기슐에 대한 지식과 선택 기훈 정휩
일단 스프링의 기본 원리를 확실하게 이해하고 나면 스프링이 이를 어떻게 다OJ'한
방법으로 확장하고 적용했는지 살며볼 차례다. 스프링은 매우 범용적인 프레임워크
다. 또한 애플리케이션의 모든 레이어를 폭넓게 다루고 있다. 스프링은 어떤 분야와
기술 환경에도 적용 가능하도록 기술 영역별로 매우 폭넓은 접근 방법을 제공한다.
그중에서 어떤 것을 선택할지는 개발자의 몫이다. 스프링이 제공히는 방법 중에서
어떤 것을 선택할 것인지， 또 스프링과 연동히는 프레임워크는 어떤 것을 선택하고
그것을 어떤 스타일로 사용할 것인지의 문제는 스프링을 사용하는 개발자에게 적지
않은 부담이다. 단지 이런 고민을 피하려고 남들이 만들어놓은 예제를 가져다가 생
각 없이 사용히는 일은 피해야 한다. 스프링 학습의 두 번째 단계는 바로 이 다OJ'한
선택의 문제를 각 기술영역별로 효과적으로 다루는 법을 배우는 것이다. 먼저 스프
링이 제공하는 기술의 종류와 접근 방법에는 어떤 것이 있는지 충분히 살펴보고， 선
택의 기준을 마련해서 그때그때 상햄l 맞는 최선의 기술과 접근 방법을 선돼할 수
있어야한다.

스프링의적용과확장
마지막으로 스프링의 다양한 기술을 어떻게 실제 애플리케이션 개발에 어떤 식으로
적용해야 하는지를 공부해야 한다. 스프링은 특정 아키텍처에 제한되는 프레임워크
가 아니다. 스프링은 이전에는 기술적인 문제로 쉽게 적용하지 못했던 아키텍처도
마음껏 활용할 수 있게 도외준다. 또한 스프링에 제공하는 기능을 그대로 사용하는
것 외에도 그것을 확장하거나 추상화해서 사용히는 방법을 알아야 한다. 스프링을
효과적으로 샤용하는 기업과 개발팀에서는 스프령을 기반으로 프레임워크를 만들어
서 λ}용한다. 이것은 매우 자연스럽고 바람직한 방법이다. 프레임워크를 만든다고
해서 스프링은 내부로 감추고 새로 만든 프레임워크에 모든 기능을 넣어야 하는 건
아니다. 오히려 스프링을 더 효과적으로 사용할 수 있도록 주어진 환경과 현재 프로
젝트에 맞는 방식의 사용 기준을 마련하고 이를 틀(프레
임워크)의 형태로 만들어서 개발


자들이 이용할 수 있게 해주는 것이다. 스프링의 자유도를 줄이고 각 현장의 상황11
맞는 접근 방법을 정립해주는 작업이라고도 볼 수 있다. 때로는 스프링이 직접 지원
하지 않는 기술을 접목해서 사용히는 경우를 위해서 해당 기술을 스프링에 맞게 통
합하는 작업도 포함된다.

세 번째 단계는 이렇게 스프링을 실전에서 사용하는 데 필요한 응용 방법과 확장
방법을 공부하는 것이다.

I 스프링의 이해와 원리〉의 구성과 예제 렐
l

이 책은 이 세 가지 단계를 따라서 스프링을 공부하려는 사람을 대상으로 쓰여진 책으
로. Vo
l
.l
에서는 첫 단계인 ‘핵심 가치와 원리에 대한 이해’를 중심으로 하고. Vol. 2에
서는 두 번째 단계인 ‘스프링 기술에 대한 지식과 선택’을 집중해서 다룬다. 세 번째 단
계인 확장에 대해서는 책의 여러 곳에서 다OJ=한 전략과 예제， 힌트를 제공한다. 하지만
본격적으로 응용과 확쟁l 대한 지식을 쌓는 일은 독자들의 몫이다. 각자의 상햄 맞
게 처음 두 단계에서 배운 지식을 응용해 스프링을 확장해보는 훈련을 해야 한다.

<Vo1. 1 스프링의 이해와 원리〉
에서는 간단한 예제를 만들어가는 과정을 통해 스프링
의 기본 원리와 핵심 기술을 설명한다. 스프링은 개발자가 만드는 코드가 얹혀서 동작
하는 프레임워크다. 프레임워크의 가장 중요한 목적은 개발자가 일정한 틀을 따라 효과
적으로 애플리케이션을 개발하도록 돕는 것이다. 따라서 프레임워크를 잘 이해하려면
프레임워크를 사용했을 때 애플리케이션 묘드가 어떻게 만들어지는지 자세히 살펴봐야
한다.

Vo1. 1
에서는 각 장마다 스프링 프레임워크를 시용하지 않고 개발한 단순한 코드를
먼저 작성해보고， 여러 단계를 거쳐 최종적으로 스프링 프레임워크를 활용한 코드로 발
전시킨다. 프레임워크를 적용하지 않았을 때의 코드와 적용 후의 코드를 비교하면서，
스프링 프레임워크를 사용하면 어떤 식으로 코드가 만들어져야 하는지를 설명한다.

V이. 1
에서 다루는내용은
V이
.2에서 본격적으로소개할스프링의 다OJ=한기술을이
해히는 데 중요한 기반이 된다. 스프링에 적용된 기본 패턴과 기반이 되는 원리를 V이. 1
에서 설명하는순서에 따라학습해두면 이후에 스프링의 개별 기술과
API를 익힐 때 많
은도움이될것이다.

l
장부터 7장까지는 사용자 관리 기능을 구현하는 하나의 예제를 만드는 과정을 단
계적으로 설명한다. 예제는 처음부터 끝까지 모두 연결된다. 코드를 지속적으로 개선하


면서 발전시키기 때문에 코드가 계속 바뀌고 새로운 클래스가 추가되거나 사라지기도
한다. 부록 CD의 예제들은 각 %써l서 코드가 바뀌는 주요 절별로 제공된다. 기능하면
Vol.1
의 예제는 책의 내용을 참고해서 직접 따라 해보기를 권장한다. 코드가 만들어지
고 개선되고 발전히는 과정을 직접 체험하는 것이 V이. 1
의 내용을 이해히는 데 가장 좋
은방법이다.

스프링 3.1
의 새로운 기술을 다루는 7.6절을 제외한 나머지 모든 예제는 스프링 3.0
을 기준으로 사용할 라이브러리를 소개한다. 모든 내용은 스프링 3
.
1
에서도 동일하게
적용되므로 스프링 3.1을 이용해 예제를 작성해도 무방하다. 부록 CD에는 스프링 3.0
과 3.1 버전으로 각각 작성된 Vol.1 의 예제 프로젝트가 담겨 있다.

[ 이책의대상독자

이 책은 스프링을 이용해서 엔터프라이즈 자바 애플리케이션을 개발하려는 모든 개발

자를 대상으로 한다. 이 책을 공부하기 위해서는 자바 언어와 JDBC를 이용한 DB 프로

그래밍， 그리고 기초적인 웹 개발 지식이 필요하다.

[ 스프링 3.0으| 달라진 기능 펙 l

스프링 3.0의 새로운 기능과 특징은 다음과 같다.

• Java 5와 JavaEE 6
스프링 3
.0은 자바 5 언어의 특정을 본격적으로 적용해서 만들어진 최초의 스프링
버전이다. 공식적으로 스프링 3.0은 J2SE 5.0 이상의 환경에서 사용해야 하며， 주요
API에서 자바 5의 새로운 언어 기능을 이용하도록 개선됐다.

스프링 3.0은 J2EE 1
.4와 JavaEE 5와 완벽하게 호환되며 JavaEE 6의 일부 스
펙을 지원한다. JavaEE 6에는 스프링 개발팀의 주도로 만들어진 표준 DI 스펙인
Dependency Injection for Java(JSR-330)이 포함되어 있다. 스프링 3.0은 JSR-330
을 완벽하게 지원히는 최초의 오푼소스 프레임워크다. 그 외에도 JPA -2. 0(JSR-317),


Bean Validation(JsR-303), JSF -2. 0
(JSR-314
)과 같은 주요 JavaEE 6 기술을 직접적으
로지원한다.

• 스프링 표현식 언어(SpEL)
SpEL은 3.0에서 새롭게 도입된 강력한 기능을 가진 스프링의 공식 표현식 언어
EL다.
SpEL은 빈 설정에서부터 스프링 MVC
의 뷰에 이르기까지 스프링 3.0
의 다%댄f 영
역에 적용되어 있으며 SpEL API를 애플리케이션에서 직접 활용할 수도 있다.
• 자바 코드툴 이용한 미 설정과 DIJμSR...，앓이
기존에 제공되던 XML과 애노테이션을 이용한 빈 설정 기능에 자바 묘드를 이
용한 빈 메타정보 생성과 DI 설정 기능이 추가됐다. 자바 클래스와 메소드에
@Configuration과 @Bean 등의 애노테이션을 부여해서 DI 설정정보로 이용할 수 있다.
@Inject와 Provider 같은 자바 표준 DI 애노테이션을 이용한 DI 설정도 지원한다.

• OXM
OXM은 오브젝트-XML 매핑
Object-XML Mapping의 약자다. 오브젝트와 XML 문서의

상호변환을 지원히는 자바 기술에 대한 서비스 추상화 모률인 OXM
이 새롭게 추가

됐다. JAXB2를 비롯해서 5가지의 대표적인 OXM 라이브러리를 지원한다.OXM

은 스프령 MVC
의 메시지 전송과 뷰 기술에도 적용됐다.

• @MVC와
REST
@MVC는 애노테이션을 적극적으로 활용해서 웹 프레젠테이션 계층을 편리하게 개
발할 수 있도록 만들어진 스프링의 최신 웹 기술이다. 스프링 3.0의 @MVC는 전통
적인 스프링 MVC 개발 방법을 완전히 대체할 수 있을 만람 높은 완성도를 지니고
있다. 스프링 3.0은 Res
tTemplate과 메시지 컨버터를 이용해 REST 개발을 완벽하
게 지원해주기도 한다. 이 외에도 최신 기술을 활용해서 웹 개발을 더욱 편리하게 만
들어주는 다
OJ'한 부가 기능이 추가됐다.

• 내짙뱅
DB
지원
Derby, HSQL, H2에 대한 내장형 DB 지원기능이 추가됐다. 자체 스키마를 가진 내
장형 DB 전용 태그를 이용해서 내장형 DB 엔진을 손쉽게 등록하고 사용할 수 있다.

• Converter, ConversionService, Formatter
기존에 사용되던 PropertyEditor를 대신할 수 있는 Converter와 ConversionService
타입 변환 API가 추가됐다. 새로운 타입 변환 API는 멀티스레드 환경에서도 안전하
게 공유될 수 있고 애노태이션과 같은 메타정보를 변환 작업에 활용할 수 있는 확장
성을 갖고 있다. 웹 환경에 특화돼서 만들어진 Formatter도 제공된다.

.，푼릴fI에할띈챈로운캔 휘|

스프링 3.1
에 추가된주요한기능과특정은다음과같다.

• 강화된 자바 코드롤 이용한 빈 실정
스프링 3
.
1은 스프링 3.0부터 지원하기 시작한 자바 코드를 이용한 빈 설정 방식을
대폭 확장해서 스프링 빈 설정의 거의 모든 영역으로 확대했다. 기존에 XML로 작성
했던 스프링 설정 정보를 3.1 에서는 자바 묘드로 대체할 수 있다.XML을 전혀 사용
하지 않고 스프링 애플리케이션을 작성할 수도 있다. 자바 코드를 이용한 빈 설정을
위해 다양한 애노테이션이 추가됐다. XML의 전용 커스텀 태그를 대체할 수 있는，

@Enable로 시작하는 전용 애노테이션도 제공된다.

• 런타임환경추상화
스프링 애플리케이션이 실행되는 런타임 환경 정보를 추상화한 환경 오브젝트가 컨
테이너를 통해 제공된다. 환경 오브젝트가 제공하는 주요 기능은 실행환경에 따라
달라지는 빈 설정을 효과적으로 관리할 수 있는 프로따일과 각종 프로퍼티 정보를
컨테이너를통해 일관된 방식으로 제공할수 있게 해주는 프로퍼티 소스다.
• JPA 지원 확장과 하이버네이트 4 지원
하이버네이트 4 지원 기능이 새롭게 추가됐다. jPA를 이용할 때보다 좀 더 쉽게 설
정정보를 작성할 수 있는 편리한 기능도 추가됐다.
• 새로운 DispatcherServlet 전략과 폴래시 뱀
스프링 3.0에서 사용되던 DispatcherServlet 전략의 일부가 새롭게 설계된 전략으
로 대체됐다. 이를 통해 MVC 기능을 확장하기가 편리해졌다. Post/Redirect/Get
패턴에 사용할수 있는플래시 뱀 기능도추가됐다.

캐시추S화

AOP를 이용한 메소드 레벨의 캐시 추상화 기능이 추기됐다. 이를 이용해 캐시 구현
기술에 독립적인 방식으로 애플리케이션 빈에 캐시 기능을 적용할 수 있게 됐다. 랩
을 이용한 간단한 캐시 구현부터 EhCac
h
e를 이용한 고급 캐시 기술까지 지원한다.

스프링은 배우기 쉬운 기술이 아니다. 충분한 시간을 들여서 공부하고 고민하고 훈
련하는 시간이 필요하다. 스프링을 학습하다 보면 스프링 자체보다도 스프링이 지지하
는 프로그래밍 모델， 개발과 설계 원리나 개념 또는 관련 기술을 공부해야 할 필요를 느
껄 것이다. 그래서 스프링의 학습은 만만치 않다. 반면에 즐겁기도 하다. 스프링을 통해
서 자바와엔터프라이즈 개발의 다양한 영역을함께 배울수 있기 때문이다. 다만， 충분
한 시간을 들여서 차근차근 공부할 것을 권하고 싶다. 관련 지식 중에서 자신에게 부족
한 부분이 있다고 생각되면 그 부분을 한 번쯤 체계적으로 살펴본 뒤에 다시 스프링으
로 돌아오는 편이 좋을 것이다.

스프링을 성공적으로 학습했는지를 확인할 수 있는 좋은 방법이 있다. 스프링을 공
부하고 적용한 이후에 자신이 좀 더 나은 개발자가 되었는가 확인해보는 것이다. 스프
링을 사용하고 나서 자신의 묘드가 좀 더 깔끔하고 단순하면서 객체지향 원칙에 충실하
게 작성됐는지， 생산성과 품질이 더 나아졌는지 스스로 질문해보자. 이전보다 더 많은
테스트 코드를 작성하고 있고， 유연하고 확장이 손쉬운 애플리케이션이 만들어지고 있
는지도 점검해보자. 무엇보다도 스프링을 사용하면서 개발이 좀 더 즐거워졌는가 스스
로에게 물어보면 좋겠다. 아마도 언젠가는 ‘도대체 스프링이 없을 때는 어떻게 개발을
했었는지 상상도 안 된다’라는 생각이 들 때가 올 것이다. 니를 비롯해서 함께 스프링을
시용해 개발했던 많은 동료가 공통적으로 했던 이야기가 바로 그것이다. 스프링을 공부
하고 적용했지만 스프링의 사용법에 조금 익숙해진 것을 빼면 더 나아진 게 없다고 느
낀다면 스프링을 잘못 공부한 것일지도 모른다.

마지막으로 이 책에 나오는 예제는 가능한 직접 따라 해보기를 권장한다. 로드 존슨
이 실증적인 접근 방법을 설명하면서 한 유명한 이야기가 있다. “컴퓨터에게 물어보라
Ask the computer"는 것이다. 책에 나오는 대부분의 기능과 예제는 모두 테스트 코드가 함
께 제공된다. 스스로 스프링의 기능을 테스트하는 코드를 만들어보며 학습하는 것은 매
우유익할것이다.


(Vol.1 스프링의 이혜와 원리〉톨 시작하며

스프링올 효과적으로 사용하려면 스프링이 지지하는 가치와 이루고자 하는 목표를 반드시 이해해야::0 .:
한다. 그리고 목표를 이루기 위해. 스프링이 제공하는 구체적인 기솔에는 어떤 것이 있으며 왜 필요
한지알아야한다.

스프링은 단순하게 기계적으로 적용할 수 있는 기술이 아니다. 스프링은 먼저 이해해야 하며. 그 이
해활 바탕으로 창조적으로 응용해야만 스프링이 제공하는 진정한 가치를 얻을 수 있다.

.. . .

, .

-----‘

----’‘

--’

f ---’

-

•••••,. •

.... .. • .. •

‘ .-....-.(’ ) .

• . . -



까、 프링은 자비를 기반으로 한 기술이다. 스프링이 자H에서 가장 중요하게 가치를
-두는 것은 바로 객체지향 프로그래밍이 가능한 언어라는 점이다. 자바 엔터프라
이즈 기술의 혼란 속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고， 그로
부터 객체지향 프로그래밍이 제공하는 폭넓은 혜택을 누릴 수 있도록 기본으로 돌아가
자는 것이 바로 스프링의 핵심 철학이다.

그래서 스프링이 가장 관심을 많이 두는 대상은 오브젝트다. 스프링을 이해하려면 먼
저 오브젝트에 갚은 관심을 가져야 한다. 애플리케이션에서 오브젝트가 생성되고 다른
오브젝트와 관계를 맺고， 시용되고， 소멸하기까지의 전 과정을 진지하게 생각해볼 필요
가 있다. 더 나-ó}가서 오브젝트는 어떻게 설계돼야 하는지 어떤 단위로 만들어지며 어
떤 과정을 통해 자신의 존재를 드러내고 등장해야 하는지에 대해서도 살펴봐야 한다.

결국 오브젝트에 대한 관심은 오브젝트의 기술적인 특정과 사용 방법을 넘어서 오브

젝트의 설계로 발전하게 된다. 객체지향 설계。bject oriented design의 기초와 원칙을 비롯해
서， 다OJ=한 목적을 위해 재활용 가능한 설계 방법인 디자인 패턴， 좀 더 깔끔한 구조가
되도록 지속적으로 개선해나가는 작업인 리팩토링， 오브젝트가 기대한 대로 동작하고

있는지를 효과적으로 검증히는 데 쓰이는 단위 태스트와 같은 오브젝트 설계와 구현에
관한여러 가지 응용기술과지식이 요구된다.

스프링은 객체지향 설계와 구현에 관해 특정한 모댈과 기법을 억지로 강요하지는 않
는다. 하지만 오브젝트를 어떻게 효과적으로 설계하고 구현하고， 시용하고， 이를 개선
해나갈 것인가에 대한 명쾌한 기준을 마련해준다. 동시에 스프링은 객체지향 기술과 설
계， 구현에 관한 실용적인 전략과 검증된 베스트 프래티스를 평범한 개발자도 자연스럽
고 손쉽게 적용할 수 있도록 프레임워크 형태로 제공한다.

1장-오브젝트와 의존관계 53


l
장에서는 스프링이 어떤 것이고， 무엇을 제공하는지보다는 스프링이 관심을 갖는
대상인 오브젝트의 설계와 구현， 동작원리에 더 집중하기를 바란다. 그러다 보면 자연
스럽게 스프링이 무엇인지도 이해될 것이다.

Iill1 초난감
[11:1.] 델
l

사용자 정보를 JDBC API를 통해 DB에 저장하고 조회할 수 있는 간단한 DAO를 하나
만들어보자.

훌
DAO
DAI이Data Access Object)는 DB를 사용해 데이터훌 조회하거나 조작하는 기능율 전담하도록
만든 오브젝트를 말한다.

1.1.1 User
시용자 정보를 저장할 때는 자바빈 규약을 따르는 오브젝트를 이용하면 편리하다. 먼저
샤용자 정보를 저장할 User 클래스를 만든다. 리스트 1-1
은 id, name , password 세 개
의 프로퍼티를 가진 User 클래스다.

리스트 1-1 사용자 정보 저장용 자바민 User 클래스

package springbook.user.domain;

public class User (
String id;
String name;
String password;

public String getld() (
return id;

public void setld(String id) (
this.id = id;

public String getName() {
return name;


public void setName(String name) (
this.name = name;

public String getPassword() (
return password;

public void setPassword(String password) {
this .password = password;

이제 User 오브젝트에 담긴 정보가 실제로 보관될 DB
의 테이블을 하나 만들어보자.
테이블 이름은 USER로 프로머티는 User 클래스의 프로퍼티와 동일하게 구성한다. 표

}-}은
USER 테이블 펼드 내역이다.
표 1-1 USERS 테이블 필드 구성
| 일드명 )
Id
Name
Password
타입
VARCHAR(10)
VARCHAR(20)
VARCHAR(20)
) 설청
Primary Key
Nol Null
Nol Null
|

MySQL을 사용한다면 DB 생성 후에 다음과 같은 CREATE TABLE 명령을 실행해

테이블을만들면된다.

create table users (
id varchar(10) primary key ,
name varchar(20) not null ,
password varchar(10) not null

이 책의 예제는 특정 DB
에 종속적이지 않으므로 사용하기 편한 다른 DB를 이용해

도좋다.

響
X뻐}빈
자바빈(Java8E경n)은 원래 비주얼 훌에서 조작 가능한 컴포넌트훌 말한다. 자바의 주력 개발 풀
랫풀이 웹 기반의 엔터프라이즈 방식으로 바뀌면서 비주얼 컴포넌트로서 자바번은 인기를 잃어
갔지만. 자바빈의 몇 가지 코딩 관례는 JSP 빈，
EJ없i 갈은 표준 기솔과 자바빈 스타일의 오브
젝트훌 사용하는 오픈소스 기슐올 통해 계속 이어져 왔다.01제는 자바먼이라고 말하면 비주얼

1장-오브젝트와 의존관계 55


컴포넌트라기보다는 다음 두 가지 관례톨 따라 만둘어진 오브젝트톨 가리킨다. 간단히 빈이라
고부르기도한다.

• 디롤트 생성자: 자바빈은 따라미터가 없는 디를트 생성자톨 갖고 있어야 한다. 톨이나 프레임
워크에서 리풀렉션율 이용해 오브젝트톨 생성하기 때문에 뭘요하다.

• 프로퍼티: 자바먼이 노훌하는 이톰옳 가진 속성율 프로퍼티라고 한다. 프로퍼티는 set2.로 시
작하는 수정자 메소드(setter)와 get2.로 시작하는 접근자 메소드(getter)톨 이용해 수정 또는
조회할수있다.
1.1.2 UserDao
시용자 정보를 DB에 넣고 관리할 수 있는 DAO 클래스를 만들어보자. 사용자 정보를

관리히는 DAO이므로 UserDao라는 이름으로 클래스를 하나 생성한다. 사용자 정보의

등록， 수정， 삭제와 각종 조회 기능을 만들어야겠지만， 일단 새로운 시용자를 생성하

고(add) , 아이디를 가지고 사용자 정보를 읽어오는(get
) 두 개의 메소드를 먼저 만들어보

겠다.

JDBC를 이용히는 작업의 일반적인 순서는 다음과 같다.

• DB 연결을 위한 Connection을 가져온다.
• SQL을 담은 Statement
(또는 PreparedS tatement)를 만든다.
• 만들어진 Statement를 실행한다.
• 조회의 경우 SQL 쿼리의 실행 결과를 ResultSet으로 받아서 정보를 저장할 오브젝트(여기서
는 User
)에 옮겨준다.
• 작업 중에 생성된 Connection. Statement. Resul tSet 같은 리소스는 작업을 마친 후 반드시
닫아준다.
• JDBC API가 만들어내는 예외exception를 잡아서 직접 처리하거나， 메소드에 throws를 선
언해서 예외가 발생하면 메소드 밖으로 던지게 한다.

일단 예외는 모두 메소드 밖으로 던져버리는 편이 간단하다. 리스트 1-2는 JDBC
API
의 기본적인 사용 방법을 따라서 만든 UserDao 클래스다.

리스트 1-2JDBC률 이용한 동륙과 조회 기능이 있는 User다g 클래스

package springbook.user .dao;
public class UserDao {


public void add(User user) throws ClassNotFoundException , 5QLException {
Class.forName( "com .mysql. jdbc. Driver");
Connection c = DriverManager.getConnection(

“jdbc :mysql: /!localhost/springbook" , "spring" , "book");

Prepared5tatement ps = c.prepare5tatement(

"insert into users(id , name , password) values(ζ?，?)");
pS.set5tring(1 , user.getld());
pS.set5tring(2 , user.getName());
pS.set5tring(3 , user.getPassword());

pS.executeUpdate();

ps .close();
c.close();

public User get(5tring id) throws ClassNotFoundException , 5QLException {
Class. forName( ‘’com.mysql .jdbc.Driver“);
Connection c = DriverManager.getConnection(

"j dbc :mysql : / !localhost/springbook'’, ‘ spring" , "book'’);

Prepared5tatement ps = c.prepare5tatement(
"select * from users where id = ?");
pS.set5tring(1 , id);

Result5et rs =pS .executeQuery ();
rs .next();
User user = new User();
user.setld(rs .get5tring("id"));
user.setName(rs .get5tring("name"));

user.setPassword(rs.get5tring(ψassword"));

rs . close ();
ps . close();
c.close();

return user;

1장-오브젝트와 의존관계 57


제법 복잡해 보이는 코드가 만들어졌다. 그런데 이 클래스가 제대로 동작하는지 어
떻게 확인할 수 있을까? 일단 생각해볼 수 있는 단순한 방법은 DAO의 기능을 λF용하
는 웹 애플리케이션을 만들어 서벼에 배치하고 웹 브라우저를 통해 DAO 기능을 사용
해보는 것이다. 하지만 간단한 UserDao 묘드가 동작함을 확인하기 위한 작업치고는 너
무 부담이 크다. 배보다 배꼽이 더 큰 일이 돼버릴 것이다. 그렇다고 코드를 눈으로만
확인하고서 잘 동작할 것이라고 안심하기에는 좀 꺼림칙하다.

1.1.3 mainO을이용한
DAO
테스트코드
만들어진 묘드의 기능을 검증하그l자 할 때 사용할 수 있는 가장 간단한 방법은 오브젝
트 스스로 자신을 검증하도록 만들어주는 것이다. 모든 클래스에는 자신을 엔트리 포인
트로설정해 직접 실행이 기능하게 해주는스태틱 메소드
main()
이 있지 않은가.
이제 main 메소드를 만들고 그 안에서 UserDao
의 오브젝트를 생성해서 add( )와
get( ) 메소드를 검증해보자. 먼저 User 오브젝트를 생성하고 프로퍼티에 값을 넣은 다
음에 add() 메소드를 이용해 DB
에 등록해본다. Connection 설정과 코드에 모두 이상
이 없다면 main() 메소드는 에러 없이 종료될 것이다. 등록된 결과를 DB 콘솔에서 확
인해볼 수도 있겠지만， 그보다는 조회용으로 만든 get() 메소드를 사용해 DB
에 저장
된 결과를 가져와 보는 게 훨씬 편리하다. 눈으로 결괴를 확인할 수 있도록 각 단계별로
System
.
out
.
println()
을 이용해 콘솔에 적절한메시지를출력하게 만들자.
리스트 1-3은 이렇게 만들어진 셀프 테스트용 maln 메소드다.

리스트 1-3 테스트용 main() 메소드

public static void main(String[] args) throws ClassNotFoundException , SQLException (
UserDao dao = new UserDao();

User user = new User();
user.setId("whiteship');

user.setName("
백기 선 ");
user .setPassword( 깨arried');
dao.add(user);

System.out.println(user.getId() + ’ 등록 성공");
User user2 =dao.get(user .getId());
System .out.println(user2.getName());


System.out .println(user2.getPassword());
System.out .println(user2.getId() + " 조회 성공");


이 클래스를 실행하면， 즉 main() 메소드를 실행하면 다음과 같은 태스트 성공 메시
지를 얻을 수 있다. 혹시 실패했다면 DB 설정과 Connection 정보. Users 테이블 등록
여부 등을 확인해보자. 시용할 DB
의 드라이버가 클래스패스에 있어야 하는 것도 잊지
말자. MySQL 5.1 버전을 시용한다면 mysql-connector-java-5.1.7-bin.jar 파일을
클래스패스에 넣어줘야 한다.

whiteship 등록 성공

백기선

married

whiteship 조회 성공

이렇게 해서 사용자 정보의 등록과 조회가 되는 초간단 DAO와 태스트용 메소드까지
완성했다. 그런데 지금 만든 UserDao 클래스 코드에는 사실 여러 가지 문제가 있다. 실
제 프로젝트에서 자바 개발자가 이렇게 DAO를 개발했다면 개발팀에서 바로 쫓겨나지
않을까 싶을 만큼 한심한 묘드다. 코드를 보는 사람을 몹시 당황하게 만들 수 있는 초난
감 코드의 조건을 두루 갖춘 DAO 묘드다.

그렇다고 걱정할 것은 없다. 이제부터 이 문제 많은 초난감 DAO 코드를 객체지향
기술의 원리에 충실한 멋진 스프링 스타일의 코드로 개선해보는 작업을 할 것이다.

일단 UserDao 클래스 코드의 문제점은 무엇일까 스스로 생각해보자. 문제점이라고
하면 뭔가 기능이 정상적으로 동작하지 않아야 할 멘데 사실 위의 DAO는 우리가 기대
했던 기능을 충실하게 동작한다는 사실을 초간단 main() 메소드 태스트 방식을 이용해
이미 두 눈으로 검증했다. 그렇다면 왜 이 코드에 문제가 많다고 히는 것일까? 잘 동작
하는 코드를 굳이 수정하고 개선해야 하는 이유는 뭘깨 그렇게 DAO 코드를 개선했을
때의 장점은 무엇일까? 그런 장점들이 당징벼11. 또는 미래에 주는 유익은 무엇인가? 또，

객체지향 설계의 원칙과는 무슨 상관어 있을깨 이 DAO를 개선핸 경우와 그대로 사

용하는 경우， 스프링을 사용하는 개발에서 무슨 차이가 있을까?

스프링을 공부한다는 건 바로 이런 문제 제기와 의문에 대한 답을 찾아나가는 과정
이다. 스프링은 기계적인 답변이나 성급한 결론을 주지 않는다. 최종 결론은 스프링을
이용해 개발자 스스로 만들어내는 것이지， 스프링이 럽석 줄 수 있는 게 아니기 때문이

1장-오브젝트와 의존관계 59


다. 스프링은 단지 그 과정에서 이런 고민을 제대로 하고 있는지 끊임없이 확인해주고，

좋은 결론을 내릴 수 있도록 객체지향 기술과 자바 개발의 선구자들이 먼저 고민하고

제안한 방법에 대한 힌트를 제공해줄 뿐이다.

[ 1.2 DAO으| 분리 치11 I
1.2.1 관심사의 분리
세%에는 변하는 것과 변하지 않는 것이 있다. 하지만 객체지향의 세계에서는 모든 것
이 변한다. 여기서 변한다는 것은 변수나 오브젝트 펼드의 값이 변한다는 게 아니다. 오
브젝트에 대한 설계와 이를 구현한 코드가 변한다는 뭇이다. 소프트웨어 개발에서 끝이
란 개념은 없다. 사용자의 비즈니스 프로세스와 그에 따른 요구사항은 끊임없이 바뀌
고 발전한다. 애플리케이션이 기반을 두고 있는 기술도 시간이 지남에 따라 바뀌고， 운
영되는 환경도 변화한다. 애플리케이션이 더 이상 사용되지 않아 폐기처분될 때가 돼야
변회는중지된다.
그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를
어떻게 대비할 것인가이다. 지금 당장 구현하고 있는 기능도 만들기 바쁜데 무슨 미래
를 생각할 여유가 있겠느냐고 반문할지 모르겠다. 맞는 말이다. 하지만 지혜로운 개발
자는 오늘 이 시간에 미래를 위해 설계하고 개발한다. 그리고 그 덕분에 미래에 닥칠지
도 모르는 거대한 작업에 대한 부담과 변경에 따른 엄청난 스트레스， 그로 인해 발생하
는 고객과의 사이에서 또 개발팀 내에서의 갈등을 최소화할 수 있다.
변회는 먼 미래에만 일어나는 게 아니다. 며칠 내에， 때론 몇 시간 후에 변화에 대한
요구가 갑자기 발생할 수 있다. 객체지향 설계와 프로그래밍이 이전의 절차적 프로그래
밍 패러다임에 비해 초기에 좀 더 많은 번거로운 작업을 요구히는 이유는 객체지향 기
술 자체가 지니는， 변회에 효과적으로 대처할 수 있다는 기술적인 특정 때문이다. 객체
지향 기술은 흔히 실세계를 최대한 기깝게 모댈링해낼 수 있기 때문에 의미가 있다고
여겨진다. 하지만 그보다는 객체지향 기술이 만들어내는 기장의 추상세계 자체를 효과
적으로 구성할 수 있고， 이를 자유롭고 편리하게 변경 발전 확장시킬 수 있다는 데 더
의미가있다.
미래를 준비하는 데 있어 가장 중요한 과제는 변화에 어떻게 대비할 것인가이다. 가
장 좋은 대책은 변화의 폭을 최소한으로 줄여주는 것이다. 두 명의 개발자에게 동일한


기능 변경을 요청했다고 하자. 그런데 한 명은 단 몇 줄의 코드만 수정하고， 그 변경이
나머지 기능에는 전혀 문제를 일으키지 않는다는 것까지 검증해주는 데 5분이 걸렸다.
그런데 다른 개발지는 동일한 기능을 변경하는 데 5
시간이 걸린데다， 그것이 기존에 잘
동작하던 다른 기능에 오류를 일으킬지도 모른다는 새로운 불안감까지 일으켰다면 과
연 어떤 개발자가 더 미래의 변회를 잘 준비한 것일까? 당연히 최소한의， 확신을 가진
작업만으로도 기능을 수정해낸 개발자다.

그러면 어떻게 변경이 일어날 때 필요한 작업을 최소화하고， 그 변경이 다른 곳에 문
제를 일으키지 않게 할 수 있었을까? 그것은 분리와 확장을 고려한 설계가 있었기 때문
이다.

먼저 분리에 대해 생각해보자.

변경에 대한 요청이 “DB를 오리클에서 MySQL로 바꾸면서， 웹 화면의 레이아웃을
다중 프레임 구조에서 단일 프레임에 Ajax를 적용한 구조로 바꾸고， 매출이 일어날 때
에 지난달 평균 매출액보다 많으면 감사 시스랩의 정보가 웹 서비스로 전송되는 동시에
로그의 날짜 포뱃을 6자리에서 Y2K를 고려해 8자리로 바꿔라”는 식으로 발생하지는
않는다. 무슨 얘긴가 하면 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서
일어난다는뭇이다.

문제는， 변회는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한
곳에 집중되지 않는 경우가 많다는 점이다. 단지 DB 접속용 암호를 변경하려고 DAO
클래스 수백 개를 모두 수정해야 한다면? 트랜잭션 기술을 다른 것으로 바꿨다고 비즈
니스 로직이 담긴 코드의 구조를 모두 변경해야 한다면? 또는 다른 개발자가 개발한 코
드에 변경이 일어날 때마다 내가 만든 클래스도 함께 수정을 해줘야 한다면 얼마나 끔
찍할지모르겠다.

변화가 한 번에 한 가지 관심에 집중돼서 일어난다면， 우리가 준비해야 할 일은 한
가지 관심이 한 군데에 집중되게 하는 것이다. 즉 관심이 같은 것끼리는 모으고， 관심이
다른 것은 따로 떨어져 있게 히는 것이다.

프로그래밍의 기초 개념 중에 관심사의 분리Sepa떼ion 01 Concerns라는 게 있다. 이를 객
체지향에 적용해보면， 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모
이게 하고， 관심이 다른 것은 기능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하

는 것이라고 생각할 수 있다.
모든 것을 뭉똥그려서 한데 모으는 편이 처음엔 쉽고 편하다. 그런데 언젠가는 그 뭉
쳐 있는 여러 종류의 관심사를 적절하게 구분하고 따로 분리하는 작업을 해줘야만 할

1장-오브젝드와 의존관계 61


때가 온다. 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과
적으로 집중할 수 있게 만들어주는 것이다.

1.2.2 커넥션 만들기의 추출
UserDao의 구현된 메소드를 다시 살펴보자. 자세히 들여다보면 add() 메소드 하나에서
만 적어도 세 가지 관심사항을 발견할 수 있다.

UserDao의 관심사항

• 첫째는 DB와 연결을 위한 커넥션을 어떻게 가져올까라는 관심이다. 더 세분화해서 어떤
DB를 쓰고， 어떤 드라이버를 사용할 것이고， 어떤 로그인 정보를 쓰는데， 그 커넥션을 생성
히는 방법은 또 어떤 것이다라는 것까지 구분해서 볼 수도 있다. 세부관심까지 분류하면 너
무 복2얘}지므로 일단은 뭉뚱그려서 DB 연결과 관련된 관심이 하나라고 보자. 이것만 해도
여타 관심사항괴는 명확히 구분된다.
• 둘째는 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 Statement를 만들고 실행하는
것이다. 여기서의 관심은 따라미터로 넘어온 사용자 정보를 Statement
에 바인딩시키고，
Statement에 담긴 SQL을 DB를 통해 실행시키는 방법이다. 따라미터를 바인딩하는 것과
어떤 SQL을 사용할지를 다른 관심사로 분리할 수도 있기도 하지만， 우선은 이것도 하나로
묶어서생각하자.
• 셋째는 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘서 소중
한 공유 리소스를 시스댐에 돌려주는 것이다.
UserDao는 현재 초난감 상태이므로 펼요하지만 생략된 것이 많다. JDBC 개발 경험
이 있는 개발자라면 당연히 눈치 겠겠지만， 위의 DAO 코드에는 예외상황에 대한 처리
가 전혀 없다. 수많은 동시 사용자가 있고， 한번 시작되면 장기간 운용되는 서버에 올라
간다면 예외상햄l 적절하게 대응해서 공유 리소스를 반환하지 않는 일이 없도록 세심
하게 주의해야 한다
. 이 부분은 뒤에서 다시 다루기로 하고 일단은 무시하고 넘어가자.

가장 문제가 되는 것은 첫째 관심사인 DB 연결을 위한 Connection 오브젝트를 가져
오는 부분이다. 현재 DB 커넥션을 가져오는 코드는 다른 관심사와 섞여서 같은 add( )
메소드에 담겨 있다. 더 큰 문제는 add() 메소드에 있는 DB 커넥션을 가져오는 코드와
통일한 코드가 get() 메소드에도 중복되어 있다는 점이다. 아직까지는 두 개의 메소드
밖에 만들지 않았지만， 앞으로 수백， 수천 개의 DAO 메소드를 만들게 될지 모르는데，
그렇게 된다면 DB 커넥션을 가져오는 코드가 여기저기에 계속 중복돼서 나타날 것이


다. 바로 이렇게 하나의 관심사가 방만하게 중복되어 있고， 여기저기 흩어져 있어서 다
른 관심의 대상과 얽혀 있으면 변경이 일어날 때 엄청난 고통을 일으키는 원인이 된다.
지저분하게 꼬여 있는 스파게티 코드가 된다는 돗이다.

중복코드의메소드추출
가장 먼저 할 일은 커넥션을 가져오는 중복된 코드를 분리히는 것이다. 중복된 DB 연
결 묘드를 getConnection()
이라는 이름의 독립적인 메소드로 만들어둔다. 각 DAO 메
소드에서는 이렇게 분리한 getConnection() 메소드를 호출해서 DB 커넥션을 가져오
게 만든다. 리스트 1-4는 이렇게 수정한
UserDao 코드의 일부분이다.

리스트 1-4
geε。nnection(
) 메소드흩 추훌해서 종복을 제거한 UserD∞

public void add(User user) throws ClassNotFoundException , SQLException (
Connection c = getConnection();

public User get(String id) throws ClassNotFoundException, SQLException (
Connection c = getConnection();

↓
DB
연결 |爛
ge•Co nnection( ) 메소드훌
이용하게 한다 ..... 중복된 코드률 독립적인 메소드로
「
만들어서 중복을 제거했다

private Connection getConnection() throws ClassNotFoundException , SQLException (
Class.forName('com.mysql.jdbc.Driver');
Connection c =DriverManager.getConnection(

'jdbc:mysql://localhost/springbook' ’ 'spring' ’ 'book');
return c;

지금은 UserDao 클래스의 메소드가 두 개이지만 나중에 메소드가 2，
000개쯤 된다고
상상벼}보자. DB 연결과관련된부분에 변경이 일어났을경우， 예를들어 DB
종류와접
속 방법이 바뀌어서 드라이버 클래스와 URL이 바뀌었다거나， 로그인 정보가 변경돼
도 앞으로는 getConnection( ) 이라는 한 메소드의 묘드만 수정하면 된다. 관심의 종류
에 따라 코드를 구분해놓았기 때문에 한 가지 관심에 대한 변경이 일어날 경우 그 관심
이 집중되는 부분의 코드만 수정하면 된다. 관심이 다른 묘드가 있는 메소드에는 영향
을주지도않을뿐더러， 관심 내용이 독립적으로존재하므로수정도간단해졌다.

1장-오브젝트와 의존관계 63


변경사항에 대한 검증: 리팩토링과 테스트
그런데 앞에서 이미 UserDao
의 기능이 잘 통작한다는 것을 테스트해봤다. 하지만 코드
를 수정한 후에는 기능에 문제가 없다는 게 보장되지 않는다. 다시 검증이 필요하다. 변
경된
UserDao의 기능이 변경하기 전과동일한지 확인해보려면 어떻게 해야할까?방법
은 간단하다. 앞에서 만들어뒀던 main() 메소드를 이용한 태스트를 실행해보면 된다.
현재 main() 메소드 태스트에는 한 가지 단점이 있는데. main() 메소드를 여러 번 실행
하면 두 번째부터는 무조건 예외가 발생한다는 점이다. 태이블의 기본키인 id 값이 중
복되기 때문이다. 따라서 main() 메소드 테스트를 다시 실행하기 전에 User 태이블의
사용자 정보를 모두 삭제해줘야 한다. 그리고 다시 UserDao 클래스(사실은 static main 메소
되를 실행해보자. 아마 문제없이 이전과 동일한 결과가 출력될 것이다. 예외가 발생했
다면 변경 작업에 문제가 있는 것이니 문제가 있는 코드를 찾아 수정하자
. 물론 수정한
코드의 검증은 다시 main() 메소드를 실행해서 처음과 같은 결과가 화면에 출력되는지
를확인해보면된다.
밍땀 한 작업은 UserDao
의 기능에는 아무런 변회를 주지 없t다. 여전히 사용자 정
보를 등록하고 조회히는 조금 난감한 DAO 클래스일 뿐이다. 하지만 중요한 변화가 있
었다. 앞에서 한 작업은 여러 메소드에 중복돼서 동장하는 특정 관심사항이 담긴 코드
를 별도의 메소드로 분리해낸 것이다. 이 작업은 기능에는 영향을 주지 않으면서 코드
의 구조만 변경한다. 기능이 추가되거나 바뀐 것은 없지만 UserDao는 이전보다 훨씬 깔
끔해졌고 미래의 변화에 좀 더 손쉽게 대웅할 수 있는 코드가 됐다. 이런 작업을 리팩토
링
refactoring이라고 한다. 또한 위에서 사용한 getConnection( )이라고 하는 공통의 기능
을 담당히는 메소드로 중복된 코드를 뽑아내는 것을 리팩토링에서는 메소드 추출extract
method 기법이라고 부른다.
리팩토링은 객체지향 개발자라면 반드시 익혀야 하는 기법이다. 초난감 DAO 코드
를 개선해나가는 과정에서 우리는 기능을 추가하고 변경하기보다는， 겉으로 드러나는
기능은 그대로이지만 코드 구조와 구현 방법을 바꿈으로써 더 나은 DAO를 만드는 데
주력할 것이다. 앞으로는 이런 작업을 진행할 때 리돼토링한다고 이야기하겠다.

뿔
리뿔링
리팩토링은 기존의 코드톨 외부의 동작방식에는 변화 없이 내부 구조톨 변경해서 채구성하는
작엉 또는 기솔율 말한다. 리팩토링율 하면 코드 내부의 싫계가 개선되어 코드톨 이해하기가
더 편해지고. 변화에 효률적으로 대용힐 수 있다. 걸국 생산성은 올라가고. 코드의 홈질온 높아
지며. 유지보수하기 용이해지고. 견고하면서도 유연한 제품옳 개발할 수 있다. 리빽토링이 질


실히 필요한 코드의 특징옳 나쁜 냄새라고 부르기도 한다. 대표적으로， 종복된 코드는 매우 혼
하게 발견되는 나혼 냄새다. 이런 코드는 적절한 리팩토링 방법올 적용해 나쁜 냄새톨 제거해
줘야한다.

리팩토링은 개밟자가 직관적으로 수행힐 수 있긴 하지만. 본격적으로 적용하자연 학습과 훈련
이 필요하다. 나뽕 냄새에는 어떤 종류가 있고 그에 따론 적절한 리팩토링 방법은 무엇인지 앓아
보고. 흥봄한 연융올 해두면 도용이 된다. 리팩토링올 공부할 때는 리팩토링에 관해 체계적으로 잘
정리한 책인 r리팩토링j마틴 파율러. 켄트 백 공저}올 추천흔봐.

1.2.3 DB 커넥션 만들기의 독립
아주 초보적인 관심사의 분리 작업이지만 메소드 추출만으로도 변화에 좀 더 유연하게
대처할 수 있는 코드를 만들었다. 이번엔 좀 더 나아가서 변회에 대응히는 수준이 아니
라， 아예 변회를 반기는 DAO를 만들어보자.
앞에서 만든 UserDao가 발전에 발전을 거듭해서 드디어 ‘초슈퍼울트라캡짱 사용자
관리 DAO’가 됐고， 업계에 널리 알려지면서 인기를 꿀더니 급기야 세계적인 포탈 사이
트 N 사와 D 사에서 사용자 관리를 위해 이 UserDao를 구매하겠다는 주문이 들어왔다
고 상상해보자. 그런데 납품 과정에서 문제가 발생했다. 문제는 N 사와 D 사가 각기 다
른 종류의 DB를 사용하고 있고， DB 커넥션을 가져오는 데 있어 독자적으로 만든 방법
을 적용하고 싶어한다는 점이다. 더욱 큰 문제는 UserDao를 구매한 이후에도 DB 커넥
션을 가져오는 방법이 종종 변경될 기능성이 있다는 점이다.
이런 경우에는 이예 UserDao
의 소스묘드를 고객에게 제공해주고， 변경이 펼요하면
getConnection( ) 메소드를 수정해서 사용하라고 할 수 있다. 하지만 초특급 비밀기술
이 적용된 UserDao인지라 고객에게 소스를 직접 공개하고 싶지는 않다. 고객에게는 미
리 컴따일된 클래스 바이너리 파일만 제공하고 싶다. 과연 이런 경우에 UserDao 소스코
드를 N 사와 D 사에 제공해주지 않고도 고객 스스로 원하는 DB 커넥션 생성 방식을 적
용해가면서 UserDao를 사용하게 할 수 있을까?

상속을통한확장
물론 방법은 있다. 기존 UserDao 코드를 한 단계 더 분리하면 된다. 일단 우리가 만든
UserDao에서 메소드의 구현 코드를 제거하고 getConnection( )을 추상 메소드로 만
들어놓는다. 추상 메소드라서 메소드 묘드는 없지만 메소드 자체는 존재한다. 따라서
add() , get() 메소드에서 getConnection()을 호출하는 묘드는 그대로 유지할 수 있다.

1장-오브젝트와 의존관겨
65


이제 이 추상 클래스인 UserDao를 N 사와 D 사에게 판매한다. UserDao를 구입한 포탈
시들은 UserDao 클래스를 상속해서 각각 NUserDao와 DUserDao라는 서브클래스를 만
든다. 서브클래스에서는 UserDao에서 추상 메소드로 선언했던 getConnection() 메소
드를 원하는 방식대로 구현할 수 있다. 이렇게 하면 UserDao의 소스코드를 제공해서
수정해 쓰도록 하지 않아도 getConnection( ) 메소드를 원하는 방식으로 확장한 후에
UserDao의 기능과 함께 사용할 수 있다.

기존에는 같은 클래스에 다른 메소드로 분리됐던 DB 커넥션 연결이라는 관심을 이
번에는 상속을 통해 서브클래스로 분리해버리는 것이다. 그림 1-1
은 UserDao를 리팩토
링해서 getConnection( ) 기능을 자유롭게 확장하는 방법을 보여준다.

O••rDa。

add()

get ()
getConnection ()

亡수
getConnection() getConnection ()
그림 1-1 상속을 통한 UserDao 확장 방법

리스트 1-5는 이렇게 리팩토링한 코드다.
리스트 1-5 상속을 통한 확장 방법이 제공되는 UserDao

public abstract class UserDao (
public void add(User user) throws ClassNotFoundException , SQLException (
Connection c =getConnection();

public User get(String id) throws ClassNotFoundException , SQLException (
Connection c = getConnection();

구현 코드는 제거되고 추상 메소드로 바뀌었다
메소드의 구현은 서브클래스가 담S연‘다

P빼 SQLException;


상속율 통해 확장된 gelConnection( ) 메소드

public class NUserDao extends UserDao (

public Connection getConnection() throws ClassNotFoundException,
SQLException {
/I N 사 DB connection 생성쿄드


public class DUserDao extends UserDao (
public Connection getConnection() throws ClassNotFoundException ,
SQLException (
/I D 사 DB connection 생성쿄드

수정한 코드를 잘 살펴보자. DAO의 핵심 기능인 어떻게 데이터를 등록하고 가져올
것인개SQL 작성
， 따라미터 바인딩
. 쿼리 실행. 검색정보 전댈라는 관심을 담당하는 UserDao와. DB 연
결 방법은 어떻게 할 것인가라는 관심을 담고 있는 NUserDao. DUserDao가 클래스 레벨
로 구분이 되고 있다. 클래스 계층구조를 통해 두 개의 관심이 독립적으로 분리되면서
변경 작업은 한층 용이해졌다. 이제는 UserDao의 코드는 한 줄도 수정할 필요 없이 DB
연결 기능을 새롭게 정의한 클래스를 만들 수 있다. 이제 UserDao는 단순히 변경이 용
이하다라는 수준을 넘어서 손쉽게 확장된다라고 말할 수도 있게 됐다. 새로운 DB 연결
방법을 적용해야 할 때는 UserDao를 상속을 통해 확장해주기만 하면 된다.

이렇게 슈퍼클래스에 기본적인 로직의 흐름(커넥션 가져오기
. SQL 생성. 실행
， 반환)을 만들
고， 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로
만든 뒤 서브클래스에서 이런 메소드를 펼요에 맞게 구현해서 사용하도록 하는 방법

을 디자인 패턴에서 템플릿 메소드 패턴templat
e method pattern이라고 한다. 템플릿 메소
드 패턴은 스프링에서 애용되는 디자인 패턴이다. UserDao의 getConnection( ) 메소드
는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드다. 그리고
UserDao의 서브클래스의 getConnection( ) 메소드는 어떤 Connection 클래스의 오브
젝트를 어떻게 생성할 것인지를 결정하는 방법이라고도 볼 수 있다. 이렇게 서브클래스

에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 팩토리 메소드 때턴factory meth여
pattern이라고 부르기도 한다. 그림 1-2에 이를 다이어그랩으로 표현해뒀다.
서브클래스에서 구현히는 getConnection( ) 메소드는 JDBC가 정의한 Connection
인터페이스를 구현한 Connection 오브젝트를 각자의 생성 알고리즘을 이용해 만들어

1장-오브젝트와 의존관계 67


낸다. getConnection() 메소드에서 생성히는 Connection 오브젝트의 구현 클래스는
제각각이겠지만 UserDao는 Connection 인터페이스 타입의 오브젝트라는 것 외에는
관심을 두지 않는다. 그저 Connection 인터페이스에 정의된 메소드를 사용할 뿐이다.
UserDao는 어떤 기능을 사용한다는 데에만 관심이 있고， NUserDao나 DUserDao에서는
어떤 식으로 Connection 기능을 제공하는지에 관심을 두고 있는 것이다. 또， 어떤 방법
으로 Connection 오브젝트를 만들어내는지도 NUserDao와 DUserDao의 관심사혐}이다.
서버의 DB 커넥션 풀에서 가져올수도 있고， 드라이버를 직접 이용해 새로운
DB 커넥
션을 만들 수도 있다. UserDao는 Connection 오브젝트가 만틀어지는 방법과 내부 동작
방식에는 상관없이 자신이 필요한 기능을 Connection 인터페이스를 통해 사용하기만
할 뿐이다. 매우 깔끔한 방식으로 관심사항을 분리해 상하위 클래스에 나눠 담도록 만 든것이다.

-아

생

… >
---”

’

” (-)

다룹감ion

7 7

그림 1-2 UserD∞어| 적용된 팩토리 메소드 때턴

그림 1-2는 서브클래스의 getConnection( )을 통해 만들어진 Connection 오브젝트의
종류가 달라질 수 있게 하는 것을 목적으로 히는 디자인 패턴인 팩토리 메소드 패턴을
나타내는 그림이기도 하다. NUserDao와 DUserDao가 모두 같은 종류의 Connection 구현
클래스의 오브젝트를 리턴할 수도 있다. 그래도 오브젝트를 생성하는 방식이 다르다면，
이는 팩토리 메소드 패턴으로 이해할 수 있다.

혹시라도 갑자기 동장한 디자인 패턴 용어에 당황하지 말기 바란다. 디자인 패턴에
익숙하지 않거나 패턴의 종류를 잘 모르더라도 괜찮다. 중요한 건 상속구조를 통해 성
격이 다른 관심사항을 분리한 코드를 만들어내고 서로 영향을 덜 주도록 했는지를 이
해하는 것이다. 그런데 디자인 패턴은 설계 전략이기도 하지만 굉장히 편리한 커뮤니케
이션 수단이기도 하다. 스프링 개발지들 λ에에 지주 언급되는 몇 가지 주요한 디자인

-----
getConnection () getConnectι。n()
”
빼야짧0맹‘
$
야‘띠
Connection
r--------~----------~


패턴이라도 틈틈이 공부해두면 좋을 것이다. 패턴을 잘 아는 개발자라면 앞의 몇 페이
지에 달하는 설명을 “UserDao에 팩토리 메소드 패턴을 적용해서 getConnection( )을 분
리합시다”라는 한마디에 담아낼 수 있을 만큼 경제적이다.


響
디자인때턴

디자인 때턴은 소프트웨어 설계 시 특정 상황에서 자주 만나는 문제훌 해결하기 위해 시용활
수 있는 채사용 가능한 솔루션을 말한다. 모든 때턴에는 간결한 이륨이 있어서 잘 알려진 때턴
올 적용하그l자 할 때 간단히 때턴 이률올 언급하는 것만으로도 설계의 의도와 해결핵올 함께
설명할 수 있다는 장점이 있다. 디자인 때턴은 주로 객체지향 설계에 관한 것이고， 대부봄 객체
지항적 설계 원칙을 이용해 문제훌 해결한다. 패턴의 설계 구조률 보면 대부분 비슷한데. 그 이
유는 객체지향적인 설계로부터 문제훌 해결하기 위해 적용할 수 있는 확장성 추구 방법이 대부
분 두 가지 구조로 정리되기 때문이다. 하나는 클래스 상속이고 다른 하나는 오브젝트 합성이
다. 따라서 때턴의 결과로 나온 코드나 설계 구조만 보면 대부분 비슷해 보인다. 때턴에서 가장
중요한 것은 각 때턴의 핵심이 담긴 목적 또는 의도다. 때턴율 적용할 상황. 해결해야 할 문제，
솔루션의 구조와 각 요소의 역할과 함께 핵심 의도가 무엇인지률 기억해둬야 효빠.

디자인 때턴온 객체지향 언어인 자바톨 사용하는 개발자라먼 반드시 공부해야 할 주제다.
디자인 때턴율r
최초로 집대성한 책인 rGoF의 디자인 때턴i에릭 감마 외) 또는 rHead Fi엠
마웠gn Palternsi에릭 프리먼}옳 추천한다. GOF의 책온 딱력하고 어렵게 느껴질 수도 있지만，
디자인 때턴의 가장 충요한 핵심율 잘 설명하는 최고의 책이다. 다른 책옳 먼저 공부하더라도
언젠가 한 번온 팍 읽어보기 바란다.

월풍
햄톨횟빼;젤때턴
상속율 흉해 슈퍼클래스의 기능율 확장할 때 사용하는 가장 대표적인 방법이다. 변하지 않는 기
능온 슈퍼클래스에 만들어두고 자주 변경되며 확장힐 기눔은 서브쿨래스에서 만둘도록 효봐.
슈퍼률래스에서는 미리 추상 메소드 또는 오버라이드 가능한 메소드률 정의해두고 이룰 활용해
코드의 기본 알고리홈율 담고 있는 템훌릿 메소드률 만든다. 슈퍼쿨래스에서 디롤트 기능옳 정
의해두거나 비워뒀다가 서브클래스에서 선택적으로 오버라이드훨 수 있도룩 만돌어둔 메소드
톨 혹(hook) 메소드라고 한다. 서브클래스에서는 추상 메소드톨 구현하거나， 혹 메소드톨 오버
라이드하는 방법옳 이용해 기능의 잃부홉 확장한다.

public abstract class Super (

public void templateMethαj() (
11 기본 알고리즘 코드
hook빼eth여();

기본 앓고리홈 끓격올 담은 메소드톨 템훌릿 메소드라
부른다 템훌릿 머|소드는 서브훌래스빼서 오버라이드하
’ abstractMethod(); 거나 구현휠 메소드를 사용흔빠.

1장-오브젝트와 의존관겨
69


protected void hookMethod() { } -선택적으로 오버라이드 가농한 혹 때소드
public abstract void abstractMeth여0;-서브훌래스때서 반드시구현해야하는

추상빼소드

슈퍼를래스의 빼소드톨 오버라이드하거나 구현혜
public class Sub1 extends Super { -서 기S를흩 확장혼펙. 다옆} 확장 톨래스톨 E에i

protected void hookMethod() { 수 있다

public void abstractMethod() {

웰
의를리메짚때린
팩토리 메소드 때턴도 탬훌릿 메소드 때턴과 마찬가지로 상숙옳 흥해 기능률 확장흩때| 하는 때
힌이다. 그래서 구조도 비숫하다. 슈퍼콜래스 코드에서는 서브률래스에서 구현할 빼소드톨 호
흩해서 월요한 타입의 오브젝트톨 가져와 사용효빠. 이 메소드는 추로 인터페이스 타입으로 오
브잭트톨 리턴하므로 서브률래스에서 정확히 어떤 률래스의 오브젝트톨 만훌어 리턴활치는 슈
퍼롤래스애서는 알지 못한다. 사실 관심도 없다. 서브률래스는 다양한 방법으로 오브젝트훌 생
성하는 빼소드톨 채정의할 수 있다. 이렇게 서브쿨래스에서 오브젝트 생성 방법과 클래스훌 결
정할 수 있도룩 미리 정의해푼 메소드톨 팩토리 메소드라고 하고， 이 방식옳 통해 오브젝트 생
성 방법옳 나머지 로직. 즉 슈퍼클래스의 기본 코드에서 독립시키는 방법롤 팩토리 메소드 때턴
이라고 한다. 그림 1-2는 팩토리 메소드 패턴의 구조톨 잘 나타내고 있다. 자바에서는 종종 오
브젝트툴 생성하는 기능율 가진 메소드톨 일반적으로 팩토리 메소드라고 부르기도 한다.01때
말하는 팩토리 메소드와 팩토리 메소드 때턴의 팩토리 메소드는 의미가 다르므로 혼동하지 않
도룩주의해야한다.

이렇게 댐플릿 메소드 패턴 또는 팩토리 메소드 패턴으로 관심사항이 다른 묘드를
분리해내고， 서로 독립적으로 변경 또는 확장할 수 있도록 만드는 것은 간단하면서도
매우 효과적인 방법이다.

하지만 이 방법은 상속을 사용했다는 단점이 있다. 상속 자체는 간단해 보이고 시용
하기도 편리하게 느껴지지만 사실 많은 한계점이 있다. 만약 이미 UserDao가 다른 목적
을 위해 상속을 시용하고 있다면 어쩔 것인가? 자바는 클래스의 다중상속을 허용하지
않는다. 단지， 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어버리
면， 후에 다른 목적으로 UserDao에 상속을 적용하기 힘들다.

또 다른 문제는 상속을 통한 ÀJ하위 클래스의 관계는 생각보다 밀접하다는 점이다.


상속을 통해 관심이 다른 기능을 분리하고， 필요에 따라 다양한 변신이 가능하도록 확

장성도 줬지만 여전히 상속관계는 두 가지 다른 관심사에 대해 긴밀한 결합을 허용한

다. 서브클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다. 그래서 슈퍼클래스 내부

의 변경이 있을때 모든서브클래스를함께수정하거나다시 개발해야할수도있다. 반
대로 그런 변화에 따른 불편을 주지 않기 위해 슈퍼클래스가 더 이상 변화하지 않도록
제약을 가해야 할지도 모른다.

확장된 기능인 DB 커넥션을 생성하는 코드를 다른 DAO 클래스에 적용할 수 없다
는 것도 큰 단점이다. 만약 UserDao 외의 DAO 클래스들이 계속 만들어진다면 그때는
상속을 통해서 만들어진 getConnection( )의 구현 묘드가 매 DAO 클래스마다 중복돼
서 나타나는심각한문제가발생할것이다.

: ~으| 확장 펜I I

모든 오브젝트는 변한다고 했다. 그런데 오브젝트가 다 동일한 방식으로 변히는 건 아
니다. 관심사에 따라서 분리한 오브젝트들은 제각기 독특한 변화의 특징이 있다. 지금
까지 데이터 액세스 로직을 어떻게 만틀 것인가와 DB 연결을 어떤 방법으로 할 것인가
라는두 개의 관심을상하위 클래스로분리시켰다. 이 두 개의 관심은변화의 성격이 다

르다.

변화의 성격이 다르다는 건 변화의 이유와 시기 주기 등이 다르다는 뭇이다.
UserDao는 JDBC API를 사용할 것인가 DB 전용 API를 사용할 것인가， 어떤 테이블
이름과 필드 이름을 시용해 어떤 SQL을 만들 것인가， 어떤 오브젝트를 통해 DB
에 저

장할 정보를 전달받고. DB에서 꺼내온 정보를 저장해서 넘겨줄 것인가와 같은 관심
을 가진 코드를 모아둔 것이다. 따라서 이런 관심사가 바뀌면 그때 변경이 일어난다.
하지만 이때도 DB 연결 방법이 그대로라면 DB 연결 확장 기능을 담은 NUserDao나
DUserDao의 묘드는 변하지 않는다. 반대로 사용자 정보를 저장하고 가져오는 방법에 대
한 관심은 바뀌지 않지만 DB 연결 방식이나 DB 커넥션을 가져오는 방법이 바뀌면， 그
때는 UserDao 묘드는 그대로인 채로 NUserDao나 DUserDao의 코드만 바뀐다.

추상 클래스를 만들고 이를 상속한 서브클래스에서 변화가 필요한 부분을 바꿔서 쓸
수 있게 만든 이유는바로 이렇게 변화의 성격이 다른 것을분리해서， 서로 영향을주지
않은 채로 각각 멸요한 시점에 독립적으로 변경할 수 있게 하기 위해서다. 그러나 여러

가지 단점이 많은， 상속이라는방법을사용했다는사실이 불편하게 느껴진다.

1장-오브젝트와의홈관계 71


1.3.1 클래스의 분리
이번에는 관심사가 다르고 변화의 성격이 다른 이 두 가지 묘드를 좀 더 화끈하게 분리
해볼 생각이다. 두 개의 관심사를 본격적으로 독립시키면서 동시에 손쉽게 확장할 수

있는방법을알아보자.

지금까지는 성격이 다른， 그래서 다르게 변할 수 있는 관심시를 분리히는 작업을 점

진적으로 진행해왔다. 처음에는 독립된 메소드를 만들어서 분리했고， 다음에는 싱P하위

클래스로 분리했다. 이번에는 아예 상속관계도 아닌 완전히 독립적인 클래스로 만들어

보겠다. 방법은 간단하다. DB 커넥션과 관련된 부분을 서브클래스가 아니라， 아예 별

도의 클래스에 담는다. 그리고 이렇게 만든 클래스를 UserDao가 이용하게 하면 된다.

정말간단하지않은가?

U••rI.써。

simpleConnectionMaker

-------------->

add()

get ()

그림 1-3 투 개의 독립된 클래스로 분리한 결과

그림 1-3
에 나와 있는 것처럼 SimpleConnectionMaker
라는 새로운 클래스를 만
들고 DB 생성 기능을 그 안에 넣는다. 그리고 UserDao는 new 키워드를 사용해
SimpleConnectionMaker 클래스의 오브젝트를 만들어두고， 이를 add (). get () 메소드
에서 사용하면 된다. 각 메소드에서 매번 SimpleConnectionMaker의 오브젝트를 만들
수도 있지만， 그보다는 한 번만 SimpleConnectionMaker 오브젝트를 만들어서 저장해두
고 이를 계속 사용하는 편이 낫다.

이렇게 수정한 UserDao 코드는 리스트 1-6과 같다. UserDao는 상속을 통한 방법을 쓰
지 않으니 더 이상 abstract일 필요는 없다. 먼저 생성자에서 SimpleConnectionMaker의
오브젝트를 만들어두고. add/get 메소드에서 이를 이용해 DB 커넥션을 가져오면 된다.

리스트 1-6 독립된 Sim머eConnectionMaker톨 사용하게 만든 UserO∞

public class UserDao {
private SimpleConnectionlaker simpleConnectionlaker;

상태톨 관리하는 것도 아니니 한 번만 만둘어 인스턴스
」수에 저장해두고 메소드에서 사용하게 효되

publ ic UserDao() { ~ . -" --,=-" , --..
simpleConnection삐
aker =new SimpleConnectionlaker();


public void add(User user) throws ClassNotFoundException , SQLException (
Connection c =simpleConnectionMaker.makeNewConnection();

public User get(String id) throws ClassNotFoundException , SQLException (
Connection c =simpleConnectionMaker.makeNewConnection();

DB 커넥션 생성 기능을 독립시킨 SimpleConnectionMaker는 리스트 1-7과 같이 만
든다.

리스트 1-7 독립시킨 DB 연결 기능인 SimpleConnectionMaker

package springbook.user.dao;
‘ 더 이상 상속을 이용한 확장 방식을 사용할 필요가
| ’ public class SimpleConnectionMaker ( 없으니 추상 클래스로 묘멸 필요가 없다

public Connection makeNewConnection() throws ClassNotFoundException ,

SQLException (
Class .forName( "com .mysql. jdbc .Dri ver ‘);
Connection c =DriverManager.getConnection(

"j dbc :mysql: /!localhost/springbook" , 연pring"， "book");
return c;

기존 코드에 많은 수정을 했지만 기능에 변화를 준 것은 없다. 단지 내부 설계를 변
경해서 좀 더 나은 코드로 개선했을 뿐이다. 기능에 변화가 없다는 것은 이런 리돼토링
작업의 전제이기도 하지만 사실은 검증 내용이기도 하다. 정말 기능의 변화가 없이 동
일한지 누군가확인해주지 않으면 안된다. 따라서 앞에 만들어둔
main() 메소드를 다
시 실행해서 수정하기 전과 통일한 결과가 나오는지 확인해보자. 테스트를 실행하기 전
에 DB에 남아 있는 기존 데이터를 지우는 것을 잊으면 안 된다.

성격이 다른 코드를 화끈하게 분리하기는 잘한 것 같은데， 이번엔 다른 문제가
발생했다
N 사와 D 사에 UserDao 클래스만 공급하고 상속을 통해 DB 커넥션 기
능을 확장해서 사용하게 했던 게 다시 불가능해졌다. 왜냐하면 UserDao
의 코드가
SimpleConnectionMaker라는 특정 클래스에 종속되어 있기 때문에 상속을 사용했을 때
처럼 UserDao 코드의 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다. 다른 방식

1장-오브젝트와 의존관계 73


으로 DB 커넥션을 제공히는 클래스를 사용하기 위해서는 UserDao 소스코드의 다음 줄
을 직접 수정해야 한다. UserDao의 소스코드를 함께 제공하지 않고는 DB 연결 방법을
비꿀 수 없다는 처음 문제로 다시 되돌아와 버렸다.

simpleConnectionMaker = new SimpleConnectionMaker();

이렇게 클래스를 분리한 경우에도 상속을 이용했을 때와 마찬가지로 자유로운 확장
이 가능하게 하려면 두 가지 문제를 해결해야 한다. 첫째는 SimpleConnectionMaker의
메소드가 문제다. 우리는 makeNewConnection()
을 사용해 DB 커넥션을 가져오게 했는
데， 만약 D 사에서 만든 DB 커넥션 제공 클래스는 openConnection()
이리는 메소드 이
름을 사용했다면 UserDao 내에 있는 add (). get () 메소드의 커넥션을 가져오는 코드를
다음과 같이 일일이 변경해야 한다. 지금은 메소드가 단 두 개이니 상관없지만， 수십，
수백 개가 되면 그때는 작업의 양이 너무 커진다.

Connection c =simpleConnectionMaker.openConnection();

두 번째 문제는 DB 커넥션을 제공하는 클래스가 어떤 것인지를 UserDao가 구체적으

로 알고 있어야 한다는 점이다. UserDao에 SimpleConnectionMaker라는 클래스 타입의

인스턴스 변수까지 정의해놓고 있으니，
N 사에서 다른 클래스를 구현하면 어쩔 수 없이

UserDao 자체를 다시 수정해야 한다.

이런 문제의 근본적인 원인은 UserDao가 바뀔 수 있는 정보， 즉 DB 커넥션을 가져
오는 클래스에 대해 너무 많이 알고 있기 때문이다. 어떤 클래스가 쓰일지， 그 클래스
에서 커넥션을 가져오는 메소드는 이름이 뭔지까지 일일이 알고 있어야 한다. 따라서
UserDao는 DB 커넥션을 가져오는 구체적인 방법에 종속되어 버린다. 지금은 UserDao
가 SimpleConnectionMaker라는 특정 클래스와 그 코드에 종속적이기 때문에 앞으로 납
품 후에 고객이 DB 커넥션을 가져오는 방법을 자유롭게 확장하기가 힘들어졌다. 이래
서는 상속을 이용한 방법만도 못한 게 아닌가 싶다.

1.3.2 인터페이스의 도입
그렇다면 클래스를 분리하면서도 이런 문제를 해결할 수는 없을까? 물론 있다. 가장 좋
은 해결책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중죠써l 추상적인
느슨한 연결고리를 만들어주는 것이다. 추상화란 어떤 것들의 공통적인 성격을 뽑아내
어 이를 따로 분리해내는 작업이다. 자님까 추상회를 위해 제공하는 가장 유용한 도구
는 바로 인터페이스다. 인터페이스는 자신을 구현한 클래스에 대한 구체적인 정보는 모


두 감춰
버린다. 결국 오브젝트를 만들려면 구체적인 클래스 하나를 선택해야겠지만 인
터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들
때 사용할 클래스가 무엇인지 몰라도 된다. 인터페이스를 통해 접근하게 하면 실제 구
현 클래스를 바꿔도 신경 쓸 일이 없다.

그림 )-4는 인터페이스를 도입한 후 클래스의 관계를 표현한 것이다. 이제 UserDao
는 자신이 사용할 클래스가 어떤 것인지 몰라도 된다. 단지 인터페이스를 통해 원히는
기능을 사용하기만 하면 된다.

U.ert써0

connecti onMaker

add()

get ()

「

’

NConnectionMaker DConnactioÑμ‘
kar
makeConnection () makeConnection()

그림 1-4 인터페이스를 도입한 결과

인터페이스는 어떤 일을 하겠다는 기능만 정의해놓은 것이
다. 따라서 인터페이스에는
어떻게 하겠다는 구현 방법은 나타나 있지 않다. 그것은 인터페이스를 구현한 클래스들
이 알아서 결정할 일이다. UserDao가 인터페이스를 사용하게 한다변 인터페이스의 메
소드를 통해 알 수 있는 기능에만 관심을 가지면 되지， 그 기능을 어떻게 구현했는지에
는 관심을 둘 펼요가 없다.

먼저 리스트 )-8과 같이 ConnectionMaker 인터페이스를 정의하자. DB 커넥션을
가져오는 메소드 이름은 makeConnection()
이라고 정했다. 이 인터페이스를 사용하는
UserDao 입징벼l서는 ConnectionMaker 인터페이스 타입의 오브젝트라면 어떤 클래스로
만들어졌든지 상관없이 makeConnection() 메소드를 호출하기만 하면 Connection 타입
의 오브젝트를 만들어서 돌려줄 것이라고 기대할 수 있다.

리스트 1-8 ConnectionMaker 인터페이스

ConnectionMaker
makeConnection ()
……
’

package springbook.user.dao;

public interface ConnectionMaker {
public Connection makeConnection () throws ClassNotFoundException ,
SQLException;

1장-오브젝드와 의존관계 75


고객에게 납품을 할 때는 UserDao 클래스와 함께 ConnectionMaker 인터페이스도 전
달한다. 그리고 D 사의 개발자라면 리스트 1-9와 같이 ConnectionMaker 인터페이스를
구현한 클래스를 만들고 자신들의 DB 연결 기술을 이용해 DB 커넥션을 가져오도록
메소드를 작성해주면 된다.

리스트 1-9 ConnectionMaker 구현 클래스

package springbook .user.dao;
public class DConnectionMaker implements ConnectionMaker (
public Connection makeConnection( ) throws ClassNotFoundException , SQLException {

// D 사의 독자적인 방법으로 Connection올 생성하는 코드

리스트 1-10은특정 클래스
대신 인터페이스를사용해서 DB 커넥션을가져와사용
하도록 수정한 UserDao 코드다.

리스트 1-10 ConnectionMaker 인터페이스톨 사용하도록 개선한 UserOa。

public class UserDao (
private ConnectionMaker connectionMaker; -→~ 인터페이스톨 룡해 오브젝트에 접근하므로

구체적인 클래스 정보흘 일 필요가 없다

public UserDao () (
connection
삐
aker = new DConnectionMaker(); ~ 앗! 그런데 여기에는 클래스

이홈이나오내
11

public void add(User user) throws ClassNotFoundException , SQLException (
Connection c = connectionMaker.makeConnection() ;

니 인터페이스에 정의된 메쏘톨 A용빡

클래스가 바켄다고 해도 메소드 이륨이 변
경월걱정은없다.

public User get(String id) throws ClassNotFoundException , SQLException (
Connection c = connectionMaker.makeConnection();

UserDao의 add() . get() 메소드와 펼드에는 ConnectionMaker라는 인터페이스와 인
터페이스의 메소드인 makeConnection만 사용하도록 했다. 그러니 이제는 아무리 N 사


와 D 사가 DB 접속용 클래스를 다시 만든다고 해도 UserDao의 묘드를 묻어 고칠 일은
없을 것 같다. 그런데 UserDao 묘드를 자세히 살펴보면 DConnection
이라는 클래스 이
름이 보인다. DConnection 클래스의 생성자를 호출해서 오브젝트를 생성히는 묘드가
다음과 같이 여전히 UserDao
에 남아 있다.

connectionMaker = new DConnectionMaker();

UserDao
의 다른 모든 곳에서는 인터페이스를 이용하게 만들어서 DB 커넥션을 제공

하는 클래스에 대한 구체적인 정보는 모두 제거가 가능했지만， 초기에 한 번 어떤 클래

스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아 있다. 제거

하고 싶은데 간단한 방법이 보이지 않는다. 클래스 이름을 넣어서 오브젝트를 만들지

않으면 어떻게 사용하란 말인가!

결국， 또 다시 원점이다. 여전히 UserDao 소스묘드를 함께 제공해서， 필요할 때마다

UserDao의 생성자 메소드를 직접 수정하라고 하지 않고는 고객에게 지유로운 DB 커넥

션 확장 기능을 가진 UserDao를 제공할 수가 없다.

1.3.3 관계설정 책임의 분리
UserDao와 ConnectionMaker라는 두 개의 관심을 인터페이스를 써가면서까지 거의 완
벽하게 분리했는데도， 왜 UserDao가 인터페이스뿐 아니라 구체적인 클래스까지 알아야
한다는 문제가 발생하는 것일까? 여전히 UserDao에는 어떤 ConnectionMaker 구현 클
래스를 시용할지를 결정히는 묘드가 남아 있다. 이 때문에 인터페이스를 이용한 분리에
도 불구하고 여전히 UserDao 변경 없이는 DB 커넥션 기능의 확장이 자유롭지 못한데，
그 이유는 UserDao 안에 분리되지 않은， 또 다른 관심사항이 존재하고 있기 때문이다.
UserDao
에는 어떤 ConnectionMaker 구현 클래스를 사용할지를 결정하는 new
DConnectionMaker()
라는 코드가 있다. 이 코드는 기존 UserDao의 관심사인 JDBC API
와 User 오브젝트를 이용해 DB
에 정보를 넣고 빼는 것도 아니고， ConnectionMaker 인
터페이스로 대표되는 DB 커넥션을 어떻게 가져올 것인가라는 관심사도 아니다. new
DConnectionMaker()
라는 묘드는 매우 짧고 간단하지만 그 자체로 충분히 독립적인 관
심사를 담고 있다. 바로 UserDao가 어떤 ConnectionMaker 구현 클래스의 오브젝트
를 이용하게 할지를 결정하는 것이다. 간단히 밀봐자면 UserDao와 UserDao가 사용할
ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심이다.
이 관심시를 담은 코드를 UserDao에서 분리하지 않으면 UserDao는 결코 독립적으로 확
장 기능한 클래스가 될 수 없다.

1장-오브젝트와 의존관계 77


UserDao를 시용하는 클라이언트가 적어도 하나는 존재할 것이다. 여기서 말하는 클
라이언트는 거창하게 브라우저나
PC 같은클라이언트장비를 말하는 게 아니다. 두 개
의 오브젝트가 있고 한 오브젝트가 다른 오브젝트의 기능을 사용한다면， 사용되는 쪽
이 사용하는 쪽에게 서비스를 제공하는 셈이다. 따라서 사용되는 오브젝트를 서비스，
사용하는 오브젝트를 클라이언트라고 부를 수 있다. UserDao의 클라이언트라고 하면
UserDao를 사용히는 오브젝트를 가리 킨다. UserDao와 ConnectionMaker 구현 클래스 얘
기를 하다가， 왜 푼금없이 클라이언트 오브젝트를 끄집어내느냐 하면， 바로 이 UserDao
의 클라이언트 오므젝트가 바로 제3
의 관심사항인 UserDao와 ConnectionMaker 구현 클
래스의 관계를 결정해주는 기능을 분리해서 두기에 적절한 곳이기 때문이다.

UserDao의 클라이언트에서 UserDao를 사용하기 전에 먼저 UserDao가 어떤
ConnectionMaker의 구현 클래스를 λ}용할지를 결정하도록 만들어보자. 즉 UserDao 오
브젝트와 특정 클래스로부터 만들어진 ConnectionMaker 오브젝트 사이에 관계를 설정
해주는 것이다. 사실 클래스 사이의 관계를 설정해주는 건 아니다. 클래스 사이에 관계
가 만들어진다는 것은 한 클래스가 인터페이스 없이 다른 클래스를 직접 시용한다는 뭇
이다. 따라서 클래스가 아니라 오브젝트와 오브젝트 사이의 관계를 설정해줘야 한다.

오브젝트사이의 관계는 런타임 시에 한쪽이 다른오브젝트의 레퍼런스를갖고 있는
방식으로 만들어진다. 예를 들면 다음 코드는 DConnectionMaker
의 오브젝트의 레퍼 런
스를 UserDao의 connectionMaker 변수에 넣어서 사용하게 함으로써， 이 두 개의 오브
젝트가 ‘사용’이라는 관계를 맺게 해준다.

connectionMaker =new DConnectionMaker();

오브젝트 λ씨의 관계가 만들어지려면 일단 만들어진 오브젝트가 있어야 하는데， 이
처럼 직접 생성자를 호출해서 직접 오브젝트를 만드는 방법도 있지만 외부에서 만들어
준 것을 가져오는 방법도 있다. User
D
ao도 동작하려면 하나의 오브젝트가 만들어질 것
이다. UserDao 오브젝트가 다른 오브젝트와 관계를 맺으려면 관계를 맺을 오브젝트가
있어야 할 댄데， 이 오브젝트를 목 UserDao의 코드 내에서 만들 필요는 없다. 오브젝트
는 얼마든지 메소드 파라미터 등을 이용해 전달할 수 있으니 외부에서 만든 걸 가져올
수도있다.

외부에서 만든 오브젝트를 전달받으려면 메소드 따라미터나 생성자 파라미터를 이
용하면 된다. 이때 파라미터의 타입을 전달받을 오브젝트의 인터페이스로 선언해뒀다
고 해보자. 이런 경우 파라미터로 전달되는 오브젝트의 클래스는 해당 인터페이스를 구
현하기만 했다면 어떤 것이든지 상관없다. 단지 해당 인터페이스 타업의 오브젝트라면


파라미터로 전달 가능하고， 파라미터로 제공받은 오브젝트는 인터페이스에 정의된 메
소드만 이용한다면 그 오브젝트가 어떤 클래스로부터 만들어졌는지 신경 쓰지 않아도

된다.

ConnectionMaker 인터페이스를 적용한 그림 1-4를 다시 살펴보자. 인터페이
스를 사용한 덕분에 UserDao와 ConnectionMaker의 구현 클래스들은 직접 연결되
어 있지 않는 것처럼 보인다. 하지만 리스트 1-10의 UserDao 묘드를 자세히 살펴보
면 ConnectionMaker 인터페이스를 사용했음에도 불구하고 그림 1-5와 같이 UserDao
와 DConnectionMaker 클래스 사이에 직접적인 관계가 었다는 사실을 알 수 있다.
UserDao
에 new DConnectionMaker()
라는 코드가 나오기 때문이다. 그래서 UserDao
가 NConnectionMaker를 사용하게 하려면 UserDao의 코드를 뜯어고쳐서 이번에는

NConnectionMaker와 관계를 맺도록 만들어야 한다.

따라서 UserDao의 모든 코드는 ConnectionMaker 인터페이스 외에는 어떤 클래스와
도 관계를 가져서는 안 되게 해야 한다. 그래야만 그림 1-4와 같은 의존관계가 만들어
질 것이고， 그 덕분에 UserDao의 수정 없이 DB 커넥션 구현 클래스를 변경할 수 있다.

띈ζJ------------:끼 Conne빡Maker

?'、、
r------------‘--------------1
’ ’

灣#넓n짧禮 、커 I I

DConnectionMaker NConnectionMaker

그림 1-5 클래스 사이에 불필요한 의존관계를 갖고 있는 구조

물론 UserDao 오브젝트가 동작하려면 특정 클래스의 오브젝트와 관계를 맺어야 한다.
DB 커넥션을 제공히는 기능을 가진 오브젝트를 사용하기는 해야 하니 말이다. 인터페
이스 자체에는 기능이 없으니 이를 사용할 수도 없다. 결국 특정 클래스의 오브젝트와
관계를맺게된다.

하지만 클래스 사이에 관계가 만들어진 것은 아니고， 단지 오브젝트 사이에 다이내
믹한 관계가 만들어지는 것이다. 이 차이를 잘 구분할 수 있어야 한다. 클래스 사이의
관계는 코드에 다른 클래스 이름이 나타나기 때문에 만들어지는 것이다. 하지만 오브
젝트 사이의 관계는 그렇지 않다. 묘드에서는 특정 클래스를 전혀 알지 못하더라도 해
당 클래스가 구현한 인터페이스를 사용했다면， 그 클래스의 오브젝트를 인터페이스 타
입으로 받아서 사용할 수 있다. 바로 객체지향 프로그램에는 다형성이라는 특징이 있는

덕분이다.
UserDao 오브젝트가 DConnectionManager 오브젝트를 사용하게 하려면 두 클래스의

1장-오브젝트와 의존관계 79


오브젝트 사이에 런타임 시용관계 또는 링크 또는 의존관계라고 불리는 관계를 맺어주
면 된다. 그림 1-6은 이 두 오브젝트 사이에 의존관계가 만들어진 것을 보여준다. 그림
1-6은 모댈링 시점의 클래스 다이어그햄이 아니라 런타임 시점의 오브젝트 간 관계를
나타내는 오브젝트 다이어그램임을 주의하자. 모댈링 시에는 없었던， 그래서 코드에는
보이지 않던 관계가 오브젝트로 만들어진 후에 생성되는 것이다.

:
UserDa。
켜 DConnect빼

그힘 1-6 UserDa。
오브젝트와 DConnectionMaker 오브젝트 사이의 관계가 만툴어진 상태

그렇다면 UserDao도 아니고 DConnectionMaker와 같은 ConnectionMaker 구현 클래스
도 아닌 제3의 오브젝트라고 했던 UserDao의 클라이언트는 무슨 역할을 하는 것일깨
그림 1-4와 같은 구조의 클래스들을 이용해 그림 1-6과 같은 런타임 오브젝트 관계를
갖는 구조로 만들어주는 게 바로 클라이언트의 책임이다.

클라이언트는 자기가 UserDao를 사용해야 할 입장이기 때문에 UserDao의 세부 전략
이라고도 볼 수 있는 ConnectionMaker
의 구현 클래스를 선택하고， 선택한 클래스의 오
브젝트를 생성해서 UserDao와 연결해줄 수 있다. 기존의 UserDao에서는 생성자에게 이
책임이 있었다. 자신이 사용할 오브젝트를 직접 만들어서 자신과 관계를 만들어버리
는 것이 기존 UserDao 생성자가 한 일이다. 다시 말하지만 이것은 UserDao의 관심도 아
니고 책임도 아니다. 다른 관심사가 함께 있으니 확장성을 떨어뜨리는 문제를 일으키는
것이다.

자， 이제 이 다른관심을분리해서 클라이언트에게 떠넘겨보자.

현재는 UserDao 클래스의 main() 메소드가 UserDao 클라이언트라고 볼 수 있다.
좀 더 깔끔하게 구분하기 위해 아예 UserDaoTest
라는 이름의 클래스를 하나 만들
고 UserDao에 있던 main() 메소드를 UserDaoTest로 옮겨보자. 그리고 UserDao의 생
성자를 수정해서 클라이언트가 미리 만들어둔 ConnectionMaker
의 오브젝트를 전달
받을 수 있도록 따라미터를 하나 추가한다. UserDao
의 생성자는 이제 리스트 1-11
과 같이 바뀌었다. 클라이언트와 같은 제3
의 오브젝트가 UserDao 오브젝트가 사용할
ConnectionMaker 오브젝트를 전달해주도록 만든 것이다. 그런데， 이렇게 하고 나니
UserDao에는 ConnectionMaker의 구체적인 구현 클래스 이름인 DConnectionMaker가 사
라졌다! 드디어 처음 기대했던 그림 1-4의 구조가 반영된 묘드가 된 것이다.


리스트 1-11 수정한 생성자

public UserDao(ConnectionMaker connectionMaker) (
this.connectionMaker =connectionMaker;


DConnectionMaker는 왜 사라졌을까? DConnectionMaker를 생성하는 코드는 UserDao
와 특정 ConnectionMaker 구현 클래스의 오브젝트 간 관계를 맺는 책임을 담당하는 코
드였는데， 그것을 UserDao
의 클라이언트에게 넘겨버렸기 때문이다. 이제 클라이언트로
서 새로운 책임을 맡게 된 UserDaoTest
의 main() 메소드는 기존 UserDao의 main() 메
소드를 그대로 가져온 후 리스트 1-12와 같이 코드를 수정한다. 기존 UserDao의 생성
자에 있다가 사라진 new DConnectionMaker()
라는 구체적인 클래스 이름을 가진 코드
가 바로 여기에 등장한다.

리스트 1-12 관계설정 책임이 추가된 UserD∞ 클매|언트인 main() 메소드

public class UserDaoTest (
public static void main(String[] args) throws ClassNotFoundException ,

SQLException (
ConnectionMaker connectionMal‘er = new DConne띠onMakerO;-..
UserD∞기 사용할 ConnectionMaker

UserDao dao =new UserDao(connectionMaker);+ 구현 클래스룰 결정하고 오브젝트톨
만든다
1. USerD∞생성
2. 사용힐 ConnectionMaker 타입의 오브젝트 제공
결국 두 오브젝트 사이의 의존관계 설정 효과

UserDaoTest는 UserDao와 ConnectionMaker 구현 클래스와의 런타임 오브젝트 의존
관계를 설정히는 책임을 담당해야 한다. 그래서 특정 ConnectionMaker 구현 클래스의
오브젝트를 만들고. UserDao 생성자 파라미터에 넣어 두 개의 오브젝트를 연결해준다.
그리고 원래 자기 책임이던 UserDao에 대한 태스트 작업을 수행한다.

드디어 UserDao
에 있으면 안 되는 다른 관심사항 책임을 클라이언트로 떠넘기는 작
업이끝났다.

클라이언트인 UserDaoTest가 이렇게 수고해준 덕분에 이제는 UserDao의 변경 없이
도 지유롭게 N 사와 D 사는 자신들을 위한 DB 접속 클래스를 만들어서 UserDao가 사
용하게 할 수 있다. NConnectionMaker 클래스를 만들었다면 UserDaoTest와 같은 클라

1장-오브젝트와 의존관계 81


이언트 코드를 리스트 1-13처럼만 만들어주변 된다. 이렇게 해서 UserDao에는 전혀 손
대지 않고도모든고객이 만족스럽게 DB 연결 기능을확장해서 사용할수 있게 됐다.

리스트 1-13 클라이언트 역할의 UserD∞，Test

public static void main(String[] args) throws ClassNotFoundException , SQLException
ConnectionMaker connectionMaker = new NConnectionMaker();

UserDao는 자신의 관심사이자 책임인 사용자 데이터 액세스 작업을 위해 SQL을 생
성하고， 이를 실행하는 데만 집중할 수 있게 됐다. 더 이상 DB 생성 방법이나 전략에
대해서는 조금도 고민할 필요가 없다. DB 커넥션을 가져오는 방법을 어떻게 변경하든
UserDao 코드는 아무런 영향을 받지 않는다.

이렇게 인터페이스를 도입하고 클라이언트의 도움을 얻는 방법은 상속을 사용해 비
슷한 시도를 했을 경우에 비해서 훨씬 유연하다. ConnectionMaker라는 인터페이스를
사용하기만 한다변 다른 DAO 클래스에도 ConnectionMaker의 구현 클래스들을 그대로
적용할 수 있기 때문이다. DAO가 아무리 많아져도 DB 접속 방법에 대한 관심은 오직
한 군데에 집중되게 할 수 있고， DB 접속 방법을 변경해야 할 때도 오직 한 콧의 코드
만수정하면된다.

그림 1-7은 UserDao가 사용할 ConnectionMaker 클래스를 선정하는 책임을
UserDaoTest가 담당하고 있는 구조를 보여준다.D 사에서 UserDao를 구매한 후
DConnectionMaker를 만들어 적용한 경우라고 생각해보자. 먼저 UserDaoTest는
UserDao가 실제로 사용할 DConnectionMaker 오브젝트를 생성한다. 그리고 UserDao
오브젝트를 생성하면서 생성자를 통해 DConnectionMaker 오브젝트를 전달한다. 물
론 UserDao
의 생성자는 ConnectionMaker 인터페이스· 타입으로 전달받기 때문에
ConnectionMaker 인터페이스를 구현했다면 어떤 클래스로 만든 오브젝트라도 상
관없다. 관심도 없다. 이제 UserDaoTest는 멸요한 오브책트를 생성하고 관계를 맺
어주는 준비 작업을 모두 마쳤으니， 태스트를 위해 UserDao의 add() , get() 메소드
를 사용한다. 이때 UserDao는 생성자를 통해 전달받아서 인스턴스 변수에 저장해둔
DConnectionMaker 오브젝트의 makeConnection() 메소드를 호출해서 DB 커넥션을 생
성해사용한다.


UserDaoTest f앨원4센꿀Z〉! Use매a。 ~
__<<!-t홀?'-->I |

、

、

、

--':.^별℃ >| c。nIiecti。ri빼kar
‘-----------_.생성” DConnectionMaker

그림 1-7 관계설정 책임을 담당한 클라이언트 UserDaoTest가 추가된 구조

앞에서 사용했던 상속을 통한 확장 방법보다 더 깔끔하고 유연한 방법으로 UserDao
와 ConnectionMaker 클래스들을 분리하고 서로 영향을 주지 않으면서도 필요에 따라
자유롭게 확장할 수 있는 구조가 됐다.

디음은 객체지향 설계와 프로그래밍의 이론을 통해서 마지막으로 적용한 방법을 좀
더 체계적으로 살펴보겠다.

1.3.4 원칙과꽤턴
지금까지 초난감 DAO 코드를 개선해옹 결괴를 객체지향 기술의 여러 가지 이론을 통
해 설명하려고 한다. 따라서 갑자기 많은 용어가 등장할 것이다. 이런 용어에 친숙하지
않은 개발자라면 부담을 느낄 수도 있겠는데， 일단 이런 잘 알려진 이론을 통해서 지금
까지 해옹 작업의 결과가 어떤 장점이 있는지 설명할 수 있구나 하는 정도로 이해하고
넘어가도 좋다. 좀 더 관심이 있다면 여기에 소개한 원리와 패턴에 관한 인터넷 자료나
서적을 찾아서 공부해보자. 여기 나오는 용어들은 스프링을 설명할 때 자주 등장하므로
친숙해지면 스프링을 이해하는 데 많은 도움이 된다.

개방폐쇄원칙

개방 펴|쇄 원칙OCP. Open-Closed Principle을 이용하면 지금까지 해옹 리패토링 작업의 특정

과 최종적으로 개선된 설계와 코드의 장점이 무엇인지 효과적으로 설명할 수 있다. 개

방 패쇄 원칙은 깔끔한 설계를 위해 적용 가능한 객체지향 설계 원칙 중의 하나다. 이

원칙을 간단히 정의하자면 ‘클래스나 모률은 확장에는 열려 있어야 하고 변경에는 닫혀

있어야 한다’라고 할 수 있다. UserDao는 DB 연결 방법이라는 기능을 확장하는 데는 열

려 있다. UserDao에 전혀 영향을 주지 않고도 얼마든지 기능을 확장할 수 있게 되어 있

다. 동시에 UserDao 자신의 핵심 기능을 구현한 코드는 그런 변화에 영향을 받지 않고

유지할 수 있으므로 변경에는 닫혀 있다고 말할 수 있다.

그림 1-7은 개방 패쇄 원칙을 가장 잘 보여주는 그림이다. 인터페이스를 통해 제공

1장-오브젝트와 의혼관계 83


되는 확장 포인트는 확장을 위해 활짝 개방되어 있다. 반면 인터페이스를 이용하는 클
래스는 자신의 변화가 불필요하게 일어나지 않도록 굳게 폐쇄되어 있다. 만약 초난감
DAO 처음의 모습이라면 어떨까? 초난감 DAO는 DB 연결 방법을 확장하기도 매우 불
편하니 확장에 필요한 유연성은 부족하고 DB 연결 방법을 확장하그1자 하면 DAO 내
부도 변경해야 하니 변화에 구멍이 나 있는 셈이다. 즉 초난감 DAO는 개방 패쇄 원칙
을잘따르지못한설계라고할수있다.

잘 설계된 객체지향 클래스의 구조를 살펴보면 바로 이 개방 패쇄 원칙을 아주 잘 지
키고 있다. 인터페이스를 사용해 확장 기능을 정의한 대부분의 API는 바로 이 개방 패
쇄 원칙을 따른다고 볼 수 있다.

월폼 객체지황 염계 원칙(SOU미
객체지향 기솔은 어느 날 한 번에 만풀어진 것이라기보다는 오랜 시ζ뻐| 젊쳐 점진적으로 밟전
해온 기슐이라고 를 수 있다. 그뭘기 때문에 객체지향 프로그래밍 언어의 종류도 다.'Y하고 객체
지항 기슐율 받O끊01고 적용하는 관점과 기법도 조금씩 차이가 있다. 그럽에도 객체지향이라
는 이롬으로 묶옳 수 있는 분명한 특징이 있다. 객체지향 설계 원칙은 객체지향의 륙징올 잘 살
릴 수 있는 설계의 특징을 말한다. 원칙이라는 건 어떤 상횡에서든 100% 지켜져야 하는 절대적
인 기준이라기보다는. 예외는 있겠지만 대부분의 상뺑| 잘 툴어맞는 개|드라인과 같은 것이
다. 디자인 때턴은 특별한 상웰11서 발생하는 문제에 대한 좀 더 구체적인 솔루션이라고 힌다면，
객체지항 설계 원칙은 줌 더 일반적인 상황에서 적용 가능한 설계 기준이라고 불 수 있다. 당연
한 일이지만 객체지향 디자인 때턴은 대부붐 객체지향 설계 원칙율 잘 지켜서 만둘어져 있다.

오랜 시간 동안 많온 학자와 개발자 사이에서 공감대가 형성된 객체지향 설계에 관한 여러
가지 원리와 원칙올 체계적으로 잘 정리하고， 멋진 이륨과 약자도 만톨어서 공개된 것이 바로
SOUD라고도 불리는 5가지 객체지향 설계의 원칙이다. 객체지향 설계와 테스트 등옳 전문적으
로 가르치고 건설팅하는. 로버트 마틴이 정리한 이 5가지 객체지향 설계 원칙은 한 번용 공부해
두는편이훌다.

로버트 마틴이 정리한 객체지향 설계 원칙인 SOUD어| 대한 소개는 관련 웹사이트(http:μ
butunclebob.com/ArticleS.UncleBob.PrincjplesOfOod)에서 찾아볼 수 있다. SOUD 원칙올
잘 설명하는 도서로는 밥 마틴이 쓴 rJava 프로그래머훌 위한 UML 실전에서는 이것만 쓴다
(UML for Java Programmer)J라는 책울 추천한다. UML 책인 것 강지만 객체지향 설계 원칙
에 대한 자세한 싫명과 함께， 실용적인 조언과 사례를 잘 제공해주고 있는 책이다. 역시 밥 마
틴이 쓴 r소프트웨어 개발의 지혜: 원칙. 디자인 때턴， 실천 방법(Ag
ile S얘ware Deve때ment，
Principles. Pattems, a때 Practicesh도 SOUD 원칙을 실용적인 예제와 함께 깊이 있게 다루고
있다.

SOUD는 아래 5가지 원칙의 첫 글자를 따서 만든 단어다.

• SRP(The Single Responsibility Principle): 단일 책임 원칙
'OCP(π1e Open CI∞ed Principle): 개방 펴|쇄 원칙

• LSP(The 니skov Substitution Principle): 리스코프 치환 원칙
• ISP(The Inte에ace Segregation Principle): 인터페이스 분리 원칙 ·
• DIP(The Dependency Inversion Principle): 의존관계 역전 원칙
높은 응집도와 낮은 결합도

개방 패쇄 원칙은 높은 응집도와 낮은 결합도high coherence and low cou이
Ing라는 소프트웨어

개발의 고전적인 원리로도 설명이 가능하다. 응집도가 높다는 건 하나의 모률， 클래스

가 하나의 책임 또는 관심사에만 집중되어 있다는 뭇이다. 불필요하거나 직접 관련이
없는 외부의 관심과 책임이 얽혀 있지 않으며， 하나의 공통 관심사는 한 클래스에 모여
있다. 높은 응집도는 클래스 레벨뿐 아니라， 패키지， 컴포넌트， 모률에 이
르기까지 그
대상의 크기가 달라도 통일한 원리로 적용될 수 있다.

높은응집도

응집도가 높다는 것은 변화가 일어날 때 해당 모률에서 변하는 부분이 크다는 것으
로 설명할 수도 었다. 즉 변경이 일어날 때 모률의 많은 부분이 함께 바뀐다면 응집
도가 높다고 말할 수 있다. 만약 모률의 일부분에만 변경이 일어나도 된다면， 모률

전체에서 어떤 부분이 바뀌어야 하는지 따악해야 하고 또 그 변경으로 인해 바뀌지
않는 부분에는 다른 영향을 미치지는 않는지 확인해야 하는 이중의 부담이 생긴다.

처음에 만든 초난감 DAO에서 DB 커넥션을 만드는 기능을， Dri verManager를 이
용한 방법에서 다른 DB 커넥션 풀 라이브러리를 사용히는 방법으로 변경한다고 해
보자. 초난감
DAO처럼 여러 관심사와책임이 얽혀 있는복잡한코드에서는 변경이
펼요한 부분을 찾아내는 것도 번거로운 일일뿐더러， 그렇게 변경한 것이 혹시 DAO
의 다른 기능에 영향을 줘서 오류를 발생시키지는 않는지도 일일이 확인해야 한다.

반면에 ConnectionMaker 인터페이스를 이용해 DB 연결 기능을 독립시킨 경우라
면， 그저 DB 커넥션 풀을 활용히는 ConnectionMaker 구현 클래스를 새로 만들기만
하면 된다. 기존에 구현한 DConnectionMaker를 일부 수정하더라도 마찬가지다. 작
업은 항상 전체적으로 일어나고 무엇을 변경할지 명확하며， 그것이 UserDao 등 다른
클래스의 수정을요구하지 않을뿐더러 기능에 영향을주지 않는다는사실을손쉽게
확인할 수 있다. DB 연결 방식에 변경이 일어난 경우에 이를 검증하려고 한다면， 변
경한 ConnectionMaker 구현 클래스를 직접 테스트해보는 것만으로도 충분하기 때
문이다. 기존의 NConnectionMaker를 개선해서 버전 2.0으로 만들었다고 하자. 수정

1장-오브젝트와 의존관계 85


된 NConnectionMaker를 테스트하기 위해 이를 시용하는 모든 DAO를 다 일일이 테
스트해야 할까? 뭐， 테스트해서 나뿔 거야 없지만 굳이 할 이유는 없다. 새로 만든
NConnectionMaker를 직접 태스트해도 충분하다. ConnectionMaker를 분리해서 응집
도를높인덕분이다.

• 낮은결합도
낮은 결합도는 높은 응집도보다 더 민감한 원칙이다. 책임과 관심사가 다른 오브젝
트 또는 모률과는 낮은 결합도， 즉 느슨하게 연결된 형태를 유지하는 것이 바람직하
다. 느슨한 연결은 관계를 유지히는 데 쪽 필요한 최소한의 방법만 간접적인 형태로
제공하고， 나머지는 서로 독립적이고 알 필요도 없게 만들어주는 것이다. 결합도가
낮아지면 변화에 대응하는속도가높아지고 구성이 깔팝해진다. 또한확장하기에도
매우편리하다.
여기서 결합도란 ‘하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다
른 오브젝트에게 변화를 요구히는 정도’라고 설명할 수 있다. 낮은 결합도란 결국，
하나의 변경이 발생할 때 마치 파문이 이는 것처럼 여타 모률과 객체로 변경에 대
한 요구가 전파되지 않는 상태를 말한다. ConnectionMaker 인터페이스의 도입으
로 인해 DB 연결 기능을 구현한 클래스가 바뀌더라도 DAO의 코드는 변경될 필요
가 없게 됐다. ConnectionMaker와 UserDao의 결합도가 낮아진 것이다. 더 나아가서
ConnectionMaker의 클래스를 결정하는 책임을 DAO의 클라이언트로 분리한 덕분에
샤용할 ConnectionMaker 구현 클래스가 바뀌어도 DAO 클래스의 코드를 수정할 필
요가 없게 됐다. 결합도가 더욱 낮아진 것이다. 결합도가 높아지면 변경에 따르는 작
업량이 많아지고， 변경으로 인해 버그가 발생할 가능성이 높아진다.

UserDao 클래스는 그 자체로 자신의 책임에 대한 응집도가 높다. 시용자의 데이터를
처리하는 기능이 여기저기 흩어져 있지 않고 DAO 안에 이해하기 쉽고， 깔끔하게 모여
있다. ConnectionMaker 또한 자신의 기능에 충실하도록 독립돼서 순수한 자신의 책임
을 담당하는 데만 충실할 수 있다.

동시에 UserDao와 ConnectionMaker
의 관계는 인터페이스를 통해 매우 느슨하게 연
결되어 있다. UserDao는 구체적인 ConnectionMaker 구현 클래스를 알 필요도 없고， 구
현 방법이나 전략， 뒤에서 사용하는 또 다른 오브젝트에 대해서도 신경 쓰지 않아도 된
다. 꼭 필요한 관계만 ConnectionMaker라는 인터페이스를 통해 낮은 결합도로 최소한
으로 연결되어 었다. ConnectionMaker가 자체의 응집력을 유지하면서 확장되고 발전하


더라도 이 낮은 결합도를통해 관계하고 있는
UserDao나 기타
DAO에 영향을주지 않
을수있다.

전략패턴
개선한 UserDaoTest-UserDao-ConnectionMaker 구조를 디자인 패턴의 시각으로 보면
전략 패턴Strategy Pattern에 해당한다고 볼 수 있다. 전략 패턴은 디자인 패턴의 꽃이라고
불릴 만큼 다양하게 자주 시용되는 패턴이다. 개방 패쇄 원칙의 실현에도 가장 잘 들어
맞는 패턴이라고 볼 수 있다. 전략 패턴은 자신의 기능 맥락∞ntext에서， 펼요에 따라 변
경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리시키고， 이를 구현한 구
체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.
여기서 말히는 알고리즘이란 거창한수학적 알고리즘을 말하는 게 아니고， 독립적인 책
임으로 분리가 가능한 기능을 뭇한다. 이를 대체 기능한 전략이라고 보기 때문에 패턴
의 이름이 전략 패턴이다.
UserDao는 전략 패턴의 컨텍스트에 해당한다. 컨텍스트는 자신의 기능을 수행히는
데 필요한기능중에서 변경 가능한 DB 연결 방식이라는알고리즘을
ConnectionMaker
라는 인터페이스로 정의하고， 이를 구현한 클래스， 즉 전략을 바꿔가면서 사용할 수 있
게분리했다.
전략 패턴은 UserDaoTest와 같은 클라이언트의 필요성에 대해서도 잘 설명하고 있
다. 전략 패턴의 적용 방법을 보면 클라이언트의 역할이 잘 설명되어 있다. 컨텍스트
(UserDao
)를 사용히는 클라이 언트(UserDaoTest
)는 컨텍스트가 사용할 전략딴(Coonπmln매ct
lOn1Ma앤〈애별를 구

이뼈
매빼뻐뻐
er

lec다
배빼허k


현한 클래스스’ 때1n뼈야
빼

nec

예를 들어 DCoωoαonn
chon1

이다.

이렇게 보면 가장 최근에 만든 UserDao는 개방 패쇄 원칙을 잘 따르고 있으며， 응집
력이 높고 결합도는 낮으며 전략 패턴을 적용했음을 알 수 있다. 사실 지금은 이렇게
말하기엔 낯간지러울 만큼 간단한 코드이지만， 이 구조가 점점 복잡하게 발전해나가면
이 원칙과 패턴의 장점이 확연하게 드러날 것이다.

오랫동안 스프링에 대해 별 언급이 없어서 섭섭할 태니， 이쯤에서 한마디 하고 넘어
가자. 스프링이란 바로 지금까지 설명한 객체지향적 설계 원칙과 디자인 패턴에 나타난
장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임워크다. 그런데 지금까지
살펴본 묘드나 기술에는 스프링이 전혀 보이지가 않으니 어찌 된 것인가? 걱정할 것 없
다. 스프링의 둥장이 펼요할 때가 됐으니 슬슬 기대해도 좋다.

1ε(-오브젝트와 의존관계 87


[ íÆ! 제어의 역전(l
oC) 텔|

IoC라는 약자로 많이 시용되는 제어의 역전Inversion
이
Control이라는 용어가 있다. 스프링

을 통해 일반 개발자에게는 많이 알려진 용어이지만 이 제어의 역전이라는 개념은 상
당히 오래전부터 있었다.90년 중반에 출판된 rGoF의 디자인 패턴」 책에서도 이 용어를
찾아볼 수 있다. 이 IoC가 무엇인지 살펴보기 위해 UserDao 묘드를 좀 더 개선해보겠다.

1.4.1 오브젝트 팩토리
지금까지는 문제가 많은 초난감 DAO를 깔끔한 구조로 리팩토링하는 작업을 수행했다.
그런데 눈치 랬을지 모르겠지만 사실 그 과정에서 얼렁뚱땅 넘긴 게 하나 있다. 바로
클라이 언트인 UserDaoTest
다.
UserDaoTest는 기존에 UserDao가 직접 담당하던 기능 즉 어떤 ConnectionMaker
구현 클래스를 사용할지를 결정하는 기능을 영겁결에 떠맡았다. UserDao
가
ConnectionMaker 인터페이스를 구현한 특정 클래스로부터 완벽하게 독립할 수 있도록
UserDao의 클라이언트인 UserDaoTest가 그 수고를 담당하게 된 것이다.
그런데 원래 UserDaoTest는 UserDao의 기능이 잘 동작히는지를 테스트하려고 만든
것이 아닌가? 그런데 지금은 또 다른 책임까지 떠맡고 있으니 뭔가 문제가 있다. 성격
이 다른 책임이나 관심사는 분리해버리는 것이 지금까지 해왔던 주요한 작업이다. 그러
니 이것도 분리하자. 이렇게 분리될 기능은 UserDao와 ConnectionMaker 구현 클래스의
오브젝트를 만드는 것과， 그렇게 만들어진 두 개의 오브젝트가 연결돼서 시용될 수 있
도록 관계를 맺어주는 것이다.

팩토리
분리시킬 기능을 담당할 클래스를 하나 만들어보겠다. 이 클래스의 역할은 객체의 생
성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 것인데， 이런 일을 하는 오
브젝트를 흔히 팩토리factory라고 부른다. 이는 디자인 패턴에서 말하는 특별한 문제를 해
결하기 위해 사용되는 추상 팩토리 패턴이나 팩토리 메소드 패턴과는 다르니 혼동하지
말자. 단지 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을
깔끔하게 분리하려는 목적으로 시용하는 것이다. 어떻게 만들지와 어떻게 사용할지는
분명다른관심이다.
팩토리 역할을 맡을 클래스를 DaoFactory라고 하자. 그리고 UserDaoTest에 담겨 있


던 UserDao , ConnectionMaker 관련 생성 작업을 DaoFactory로 옮기고. UserDaoTest
에
서는 DaoFactory
에 요청해서 미리 만들어진 UserDao 오브젝트를 가져와 사용하게 만
든다.

리스트 1-14는 이렇게 만들어진 DaoFactory 클래스다.

리스트 1-14 UserDao의 생성 책임을 맡은 팩토리 클래스

package springbook.user .dao;

팩토리의 메소드는 냉erOa。 티입의 오브젝트훌

어떻게 만들고 어딸게 준비시힐지훌 결정한다

public class DaoFactory {

public UserD녕
o userDao() {
ConnectionMaker connectionMaker = new DConnectionMaker();
UserDao userDao =new UserDao(connectionMaker);

return userDao;

DaoFactory
의 userDao 메소드를 호출하면 DConnectionMaker를 λF용해 DB 커넥
션을 가져오도록 이미 설정된 UserDao 오브젝트를 돌려준다. UserDaoTest는 이제
UserDao가 어떻게 만들어지는지 어떻게 초기화되어 있는지에 신경 쓰지 않고 꽤토리로
부터 UserDao 오브젝트를 받아다가 자신의 관심사인 테스트를 위해 활용하기만 하면
그만이다. 이렇게 해서 각각이 자신의 책임에만 충실하도록 역할에 따라 분리하는 작업
을마쳤다.

이렇게 수정된 UserDaoTest의 코드는 리스트 1-15와 같다.

리스트 1-15 팩토리를 사용하도록 수정한 UserD∞T않t

public class UserDaoTest (
public static void main(String[] args) throws ClassNotFoundException ,
SQLException {
UserDao dao =new DaoFactorY().userDao();

리팩토링한 뒤에는 잊지 말고 테스트를 실행하자. 개선된 코드도 이전과 같이 동일
하게동작할것이다.

1장-오브젝트와 의존관계 89


ConnectionMa.ker ConnectionMa.ker
설계도로서의팩토리
이렇게 분리된 오브젝트들의 역할과 관계를 분석해보자. UserDao와 ConnectionMaker는
각각 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하고 있고. DaoFactory
는 이런 애플라케이션의 오브젝트들을 구성하고 그 관계를 정의히는 책임을 맡고 있음
을 알 수 있다. 전자가 실질적인 로직을 담당히는 컴포넌트라면， 후자는 애플리케이션
을 구성히는 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할을 한다고 볼 수 있다.
설계도라고 하면 거창한 것 같지만 간단히 어떤 오브젝트가 어떤 오브젝트를 사용하는
지를 정의해놓은 묘드라고 생각하면 된다. 이런 작업이 애플리케이션 전체에 걸쳐 일어
난다면 컴포넌트의 의존관계에 대한 설계도와 같은 역할을 하게 될 것이다. 그림 1-8은
DaoFactory를 적용한 구조를 이런 관점으로 구분한 그림이다.

i f--"'별
;
f f-'산올

Cliant UserDa

킹포딘닝를 A
DConnectionMak.r

: 《요정” “생성
써 생성>>---~

| 、


<
|
|
|
‘ ‘
、
、
、------>1
。
aoFactory

「


||

L

그림 1-8 오브젝트 팩토리를 훨용한 구조

이제 N 사와 D 사에 UserDao를 공급할 때 UserDao. ConnectionMaker와 함께
DaoFactory도 제공한다. UserDao와 달리 DaoFactory는 소스를 제공한다. 새로운
ConnectionMaker 구현 클래스로 변경이 필요하면 DaoFactory를 수정해서 변경된 클래
스를 생성해 설정해주도록 코드를 수정해주면 된다. 여전히 우리의 핵심 기술이 담긴
UserDao는 변경이 필요 없으므로 안전하게 소스코드를 보존할 수 있다. 동시에 DB 연
결 방식은 자유로운 확장이 가능하다.

DaoFactory를 분리했을 때 얻을 수 있는 장점은 매우 다양하다. 그중에서도 애플리
케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트
를 분리했다는 데 가장 의미가 있다.

도

햄


1.4.2 오브젝트 팩토리의 활용
DaoFactory를 좀 더 살펴보자. DaoFactory에 UserDao가 아닌 다른 DAO의 생성 기능
을 넣으면 어떻게 될까? AccountDao, MessageDao 등을 만들었다고 해보자. 이 경우에
UserDao를 생성하는 userDao() 메소드를 복사해서 accountDao() , messageDao() 메소
드로 만든다면 새로운 문제가 발생한다. ConnectionMaker 구현 클래스의 오브젝트를
생성히는 코드가 메소드마다 반복되는 것이다. 어떤 ConnectionMaker 구현 클래스를
사용할지를 결정하는 기능이 중복돼서 나타난다고 볼 수 있다.
여러 개의 DAO를 생성히는 메소드가 추가된 리
스트 1
-16을 살펴보자. 세 개의
DAO를 만드는 팩토리 메소드 안에 모두 new DConnectionMaker라는 ConnectionMaker
구현 클래스의 인스턴스를 만드는 부분이 반복돼서 나타난다. 이렇게 오브젝트 생성 코
드가 중복되는 건 좋지 않은 현상이다.DAO가 더 많아지면 ConnectionMaker의 구현
클래스를 비꿀 때마다 모든 메소드를 일일이 수정해야 하기 때문이다.

리스트 1-16 DAO 생성 메소드의 추가로 인해 발생하는 중복

public class DaoFactory {
public UserDao userDao() (
return new UserDa이
new DConnectionMaker()); t

ConnectionMaker 구현 클래스롤
선정하고 생성하는 코드의 중복

public AccountDao accountDao() ( T
return new AccountDao(new DConnectionMaker()
)
;~

public MessageDao messageDao () (
return new MessageDao (new DConnectionMaker());

중복 문제를 해결하려면 역시 분리해내는 게 가장 좋은 방법이다. Connect ionMaker
의 구현 클래스를 결정하고 오브젝트를 만드는 코드를 별도의 메소드로 뽑아내자.
DAO를 생성하는 각 메소드에서는 새로 만든 ConnectionMaker 생성용 메소드를 이용
하도록 수정한다. 초난감 DAO의 코드에서 getConnection 메소드를 따로 만들어 DB
연결 기능을 분리해낸 것과 동일한 리팩토링 방법이다. 이렇게 해두면 아무리 DAO 팩
토리 메소드가 많아져도 문제가 없다. ConnectionMaker의 구현 클래스를 비꿀 필요가
있을 때도 리스트 1-17과 같이 딱 한 군데만 수정하면 모든 DAO 팩토리 메소드에 적
용된다.

1잠」 오브젝트와 의존관계 91


리스트 1-17 생성 오브젝트 코드 수정

public class DaoFactory (
public UserDao userDao () (
return new UserDao(connectionMaker());

public AccountDao accountDao() (
return new AccountDao(connectionMaker()) ;

public MessageDao messageDao() (
return new MessageDao(connectionMaker());

public ConnectionMaker connectionMaker() (
return new DConnectionMaker(); • 운리해서 종목옳 제거한 ConnectionMaker

타입오브젝트생성코드

1.4.3 저|어권의 이전을 통한 제어관계 역전
이제 제어의 역전이라는 개념에 대해 알아보자. 제어의 역전이라는 건， 간단히 프로그
램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다.
일반적으로 프로그램의 흐름은 main() 메소드와 같이 프로그램이 시작되는 지점
에서 다음에 시용할 오브젝트를 결정하고， 결정한 오브젝트를 생성하고， 만들어진 오
브젝트에 있는 메소드를 호출하고 그 오브젝트 메소드 안에서 다음에 사용할 것을 결
정하고 호출히는 식의 작업이 반복된다. 이런 프로그램 구조에서 각 오브젝트는 프
로그랩 흐름을 결정하거나 사용할 오브젝트를 구성하는 작업에 능동적으로 참여한
다. 초기 UserDao를 보면 테스트용 main() 메소드는 UserDao 클래스의 오브젝트를 직
접 생성하고， 만들어진 오브젝트의 메소드를 시용한다. UserDao 또한 자신이 사용할
ConnectionMaker의 구현 클래스(예를 들연 DConnectionMaker)를 자신이 결정하고， 그 오브젝
트를 펼요한 시점에서 생성해두고 각 메소드에서 이를 시용한다. 모든 오브젝트가 능
통적으로 자신이 시용할 클래스를 결정하고 언제 어떻게 그 오브젝트를 만들지를 스스
로관장한다. 모든종류의 작업을사용하는쪽에서 제어하는구조다.
제어의 역전이란 이런 제어 흐름의 개념을 꺼꾸로 뒤집는 것이다. 제어의 역전에서


는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도
않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 제어 권한
을 자신이 아닌 다른 대생l
게 위임하기 때문이다. 프로그햄의 시작을 담당하는 main()
과 같은 엔트리 포인트를 제외하면 모든 오브젝트는 이렇게 위임받은 제어 권한을 갖는
특별한 오브젝트에 의해 결정되고 만들어진다.

제어의 역전 개념은 사실 이미 폭넓게 적용되어 있다. 서블릿을 생각해보자. 일반적
인자바프로그램은
mai
n
() 메소드에서 시작해서 개발자가미리 정한순서를따라오브
젝트가 생성되고 실행된다. 그런데 서블릿을 개발해서 서버에 배포할 수는 있지만， 그
실행을 개발자가 직접 제어할 수 있는 방법은 없다. 서블릿 안에 main() 메소드가 있어
서 직접 실행시킬 수 있는 것도 아니다. 대신 서블릿에 대한 제어 권한을 가진 컨테이너
가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메소드를 호출한다. 이
렇게 서블릿이나 JSP, EJB처럼 컨테이너 안에서 동작히는 구조는 간단한 방식이긴 하
지만 제어의 역전 개념이 적용되어 있다고 볼 수 있다.

제어의 역전 개념이 적용된 예를 디자인 패턴에서도 여렷 찾아볼 수 있다. 초난감
DAO 개선 작업의 초기에 적용했던 템플릿 메소드 패턴을 생각해보자. 추상 UserDao
를 상속한 서브클래스는 getConnection( )을 구현한다. 하지만 이 메소드가 언제 어떻
게 사용될지 자신은 모른다. 서브클래스에서 결정되는 것이 아니다. 단지 이런 방식으
로 DB 커넥션을 만든다는 기능만 구현해놓으면， 슈퍼클래스인 U
serDao의 템플릿 메소
드인 add (), get () 둥에서 필요할 때 호출해서 사용하는 것이다. 즉 제어권을 상위 댐
플릿 메소드에 넘기고 자신은 필요할 때 호출되어 사용되도록 한다는， 제어의 역전 개
념을 발견할 수 있다. 탱플릿 메소드는 제어의 역전이라는 개념을 활용해 문제를 해결
히는 디자인 패턴이라고 볼 수 있다.

프레임워크도 제어의 역전 개념이 적용된 대표적인 기술이다. 프레임워크는 라이브
러리의 다른 이름이 아니다. 프레임워크는 단지 미리 만들어둔 반제품이나， 확장해서
사용할 수 있도록 준비된 추상 라이브러리의 집합이 아니
다. 프레임워크가 어떤 것인지
이해하려면 라이브러리와 프레임워크가 어떻게 다른지 알아야 한다. 라이브러리를 사
용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다. 단지 동작히는 중에
필요한 기능이 있을 때 능동적으로 라이브러리를 시용할 뿐이다. 반면에 프레임워크는
거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 보통 프레임워크 위에 개발
한 클래스를 등록해두고， 프레임워크가 흐름을 주도히는 중에 개발자가 만든 애플리케
이션 코드를 시용하도록 만드는 방식이다. 최근에는 툴킷， 엔진， 라이브러리 등도 유행

1장-오브젝트와 의존관계 93


을 따라서 무작정 프레임워크라고 부르기도 히는데 이는 잘못된 것이다. 프레임워크에
는 분명한 제어의 역전 개념이 적용되어 있어야 한다. 애플리케이션 코드는 프레임워크
가 찌놓은 틀에서 수동적으로 동작해야 한다.

우리가 만든 UserDao와 DaoFactory
에도 제어의 역전이 적용되어 있다. 원래
ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 제어권은 UserDao에게
있었다. 그런데 지금은 DaoFactory에게 있다. 자신이 어떤 ConnectionMaker 구현 클래
스를 만들고 시용할지를 결정할 권한을 DaoFactory
에 넘겼으니 UserDao는 이제 능동적
이 아니라 수동적인 존재가 됐다. UserDao 자신도 돼토리에 의해 수동적으로 만들어지
고 자신이 시용할 오브젝트도 DaoFactory가 공급해주는 것을 수동적으로 사용해야 할
입징L이 됐다. UserDaoTest는 DaoFactory가 만들고 초기화해서 자신에게 사용하도록 공
급해주는 ConnectionMaker를 사용할 수밖에 없다. 더욱이 UserDao와 ConnectionMaker
의 구현체를 생성히는 책임도 DaoFactory가 맡고 있다. 바로 이것이 제어의 역전(앞으로
는약자인 l
oC를
사용하겠대이 일어난 상횡어다. 자연스럽게 관심을 분리하고 책임을 나누고 유
연하게 확장 가능한 구조로 만들기 위해 DaoFactory를 도입했던 과정이 바로 IoC를 적
용하는작업이었다고볼수있다.

그러고 보니， 우리는 대표적인 IoC 프레입워크라고 불리는 스프링 없이도 IoC 개념
을 이미 적용한 셈이다.IoC는 기본적으로 프레임워크만의 기술도 아니고 프레임워크
가 쪽 펼요한 개념도 아니다. 단순하게 생각하면 디자인 패턴에서도 발견할 수 있는 것
처럼 상당히 폭넓게 사용되는 프로그래밍 모텔이다. IoC를 적용함으로써 설계가 깔끔
해지고 유연성이 증가하며 확장성이 좋아지기 때문에 펼요할 때면 IoC 스타일의 설계
와 코드를 만들어 사용하면 된다.

제어의 역전에서는 프레임워크 또는 컨테이너와 같이 애플리케이션 컴포넌트의 생
성과관계설정， 시용， 생명주기 관리 등을관장히는존재가펼요하다. DaoFactory는오
브젝트 수준의 가장 단순한 IoC 컨테이너 내지는 IoC 프레임워크라고 불릴 수 있다. 단
순한 적용이라면 DaoFactory와 같이 IoC 제어권을 가진 오브젝트를 분리해서 만드는
방법이면 충분하겠지만.IoC를 애플리케이션 전반에 걸쳐 본격적으로 적용하려면 스프
링과 같은 IoC 프레임워크의 도움을 받는 편이 훨씬 유리하다. 스프링은 IoC를 모든 기
능의 기초가 되는 기반기술로 삼고 있으며. IoC를 극한까지 적용하고 있는 프레임워크
다. 이제 본격적으로 스프링이 제공하는 IoC에 대해 살펴보자.


[ 1.5 스프링의 m:1] 펴

드디어 스프링을 사용해볼 때가 됐다. 그렇다고 별로 긴장할 건 없다. 지금까지 만들었
던 것들을 그대로 스프링에서 사용할 수 있으니까 말이다.

스프링은 여러 가지 얼굴을 가졌다. 애플리케이션 개발의 다양한 영역과 기술에 관
여한다. 그리고 매우 많은 기능을 제공한다. 하지만 스프링의 핵심을 담당히는 건， 바로
빈 팩토리 또는 애플리케이션 컨텍스트라고 불리는 것이다. 이 두 가지는 우리가 만든
Dao
Factory가 하는 일을 좀 더 일반화한 것이라고 설명할 수 있다.

1.5.1 오브젝트 팩토리를 이용한 스프링 loC
애플리케이션 컨텍스트와 설정정보
이제 Dao
F
actory를 스프링에서 사용이 기능하도록 변신시켜보자. 스프링에서는 스프링
이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈뾰'an이라고 부른다. 자
바빈 또는 엔터프라이즈 자바빈EJB에서 말하는 빈과 비슷한 오브젝트 단위의 애플리케
이션 컴포넌트를 말한다. 동시에 스프링 빈은 스프링 컨테이너가 생성과 관계설정， 사
용등을제어해주는제어의 역전이 적용된오브젝트를가리키는말이
다.
스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토
리
bean factory라고 부른다. 뒤에서 자세히 설명하겠지만 보통 빈 팩토리보다는 이를 좀
더 확장한 애플리케이션 컨텍스트ap미cation context를 주로 사용한다. 애플리케이션 컨텍스
트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리라고 생각하면 된다. 앞으로 빈 팩토
리와 애플리케이션 컨텍스트라는 용어를 함께 사용할 벤데， 두 가지가 동일하다고 생
각하면 된다. 빈 팩토리라고 말할 때는 빈을 생성하고 관계를 설정히는 IoC의 기본 기
능에 초점을 맞춘 것이고， 애플리케이션 컨텍스트라고 말할 때는 애플리케이션 전반에
걸쳐 모든 구성요소의 제어 작업을 담당하는 IoC 엔진이라는 의미가 좀 더 부각된다고
보면된다.
애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈(뾰젝트)의 생성， 관계설정 등의
제어 작업을 총괄한다. 기존 DaoFactory 코드에는 설정정보， 예를 들어 어떤 클래스의
오브젝트를 생성하고 어디에서 사용하도록 연결해줄 것인가 등에 관한 정보가 평범한
자바 코드로 만들어져 있다. 애플리케이션 컨텍스트는 직접 이런 정보를 담고 있진 않
다. 대
신 별도로 설정정보를 담고 있는 무엇인가를 가져와 이를 활용하는 범용적인 IoC
엔진 같은 것이라고 볼 수 있다.

1~L 오브젝트와 의존관계 95


빈 팩토리 또는 애플리케이션 컨텍스트가 사용하는 설정정보를 만드는 방법은 여러
가지가 있는데， 우리가 앞에서 만든 오브젝트 팩토리인 DaoFactory도 조금만 손을 보면
설정정보로 사용할 수 있다. 앞에서는 DaoFactory 자체가 설정정보까지 담고 있는 IoC
엔진이었는데 여기서는 자바 코드로 만든 애플리케이션 컨텍스트의 설정정보로 활용될
것이다. 그림 1-8에서 애플리케이션의 로직을 담고 있는 컴포넌트와 설계도 역할을 하
는 팩토리를 구분했었다. 바로 이 설계도라는 게 바로 이런 애플리케이션 컨텍스트와
그 설정정보를 말한다고 보면 된다. 그 자체로는 애플리케이션 로직을 담당하지는 않지
만 IoC 방식을 이용해 애플리케이션 컴포넌트를 생성하고， 사용할 관계를 맺어주는 동
의 책임을 담당히는 것이다. 마치 건물이 설계도면을 따라서 만들어지듯이， 애플리케
이션도 애플리케이션 컨텍스트와 그 설정정보를 따라서 만들어지고 구성된다고 생각할
수있다.

DaoFactory롤 사용하는 애플리케이션 컨텍스트
DaoFactory를 스프링의 빈 팩토리가 사용할 수 있는 본격적인 설정정보로 만들어보
자. 먼저 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할
수 있도록 @Configuration이라는 애노테이션을 추가한다. 그리고 오브젝트를 만들어
주는 메소드에는 @Beanol
라는 애노테이션을 붙여준다. userDao() 메소드는 UserDao
타입 오브젝트를 생성하고 초기화해서 돌려주는 것이니 당연히 @Beanol 붙는다. 또
한 ConnectionMaker 타입의 오브젝트를 생성해주는 connectionMaker() 메소드에도
@Bean을 붙여준다. 그 외에는 수정할 코드가 없다. 이 두 가지 애노테이션만으로 스프
링 프레임워크의 빈 팩토리 또는 애플리케이션 컨텍스트가 IoC 방식의 기능을 제공할
때 사용할완벽한설정정보가된 것이다.
리스트 1-18은 이 두 가지 애노태이션이 적용된 DaoFactory 클래스다. 자바 코드의
탈을 쓰고 있지만， 사실은 XML과 같은 스프링 전용 설정정보라고 보는 것이 좋다.

리스트 1-18 스프링 빈 팩토리가 사용할 설정정보톨 담은 DaoFacIαy 클래스

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

OConfiguration _ 애롤러케이션 컨텍스트 또는 빈 팩토리가 사용힐 설정정보라는 표시

public class DaoFactory {
OBean • 오브젝트 생성을 담탱}는 loC용 메소드èf는 표시
public UserDao userDao() {

return new UserDao(connectionMaker());


ilBean

public ConnectionMaker connectionMaker() (
return new DConnectionMaker();


이제 DaoFactory를 설정정보로 사용하는 애플리케이션 컨텍스트를 만들어보자. 애
플리케이션 컨텍스트는 ApplicationContext 타입의 오브젝트다. ApplicationContext
를 구현한 클래스는 여러 가지가 있는데 DaoFactory처럼 @Configuration이 붙은 자바
코드를 설정정보로 시용하려면 AnnotationConfigApplicationContext를 이용하면 된
다. 애플리케이션 컨텍스트를 만들 때 생성자 따라미터로 DaoFactory 클래스를 넣어
준다. 이제 이렇게 준비된 ApplicationContext
의 getBean()
이라는 메소드를 이용해
UserDao의 오브젝트를 가져올 수 있다. 리스트 1-19는 애플리케이션 컨텍스트를 적용
하도록 수정한 UserDaoTest 코드다.

리스트 1-19 애폴리케이션 컨텍스트톨 적용한 UserO∞，Test

public class UserDaoTest (
public static void main(String[) args) throws ClassNotFoundException ,
SQLException (
ApplicationContext context =
new AnnotationConfigApplicationContext(DaoFactory.class);
UserDao dao =context.getBean("userDao" , UserDao.class);

getBean() 메소드는 ApplicationContext가 관리하는 오브젝트를 요청히는 메소드
다. getBean()
의 파라미터인 "userDao"
는 ApplicationContext
에 등록된 빈의 이름이
다. DaoFactory에서 @Bean이라는 애노테이션을 userDao라는 이름의 메소드에 붙였는
데， 이 메소드 이름이 바로 빈의 이름이 된다. userDao라는 이름의 빈을 가져온다는 것
은 DaoFactory
의 userDao() 메소드를 호출해서 그 결과를 가져온다고 생각하면 된다.
메소드의 이름을 myPreciousUserDao() 라고 했다면 getBean("myPreciousUserDao" ,
UserDao.class)
로 가져올 수 있다. 그런데 UserDao를 가져오는 메소드는 하나뿐인데
왜 굳이 이름을 사용할깨 그것은 UserDao를 생성하는 방식이나 구성을 다르게 가져가

1장-오브젝트와 의존관계 97


는 메소드를 추가할 수 있기 때문이다. 그때는 specialUserDao() 라는 메소드로 만들고
getBean("specialUserDao". UserDao.class)
로 가져오면 된다.

getBean()
은 기본적으로 Object 타입으로 리턴하게 되어 있어서 매번 리턴되는 오
브젝트에 다시 캐스팅을 해줘야 하는 부담이 있다. 자바 5 이상의 제네릭
genenc 메소드
방식을 시용해 getBean()
의 두 번째 파라미터에 리턴 타입을 주면， 지저분한 캐스팅 코
드를 시용하지 않아도 된다.

스프링의 기능을 사용했으니 필요한 라이브러리를 추가해줘야 한다. 스프링 배포판
을 다운로드하거나 예제의 lib 폴더에서 필요한 파일을 가져다 프로젝트에 추가하고 클
래스패스에 포함시켜줘야 한다. 준비가 됐으면 검증을 위해 UserDaoTest를 실행해보
자. 에러 없이 테스트가 성공했다면， 드디어 첫 번째 스프링 애플리케이션을 성공적으
로만든것이다.

fIt후가활라이브러리
com.spri때∞urce.net.sf.cgli
b-2.
2.0.jar
com.springsource.org.apache.oαnmons.l얘ging-1.
1.1.jar
org.sprin이ramework.asm-3.0.7.RELEASE.jar
org.sp끼때fraπlework.
beans-3.0.7.RELEASE.βHr
αg.Sαpn
r1l;여，떠-amewoαork.context-3.0.7.RE도ASE.jar

lfr
org.springframework.∞re-3.0.7.RELEASE.βr
org.springfraræwα1<，
expre:양>sion


γ

r-3.0
.7.RELE영E.βr

그런데 스프링을 적용하긴 했지만 사실 앞에서 만든 DaoFactory를 직접 사용한 것
과 기능적으로 디를 바 없다. 오히려 DaoFactory를 만들어서 바로 사용한 것보다 좀 더
번거로운 준비 작업과 코드가 펼요하다. 스프링을 사용해 IoC를 적용했다고 해서 별로
장점이 없지 않을까 히는 의문이 들 수도 있다. 그렇다면 굳이 스프링을 사용하지 않고
그냥 DaoFactory 같은 오브젝트 돼토리를 만들어서 사용하면 되는 게 아닐까? 물론 그
렇지 않다. 스프링은 지금 우리가 구현했던 DaoFactory를 통해서는 얻을 수 없는 방
대한 기능과 활용 방법을 제공해준다. 이런 특성에 대해서는 앞으로 계속 살펴볼 예
정이다.


1.5.2 애플리케이션 컨텍스트의 동작방식
기존에 오브젝트 팩토리를 이용했던 방식과 스프링의 애플리케이션 컨텍스트를 사용한
방식을비교해보자.
오브젝트 팩토리에 대응되는 것이 스프링의 애플리케이션 컨텍스트다. 스프링에서
는 이 애플리케이션 컨텍스트를 IoC 컨테이너라 하기도 하고， 간단히 스프링 컨태이
너라고 부르기도 한다. 또는 빈 팩토리라고 부를 수도 있다. 애플리케이션 컨텍스트는
ApplicationContext 인터페이스를 구현하는데. Appl icationContext는 빈 팩토리가 구
현하는 BeanFactory 인터페이스를 상속했으므로 애플리케이션 컨텍스트는 일종의 빈
팩토리인 셈이다. 애플리케이션 컨텍스트가 스프링의 가장 대표적인 오브젝트이므로，
애플리케이션 컨텍스트를 그냥 스프링이라고 부르는 개발자도 있다.
DaoFactory가 UserDao를 비롯한 DAO 오브젝트를 생성하고 DB 생성 오브젝트와
관계를 맺어주는 제한적인 역할을 하는 데 반해 애플리케이션 컨텍스트는 애플리케이
션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다. 대
신 ApplicationContext에는 DaoFactory와 달리 직접 오브젝트를 생성하고 관계를 맺
어주는 코드가 없고， 그런 생성정보와 연관관계 정보를 별도의 설정정보를 통해 얻는
다. 때로는 외부의 오브젝트 팩토리에 그 작업을 위임하고 그 결과를 가져다가 사용하
기도한다.
@Configuration
이 붙은 DaoFactory’는 이 애플리케이션 컨텍스트가 활용하는 IoC
설정정보다. 내부적으로는 애플리케이션 컨텍스트가 DaoFactory
의 userDao( ) 메소드
를 호출해서 오브젝트를 가져옹 것을 클라이언트가 getBean()
으로 요청할 때 전달해준
다. 그림 1-9는이 애플리케이션 컨텍스트가사용되는방식을보여준다.

Client ApplicationContext 8Con:figuration
f|L
《용혹)) DaoFactory

@Sean userDao {

비」

-

때

빼「쐐

μ떼
뿔-뼈

-g -”

((요정))

---’

"userDa。‘
+

((
생성요정))

•

생성》

’

“----------------《엠

UserDao

----------------------->1 |

그림 1-9 애를리케이션 컨텍스트가 동작하는 방식

1장-오브젝트와 의존관계 99


애플리케이션 컨텍스트는 DaoFactory 클래스를 설정정보로 등록해두고 @Bean
이 붙은
메소드의 이름을 가져와 빈 목록을 만들어둔다. 클라이언트가 애플리케이션 컨텍스트
의 getBean() 메소드를 호출하면 자신의 빈 목록에서 요청한 이름이 있는지 찾고， 있다
면 빈을 생성히는 메소드를 호출해서 오브젝트를 생성시킨 후 클라이언트에 돌려준다.

DaoFactory와 같은 오브젝트 팩토리에서 샤용했던 IoC 원리를 그대로 적용하는 데
애플라케이션 컨텍스트를 사용히는 이유는 범용적이고 유연한 방법으로 IoC 기능을 확
장하기 위해서다. DaoFactory를 오브젝트 팩토리로 직접 사용했을 때와 비교해서 애플
리케이션 컨텍스트를 사용했을 때 얻을 수 있는 장점은 디음과 같다.

• 를라이언트는 구체적인 팩토리 를래스롤 알 필요가 없다
애플리케이션이 발전하면 DaoFactory
처럼 IoC를 적용한 오브젝트도 계속 추가될 것
이다. 클라이언트 필요한 오브젝트를 가져오려면 어떤 팩토리 클래스를 시용해야 할
지 알0바 하고， 펼요할 때마다 팩토리 오브젝를 생성해야 하는 번거로웅이 있다. 애
플리케이션 컨텍스트를 사용하면 오브젝트 팩토리가 아무리 많아져도 이를 알아야
하거나 직접 시용할 펼요가 없다. 애플리케이션 컨텍스트를 이용하면 일관된 방식으
로 원하는 오브젝트를 가져올 수 있다. 또. DaoFactory처럼 자바 묘드를 작성하는 대
신 XML처럼 단순한 방법을 사용해 애플리케이션 컨텍스트가 사용할 IoC 설정정보
를만들수도있다.
• 애를리케이션 컨텍스트는 종합 loC 서비스톨 제공해준다
애플리케이션 컨텍스트의 역할은 단지 오브젝트 생성과 다른 오브젝트와의 관계설
정만이 전부가 아니다. 오브젝트가 만들어지는 방식 시점과 전략을 다르게 가져갈
수도 있고， 이에 부가적으로 자동생성， 오브젝트에 대한 후처리， 정보의 조합， 설정
방식의 다변화， 인터셉팅 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능을
제공한다. 또， 빈이 사용할 수 있는 기반기술 서비스나 외부 시스댐과의 연동 등을
컨테이너 차원에서 제공해주기도 한다.
• 애풀리케이션 컨텍스트는 빈올 검색하는 다양한 방법올 제공효
H파
애플리케이션 컨텍스트의 getBean() 메소드는 빈의 이름을 이용해 빈을 찾아준다.
타입만으로 빈을 검색하거나 특별한 애노태이션 설정이 되어 있는 빈을 찾을 수도
있다.

1.5.3 스프링 loC의 용어 정리
지금까지 IoC 전략을 구λ봐기 위해 스프링을 활용하는 간단한 방법을 알아봤다. 그러
는 사이에 새로운 용어들이 등장했는데， 경우에 따라서 조금씩 다른 의미로 사용되지
만， 기본적으로는 비슷한 개념을 가진 다OJ=한 용어가 혼용돼서 쓰이기도 하므로 흔란스
러울 수 있다. 이좀에서 용어들을 한번 정리하고 넘어가는 게 좋겠다.

• 빈bean
빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뭇이다. 관리
되는 오브젝트managed obiect라고 부르기도 한다. 주의할 점은 스프링을 사용하는 애
플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니라는 사실이다. 그중에서
스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.
• 빈 팩토리bean factory
스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다. 빈을 등록하고， 생성하고，
조회하고 돌려주고， 그 외에 부가적인 빈을 관리히는 기능을 담당한다. 보통은 이
빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용한다.
BeanFactory
라고 붙여쓰면 빈 팩토리가 구현하고 있는 가장 기본적인 인터페이스의
이름이 된다. 이 인터페이스에 getBean()
과 같은 메소드가 정의되어 있다.

• 애롤리케이션 컨텍스트application context
빈 팩토리를 확장한 IoC 컨테이너다. 빈을 등록하고 관리하는 기본적인 기능은 빈
팩토리와 동일하다. 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한
다. 빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 이야기하는 것이고，
애플리케이션 컨텍스트라고 할 때는 스프링이 제공히는 애플리케이션 지원 기능을
모두 포함해서 이야기하는 것이라고 보면 된다. 스프링에서는 애플리케이션 컨텍스
트라는 용어를 빈 팩토리보다 더 많이 사용한다. ApplicationContext
라고 적으면 애
플리케이션 컨텍트스가 구현해야 하는 기본 인터페이스를 가리키는 것이기도 하다.
ApplicationContext는 BeanFactory를 상속한다.

• 실정정보J설정 머|타정보configu떼ion metadata
스프링
의 설정정보란 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위
해 사용하는 메타정보를 말한다. 영어로 ‘config
uration’이라고 하는데， 이는 구성정
보 내지는 형상정보라는 의미다. 실제로 스프링의 설정정보는 컨테이너에 어떤 기능

1장-오브젝트와의존관계 101


을 세팅하거나 조정하는 경우에도 사용하지만， 그보다는 IoC 컨테이너에 의해 관리
되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다. 애플리케이션의 형상
정보라고 부르기도 한다. 또는 애플리케이션의 전체 그림이 그려진 청사진blueprints이
라고도한다.

• 컨테이너container 또는 loC 컨테이너
IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 컨
테이너 또는 IoC 컨테이너라고도 한다. 후지는 주로 빈 팩토리의 관점에서 이야기하
는 것이고， 그냥 컨테이너 또는 스프링 컨테이너라고 할 때는 애플리케이션 컨텍스
트를 가리키는 것이라고 보면 된다. 컨테이너라는 말 자체가 IoC의 개념을 담고 있
기 때문에 이름이 긴 애플리케이션 컨텍스트 대신에 스프링 컨테이너라고 부르는 걸
선호하는 사람들도 었다. 또 컨테이너라는 말은 애플리케이션 컨텍스트보다 추상적
인 표현이기도 하다. 애플리케이션 컨텍스트는 그 자체로 ApplicationContext 인터
페이스를 구현한 오브젝트를 가리키기도 하는데 애플리케이션 컨텍스트 오브젝트
는 하나의 애플리케이션에서 보통 여러 개가 만들어져 시용된다. 이를 통틀어서 스
프링 컨테이너라고 부를 수 있다.
때로는 컨테이너라는 말을 떼고 스프링이라고 부를 때도， 바로 이 스프링 컨태이
너를 가리키는 것일 수 있다. 예를 들어 ‘스프링에 빈을 등록하고’라는 식으로 말하는
경우에 스프링이라는 말은 스프링 컨테이너 또는 애플리케이션 컨텍스트를 가리키
는말이다.

• 스프링프레임워크
스프링 프레임워크는 IoC 컨테이너， 애플리케이션 컨텍스트를 포함해서 스프링이
제공하는 모든 기능을 통틀어 말할 때 주로 시용한다. 그냥 스프링이라고 줄여서 말
하기도한다.
Im 싱글톤 레지스트리오} 오브振 초코프 챈I

DaoFactory를 직접 사용히는 것과 @Configuration 애노테이션을 추가해서 스프링
의 애플리케이션 컨텍스트를 통해 사용하는 것은 테스트 결과만 보자면 동일한 것 같
다. 그저 애플리케이션 컨텍스트에 userDao라는 이름의 빈을 요청하면 DaoFactory의
userDao() 메소드를 호출해서 그 결괴를 돌려주는 것이라고 생각할지 모르겠다. 하

102


지만 스프링의 애플리케이션 컨텍스트는 기존에 직접 만들었던 오브젝트 팩토리와
는 중요한 차이점이 있다. 과연 어떤 차이점이 있는지 확인해보자. 먼저 DaoFactory
의
userDao() 메소드를 두 번 호출해서 리턴되는 UserDao 오브젝트를 비교해보자. 이 두
개는 같은 오브젝트일까?

활 오브책트의 톨엄성과 툴툴성
자바에서 두 개의 오브젝트가 같은가라는 말은 주의해서 써야 한다. 자바에서는 두 개의 오
브젝트가 완전히 같은 동일핸idenlica
l) 오브젝트라고 말하는 것과. 동일한 정보톨 담고 있는
(equivalent) 오브젝트라고 말하는 것은 분명한 차이가 있다. 전자는 동일성(idenlity) 비교라고
하고 후자톨 동동성(equal때) 비교라고 한다. 동일성은 언산자룩 동둥성은 equals() 메소
드톨이용해비교한다.

두 개의 오브젝트가 동일하다면 사실은 하나의 오브젝트만 존재하는 것01고 두 개의 오브젝
트 레퍼런스 변수톨 강고 있올 뿐이다. 두 개의 오브젝트가 동일하지는 않지만 동둥한 경우에는
두 개의 각기 다른 오브젝트가 메모리상에 존재하는 것인데 오브젝트의 동동성 기준에 따라 두
오브젝트의 정보가 동등하다고 판단하는 것일 뿐이다. 물론 동일한 오브젝트는 동둥하기도 할
것이다. 하지만 그 반대는 항상 참은 아니다.

자바 클래스훌 만들 때 equa잉() 메소드률 따로 구현하지 않았다면. 최상위 클래스인 Objecl
클래스에 구현되어 있는 equals() 메소드가 사용된다.Objecl의 equalsO 메소드는 두 오브젝
트의 동일성을 비교해서 그 결과훌 돌려춘다. 따라서 이때는 동일한 오브젝트여야지만 동둥한
오브젝트라고 여겨질 것이다.

알아보고 싶은 것은 DaoFactory
의 userDao( )를 여 러 번 호출했을 때 동일한 오브젝
트가 돌아오는가 아닌가이다. 코드를 보면 매번 userDao 메소드를 호출할 때마다 new
연산자에 의해 새로운 오브젝트가 만들어지게 되어 있다. 당연히 매번 다른 오브젝트가
만들어져서 돌아올 것이라고 예상할 수 있다. 직접 확인을 위해 리스트 }-20과 같이 생
성된 오브젝트를 콘솔에 출력해보자. 오브젝트를 직접 출력하면 오브젝트별로 할당되
는 고유한 값이 출력된다. 이 값이 같으면 동일한 오브젝트임을 알 수 있다.

리스트 1-20 직접 생성한 D∞Factαy 오브젝트 훌력 코드

DaoFactory factory =new DaoFactory();
UserDao dao1 = factory.userDao();
UserDao dao2 = factory.userDao();

System .out .println(dao1);
System.out.println(dao2);

1장-오브젝드와 의존관계 103


리스트 1-20의 코드를 실행하면 다음과 같은 결과가 나옹다. 출력되는 값은 매번 달
라질수있다.

springbook.dao .UserDaoOl18f375

springbook
.
dao
.
UserDa
oO
l17a8벼

출력 결과에서 알 수 있듯이， 두 개는 각기 다른 값을 가진 동일하지 않은 오브젝트
다. 즉 오브젝트가 두 개가 생겼다는 사실을 알 수 있다. userDao를 매번 호출하면 계속
해서 새로운 오브젝트가 만들어질 것이다. 여기까지는 충분히 예상할 수 있는 당연한
결과다.

이번엔 리스트 1-21
과 같이 스프링의 애플리케이션 컨텍스트에 DaoFactory를 설정
정보로 등록하고 getBean() 메소드를 이용해 userDao라는 이름으로 등록된 오브젝트를
가져와 보자. 여기서도 애플리케이션 컨텍스트가 DaoFactory
의 userDao( ) 메소드를 호
출해서 UserDao 타입 오브젝트를 만드는 건 마찬가지일 것이다. 그런데 다음 묘드를 실
행한 결괴를 보면 앞에서와 확연히 다른 결과가 나온다
.

리스트 1-낀 스프링 컨돼스트로부터 가져온 오브젝트 흩력 코드

ApplicationContext context =new
AnnotationConfigApplicationContext(DaoFactorY.class);

UserDao dao3 =context .getBean('userDao “, UserDao.class);
UserDao da여 =context .getBean("userDao' , UserDao.class);

System .out.println(dao3);
System.out .println(dao4);

이 코드를 실행한 결과는 아래와 같다.

springbook .dao .UserDao@ee22f7

springbook
.
dao.UserDao뿔e22f7

두 오브젝트의 출력 값이 같으므로 getBean()을 두 번 호출해서 가져옹 오브젝트가
동일하다는 사실을 알 수 있다. 확실히 하려면 dao3 = dao4를 출력해보면 된다. true
라고 나올 것이다. 우리가 만들었던 오브젝트 돼토리와 스프링의 애플리케이션 컨텍스
트의 동작방식에는 무엇인가 차이점이 있다. 스프링은 여러 번에 걸쳐 빈을 요청하더라
도 매변 동일한 오브젝트를 돌려준다는 것이다. 단순하게 getBean()
을 실행할 때마다
userDao( ) 메소드를 호출하고 매번 new에 의해 새로운 UserDao가 만들어지지 않는다
는뭇이다. 왜그럴까?


1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트
애플리케이션 컨텍스트는 우리가 만들었던 오브젝트 팩토리와 비슷한 방식으로 동작하
는 IoC 컨테이너다. 그러면서 동시에 이 애플리케이션 컨텍스트는 싱글톤을 저장하고
관리하는 싱글톤 레지스트라ingleton r영istry이기도 하다.

스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를
모두 싱글톤으로 만든다. 여기서 싱글톤이라는 것은 디자인 패턴에서 나오는 싱글톤 패
턴과 비슷한 개념이지만 그 구현 방법은 확연히 다르다.

서버 애플리케이션과 싱글톤
왜 스프링은 싱글톤으로 빈을 만드는 것일까? 이는 스프링이 주로 적용되는 대상이 자
바 엔터프라이즈 기술을 사용하는 서버환경이기 때문이다. 물론 스프링으로 PC 등에서
동작하는 독립형 윈도우 프로그램 같은 걸 개발할 수도 있긴 하지만 실제로는 극히 드
물다. 태생적으로 스프링은 엔터프라이즈 시스탬을 위해 고안된 기술이기 때문에 서버
환경에서 시용될 때 그 가치가 있다. 실제로 스프링은 대부분 서버환경에서 사용된다.
스프링이 처음 설계됐던 대규모의 엔터프라이즈 서버환경은 서버 하나당 최대로 초
당 수십에서 수백 번씩 브라우저나 여타 시스뱀:로부터의 요청을 받}아 처리할 수 있는
높은 성능이 요구되는 환경이었다. 또 하나의 요청을 처리하기 위해 데이
터 액세스 로
직， 서비스 로직， 비즈니
스 로직， 프레젠태이션 로직 등의 다양한 기능을 담당하는 오브
젝트들이 참여히는 계층형 구조로 이뤄진 경우가 대부분이다. 비즈니
스 로직도 복잡한
경우가많다.
그런데 매
번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로
만들어서 사용한다고 생각해보자. 요청 한 번에 5
개의 오브젝트가 새로 만들어지고 초
당 5007H의 요청이 들어오면 초당 2500
7H의 새로운 오브젝트가 생성된다. 1분이면 십
오만 개， 한 시간이면 9백만 개의 새로운 오브젝트가 만들어진다. 아무리 자바의 오므
젝트 생성과 가비지 컬렉션GC의 성능이 좋아졌다고 한들 이렇게 부하가 걸리면 서버가
감당하기힘들다.
그래서 엔터프라이
즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔
다. 서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수
있다. 스펙
에
서 강제하진 않지만， 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동
작한다. 서블릿 클래스당 하나의 오브젝트만 만들어두고 사용자의 요청을 담당하는 여
러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

1장-오브젝드와 의존관계 105


이렇게 애플리케이션 안에 제한된 수， 대개 한 개의 오브젝트만 만들어서 사용히는
하는 것이 싱글톤 패턴의 원리다. 따라서 서버환경에서는 서비스 싱글톤의 시용이 권장
된다. 하지만 디자인 패턴에 소개된 싱글톤 패턴은 시용하기가 까다롭고 여러 가지 문
제점이 있다. 그래서 심지어 이런 싱글톤 패턴을 피해야 할 패턴이라는 의미로 안티패

턴anti pattern이라고 부르는 사람도 있다.

활 싱를톨 꽤턴(힐f엄뻐ton Pattem)
싱글혼 때턴은 GoF가 소개한 디자인 때턴 종의 하나다. 디자인 때턴 중에서 가장 자주 활용되
는 때턴이기도 하지만 가장 많은 비판율 받는 때턴이기도 하다. 심지어 디자인 책올 쓴 GOF 맹

버조차도 싱글톤 때턴은 매우 조심해서 사용해야 하거나 피해야 활 때턴이라고 말하기도 한다.

싱글톤 패턴은 어떤 률래스률 애풀리케이션 내에서 제한된 인스턴스 개수. 이룸처럼 주로 하
나만 존재하도록 강제하는 때턴이다 이렇게 하나만 만들어지는 클래스의 오브전l트는 애폴리케
이션 내에서 전역적으로 접근이 가능하다. 단일 오브젝트만 존채해야 하고 이톨 애를리케이션
의 여러 곳에서 공유하는 경우에 주로 사용한다.

싱글톤패턴의한계
자바에서 싱글톤을 구현하는 방법은 보통 이렇다.

• 클래스 밖에서는 오브젝트를 생성하지 못하도록 생성자를 pnvate으로 만든다.
• 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드를 정의한다.
• 스태틱 팩토리 메소드인 getlnstance( )를 만들고 이 메소드가 최초로 호출되는 시점에서 한
번만 오브젝트가 만들어지게 한다. 생성된 오브젝트는 스태틱 필드에 저장된다. 또는 스태
틱 필드의 초기값으로 오브젝트를 미리 만들어둘 수도 있다.
• 한번 오브젝트(싱글톤)가 만들어지고 난 후에는 getlnstance( ) 메소드를 통해 이미 만들어져
스태틱 펼드에 저장해둔 오브젝트를 넘겨준다.
UserDao를 전형적인 싱글톤 패턴을 이용해 만든다면 리스트 1-22와 같이 될 것이다.

리스트 1-22 싱글톤 꽤턴올 적용한 UserD∞

public class UserDao {
private static UserDao INSTANCE;

private UserDao(ConnectionMaker connectionMaker) {
this.connectionMaker =connectionMaker;


public static synchronized UserDao getlnstance() {
if (INSTANCE == null) INSTANCE = new UserDao(???);
return INSTANCE;


일단 깔끔하게 정리했던 UserDao
에 싱글톤을 위한 묘드가 추가되고 나니 묘드가 상
당히 지저분해졌다는 느낌이 든다. 게다가 private으로 바뀐 생성자는 외부에서 호출
할 수가 없기 때문에 DaoFactory에서 UserDao를 생성하며 ConnectionMaker 오브젝트
를 넣어주는 게 이제는 불가능해졌다. 여러모로 생각해봐도 지금까지 깔끔하게 개선해
옹 UserDao에 싱글톤 패턴을 도입하는 건 무리로 보인다.

일반적으로 싱글톤 패턴 구현 방식에는 다음과 같은 문제가 있다.

• private 생성자톨 갖고 있기 때문에 S받할 수 없다
싱글톤 패턴은 생성자를 private으로 제한한다. 오직 싱글톤 클래스 자신만이 자기
오브젝트를 만들도록 제한히는 것이다. 문제는 private 생성자를 가진 클래스는 다
른 생성자가 없다연 상속이 불가능하다는 점이다. 객체지향의 장점인 상속과 이를
이용한 다형성을 적용할 수 없다. 기술적인 서비스만 제공히는 경우라면 상관없겠지
만， 애플리케이션의 로직을 담고 있는 일반 오브젝트의 경우 싱글톤으로 만들었을
때 객체지향적인 설계의 장점을 적용하기가 어렵다는 점은 심각한 문제다. 또한 상
속과 다형성 같은 객체지향의 특징이 적용되지 않는 스태틱 펼드와 메소드를 사용하
는것도 역시 동일한문제를발생시킨다.

• 싱글톤은 테스트하기가 힘들다
싱글톤은 테스트하기가 어렵거나 테스트 방법에 따라 아예 테스트가 불가능하다. 싱
글톤은 만들어지는 방식이 제한적이기 때문에 테스트에서 시용될 때 목 오브젝트 등
으로 대체하기가 힘들다. 싱글톤은 초기화 과정에서 생성자 등을 통해 사용할 오브
젝트를 다이내믹하게 주입하기도 힘들기 때문에 펼요한 오브젝트는 직접 오브젝트
를 만들어 사용할 수밖에 없다. 이런 경우 테스트용 오브젝트로 대체하기가 힘들다.
다음 장에서 살펴보겠지만 테스트는 엔터프라이즈 개발의 핵심인데 애플리케이션
코드를 싱글톤으로 만들면 태스트를 만드는 데 지장이 있다는 건 큰 단점이다.
1장-오브젝트와 의존관계 107


• 서버환경에서는 싱글톤이 하나만 E탤훨{지는 것을 보.~하지 못효봐
서
버에
서 클래스 로더를 어떻게 구성하고 있느냐에 따라서 싱글톤 클래스임에도 하
나 이상의 오브젝트가 만들어질 수 있다. 따라서 자바 언어를 이용한 싱글톤 패턴 기
법은 서버환경에서는 싱글톤이 콕 보장된다고 볼 수 없다. 여러 개의 NM에 분산돼
서 설치가 되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서
의가치가떨어진다.
• 싱글톤의 사용은 전역 상태톨 E톨 수 있기 때문에 바람직하지 못하다
싱글톤은 사용하는 클라이언트가 정해져 있지 않다. 싱글톤의 스태틱 메소드를 이용
해 언제든지 싱글톤에 쉽게 접근할 수 있기 때문에 애플리케이션 어디서든지 사용될
수 있고， 그러다 보면 자연스럽게 전역 상태globa
l state로 시용되기 쉽다. 아무 객체나
자유롭게 접근하고 수정하고 공유할 수 있는 전역 상태를 갖는 것은 객체지향 프로
그래밍에서는 권장되지 않는 프로그래밍 모댈이다. 그럼에도 싱글톤을 사용하면 그

런 유혹에 빠지기 쉽다. 그럴 바에는 아예 스태틱 펼드와 메소드로만 구성된 클래스
를시용하는편이낫다.

싱글톤레지스트리
스프링은 서버환경
에
서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것은
적극 지지한다. 하지만 자바의 기본적인 싱글톤 패턴의 구현 방식은 여러 가지 단점이
있기 때문에， 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한
다. 그것이 바로 싱글톤 레지스트리
singleton r멍Istry다. 스프링 컨테이너는 싱글톤을 생성하
고， 관리하고， 공급히는 싱글톤 관리 컨테이너이기도 하다. 싱글톤 레지스트리의 장점
은 스태틱 메소드와 private 생성지를 시용해야 송}는 비정상적인 클래스가 아니라 명범
한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다. 명범한 자바 클래스라도 IoC
방식의 컨테이너를 사용해서 생성과 관계설정 시용 등에 대한 제어권을 컨테이너에게
넘기면 손쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다. 오브젝트 생성에 관한
모든 권한은 IoC 기능을 제공하는 애플리케이션 컨텍스트에게 있기 때문이다.
스프링의 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 애플리케이션 클래스
라도 public 생성자를 가질 수 있다. 싱글톤으로 사용돼야 하는 환경이 아니
라면 간단
히 오브젝트를 생성해서 사용할 수 있다. 따라서 테스트 환경에서 지유롭게 오브젝트를
만들 수 있고， 태스트를 위한 목 오브젝트로 대체하는 것도 간단하다. DaoFactory에서
U
serDao에 ConnectionMaker 오브젝트를 시용하도록 관계를 설정해주듯이， 생성자 따
라미터를 이용해서 사용할 오브젝트를 넣어주게 할 수도 있다.


가장 중요한 것은 싱글톤 패턴과 달리 스프링이 지지하는 객체지향적인 설계 방식과

원칙， 디자인 패턴(싱글톤
패턴은
제외) 등을 적용하는 데 아무런 제약이 없다는 점이다. 스프

령은 IoC 컨테이너일 뿐만 아니라 고전적인 싱글톤 패턴을 대신해서 싱글톤을 만들고

관리해주는 싱글톤 레지스트리라는 점을 기억해두자. 스프링이 빈을 싱글톤으로 만드

는 것은 결국 오브젝트의 생성 방법을 제어하는 IoC 컨테이너로서의 역할이다.

앞에서 코드를 통해 확인해봤듯이， 이미 UserDao는 스프링 IoC를 적용하면서 싱글
톤으로 만들어진다. 그래서 getBean()
을 여러 번 호출해서 UserDao를 요청하더라도 매
번 동일한 오브젝트를 받게 된다. 만약 스프링 없이 DaoFactory만 사용한다면 이렇게
싱글톤 방식으로 UserDao를 한 변만 만들어두고 매번 같은 오브젝트를 리턴하게 하려면
DaoFactory가 상당히 지저분해질 것이다.

다음은 싱글톤으로 만들어지기 때문에 주의해야 할 점에 대해 알아보자.

1.6.2 싱글톤과 오브젝트의 상태
싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다. 따라

서 상태 관리에 주의를 기울여야 한다. 기본적으로 싱글톤이 멀티스레드 환경에서 서

비스 형태의 오브젝트로 시용되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태

statele잃 방식으로 만들어져야 한다. 다중 사용자의 요청을 한꺼번에 처리하는 스레드들

이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정히는 것은 매우 위험하다. 저장할

공간이 하나뿐이니 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있기 때

문이다. 따라서 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 、유지하는 상태유

지
stateω| 방식으로 만들지 않는다. 이를 지커지 않으면 개발자 혼자서 개발하고 테스트

할 때는 아무런 문제가 없겠지만， 서벼에 배포되고 여러 시용자가 동시에 접속하면 데

이터가 엉망이 돼버리는 등의 심각한 문제가 발생할 것이다. 물론 읽기전용의 값이라면

초기화 시점에서 인스턴스 변수에 저장해두고 공유하는 것은 아무 문제가 없다.

상태가 없는 방식으로 클래스를 만드는 경우에 각 요청에 대한 정보나. DB나 서버

의 리소스로부터 생성한 정보는 어떻게 다뤄야 할까? 이때는 파라미터와 로컬 변수， 리

턴 값 등을 이용하면 된다. 메소드 따라미터나， 메소드 안에서 생성되는 로컬 변수는 매

번 새로운값을 저장할독립적인 공간이 만들어지기 때문에 싱글톤이라고해도 여러 스

레드가 변수의 값을 덮어쓸 일은 없다.

UserDao를 수정한 리스트 1-23
의 코드를 살펴보자.

1장-오브젝트와 의존관계 109


리스트 1-23 인스턴스 변수를 사용하도록 수정한 U똥rDao

public class UserDao (
private ConnectionMaker connectionMaker;-•-초기에 설정하연 사용 중에는 바뀌지 않는
‘ 읽기전용 요I~턴스 변수

private Connection c; I _매번 새로운 값으로 뻐는 정보훌 담은 인스턴스 연수

private User user; 1 -심각한 문제가 발생한다‘

public User get(String id) throws ClassNotFoundException , SQLException (
this.c =connectionMaker.makeConnection();

this.user = new User();
this.user.setld(rs.getString( ‘ id') );
this.user.setName(rs.getString( ‘ name')) ;
this.user.setPassword(rs.getString('password'));

return this.user;

기존에 만들었던 UserDao와 다른 점은 기존에 로컬 변수로 선언하고 사용했던
Connection과 User를 클래스의 인스턴스 펼드로 선언했다는 것이다. 따라서 싱글톤으
로 만들어져서 멀티스레드 환경에서 사용하면 위에서 설명한 대로 심각한 문제가 발생
한다. 따라서 스프링의 싱글톤 빈으로 사용되는 클래스를 만들 때는 기존의 UserDao처
럼 개별적으로 바뀌는 정보는 로컬 변수로 정의하거나， 파라미터로 주고받으면서 시용
하게해야한다.

그런데 기존의 UserDao에서도 인스턴스 변수로 정의해서 사용한 것이 있다. 바로
ConnectionMaker 인터페이스 타입의 connectionMaker다. 이것은 인스턴스 변수를 사
용해도 상관없다. 왜냐하면 connectionMaker는 읽기전용의 정보이기 때문이다. 이 변
수에는 ConnectionMaker 타입의 싱글톤 오브젝트가 들어 있다. 이 connectionMaker도
DaoFactory
에 @Bean을 붙여서 만들었으니 스프링이 관리히는 빈이 될 것이고， 별다른
설정이 없다면 기본적으로 오브젝트 한 개만 만들어져서 UserDao의 connectionMaker
인스턴스 필드에 저장된다. 이렇게 자신이 사용하는 다른 싱글톤 빈을 저장하려는 용도
라면 인스턴스 변수를 사용해도 좋다. 스프링이 한 번 초기화해주고 나면 이후에는 수
정되지 않기 때문에 멀티스레드 환경에서 사용해도 아무런 문제가 없다.

동일하게 읽기전용의 속성을 가진 정보라면 싱글톤에서 인스턴스 변수로 사용해도
좋다. 물론 단순한 읽기전용 값이라면 static final
이나 final로 선언히는 편이 나을
것이다.


1.6.3 스프링 민의 스코프
스프링이 관리하는 오브젝트， 즉 빈이 생성되고， 존재하고， 적용되는 범위에 대해 알아
보자. 스프링에서는 이것을 빈의 스코프scope라고 한다. 스프링 빈의 기본 스코프는 싱글
톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서， 강제로 제거
하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다. 스프링에서 만들어지는
대부분의 빈은 싱글톤 스코프를 갖는다.
경우에 따라서는 싱글톤 외의 스코프를 가질 수 있다. 대표적으로 프로토타입
prototype 스묘프가 있다. 프로토타입은 싱글톤과 달리 컨테이너에 빈을 요청할 때마다
매번 새로운 오브젝트를 만들어준다. 그 외에도 웹을 통해 새로운 HTTP 요청이 생길
때마다 생성되는 요청
request 스코프가 있고 웹의 세션과 스코프가 유사한 세션sesslon
스코프도 있다. 스프링에서 만들어지는 빈의 스코프는 싱글톤 외에도 다%끝한 스코프를
사용할 수 있다. 싱글톤 외의 빈의 스코프에 대해서는 10장에서 자세히 알아보겠다.

I~ 의존관계 주입(D
I) 沙|


지금까지 스프링을 IoC 컨테이너로 적용하는 방법과 싱글톤 저장소로서의 특징을 살펴
봤다. 이번에는 스프링의 IoC에 대해 좀 더 깊이 알아보자.

1.7.1 저|어의 역전(loC)과 의존관계 주입
IoC는 소프트웨어에서 자주 발견할 수 있는 일반적인 개념이라고 설명했다. 객체지향
적인 설계나， 디자인 패턴， 컨테이너에서 동작하는 서버 기술을 사용한다면 자연스럽게
IoC를 적용하거나 그 원리로 동작하는 기술을 사용하게 될 것이다. DaoFactory처럼 객
체를 생성하고 관계를 맺어주는 등의 작업을 담당하는 기능을 일반화한 것이 스프링의
IoC 컨테이너다.
한가지 짚고넘어갈것은여기서 사용히는
IoC라는용어인데
.IoC가매우느슨하게
정의돼서 폭넓게 사용되는 용어라는 점이다. 때문에 스프링을 IoC 컨테이너라고만 해
서는 스프령이 제공하는 기능의 특정을 명확하게 설명하지 못한다. 스프링이 서블릿 컨
테
이너처럼 서버에서 동작하는 서비스 컨테이너라는 돗인지， 아니면 단순히 IoC 개념
이 적용된 탬플릿 메소드 패턴을 이용해 만들어진 프레임워크인지， 아니면 또 다른 IoC
특정을 지닌 기술이라는 것인지 파악하기 힘들다. 그래서 새로운 용어를 만드는 데 탁

1장-오브젝트와 의존관계 111


월한 재능이 있는 몇몇 사람의 제안으로 스프링이 제공히는 IoC 방식을 핵심을 짚어주

는 의존관계 주입Dependency Injection이라는 좀 더 의도가 명확히 드러나는 이름을 사용하
기 시작했다. 스프링 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린
다. 물론 스프링이 컨테이너이고 프레임워크이니 기본적인 동작원리가 모두 IoC 방식
이라고 할 수 있지만， 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 의

존관계 주입이라는 새로운 용어를 사용할 때 분명하게 드러난다. 그래서 초기에는 주로
IoC 컨테이너라고 불리던 스프링이 지금은 의존관계 주입 컨테이너 또는 그 영문약자
를 써서 DI 컨테이너라고 더 많이 불리고 있다.

활 의;핸체 추업， 의혼성 추엄. 의혼 오브잭트 주입?
‘Depe며ency Inj따lon’은 여러 가지 우리말로 번역돼서 사용된다. 그중에서 가장 혼히 사용
되는 용어가 의존성 주입이다. 하지만 의존성이라는 말은 미의 의미가 무엇인지 잘 드러내주
지 못한다. 또한 의펀종속) 오브젝트 주입이라고도 부르기도 하는데. 이때는 미가 얼어나는 방
법에 초점윷 맞춘 것이다. 엄밀히 말해서 오브젝트는 다른 오브젝트에 주입힐 수 있는 게 아니
다. 오브젝트의 레퍼런스가 전달될 뿐이다. DI는 오브젝트 레퍼런스톨 외부로부터 제공(주입)받
고 이톨 흥해 여타 오브젝트와 다이내믹하게 의존관계가 만줄어지는 것이 핵심이다. 용어는 동
작방식(메커니홉)보다는 의도톨 가지고 이륨율 짓는 것이 훌다. 그련 면에서 의존관계 주입이

라는 번역이 적절할 듯싶고. 이 책에서는 이톨 사용한다. 하지만 대가 무엇인지만 잘 인식하고
있다면 어떤 용어률 사용해도 상관없다. 의도톨 강하게 드러내는 ‘의존관계 설정’이라는 용어도
나쁘지 않다고 생각한다.

키

|
|

1.7.2 런타임 의존관계 설정
의존관계
먼저 의존관계란 무엇인지 생각해보자.
두 개의 클래스 또는 모율이 의존관계에 있다고 말할 때는 항상 방향성을 부여해줘
야 한다. 즉 누가 누구에게 의존하는 관계에 있다는 식이어야 한다. UML 모댈에서는
두 클래스의 의존관계dependency relationship를 다음과 같이 점선으로 된 화살표로 표현한

다. 그림 1-10은
A가
B에 의존하고 있음을나타낸다.

---4 I

|

A B

’•

-


j

그림 1-10 클래스의 의존관계 다이어그램


그렇다면 의존하고 있다는 건 무슨 의미일까? 의존한다는 건 의존대상， 여기서는 B가
변하면 그것이 A에 영향을 미친다는 뭇이다.8의 기능이 추가되거나 변경되거나， 형식
이 바뀌거나하면 그 영향이 A로 전달된다는 것이다. 대표적인 예는
A가
B를시용하는
경우， 예를 들어 A에서 B에 정의된 메소드를 호출해서 사용히는 경우다. 이럴 땐 ‘사용
에 대한 의존관계’가 있다고 말할 수 있다. 만약 B
에 새로운 메소드가 추가되거나 기존
메소드의 형식이 바뀌면 A도 그에 따라 수정되거나 추가돼야 할 것이다. 또는 B
의 형식
은 그대로지만 기능이 내부적으로 변경되면 결과적으로 A의 기능이 수행되는 데도 영
향을 미칠 ·수 있다. 이렇게 사용의 관계에 있는 경우에 A와 B는 의존관계가 있다고 말
할수있다.‘

다시 말하지만 의존관계에는 방향성이 있다.A가 B에 의존하고 있지만， 반대로 B는
A에 의존하지 않는다. 의존하지 않는다는 말은 B는 A의 변회에 영향을 받지 않는다는
돗이다.

UserDao의 의존관계
지금까지 작업해왔던 UserDao의 예를 보자. UserDao가 ConnectionMaker에 의존하고
있는 형태다. 그림 1-11
은 앞에서 작업했던 UserDao가 ConnectionMaker 인터페이스
를 사용하는 것을 나타낸다. 이 그림에서 UserDao는 ConnectionMaker 인터페이스에
만 의존하고 었다. 따라서 ConnectionMaker 인터페이스가 변한다면 그 영향을 UserDao
가 직접적으로 받게 된다. 하지만 ConnectionMaker 인터페이스를 구현한 클래스， 즉
DConnectionMaker 등이 다른 것으로 바뀌거나 그 내부에서 시용히는 메소드에 변화가
생겨도 UserDao에 영향을 주지 않는다. 이렇게 인터페이스에 대해서만 의존관계를 만
들어두면 인터페이스 구현 클래스와의 관계는 느슨해지면서 변회에 영향을 덜 받는 상
태가 된다. 결합도가 낮다고 설명할 수 있다. 의존관계란 한쪽의 변화가 다른 쪽에 영향
을 주는 것이라고 했으니， 인터페이스를 통해 의존관계를 제한해주면 그만큼 변경에서
자유로워지는셈이다.

r---:.~-?>

‘ interface>>
ConnectionMalter
DConnectionM&ker

그림 1-11 인터페이스톨 통한 느슨한 결합울 강는 의존관계

1장-오브젝트와
9흩관계 113


이 그림에서 알 수 있듯이 UserDao 클래스는 ConnectionMaker 인터페이스에게만 직
접 의존한다. UserDao는 DConnectionMaker라는 클래스의 존재도 알지 못한다. 모텔의
관점에서 보자면 UserDao는 DConnectionMaker 클래스에는 의존하지 않기 때문이다.
UML에서 말히는 의존관계란 이렇게 설계 모댈의 관점에서 이야기하는 것이다. 그런데
모댈이나 코드에서 클래스와 인터페이스를 통해 드러나는 의존관계 말고， 런타임 시에
오브젝트 사이에서 만들어지는 의존관계도 있다. 런타임 의존관계 또는 오브젝트 의존
관계인데， 설계 시점의 의존관계가 실체화된 것이라고 볼 수 있다. 런타임 의존관계는

모댈링 시점의 의존관계외는 성격이 분명히 다르다.

인터페이스를 통해 설계 시점에 느슨한 의존관계를 갖는 경우에는 User
D"ao의 오브젝

트가 런타임 시에 시용할 오브젝트가 어떤 클래스로 만든 것인지 미리 알 수가 없다. 개

발자나운영자가사전에 어떤클래스의 오브젝트를쓸지 미리 정해놓을수는있지만그
것이 UserDao나 ConnectionMaker 등의 설계와 코드 속에서는 드러나지 않는다는 말이
다. 프로그랩이 시작되고 UserDao 오브젝트가 만들어지고 나서 런타임 시에 의존관계
를 맺는 대상， 즉 실제 λF용대상인 오브젝트를 의존 오브젝트dependent object라고 말한다.

의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주제， 보통 클
라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업을 말한다. UserDao는
ConnectionMaker 인터페이스라는 매우 단순한 조건만 만족하면 어떤 클래스로부터 만
들어졌든 상관없이 오브젝트를 받아들이고 사용한다.

정리하면 의존관계 주입이란 다음과 같은세 가지 조건을충족히는작업을 밀한다.

• 클래스 모댈이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인
터페이스에만 의존하고 있어야 한다.
• 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3
의 존재가 결정한다.
• 의존관계는 시용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.
의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록

도외주는 제3
의 존재가 있다는 것이다. 사실 이 개념은 앞에서 관계설정 책임을 분리하
는 작업을 할 때 이미 설명했다.DI에서 말하는 제3의 존재는 바로 관계설정 책임을 가
진 묘드를 분리해서 만들어진 오브젝트라고 볼 수 있다. 전략 패턴에 등장하는 클라이
언트나 앞에서 만들었던 DaoFactory 또 DaoFactory와 같은 작업을 일반화해서 만들어
졌다는 스프링의 애플리케이션 컨텍스트， 빈 팩토리. IoC 컨테이너 등이 모두 외부에서
오브젝트 사이의 런타임 관계를 맺어주는 책임을 지닌 제3의 존재라고 볼 수 있다.


UserDao의 의존관계 주입
UserDao
에 적용된 의존관계 주입 기술을 다시 살펴보자.
인터페이스를 사이에 두고 UserDao와 ConnectionMaker 구현 클래스 간에 의존관계
를 느슨하게 만들긴 했지만 마지막으로 남은 문제가 있었는데 그것은 UserDao가 사용
할 구체적인 클래스를 알고 있어야 한다는 점이었다. 관계설정의 책임을 분리하기 전에
UserDao 클래스의 생성지는 리스트 1-24와 같았다.

리스트 1-24 관계설정 책임 분리 전의 생성자

public UserDao() {
connectionMaker =new DConnectionMaker();

이 코드에 따르면 UserDao는 이미 설계 시점에서 DConnectionMaker라는 구체적인
클래스의 존재를 알고 있다. 따라서 모댈링 때의 의존관계 즉 ConnectionMaker 인터페
이스의 관계뿐 아니라 런타임 의존관계 즉 DConnectionMaker 오브젝트를 사용하겠다
는 것까지 UserDao가 결정하고 관리하고 있는 셈이다.

이 코드의 문제는 이미 런타임 시의 의존관계가 묘드 속에 다 미리 결정되어 있다
는 점이다. 그래서 IoC 방식을 써서 UserDao로부터 런타임 의존관계를 드러내는 코
드를 제거하고， 제3
의 존재에 런타임 의존관계 결정 권한을 위임한다. 그래서 최종적
으로 만들어진 것이 DaoFactory다. DaoFactory는 런타임 시점에 UserDao가 사용할
ConnectionMaker 타입의 오브젝트를 결정하고 이를 생성한 후에 UserDao의 생성자 따
라미터로 주입해서 UserDao가 DConnectionMaker의 오브젝트와 런타임 의존관계를 맺
게 해준다. 따라서 의폰관계 주입의 세 가지 조건을 모두 충족한다고 볼 수 있고， 이미
DaoFactory를 만든 시점에서 의존관계 주입미을 이용한 셈이다.

그림 1-12와 같이 UserDao의 의존관계는 ConnectionMaker 인터페이스뿐이다. 이
것은 클래스 모댈의 의존관계이므로 묘드에 반영되고 런타임 시점에서도 변경되지 않
는다.


<<int8rface))
UserDa。
ConnectionMaker

그림 1-12 클래스/코드 레웰의 의존관계

1장-오브젝트와 의존관계 115


런타임 시점의 의존관계를 결정하고 만들려면 제
3
의 존재가 펼요하다고 했다.
DaoFactory가 그 역할을 담당한다고 해보자. DaoFactory는 여기서 두 오브젝트 사이의
런타임 의존관계를 설정해주는 의존관계 주입 작업을 주도하는 존재이며， 동시에 IoC
방식으로 오브젝트의 생성과 초기화， 제공 등의 작업을 수행히는 컨테이너다. 따라서
의존관계 주입을 담당히는 컨테이너라고 볼 수 있고 줄여서 DI 컨테이너라고 불러도
된다. 보통 DI는 그 근간이 되는 개념인 IoC와 함께 시용해서 IoC/DI 컨테이너라는 식
으로 함께 사용하기도 한다. 아무튼 DaoFactory는 그래서 DI 컨테이너다.

DI 컨테이너는 UserDao를 만드는 시점에서 생성자의 파라미터로 이미 만들어진
DConnectionMaker의 오브젝트를 전달한다. 정확히는 DConnectionMaker 오브젝트의 레
퍼런스가 전달되는 것이다. 주입이라는 건 외부에서 내부로 무엇인가를 넘겨줘야 하는
것인데， 자바에서 오브젝트에 무엇인가를 넣어준다는 개념은 메소드를 실행하면서 따
라미터로 오브젝트의 레퍼런스를 전달해주는 방법뿐이다. 가장 손쉽게 시용할 수 있는
파라미터 전달이 가능한 메소드는 바로 생성자다.

DI 컨테이너는 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 이 생
성자의 따라미터로 오브젝트의 레퍼런스를 전달해준다. 바로 리스트 1-25
가 이 과정의
작업을 위해 필요한 전형적인 코드다. 이렇게 생성자 파라미터를 통해 전달받은 런타임
의존관계를 갖는 오브젝트는 인스턴스 변수에 저장해둔다.

리스트 1-25 의존관계 주입을 위한 코드

public class UserDao (
private ConnectionMaker connectionMaker;

public UserDao(ConnectionMaker connectionMaker) {
this.connectionMaker =connectionMaker;

이렇게 해서 두 개의 오브젝트 간에 런타임 의존관계가 만들어졌다
. UserDao 오브젝
트는 이제 생성자를 통해 주입받은 DConnectionMaker 오브젝트를 언제든지 사용하면
된다.

이렇게 DI 컨테이너에 의해 런타임 시에 의존오브젝트를사용할수 있도록그 레퍼
런스를 전달받는 과정이 마치 메소드(생성재를 통해 DI 컨테이너가 UserDao에게 주입해
주는 것과 같다고 해서 이를 의존관계 주입이라고 부른다. 그림 1-13은 이런 객체에


대한 런타임 의존관계 주입과 그것으로 발생하는 런타임 사용 의존관계의 모습을 보여
준다.


:UsarOa。
oonnaotionMakar ..
<<의존관계 주입)) ------------《
사용 의존관계))
:OConneotionMaker
makaConnaotion ()
add() /

그힐 1-13 런타임 시의 의존관계 주입과 사용 의존관계

DI는 자신이 시용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동
적으로 주입받은 오브젝트를 사용한다는 점에서 IoC
의 개념에 잘 들어맞는다. 스프링
컨테이너의 IoC는 주로 의존관계 주입 또는 DI라는 데 초점이 맞춰져 있다. 그래서 스
프링을 IoC 컨테이너 외에도 DI 컨테이너 또는 DI 프레임워크라고 부르는 것이다.

1.7.3 의존관계 검색과 주입
스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다. 코드에서는 구체
적인 클래스에 의존하지 않고 런타임 시에 의존관계를 결정한다는 점에서 의존관계 주
입과 비슷하지만， 의존관계를 맺는 방법이 외부로부터의 주입이 아니라 스스로 검색을
이용하기 때문에 의존관계 검색dependency I∞kup이라고 불리는 것도 있다. 의존관계 검색
은 자신이 펼요로 하는 의존 오브젝트를 능동적으로 찾는다. 물론 자신이 어떤 클래스
의 오브젝트를 이용할지 결정하지는 않는다. 그러면 IoC라고 할 수는 없을 것이다. 의
존관계 검색은 런타임 시 의존관계를 맺을 오브젝트를 결정히는 것과 오브젝트의 생성
작업은 외부 컨테이너에게 IoC로 맡기지만 이를 가져올 때는 메소드나 생성자를 통한
주입 대신 스스로 컨테이너에게 요청하는 방법을 사용한다.
예를 들어 UserDao의 생성지를 리스트 1-26과 같이 만들었다고 생각해보자.

리스트 1-26 DaoFactory톨 이용하는 생성자

public UserDao() (
DaoFactory daoFactory =new DaoFactory();
this.connectionMaker =daoFactory.connectionMaker();

이렇게 해도 UserDao는 여전히 자신이 어떤 ConnectionMaker 오브젝트를 λ}용할지
미리 알지 못한다. 여전히 묘드의 의존대상은 ConnectionMaker 인터페이스뿐이다. 런

1장-오브젝드와 의존관계 117


타임 시에 DaoFactory가 만들어서 돌려주는 오브젝트와 다이내믹하게 런타임 의존관계
를 맺는다. 따라서 IoC 개념을 잘 따르고 있으며， 그 혜택을 받고 있는 코드다. 하지만
적용 방법은 외부로부터의 주입이 아니라 스스로 IoC 컨테이너인 DaoFactory에게 요청
히는 것이다. DaoFactory
의 경우라면 미리 준비된 메소드를 호출하면 되니까 단순히 요
청으로 보이겠지만， 이런 작업을 일반화한 스프링의 애플리케이션 컨텍스트라면 미리
정해놓은 이름을 전달해서 그 이름에 해당히는 오브젝트를 찾게 된다. 따라서 이를 일
종의 검색이라고 볼 수 있다. 또한 그 대^.{이 런타임 의존관계를 가질 오브젝트이므로
의존관계 검색이라고 부르는 것이다.

스프링의 IoC 컨테이너인 애플리케이션 컨텍스트는 getBean()
이라는 메소드를 제
공한다. 바로 이 메소드가 의존관계 검색에 시용되는 것이다. UserDao는 리스트 1-27
과 같이 애플리케이션 컨텍스트를 사용해서 의존관계 검색 방식으로 ConnectionMaker
오브젝트를 가져오게 만들 수도 있다.

리스트 1-27 의존관계 검색율 이용하는 U똥rDa。 생성자

public UserDao() {
AnnotationConfigApplicationContext context =
new AnnotationConfigApplicationContext(DaoFactory.class);
this.connectionMaker = context.getBean(‘ connectionMaker"’ ConnectionMaker.class);

의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 었다.IoC 원칙에도
잘 들어맞는다. 단， 방법만 조금 다를 뿐이다.

그렇다면 의존관계 검색과 앞에서 살펴봤던 의존관계 주입 방법 중 어떤 것이 더 나
을까? 코드를 보면 느껄 수 있겠지만 의존관계 주입 쪽이 훨씬 단순하고 깔끔하다. 의
존관계 검색 방법은 코드 안에 오브젝트 팩토리 클래스나 스프링 API가 나타난다. 애플
리케이션 컴포넌트가 컨테이너와 같이 성격이 다른 오브젝트에 의존하게 되는 것이므
로 그다지 바람직하지 않다. 사용자에 대한 DB 정보를 어떻게 가져올 것인가에 집중해
야 히는 UserDao에서 스프링이나 오브젝트 팩토리를 만들고 API를 이용하는 코드가 섞
여 있는 것은 어색하다. 따라서 대개는 의존관계 주입 방식을 시용하는 편이 낫다.

그런데 의존관계 검색 방식을 사용해야 할 때가 있다. 앞에서 만들었던 테스트 코드
인 UserDaoTest를 보자. 태스트 코드에서는 이미 의존관계 검색 방식인 getBean()
을
사용했다. 스프령의 IoC와 DI 컨테이너를 적용했다고 하더라도 애플리케이션의 기동
시점에서 적어도 한 번은 의존관계 검색 방식을 사용해 오브젝트를 가져와야 한다. 스


태틱 메소드인 main()
에서는 DI를 이용해 오브젝트를 주입받을 방법이 없기 때문이다.
서버에서도 마찬가지다. 서버에는 main()
과 같은 기동 메소드는 없지만， 사용자의 요청
을 받을 때마다 main() 메소드와 비슷한 역할을 하는 서블릿에서 스프링 컨테이너에 담
긴 오브젝트를 사용하려면 한 번은 의존관계 검색 방식을 λF용해 오브젝트를 가져외。F
한다. 다행히 이런 서블릿은 스프링이 미리 만들어서 제공하기 때문에 직접 구현할 펼
요는없다.

의존관계 검색과 의존관계 주입을 적용할 때 발견할 수 있는 중요한 차이점이 하
나 있다. 의존관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 펼
요가 없다는 점이다. UserDao
에 스프링의 getBean()을 사용한 의존관계 검색 방법
을 적용했다고 해보자. 이 경우 UserDao는 굳이 스프링이 만들고 관리하는 빈일 필요
가 없다. 그냥 어딘가에서 직접 new UserDao() 해서 만들어서 사용해도 된다. 이때는
ConnectionMaker만 스프링의 빈이기만 하면 된다.

반면에 의존관계 주입에서는 UserDao와 ConnectionMaker 사이에 DI가 적용되려
면 UserDao도 반드시 컨테이너가 만드는 빈 오브젝트여야 한다. 컨테이너가 UserDao
에
ConnectionMaker 오브젝트를 주입해주려면 UserDao에 대한 생성과 초기화 권한을 갖
고 있어야 하고， 그러려면 UserDao는 IoC 방식으로 컨테이너에서 생성되는 오브젝트，
즉 빈이어야하기 때문이다. 이런 점에서 DI와
DU의존관계검색도
약자로
마이라고얘할것이대
은적용방법에차이가있다.

DI를 원하는 오브젝트는 먼저 자기 자신이 컨테이너가 관리하는 빈이 돼야 한다는
사실을잊지말자.

활
미받는다
01의 동작방식은 이룸 그대로 외부로부터의 주입이다. 하지만 단지 외부에서 파라미터로 오브
젝트톨 넘겨췄다고 해서， 즉 주입해췄다고 해서 다 미가 아니라는 점을 주의해야 한다. 주입받
는 메소드 파라미터가 이미 특정 클래스 타입으로 고정되어 있다면 미가 일어날 수 없다.01에
서 말하는 주입은 다이내믹하게 구현 클래스를 결정해서 제공받올 수 있도륙 인터떼이스 타입
의 파라미터를 통해 이뤄져야 한다.

그래서 이 책에서는 미 원리훌 지키며 외부에서 오브젝트톨 제공받는 방법울 단순히 ‘주입받
는다’라고 하는 대신 ‘01 받는다’라고 표현하기도 할 것이다. 좀 어색한 표현일지는 모르겠지만，
단순한 오브젝트 주입이 아니라 01 개념올 따르는 주입임을 강조하는 것이라고 이해해주먼 좋
겠다.

1장-오브젝트와 의존관계 119


1.7.4 의존관계 주입의 응용
런타임 시에 시용 의존관계를 맺을 오브젝트를 주입해준다는 DI 기술의 장점은 무엇

일까?

앞에서 살며봤던 오브젝트 팩토리가 바로 이 DI 방식을 구현한 것이니， 앞에서 설명

한 모든 객체지향 설계와 프로그래밍의 원칙을 따랐을 때 얻을 수 있는 장점이 그대로

DI 기술에도 적용될 것이다. 코드에는 런타임 클래스에 대한 의존관계가 나타나지 않

고， 인터페이스를 통해 결합도가 낮은 묘드를 만들므로， 다른 책임을 가진 시용 의존관

계에 있는 대상이 바뀌거나 변경되더라도 자신은 영향을 받지 않으며， 변경을 통한 다

OJ'한확장방법에는지유롭다는게 지금까지 설명한장점이었다.

D 사와 N 사에게 UserDao의 묘드를 판매하는 경우가 아니더라도 UserDao와

ConnectionMaker 사이에 적용된 DI는 여러 가지 방법으로 유용하게 활용될 수 있다.

이 책의 Vol.l 에서 설명하는 스프링의 각종 기술은 모두 다 이 DI 없이는 불기능한 것

들이다. 스프링이 제공하는 기능의 99%가 DI의 혜택을 이용하고 있다.DI 없이는 스프

링도 없다. 그만큼 DI를 활용할 방법은 다OJ'하다.

UserDao
가 ConnectionMaker
라는 인터페이스에만 의존하고 있다는 건，

ConnectionMaker를 구현하기만 하고 있다면 어떤 오브젝트든지 시용할 수 있다는 돗

이다.

몇 가지 응용 사례를 생각해보자.

기능구현의교환
실제 운영에 사용할 데이터베이스는 매우 중요한 자원이다. 명상시에도 항상 부하를 많
이 받고 있어서 개발 중에는 절대 시용하지 말아야 한다. 대신 개발 중에는 개발자 PC
에 설치한 로컬 DB로 시용해야 한다고 해보자. 그리고 개발이 진행되다가 어느 시점
이 되면 지금까지 개발한 것을 그대로 운영서버로 배치해서 시용할 것이다. 그런데 만
약 DI 방식을 적용하지 않았다고 해보자. 개발 중에는 로컬 DB를 사용하도록 해야 하
니 로컬 DB에 대한 연결 기능이 있는 LocalDBConnectionMaker라는 클래스를 만들고，
모든 DAO에서 이 클래스의 오브젝트를 매번 생성해서 사용하게 했을 것이다. 초난감
DAO에서 했던 바로그방식이다. 그런데 서벼에 배포할때는다시 서벼가제공하는특
별한 DB 연결 클래스를 사용해야 한다.DI를 안 했으니 모든 DAO는 코드에서 이미
클래스인 LocalDBConnectionMaker에 의존하고 있다. new LocalDBConnectionMaker()
라는 코드가 모든 DAO
에 들어 있을 것이다. 이를 서버에 배치하는 시점에서 운영서벼


에서 DB에서 연결할 때 펼요한 ProductionDBConnectionMaker라는 클래스로 변경해줘
야 한다. DAO가 100개라면 최소한 100군데의 코드를 수정해야 한다. 하나라도 빼먹
거나 잘못 고치면 서버에서 오류가 발생할 것이다. 그리고 다시 개발을 더 진행하려고
하면 다시 DAO 묘드를 LocalDBConnectionMaker를 시용하도록 수정해야 한다. 끔찍한
일이다.

반면에 DI 방식을 적용해서 만들었다고 해보자. 모든 DAO는 생성 시점에
ConnectionMaker 타입의 오브젝트를 컨테이너로부터 제공받는다. 구체적인 사용
클래스 이름은 컨테이너가 사용할 설정정보에 들어 있다. @Configuration
이 붙은
DaoFactory를 사용한다고 하면 개발자 PC에서는 DaoFactory의 코드를 리스트 1-28과
같이 만들어서 사용하면 된다.

리스트 1-28 개발용 ConnectionMaker 생성 코드

@ßean
public ConnectionMaker connectionMaker() (
return new LocalDBConnectionMaker();

이를 서버에 배포할 때는 어떤 DAO 클래스와 코드도 수정할 필요가 없다. 단지 서
버에서 사용할 DaoFactory를 리스트 1-29와 같이 수정해주기만 하면 된다. DAO가
1007H이든 1000개이든상관없다. 딱한줄이면 된다.

리스트 1-29 운영용 ConnectionMaker 생성 코드

@ß ean
public ConnectionMaker connectionMaker() (
return new ProductionDBConnectionMaker();

개발환경과 운영환경에서 DI의 설정정보에 해당하는 DaoFactory만 다르게 만들어
두면 나머지 코드에는 전혀 손대지 않고 개발 시와 운영 시에 각각 다른 런타임 오브젝
트에 의존관계를 갖게 해줘서 문제를 해결할 수 있다.

또한 QA팀이 태스트용으로 별도의 태스트 DB를 만들어서， 개발한 코드를 테스트
할 때 쓴다고 하자. 이 경우에도 DAO 코드에는 전혀 손탤 필요가 없다. 테스트 DB
에
접속하는 방법을 가진 ConnectionMaker 구현 클래스를 만들고， 그것을 테스트에서 사

1장-오브젝트와 의존관계 121


용할 DaoFactory 설정에 넣어주기만 하면 된다. 태스트가 수행되는 시점에서 테스트용
DB
에 연결해주는 오브젝트를 DI 컨테이너가 만들어 모든 DAO가 시용할 수 있도록
DI
해줄것이다.

부가기능추가

디음은 이런 경우도 생각해보자.DAO가 DB를 얼마나 많이 연결해서 시용하는지 파악
하고 싶다고 해보자. DB 연결횟수를 카운팅하기 위해 무식한 방법으로， 모든 DAO의
makeConnection() 메소드를 호출하는 부분에 새로 추가한 카운터를 증가시키는 묘드를
넣어야 할까? 그리고 분석 작업이 끝나면 모두 제거하고? 그것은 엄청난 낭비이고 노가
다다. 게다가 DAO 묘드를 수정한다는 건 지금까지 그렇게 피하려고 했던 일이 아닌가.
또한 DB 연결횟수를 세는 일은 DAO의 관심사항이 아니다. 어떻게든 분리돼야 할 책
임이기도하다.

DI 컨테이너에서라면 아주 간단한 방법으로 가능하다. DAO와. DB 커넥션을 만드
는 오브젝트 λ에에 연결횟수를 카운팅히는 오브젝트를 하나 더 추가하는 것이다. 뭔가
새로운 기능을 호출 과정에 추가하려고 한다면 분명 그 앞뒤의 묘드를 같이 수정해야
하는 것이 아닐까? 꼭 그럴 펼요는 없다.DI의 개념을 응용히는 것으로 충분하다.DI를

이용한다고 했으니 당연히 기존 묘드는 수정하지 않아도 된다. 그리고 컨테이너가 사용
하는 설정정보만 수정해서 런타임 의존관계만 새롭게 정의해주면 된다.

묘드를 직접 살펴보자. 먼저 CountingConnectionMaker라는 클래스를 리스트 1-30
과 같이 만든다. 중요한 것은 ConnectionMaker 인터페이스를 구현해서 만든다는 점이
다.
DAO가 의존할 대상이 될 것이기 때문이다.

리스트 1-30 연결횟수 카운팅 기능이 있는 클래스

package springbook.user.dao;

public class CountingConnectionMaker implements ConnectionMaker (
int counter =Ð;
private ConnectionMaker realConnectionMaker;

public CountingConnectionMaker(ConnectionMaker realConnectionMaker) {
this.realConnectionMaker =realConnectionMaker;

public Connection makeConnection() throws ClassNotFoundException , SQLException {
this.counter++;


return realConnectionlaker.makeConnection();

public int getCounter() {
return this.counter;

CountingConnectionMaker 클래스는 ConnectionMaker 인터페이스를 구현했지
만 내부에서 직접 DB 커넥션을 만들지 않는다. 대신 DAO
가 DB 커넥션을 가져
올 때마다 호출하는 makeConnection()
에서 DB 연결횟수 카운터를 증가시킨다.
CountingConnectionMaker는 자신의 관심사인 DB 연결횟수 카운팅 작업을 마치면 실
제 DB 커넥션을 만들어주는 realConnectionMaker
에 저장된 ConnectionMaker 타입
오브젝트의 makeConnection( )을 호출해서 그 결과를 DAO에게 돌려준다. 그래야만
DAO가 DB 커넥션을 사용해서 정상적으로 동작할 수 있다.

생성자를 보면 CountingConnectionMaker
도 DI
를 받는 것을 알 수 있다.
CountingConnectionMaker
의 오브젝트가 DI 받을 오브젝트도 역시 ConnectionMaker
인터페이스를 구현한 오브젝트다. 아마 실제 DB 커넥션을 돌려주는 DConnectionMaker
클래스의 오브젝트일 것이다.

CountingConnectionMaker가 추가되면서 런타임 의존관계가 어떻게 바뀌는지 살펴
보자. 그림 1-14는 CountingConnectionMaker를 사용하기 전의 런타임 의존관계다.
UserDao 오브젝트는 ConnectionMaker 타입의 DConnectionMaker 오브젝트에 의존한다.

:UserDa。
: DConnectionMaker
>

그림 1-14 CountingConnectionMaker룰 적용하기 전의 런타임 오브젝트 의존관계

UserDao
는 ConnectionMaker
의 인터페이스에만 의존하고 있기 때문에，
ConnectionMaker 인터페이스를 구현하고 있다면 어떤 것이든 DI가 가능하다. 그래
서 UserDao 오브젝트가 DI 받는 대상의 설정을 조정해서 DConnection 오브젝트 대신
CountingConnectionMaker 오브젝트로 바꿔치기히는 것이다. 이렇게 해두변 UserDao가
DB 커넥션을 가져오려고 할 때마다 CountingConnectionMaker
의 makeConnection()
메소드가 실행되고 카운터는 하나씩 증가할 것이다.

1장-오브젝트와의존관계 123


그렇다고 해서 DB 커넥션을 제공해주지 않으면 DAO
가 동작하지 않을 테
니 CountingConnectionMaker
가 다시 실제 사용할 DB 커넥션을 제공해주는
DConnectionMaker를 호출하도록 만들어야 한다. 역시 DI를 시용하면 된다. 이렇게 해
서 재구성된새로운런타임 의존관계는그림 1-15와같다.

:U••rDa。
: DConnectionMaker

-F•} C뼈tin야뼈ect 빼X

그림 1-15 CountingConnectionMaker톨 적용한 후의 런타임 오브젝트 의존관계

새로운 의존관계를 컨테이너가 사용할 설정정보를 이용해 만들어보자.
CountingDaoFactory라는 이름의 설정용 클래스를 만든다. 기존 DaoFactory와 달
리， connectionMaker() 메소드에서 CountingConnectionMaker 타입 오브젝트를 생
성하도록 만든다. 그리고 실제 DB 커넥션을 만들어주는 DConnectionMaker는 이름이
realConnectionMaker() 인 메소드에서 생성하게 한다. 그리고 realConnectionMaker()
메소드가 만들어주는 오브젝트는 connectionMaker()
에서 만드는 오브젝트의 생
성자를 통해 DI 해준다. 기존 DAO 설정 부분은 바꾸지 않아도 된다. 계속해서
connectionMaker() 메소드를 통해 생성되는 오브젝트를 시용하게 한다.

리스트 1-31
은 이렇게 만들어진 새로운 의존관계를 담은 설정용 코드다.

리스트 1-31 CountingConnectionMaker 의존관계가 추가된 DI 설정용 클래스

package springbook .user .dao;

@(onfiguration

public class CountingDaoFactory {
@ßean
public UserDao userDao() {

return new UserDao(connectionMaker());

l 모든 DAO는 여전히 connectionMaker(때|서
| 만틀어지는 오브젝트률 마 받는다

tIIIean •
public ConnectionMaker connectionMaker() (
return new CountingConnectionMaker(realConnectionMaker());

tIIIean
public ConnectionMaker realConnectionMaker() (
return new DConnectionMaker();


이제 커넥션 카운팅을 위한 실행 코드를 만든다. 기본적으로는 UserDaoTest와 같
지만 설정용 클래스를 CountingDaoFactory로 변경해줘야 한다. DAO를 DL 방식
으로 가져와 어떤 작업이든 여러 번 실행시킨다. 그리고 CountingConnectionMaker
빈을 가져온다. 설정정보에 지정된 이름과 타입만 알면 특정 빈을 가져
올 수 있으니 CountingConnectionMaker 오브젝트를 가져오는 건 간단하다.
CountingConnectionMaker에는 그동안 DAO를 통해 DB 커넥션을 요청한 횟수만큼 카
운터가 증가해 있어야 한다. 카운터 값을 가져와서 화면에 출력해보고 DAO의 사용횟
수와 일치히는지 확인해보자.

리스트 1-32는 이렇게 만들어진 CountingConnectionMaker 태스트용 클래스다.

리스트 1-32CαJntingConnectionMaker에 대한 테스트 클래스

package springbook .user .dao;

public class UserDaoConnectionCountingTest (
public static void main(String[) args) throws ClassNotFoundException ,
SQLException (
AnnotationConfigApplicationContext context =
new AnnotationConfigApplicationContext(CountingDaoFactory.class);
UserDao dao = context.getBean("userDao" , UserDao .class);

//
// DAO 사용 코드 DL(의존관계 검색}을 사용하면 이름을

// r

이용해 어떤 빈이든 가져올 수 있다

CountingConnectionMaker ccm = context.getBean("connectionMaker" ’
CountingConnectionMaker.class);
System.out.println("Connection counter "+ ccm.getCounterO);

지금은 DAO가 하나뿐이지만 DAO가 수십， 수백 개여도 상관없다.DI의 장점은
관심사의 분리$를 통해 얻어지는 높은 응집도에서 나옹다. 모든 DAO가 직접 의존
해서 사용할 ConnectionMaker 타입 오브젝트는 리스트 1-17
의 connectionMaker()

1장-오브젝트와의존관계 125


메소드에서 만든다. 따라서 CountingConnectionMaker
의 의존관계를 추가하려면 이
메소드만 수정하면 그만이다. 또한 CountingConnectionMaker를 이용한 분석 작업
이 모두 끝나면， 다시 CountingDaoFactory 설정 클래스를 DaoFactory로 변경하거나
connectionMaker() 메소드를 수정하는 것만으로 DAO의 런타임 의존관계는 이전 상태
로복구된다.

정말 멋지고 편리하지 않은가? 바로 이런 것이 의존관계 주입의 매력을 잘 드러내는
응용 방법이다. 앞으로 계속 살펴보겠지만 DI를 활용하는 방법은 매우 다%봐다. 다시
말하지만 스프링이 제공히는 대부분의 기능은 DI 없이는 존재할 수도 없는 것들이다.
스프링은 DI를 편하게 사용할 수 있도록 도와주는 도구이면서 그 자체로 DI를 적극 활
용한프레임워크이기도하다
DI가정말중요하고좋다고생각한다면자기 스스로 먼저
적용하지 않을 이유가 없다. 그래서 스프링을 공부하는 건 DI를 어떻게 활용해야 할지
를 공부하는 것이기도 하다.

1.7.5 메소드를 이용한 의존관계 주입
지금까지는 UserDao의 의존관계 주입을 위해 생성자를 사용했다. 생성자에 따라미터를
만들어두고 이를 통해 DI 컨테이너가 의존할 오브젝트 레퍼런스를 넘겨주도록 만들었
다. 그런데 의존관계 주입 시 반드시 생성자를 사용해야 하는 것은 아니다. 생성자가 아
닌 일반 메소드를 사용할 수도 있을 뿐만 아니라， 생성자를 사용히는 방법보다 더 자주
사용된다.
생성자가 아닌 일반 메소드를 이용해 의존 오브젝트와의 관계를 주입해주는 데는 크
게두가지 방법이 있다.

• 수정자 메소드를 이용한 주입
수정자setter 메소드는 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도
로 주로 사용된다. 메소드는 항상 set으로 시작한다. 간단히 수정자라고 불리기도 한
다. 수정자 메소드의 핵심기능은 파라미터로 전달된 값을 보통 내부의 인스턴스 변
수에 저장히는 것이다. 부가적으로 입력 값에 대한 검증이나 그 밖의 작업을 수행할
수도 있다. 수정자 메소드는 외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다
가 내부의 메소드에서 사용하게 하는 DI 방식에서 활용하기에 적당하다.
• 얼반 메소드훌 이용한 주입
수정자 메소드처럼 set으로 시작해야 하고 한 번에 한 개의 파라미터만 가질 수 있

다는 제약이 싫다면 여러 개의 파라미터를 갖는 일반 메소드를 DI용으로 사용할 수
도 있다. 생성자가 수정자 메소드보다 나은 점은 한 번에 여러 개의 파라미터를 받
을 수 있다는 점이다. 하지만 파라미터의 개수가 많아지고 비슷한 타입이 여러 개라
면 실수하기 쉽다. 임의의 초기화 메소드를 이용히는 DI는 적절한 개수의 파라미터
를 가진 여러 개의 초기화 메소드를 만들 수도 있기 때문에 한 번에 모든 필요한 파
라미터를 다 받。바 하는 생성자보다 낫다.

스프링은 전통적으로 메소드를 이용한 DI 방법 중에서 수정자 메소드를 가장 많이
사용해왔다. 뒤에서 보겠지만. DaoFactory 같은 자바 코드 대신 XML을 사용히는 경우
에는 자바빈 규의딸 따르는 수정자 메소드가 가장 사용하기 편리하다.

수정자 메소드 DI를 사용할 때는 메소드의 이름을 잘 결정하는 게 중요하다. 가능한
한 의미 있고 단순한 이름을 사용하자. 이름을 짓는 게 귀찮다면 메소드를 통해 DI 받
을 오브젝트의 타입 이름을 따르는 것이 가장 무난하다. 예를 들어 ConnectionMaker 인
터페이스 타입의 오브젝트를 DI 받는다면 메소드의 이름은 setConnectionMaker()
라고
히는 것이다. 특별한 이름을 지정해서 의미를 더 부여해줄 생각이 아니라면 이 관례를
따르도록한다.

UserDao도 수정자 메소드를 이용해 DI 하도록 만들어보자. 기존 생성자는 제거한
다. 생성자를 대신할 setConnectionMaker()
라는 메소드를 하나 추가하고 파라미터로
ConnectionMaker 타입의 오브젝트를 받도록 선언한다. 파라미터로 받은 오브젝트는 인
스턴스 변수에 저장해두도록 만든다. 대부분의 IDE는 수정자 메소드를 자동생성하는
기능이 있다. 인스턴스 변수만 정의해두고 자동생성 기능을 사용하면 펀리하다. 리스트
1-33은 수정자 메소드 DI를 적용한 UserDao다.

리스트 1-33 수정자 메소드 DI 방식을 사용한 U잃rD∞

public class UserDao (
private ConnectionMaker connectionMaker;

public void setConnectionMaker(ConnectionMaker connectionMaker) {
this.connectionMaker = connectionMaker;

니 수정자 머|소드 미의 전형적인 코드다 잘 기억해두자 setter 메소드는

보통 IDE의 지동생성 기능을 사용해서 만드는 것이 면리하다

UserDao를 수정자 메소드 DI 방식이 가능하도록 변경했으니 DI를 적용하는

1장-오브젝트와의존관계 127


DaoFactory
의 묘드도 함께 수정해줘야 한다. 리스트 1-34는 수정자 메소드 DI를 사용
해 UserDao 타입의 빈을 만드는 DaoFactory
의 userDao() 메소드다.

리스트 1-34 수정자 메소드 이률 사용하는 팩토리 메소드

@ßean

public UserDao userDao() {
UserDao userDao =new UserDao();
userDao.setConnectionMaker(connectionMaker());
return userDao;

단지 의존관계를 주입하는 시점과 방법이 달라졌을 뿐 결과는 동일하다.

UserDaoTest를 실행해서 개선한 코드의 기능에 문제가 없는지 확인해보자.

실제로 스프링은 생성자， 수정자 메소드， 초기화 메소드를 이용한 방법 외에도 다양

한 의존관계 주입 방법을 지원한다. 이에 대한 자세한 내용은 Vol.2에서 다룰 것이다.

1~을 이용한 설정 셀I

DaoFactory는 그 DI
의 동작원리를 잘 활용한 독립적인 오브젝트 팩토리 클래스로 시작

했지만.DI 컨테이너인 스프링을 도입하면서부터는 애노테이션을 추가해서 DI 작업에

참고하는 일종의 참고정보로 사용되고 었다. 본격적인 범용 DI 컨테이너를 사용하면서

오브젝트 사이의 의존정보는 일일이 자바 코드로 만들어주려면 번거롭다. DaoFactory

를자세히 살며보면 알수 있겠지만대부분툴에 박힌구조가반복된다. 또한
DI 구성이

바뀔 때마다 자바 묘드를 수정하고 클래스를 다시 컴따일히는 것도 귀찮은 작업이다.

스프링은 DaoFactory와 같은 자바 클래스를 이용하는 것 외에도， 다OJ=한 방법을 통

해 DI 의존관계 설정정보를 만들 수 있다. 가장 대표적인 것이 바로 XML이다.

XML은 단순한 텍스트 파일이기 때문에 다루기 쉽다. 또 쉽게 이해할 수 있으며 컴

파일과 같은 별도의 빌드 작업이 없다는 것도 장점이다. 환경이 달라져서 오브젝트의 관

계가 바뀌는 경우에도 빠르게 변경사항을 반영할 수 있다. 스키마나 DTD를 이용해서

정해진 포뱃을따라작성됐는지 손쉽게 확인할수도 있다.

이제 DaoFactory 자바 코드에 담겨 있던
.DI를 위한 오브젝트 의존관계 정보를

XML을 이용해 만들어보자.


1.8.1 XML 설정
스프링의 애플리케이션 컨텍스트는 XML에 담긴 DI 정보를 활용할 수 있다.
DI 정보
가 담긴 XML 파일은 <beans>를 루트 엘리먼트로 시용한다. 이름에서 알 수 있듯이
<beans> 안에는 여러 개의 <bean>을 정의할 수 있다. XML 설정은 @Configuration과
@Bean
이 붙은 자바 클래스로 만든 설정과 내용이 동일하다. @Configuration을
<beans>, @Bean을 <bean>
에 대응해서 생각하면 이해하기 쉬울 것이다.
하나의 @Bean 메소드를 통해 얻을 수 있는 빈의 DI 정보는 다음 세 가지다.

• 빈의 이름: @ßean 메소드 이름이 빈의 이름이다. 이 이름은 getBean()
에서 사용된다.
• 빈의 클래스. 빈 오브젝트를 어떤 클래스를 이용해서 만들지를 정의한다 .
• 빈의 의존 오브젝트: 빈의 생성자나 수정자 메소드를 통해 의존 오브젝트를 넣어준다. 의존
오브젝트도 하나의 빈이므로 이름이 있을 것이고， 그 이름에 해당하는 메소드를 호출해서
의존 오브젝트를 가져옹다. 의존 오브젝트는 하나 이상일 수도 있다.

XML에서 <bean>을 시용해도 이 세 가지 정보를 정의할 수 있다. ConnectionMaker
처럼 더 이상 의존하고 있는 오브젝트가 없는 경우에는 세 번째 의존 오브젝트 정보는

생략할 수 있다.XML은 자바 코드처럼 유연하게 정의될 수 있는 것이 아니므로， 핵심

요소를 잘 짚어서 그에 해당하는 태그와 애트리뷰트가 무엇인지 알。바 한다.

connectionMaker( ) 전환
먼저 DaoFactory의 connectionMaker() 메소드에 해당하는 빈을 XML로 정의해보자.
connectionMaker()
로 정의되는 빈은 의존하는 다른 오브젝트는 없으니 DI 정보 세 가
지 중 두 가지만 있으면 된다. 표 1-2에는 자바 코드로 만든 설정정보와 그에 대응되는
XML의 설정정보를 비교해뒀다.DI 정의 세 가지 중에서 빈의 이름과 빈 클래스(이름)
두 가지를 <bean> 태그의 id와 class 애트리뷰트를 이용해 정의할 수 있다.

표 1-2 클래스 설정과 XML 설정의 대응항목

| .퍼f 결듬첼흑=二E한펄칭로

빈설정따일 @Configuration (beans)

빈의이름 @Bean methodName() <bean id=깨ethodName"
빈의클래스 return new BeanClass( ); class='a.b.c ... BeanCI잃s")

DaoFactory
의 @Bean 메소드에 담긴 정보를 1:1로 XML의 태그와 애트리뷰트로 전
환해주기만 하면 된다. 단， <bean> 태그의 class 애트리뷰트에 지정하는 것은 자바 메

1장-오브젝트와 와존관계 129


소드에서 오브젝트를 만들 때 시용하는 클래스 이름이라는 점에 주의하자. 메소드의 리
턴 타입을 class 애트리뷰트에 사용하지 않도록 하자. XML에서는 라턴하는 타입을 지
정하지 않아도 된다. class 애트리뷰트에 넣을 클래스 이름은 패키지까지 모두 포함해
야 한다. IDE의 자바 에디터에서는 import 문을 직접 작성하지 않아도 묘드 내에서 클
래스 이름만 가지고 손쉽게 패키지 정보를 가져올 수 있는데，
XML에서는 이를 일일이
적어야 한다는 점이 처음에는 번거롭게 느껴질 것이다. 하지만 Vo1. 2에서 설명할 스프
링 지원 IDE를 시용하면 XML에서 클래스 이름을 작성할 때도 자동완성 기능을 활용
할수있으니 걱정할것은없다.

이제 connectionMaker() 메소드를 <bean) 태그로 전환해보자. @Bean은 <bean) 태그
로， 메소드 이름은 id 애트리뷰트로， new에 사용하는 클래스 이름은 class 애트리뷰트
로 대응해서 리스트 1-35와 같이 전환해주면 된다.

리스트 1-35 ∞nnect때lMaker{ ) 메소드의 (bean) 태그 전환

@8ean --------------------------------. (bean

public ConnectionMaker

connectionMaker() ( -------------------. id='connection뼈ker'
return new DConnectionMaker(); ----. class='springbook ...DConnectionMaker' />

XML 설정파일의 <bean) 태그를 보면 @Bean 메소드에서와 같은 작업이 일어나겠구
나라고 떠올릴 수 있으면 좋을 것이다.DI 컨테이너는 이 <bean) 태그의 정보를 읽어서
connectionMaker()
와 같은 작업을 진행한다.

userDao() 전환
이번에는 userDao 메소드를 XML로 변환해보자.
userDao()
에는 DI 정보의 세 가지 요소가 모두 들어 있다. 여기서 관심을 가질 것
은 수정자 메소드를 사용해 의존관계를 주입해주는 부분이다. 스프링 개발자가 수정
자 메소드를 선호하는 이유 중에는 XML로 의존관계 정보를 만들 때 편리하다는 점
도 있다. 자바빈의 관례를 따라서 수정자 메소드는 프로퍼티가 된다. 프로퍼티 이름
은 메소드 이름에서 set을 제외한 나머지 부분을 사용한다. 예를 들어 오브젝트에
setConnectionMaker()
라는 이름의 메소드가 있다면 connectionMaker라는 프로퍼티를
갖는다고할수있다.
XML
에서는 <property) 태그를 사용해 의존 오브젝트와의 관계를 정의한다.


<property> 태그는 name과 ref
라는 두 개의 애트리뷰트를 갖는다. name은 프로퍼티의
이름이다. 이 프로퍼티 이름으로 수정자 메소드를 알 수 있다. ref는 수정자 메소드를
통해 주입해줄 오브젝트의 빈 이름이다.
01 할 오브젝트도 역시 빈이다. 그 빈의 이름을
지정해주면 된다. @Bean 메소드에서라면 다음과 같이 다른 @Bean 메소드를 호출해서 주

입할 오브젝트를 가져온다.

userDao .setConnectionMaker(connectionMaker());

여기서 userDao.setConnectionMaker()
는 userDao 빈의 connectionMaker 프로
퍼티를 이용해 의존관계 정보를 주입한다는 돗이다. 메소드의 파라미터로 넣는
connectionMaker()
는 connectionMaker() 메소드를 호출해서 리턴하는 오브젝트를 주
입하라는 의미다. 이 두 가지 정보를 <property>의 name 애트리뷰트와 ref 애트리뷰트
로 지정해주면 된다. 각 정보를 <property> 태그에 대응하면 다음과 같이 전환이 가능
하다.

userDao.setConnectionMaker(connectionMaker());

-,---------r--------------------,-


~'l l
(property name="connectionMaker" ref="connectionMaker" />

마지막으로 이 <property> 태그를 userDao 빈을 정의한 <bean> 태그 안에 넣어주변
된다. 리스트 1-36은 이렇게 완성된 userDao 빈을 위한 XML 정보다.

리스트 1-36 userDao 빈 설정

(bean id="userDao" class=‘ springbook .dao .UserDao">

(property name='connectionMaker" ref="connectionMaker'’ />
(/bean>

XML의 의존관계 주입 정보
이렇게 해서 두 개의 <bean> 태그를 이용해 @Bean 메소드를 모두 XML로 변환했다. 리
스트 1-37과 같이 <beans>로 전환한 두 개의 <bean> 태그를 감씨주면 DaoFactory로부
터 XML로의 전환 작업이 꿀난다.

리스트 1-37 완성된 XML 설정정보

(beans>
(bean id="connectionMaker" 이
ass="springbook.user.dao
.
DConnectionMaker
“ />

1장-오브젝트와의존관계 131


<bean id="띠
C
spnn1
gboo
’

userDao
’”’ 이lass="닝
매밍
이’k.lμuser.dao.UserDaoψ"
<properπty name="connectionMaker'’ ref="connectionMaker" />
</bean>
</beans>

(property> 태그의 name과 ref는 그 의미가 다르므로 이름이 같더라도 어떤 차이가
있는지 구별할 수 있어야 한다. name 애트리뷰트는 DI에 사용할 수정자 메소드의 프로
퍼티 이름이며. ref 애트리뷰트는주입할오브젝트를 정의한 빈의 ID다. 보통프로퍼티
이름과 DI 되는 빈의 이름이 같은 경우가 많다. 프로퍼티 이름은 주입할 빈 오브젝트의
인터페이스를 따르는 경우가 많고 빈 이름도 역시 인터페이스 이름을 시용하는 경우가
많기 때문이다. 바뀔 수 있는 클래스 이름보다는 대표적인 인터페이스 이름을 따르는
편이자연스럽다.

하지만 프로퍼티 이름이나 빈의 이름은 인터페이스 이름과 다르게 정해도 상관없
다. 의미를 좀 더 잘 드러낼 수 있는 이름이 있다거나， 같은 이름이 중복되는 상황이라
면 적절한 다른 이름을 부여해주자. 빈의 이름을 바꾸는 경우 그 이름을 참조히는 다른
빈의 (property> ref 애트리뷰트의 값도 함께 변경해줘야 한다.

만약 connectionMaker 빈을 myConnectionMaker라는 이름으로 변경했다면 리스트
1-38과 같이 userDao 빈의 connectionMaker 프로퍼티 ref 값도 따라서 변경해줘야 한
다. connectionMaker 빈을 DI 하는 DAO가 여러 개라면 모두 변경해야 한다. 이런 경
우에 자바 코드로 된 설정이라면 IDE의 이름변경
rename 리팩토링 기능을 사용하면 간
단하다. 하지만 XML은 텍스트 파일을 수정하는 것이므로 텍스트 치활ext re이ace 기능
을 사용해야 하는데， 잘못하면 영똥한 것까지 수정할 수 있으니 조심해야 한다. 가능하
면 처음부터 이름을 잘 정하고 수정하지 않는 편이 좋다. 개발팀 내에서 공통적으로 따
를 수 있는 명명
nammg 규칙을 처음부터 잘 준비해두자.

리스트 1-38 빈의 이륨과 참조 ref의 변경

<beans>
<bean id="myConnectionMaker" class=갱
pringbook
. user.dao .DConnectionMaker" />

<bean id="userDao" class="springbook.user.dao.UserDao"
(property name="connectionMaker" ref="myConnectionMaker" /> ‘--_.
</bean>
</beans>


때로는 같은 인터페이스를 구현한 의존 오브젝트를 여러 개 정의해두고 그중에서 원
히는 걸 골라서 DI 히는 경우도 있다. 이때는 각 빈의 이름을 독립적으로 만들어두고
ref 애트리뷰트를 이용해 DI 받을 빈을 지정해주면 된다. 리스트 1-39는 Loca
lD
B와
TestDB, ProductionDB를 시용하는 ConnectionMaker 인터페이스 구현 클래스를 각각

정의해두고 DAO
에
서 하니를 선택해서 사용할 수 있도록 구성한 XML 설정이다. 이때

는 같은 인터페이스를 구현한 빈이 여러 개이므로 빈의 이름을 의미 있게 구분해서 정
해줄필요가있다.

리스트 1-39 같은 인터페이스 타입의 빈올 여러 개 정의한 경우

<beans>
<bean id=’'localDBConnectionMaker" class=‘ ...LocalDBConnectionMaker. />
<bean id=‘ testDBConnectionMaker. class=•...TestDBConnectionMaker. />
<bean id=.productionDBConnectionMaker. class=‘ ...ProductionDBConnectionMaker. />

<bean id=’ userDao" class=닝pringbook
.
u
ser.d
ao
.
UserDao"
>
<property name="connectionMaker'’ ref=.localDBConnectionMaker. />
</bean>
</beans>

개발용 PC에서는 리스트 1
-3
9와 같이 설정된 XML을 사용하고， 태스트 장비나 운
영서벼에서는 userDao 빈의 ref 값을 다르게 지정한 XML 파일을 두고 시용하면 된다.

홈
DTD와스키마
XML 문서는 미리 정해진 구조톨 따라서 작성됐는지 검사할 수 있다.
XML 문서의 구조톨 정의
하는 방법에는 010와 스키매엉"leIT녕)가 있다. 스프링의 XML 설정파일은 이 두 가지 방식율
모두지원흔봐.

OTD톨 사용힐 경우에는 〈∞ans)
웰리먼트 앞에 다옵과 길은 010 선언율 넣어준다.

<!DOCTYPE beans PUBLIC .-//SPRING//DTD BEAN 2.0//EN.

"http://www.springfr해nework.org/dtd/spring-beans-2.0.dtd">

스프링온 마톨 위한 기본 태그인 〈않ans)， (∞an) 외에도 륙별한 목적옳 위해 벌도의 태그톨
시용힐 수 있는 방법율 저|공흔빠. 이 태그률온 각각 벌개의 스키마 파월에 정의되어 있고 독립
적인 네임스떼이스톨 사용해야만 한다. 따라서 이런 태그를 사용하려면 010 대신 네임스때이
스가 지원되는 스키마톨 사용해야 효빠. (야*3ns) 태그톨 기본 네임스떼이스로 하는 스키마 선
언온다옴과곁다.

1장-오브잭트와 의존관계 133


<beans xmlns="http://www.springframework.org/sch에la/beans"

xmlns:xsi="http://빼w
.
w3
.
org/2
Ð0
1/XMLSchema-instance"

xsi:sche뻐Location=
"http://빼w.springfr빼lework. org/sch댄녕
/beans

http://www.springframework.org/sch댄녕
/beans/spring→>eans-3.0.xsd")

톨벌한 이유가 없다면 DTD보다는 스키n빠 사용하는 편이 바람직하다. 선언이 좀 더 길어서
입력하기 힘툴게 보일지 모르겠지만 VoI.1에서 설명힐 스프링 IDE의 XML 에디터톨 사용하면
스키마 선언율 죠맨f히 만툴고 관리힐 수 있으니 걱정힐 것은 없다.

1.8.2 XML을 이용하는 애플리케이션 컨텍스트
이제 애플리케이션 컨텍스트가 DaoFactory 대신 XML 설정정보를 활용하도
록 만들어보자. XML
에서 빈의 의존관계 정보를 이용하는 [oC/DI 작업에는
GenericXmlApplicationContext를 사용한다. GenericXmlApplicationContext
의 생성
자 파라미터로 XML 파일의 클래스패스를 지정해주면 된다
XML 설정파일은 클래스
패스 최상단에 두면 편하다.

애플리케이션 컨텍스트가 사용하는 XML 설정파일의 이름은 관례를 따라

applicationContext. xml이라고 만든다. DaoFactory의 DI 정보를 전환해서 만든，

<beans>로 시작히는 XML에 스프링 스커마까지 적용해서 리스트 1-40과 같이 만들어

applicationContext.xml로 저장해둔다.

리스트 1-40XML 설정정보를 담은 applicationContext.xml

(?xml version=‘ 1.0" enc때
ing=
"
UTF-8
‘
7)

(beans xmlns="http://www.springframework .org/schema/beans "
xmlns :xsi='http://www.w3.org/2Ð01/XMLSchema-instance'
xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-3.0.xsd")
(bean id="connectionMaker" class=닝pringbook
.
user
.
dao.DConnectionMaker" /)

(bean id='userDao ’, class="springbook.user.dao.UserDao')
(property name="connectionMaker' ref='connectionMaker'’ /)
(/bean)
(/beans)

다음은 UserDaoTest
의 애플리케이션 컨텍스트 생성 부분을 수정한다. DaoFactory
를 설정정보로 사용했을 때 썼던 AnnotationConfigApplicationContext 대신


GenericXmlApplicationContext를 이용해 다음과 같이 애플리케이션 컨텍스트를 생성
하게 만든다. 생성자에는 applicationContext. xml
의 클래스패스를 넣는다. 클래스패스
를 시작히는 /는 넣을 수도 있고 생략할 수도 있다. 시작히는 /가 없는 경우에도 항상
루트에서부터 시작하는 클래스패스라는 점을 기억해두자.

ApplicationContext context = new GenericXmlApplicationContext(
"applicationContext.xml");

이제 UserDaoTest를 실행해서 동일한 결과가 나오는지 확인해보자. 성공한다면 이
제 XML 설정따일을 시용하도록 변환하는 작업을 모두 마친 것이다.
GenericXmlApplicationContext 외에도 ClassPathXmlApplicationContext
를 이용해 XML
로부터 설정정보를 가져오는 애플리케이션 컨텍스트를 만

들 수 있다. GenericXmlApplicationContext
는 클래스패스뿐 아니라 다양
한 소스로부터 설정파일을 읽어올 수 있다. ClassPathXmlApplicationContext
는 XML 파일을 클래스패스에서 가져올 때 사용할 수 있는 편리한 기능이 추
가된 것이다. ClassPathXmlApplicationContext
의 기능 중에는 클래스패스
의 경로정보를 클래스에서 가져오게 하는 것이 있다. 예를 들어 springbook.
user.dao 패키지 안에 daoContext
.
xml
이라는 설정따일을 만틀었다고 해보자.
GenericXmlApplicationContext가 이 XML 설정파일을 사용하게 하려면 클래스패스
루트로부터 파일의 위치를 지정해야 하므로 다음과 같이 작성해야 한다. 패키지가 길어

지면 클래스패스를 모두 적기가 귀찮을 수도 있다.

new GenericXmlApplicationContext("springbook/user/dao/daoContext.xml");

반면에 ClassPathXmlApplicationContext는 XML 파일과 같은 클래스패스에 있
는 클래스 오브젝트를 넘겨서 클래스패스에 대한 힌트를 제공할 수 있다. UserDao는
springbook .user.dao 패키지에 있으므로 daoContext.xml과 같은 클래스패스 위에 있
다. 이 UserDao를 함께 넣어주면 XML 파일의 위치를 UserDao의 위치로부터 상대적으
로지정할수있다.

new ClassPathXmlApplicationContext("daoContext.xml “, UserDao.class );

이 방법으로 클래스패스를 지정해야 할 경우가 아니라면

GenericXmlApplicationContext를 사용히는 편이 무난하다.

1장-오브젝트와 의존관계 135


1.8.3 DataSource 인터페이스로 변환
DataSource 인터페이스 적용
ConnectionMaker는 DB 커넥션을 생성해주는 기능 하나만을 정의한 매우 단순한 인터
페이스다.IoC와 DI의 개녕을 설명하기 위해 직접 이 인터페이스를 정의하고 사용했지
만， 사실 자바에서는 DB 커넥션을 가져오는 오브젝트의 기능을 추상화해서 비슷한 용
도로 사용할 수 있게 만들어진 DataSource라는 인터페이스가 이미 존재한다. 따라서 실
전에서 ConnectionMaker와 같은 인터페이스를 만들어서 λF용할 일은 없을 것이다. 단，
DataSource는 getConnection( )이라는 DB 커넥션을 가져오는 기능 외에도 여러 개의
메소드를 갖고 있어서 인터페이스를 직접 구현하기는 부담스럽다.
일반적으로 DataSource를 구현해서 DB 커넥션을 제공하는 클래스를 만들 일은 거
의 없다. 이미 다OJ=한 방법으로 DB 연결과 풀링
pooling 기능을 갖춘 많은 DataSource 구
현 클래스가 존재하고， 이를 가져다 사용하면 충분하기 때문이다. 대부분의 DataSource
구현 클래스는 DB
의 종류나 아이디， 비밀번호 정도는 DataSource 구현 클래스를 다시
만들지 않고도 지정할 수 있는 방법을 제공한다.
리스트 1-41
의 DataSource 인터페이스에서 실제로 관심을 가질 것은
getConnection() 메소드 하나뿐이다. 이름만 다르지 ConnectionMaker 인터페이
스의 makeConnection()
과 목적이 통일한 메소드다. DAO
에서는 DataSource
의
getConnection ( ) 메소드를 시용해 DB 커넥션을 가져오면 된다.

리스트 1
-41Da떠없Jr，∞ 인터페이스

package javax.sql

public interface DataSource extends CommonDataSource ,Wrapper (
Connection getConnection() throws SQLException;

DataSource 인터페이스와 다양한 DataSource 구현 클래스를 사용할 수 있도록
UserDao를 리팩토링해보자.

일단 UserDao
에 주입될 의존 오브젝트의 타입을 ConnectionMaker
에서
DataSource로 변경한다. 그리고 DB 커넥션을 가져오는 코드를 makeConnection()
에서 getConnection( ) 메소드로 바꿔준다. 리스트 1-42는 이렇게 수정된 UserDao


클래
스다. DataSource
의 getConnection()
은 SQLException
만 던지기 때문에
makeConnection() 메소드의 throws
에 선언했던 ClassNotFoundException은 제거해도
된다.

리스트 1-42 Da떠없Jr，

α훌 사용하는 UserD∞

import iavax.sQl.DataSource;

public class UserDao (
private DataSource dataSource;

public void setDataSource(DataSource dataSource) (
this.dataSource =dataSource;

public void add(User user) throws SQLException (
Connection c = dataSource.getConnection();

디음은 DataSource 구현 클래스가 필요하다. 앞에서 만들었던 DriverManager를 사
용하는 SimpleConnectionMaker처럼 단순한 DataSource 구현 클래스를 하나 가져다 사
용하자. 스프링이 제공해주는 DataSource 구현 클래스 중에 테스트환경에서 간단히 사
용할 수 있는 SimpleDriverDataSource라는 것이 있다. 이 클래스를 사용하도록 DI를
재구성할것이다.

SimpleDriverDataSource는 DB 연결에 필요한 필수 정보를 제공받을 수 있도록 여
러 개의 수정자 메소드를 갖고 있다. 예를 들어 JDBC 드라이버 클래스，
JDBC URL,
아이디， 비밀번호등이다.

".후가휠랴이브러리
org.Sαi때framewα1<.
j따?-3.0
.7.RELE영Ejar

1장-오브젝트와 의존관계 137


자바코드설정방식
먼저 DaoFactory 설정 방식을 이용해보자. 기존의 connectionMaker() 메소드를
dataSource()로 변경하고 SimpleDriverDataSource의 오브젝트를 리턴하게 한다. 이
오브젝트를 넘기기 전에 DB 연결과 관련된 정보를 수정자 메소드를 이용해 지정해줘
야 한다. 리스트 1-43은 SimpleDriverDataSource를 시용하도록 만든 DataFactory의
dataSource() 메소드다.

리스트 1-43 Data없Jrl∞ 타입의 없떠Sou
r∞ 빈 정의 메소드

@ßean
public DataSource dataSource() (
SimpleDriverDataSource dataSource =new SimpleDriverDataSource();

dataSource .setDriverClass(com.mysql.jdbc .Driver .class);
dataSource .setUr 1 (" jdbc :mysql : / /localhost/springbook");
dataSource .setUsername("spring");
dataSource.setPassword( “book ");

return dataSource; DB 연결정보훌 수정자 메소드훌 흉해 넣
어준다 이렇게 하연 오브젝트 레옐에서
DB 연결 방식올 변경할 수 있다

DaoFactory
의 userDao() 메소드를 리스트 1-44와 같이 수정한다. UserDao는 이제
DataSource 타입의 dataSource( )를 DI 받는다.

리스트 1-44 Data없Jr∞ 타입의 빈율 미 받는 USerO뼈 ) 빈 정의 메소드

@ßean

public UserDao userDao() (
UserDao userDao = new UserDao();
userDao.setDataSource(dataSource());
return userDao;

이렇게 해서 UserDao
에 DataSource 인터페이스를 적용하고
SimpleDriverDataSource의 오브젝트를 DI로 주입해서 시용할 수 있는 준비가 끝났다.
UserDaoTest를 DaoFactory를 시용하도록 수정하고 태스트를 실행해보자.


XML
설정방식
이번에는 XML 설정 방식으로 변경해보자.
먼저 id가 connectionMaker인 <bean)을 없애고 dataSource라는 이름의 <bean)을
등록한다. 그리고 클래스를 SimpleDriverDataSource로 변경해주변 리스트 1-45와 같
은
<bean) 설정이 만들어진다.

리스트 1-45 dataSource 빈

<bean id=닝ataSource"

class="org.springframework.jdbc.datasource.SimpleDriverDataSource" /)

그런데 문제는 이 <bean) 설정으로 SimpleDriverDataSource
의 오브젝트를 만드는
것까지는 가능하지만， dataSource() 메소드에서 SimpleDriverDataSource 오브젝트
의 수정자로 넣어준 DB 접속정보는 나타나 있지 않다는 점이다. UserDao처럼 다른 빈
에 의존하는 경우에는 <property) 태그와 ref 애트리뷰트로 의존할 빈 이름을 넣어주
면 된다. 하지만 SimpleDriverDataSource 오브젝트의 경우는 단순 Cl ass 타입의 오브
젝트나 텍스트 값이다. 그렇다면 XML에서는 어떻게 해서 dataSource() 메소드에서처
럼 DB 연결정보를 넣도록 설정을 만들 수 있을까?

1.8.4 프로퍼티 값의 주입
:7~ ^ol

IU. .，-닙

이미 DaoFactory
의 dataSource() 메소드에서 본 것처럼， 수정자 메소드에는 다른 빈이
나 오브젝트뿐 아니라 스트링 같은 단순 값을 넣어줄 수도 있다. setDriverClass() 메
소드의 경우에는 Cl ass 타입의 오브젝트이긴 하지만 다른 빈 오브젝트를 DI 방식으로
가져와서 넣는 것은 아니다.

이렇게 다른 빈 오브젝트의 레퍼런스가 아닌 단순 정보도 오브젝트를 초기화하는 과
정에서 수정자 메소드에 넣을 수 있다. 이때는 m
에서처럼 오브젝트의 구현 클래스를
다이내믹하게 바꿀 수 있게 해주는 것이 목적은 아니다. 대신 클래스 외부에서 DB 연
결정보와 같이 변경 가능한 정보를 설정해줄 수 있도록 만들기 위해서다. 예를 들어 DB
접속 아이디가 바뀌었더라도 클래스 코드는 수정해줄 펼요가 없게 해주는 것이다
.

1장-오브젝트와 의존관계 139


텍스트나 단순 오브젝트 등을 수정자 메소드에 넣어주는 것을 스프링에서는 ‘값을 주
입한다고 말한다. 이것도 성격은 다르지만 일종의 DI라고 볼 수 있다. 사용할 오브젝트
자체를 바꾸지는 않지만 오브젝트의 특성은 외부에서 변경할 수 있기 때문이다.

스프링의 빈으로 등록될 클래스에 수정자 메소드가 정의되어 있다면 <property)를
사용해 주입할 정보를 지정할 수 있다는 점에서는 <property ref=" ")와 동일하다. 하
지만 다른 빈 오브젝트의 레퍼런스(ref
)가 아니라 단순 값(value
)을 주입해주는 것이기 때
문에 ref 애트리뷰트 대신 value 애트리뷰트를 사용한다.

따라서 dataSource() 메소드에서 다음과 같이 수정자 메소드를 호출해서 DB 연결
정보를 넣었던 리스트 1-46은 리스트 1-47과 같이 XML로 전환할 수 있다.

리스트 1--46 코드톨 륭한 DB 연결정보 주입

dataSource .setDriverClass(com.mysql . jdbc .Driver .class);
dataSource .setUrl( ‘ jdbc:mysql://localhost/springbook'’ );
dataSource.setUsername( 'spring');
dataSo urce.setPassword("book");

리스트 1
-47XML올 이용한 DB 연킬정보 설정

<property name="driverClass" value=’'com .mysql. jdbc .Driver" />
<property name="url" value='jdbc:mysql://localhost/springbook" />
<property name=‘ username" value="spring" />
<property name='password" value="book" />

ref 대신에 value를 시용했을 뿐이지 기존의 <property) 태그를 사용했던 것과 내용
과 방법은 동일하다. value 애트리뷰트에 들어기는 것은 다른 빈의 이름이 아니라 실제
로 수정자 메소드의 파라미터로 전달되는 스트링 그 자체다.

value 값의 자동 변환
그런데 한 가지 이상한 점이 있다. url , username , password는 모두 스트링 타입이니
원래 텍스트로 정의되는 value 애트리뷰트의 값을 시용하는 것은 문제없다. 그런데
driverCl
ass는 스트링 타입이 아니라 j ava . lang. Class 타입이다. DaoFactory
에 적용
한 예를 보면 Driver.class
라는 Class 타입 오브젝트를 전달한다. 그런데 XML에서는
별다른 타입정보 없이 클래스의 이름이 텍스트 형태로 value에 들어가 있다.


그렇다면 어떻게 이 “ com.mysql. jdbc.
Driver"
라는 스트링 값이 Class 타입의 파라
미터를 갖는 수정자 메소드에 사용될 수 있는 것일까? 스트링 값을 Class 타입 변수에
넣을 수는 없다. 다음과 같은 코드는 컴파일조차 안 될 것이 분명하다.

Cl ass driverCl ass = "com.mysq l. jdbc. Driver";

그런데 리스트 1-47과 같이 해두고 태스트를 실행하면 아무런 문제 없이 성공적으

로끝날것이다.

이런 설정이 기능한 이유는 스프링이 프로퍼티의 값을 수정자 메소드의 따라미터
타입을 참고로 해서 적절한 형태로 변환해주기 때문이다. setDriverClass() 메소드의
파라미터 타입이 Cl
ass
임을확인하고 "com.mysql.jdbc.Driver"
라는 텍스트 값을
com.
mysql.jdbc.Driver.class 오브젝트로 자동 변경해주는 것이다. 내부적으로 디음과 같
이 변환작업이 일어난다고생각하면된다.

Cl ass driverClass = Class .forName("com.mysq l. jdbc. Driver");

dataSource.setDriverC1ass(driverC1ass);

스프링은 value에 지정한 텍스트 값을 적절한 자바 타입으로 변환해준다. Integer,
Double, String, Boolean 같은 기본 타입은 물론이고 Cl ass , URL , File, Charset 같은
오브젝트로 변환할 수도 있다. 또한 값이 여러 개라면 List , Map , Set, PropertiesY. 배
열 타입으로도 값의 주입이 가능하다. Vol. 2에서 값 주입에 대한 내용을 좀 더 자세히
다룰것이다.

이렇게 해서 DataSource 인터페이스로의 전환작업을모두마쳤다. 최종적으로 리스
트 1-48과 같은 XML 설정파일이 만들어진다.

리스트 1-48 Da녀없Jr<∞률 적용 완료한 ap미i∞t때lContext.xml

<?xm1 version='’1.0" encoding="UTF-8“7>
<beans xm1ns=''http://www.springframework .org/schema/beans''
xm1ns:xsi=''http://www.w3.org/2001/XMLSchema-instance“

xsi:schemaLocation=애
ttp://www.springframework.org/schema/beans

http://www.springframework .org/schema/beans/spring-beans-3.0.xsd">

<bean id="dataSource"
class=’'org.springframework . jdbc.datasource.Simp1eDriverDataSource">
<property name="driverCl ass" va1ue="com.mysq l. jdbc. Driver" />
<property name="ur1" va1ue=" jdbc :mysq1 : / !loca1host/springbook“ />
<property name=“username'’ va1ue=닝
pring
“ />

1장-오브젝트와의존관계 141


<property name=‘ password" value="book" /)
</bean)

<bean id="userDao" class=낭
pringbook.user.dao
.
UserDao"
)
<property name="dataSource" ref="dataSource" /)
</bean)
</beans)

XML을 이용하는 애플리케이션 컨텍스트를 만들어 사용하도록 UserDaoTest를 수정
하고실행해보자. 이전과다를바없는동일한결과를볼수있을것이다.
이제 UserDao는 XML 설정파일을 사용해 스프링 컨테이너 위에서 동작하는 좀 더
깔끔한 코드로 변신했다.

1I!J 정리

l
장에서는 사용자 정보를 DB
에 등록하거나 아이디로 조회하는 기능을 가진 간단한

DAO 코드를 만들고， 그 코드의 문제점을 살펴본 뒤， 이를 다양한 방법과 패턴， 원칙，

IoC/DI 프레임워크까지 적용해서 개선해왔다.

그과정을돌아보자.

• 먼저 책임이 다른 코드를 분리해서 두 개의 클래스로 만들었다〈관심사의 분리， 리왜토령).
• 그중에서 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하도록 하고， 다른 클래스에서 인
터페이스를 통해서만 접근하도록 만들었다. 이렇게 해서 인터페이스를 정의한 쪽의 구현 방
법이 달라져 클래스가 바뀌더라도 그 기능을 사용히는 클래스의 코드는 같이 수정할 펼요
가 없도록 만들었다{전략 꽤턴)
.
• 이를 통해 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막
아주고， 자신이 사용히는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경할 수 있게 만
들었다(개방 패쇄 원칙).
• 결국 한쪽의 기능 변화가 다른 쪽의 변경을 요구하지 않아도 되게 했고(낮은 결합되， 자신의
책임과 관심사에만 순수하게 집중하는(높은옹집되 깔담한 코드를 만들 수 있었다.
• 오브젝트가 생성되고 여타 오브젝트와 관계를 맺는 작업의 제어권을 별도의 오브젝트 왜토
리를 만들어 넘겼다. 또는 오브젝트 팩토리의 기능을 일반화한 IoC 컨테이너로 넘겨서 오브
젝트가 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만들어췄다(제
어의 역전/loC
)
.

• 전통적인 싱글톤 패턴 구현 방식의 단점을 살펴보고， 서버에서 사용되는 서비스 오브젝트
로서의 장점을 살릴 수 있는 싱글톤을 사용하면서도 싱글톤 패턴의 단점을 극복할 수 있도
록 설계된 컨테이너를 활용하는 방법에 대해 알아봤다(싱글톤 레지스트리)
.
• 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어놓고， 런타임
시에 실제 사용할 구체적인 의존 오브젝트를 제3자~D1 컨테이너)의 도움으로 주입받아서 다이
내믹한 의존관계를 갖게 해주는 IoC의 특별한 케이스를 알아봤다(의존관져| 주입
/0
1).
• 의존 오브젝트를 주입할 때 생성자를 이용하는 방법과 수정자 메소드를 이용하는 방법을 알
이봤다(생성자 주입과 수정자 주입).
• 마지막으로， XML을 이용해 DI 설정정보를 만드는 방법과 의존 오브젝트가 아닌 일반 값
을 외부에서 설정해서 런타임 시에 주입핸 방법을 알아봤다(XML 설정)
.
I
장을 끝내기 전에， 스프링이란 ‘어떻게 오므젝트가 설계되고， 만들어지고， 어떻게
관계를 맺고 사용되는지에 관심을 갖는 프레임워크’라는 사실을 목 기억해두자. 스프링
의 관심은 오브젝트와 그 관계다. 하지만 오브젝트를 어떻게 설계하고， 분리하고， 개선
하고， 어떤 의존관계를 가질지 결정하는 일은 스프링
01 아니라 개발자의 역할이며 책임
이다. 스프링은 단지 원칙을 잘 따르는 설계를 적용하려고 할 때 필연적으로 등장하는
번거로운 작업을 편하게 할 수 있도록 도와주는 도구일 뿐임을 잊지 말자.

스프링을 사용한다고 좋은 객체지향 설계와 깔끔하고 유연한 코드가 저절로 만들어
질까? 그건 절대 아니다. 그 부분은 객체지향 설계와 프로그래밍에 대한 흐L습과 훈련，
경험이 필요한 부분이며 각자가 공부해야 할 책임이 있는 과제다. 다만， 스프링은 그런
좋은 설계와 코드를 적용하Jl자 할 때 좋은 동반자가 돼줄 것이다.

1장-오브젝트와의존관계 143


까、 프링이 개발자에게 제공하는 가장 중요한 가치가 무엇이냐고 질문한다면 나는
-주저하지 않고 객체지향과 태스트라고 대답할 것이다. 스프링의 핵심인 IoC와
DI는 오브젝트의 설계와 생성， 관계， 시용에 관한 기술이다. 스프링은 IoC/DI를 이용
해 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있
게 도외주는 기술이다. 동시에 스프링은 복잡한 엔터프라이즈 애플리케이션을 효과적
으로 개벌하기 위한 기술이기도 하다. 이러한 복잡한 애플리케이션을 개발하는 데 필요
한 도구 하나는 객체지향 기술이다. 그리고 다른 하나의 도구로 스프링이 강조하고 가
치를 두고 있는 것이 바로 태스트다.

애플리케이션은 계속 변하고 복잡해져 간다. 그 변화에 대응하는 첫 번째 전략이 확
장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같
은 기술이라면， 두 번째 전략은 만들어진 코드를 확신할 수 있게 해주고， 변화에 유연하
게 대처할 수 있는 자신감을 주는 태스트 기술이다.

스프령으로 개발을 하면서 태스트를 만들지 않는다면 이는 스프링이 지닌 가치의 절반
을 포기하는 셈이다. 스프링 개발자라면 테스트 작성 방법과 이를 효과적으로 개발에 활
용하는 전략을 알아야 하며， 이를 실전에 적용할 수 있어야 한다.

또한 태스트는 스프링을 학습하는 데 있어 가장 효과적인 방법의 하나다. 태스트의
작성은 스프링의 다OJ=한 기술을 활용하는 방법을 이해하고 검증하고， 실전에 적용하는
방법을 익히는 데 효과적으로 사용될 수 있다. 이 책의 나머지 부분은 이 태스트를 이용
한 학습 방법을 활용해서 스프링을 설명하고 있다.

2장에서는 태스트란 무엇이며 그 가치와 장점 활용 전략 스프링과의 관계를 살펴
본다. 그리고 이 책에서 활용할 대표적인 테스트 프레임워크를 소개하고， 이를 이용한
학습 전략도 알아볼 것이다.

2징-터ι트 145


[ 2.1 UserDaoTest 다시 보기 I펠I
2.1.1 테스트의 유용성
l
징에서 만든
UserDao가기대했던 대로동작하는지 확인하기 위해 간단한테스트묘드
를 만들었다. 만든 코드는 어떤 방법으로든 태스트해야 한다. “HelloWorld'’를 출력하는
프로그램이 아닌 이상， 묘드만 만들어놓고 잘 돌아가겠거니 하고 무책임하게 개발을 마
치려는 개발자는 。바도 없을 것이다.
이전에 만들었던 테스트묘드는
main() 메소드를 이용해 UserDao 오브젝트의 add() ,
get( ) 메소드를 호출하고， 그 결괴를 화면에 출력해서 그 값을 눈으로 확인시켜준다.
이렇게 만든 태스트용 main() 메소드를 반복적으로 실행해가면서 처음 설계한 대로
기능이 동작하는지를 매 단계 확인한 덕분에， 다양한 방법으로 초난감 UserDao 묘드의
설계와 코드를 개선했고， 심지어 스프링을 적용해서 동작하게 만들 수도 있었다. 코드
의 구조와 설계， 적용한 기술이 변경되더라도 그 기능은 처음 만들었던 초난감 UserDao
와 다를 바 없이 DB
에 사용자 정보를 등록하고， 가져오는 기능을 잘 수행한다는 걸 태
스트를 통해 확인할 수 없었다면， 그 코드를 개선하는 과정 내내 뭔가 꺼림칙하고 불안
했을 것이다. UserDao의 클래스를 책임에 따라 이리저리 분리하고， 인터페이스를 도입
하고， 오브젝트 팩토리를 통해 생성하도록 만들고， 또 스프링의 DI 방식을 XML 설정
파일까지 써서 적용했을 때 그것이 처음과 동일한 기능을 수행함을 보장해줄 수 있는
방법에는 어떤 것이 있겠는가? 태스트를 통해 직접 기능을 동작시켜서 결괴를 확인하
는 방법 외에는 없다. 코드를 들여다보며 머릿속으로 시율레이션히는 방법이 있긴 하지
만 그것만으로는 100% 확신할 수 없다.
태스트란 결국 내가 예쟁}고 의도했던 대로 코드가 정확히 동작하는지를 확인해서，
만든 코드를 확신할 수 있게 해주는 작업이다. 또한 태스트의 결과가 원하는 대로 나오
지 않는 경우에는 코드나 설계에 결함이 있음을 알 수 있다. 이를 통해 묘드의 결함을
제거해가는 작업， 일명 디버깅을 거치게 되고， 결국 최종적으로 테스트가 성공하면 모
든 결함이 제거됐다는 확신을 얻을 수 있다.

2.1.2 UserDaoTest의 특징
리스트 2-1
은 l
징F에서 만들었던 main() 메소드로 작성된 태스트 코드다. 이 태스트 코
드를 다시 한변 살펴보자.


리스트 2-1 main() 메소드로 작성된 테스트

public class UserDaoTest (
public static void main(String[] args) throws SQLException (
ApplicationContext context =new GenericXmlApplicationContext(
피pplicationContext.xml");

UserDao dao =context .getBean("userDao" , UserDao.class);

User user = new User();
user.setld("user");

user.setName("
백기선");

user.setPassword(
깨arried");

dao .add(user);

System.out .println(user.getId() + " 등록 성공“);

User user2 = dao .get(user.getld());
System .out .println(user2 .getName());
System .out.println(user2 .getPassword());

System.out .println(user2 .getld() + " 조회 성공");


이 태스트묘드의 내용을정리해보면다음과같다.

• 자바에서 가장 손쉽게 실행 가능한 main() 메소드를 이용한다.
• 태스트할 대상인 UserDao의 오브젝트를 가져와 메소드를 호출한다.
• 테스트에 사용할 입력 값(User 오브젝트)을 직접 코드에서 만들어 넣어준다.
• 테스트의 결과를 콘솔에 출력해준다.
• 각 단계의 작업이 에러 없이 끝나면 콘솔에 성공 메시지로 출력해준다.
이 태스트 방법에서 가장 돋보이는 건， main() 메소드를 이용해 쉽게 테스트 수행을
가능하게 했다는 점과 테스트할 대상인 UserDao를 직접 호출해서 시용한다는 점이다.

2장-테스트 147


웹을 통한 DAO 테스트 방법의 문제점
보통 웹 프로그램에서 사용하는 DAO를 태스트하는 방법은 다음과 같다. DAO를 만
든 뒤 바로 태스트하지 않고， 서비스 계층， MVC 프레젠테이션 계충까지 포함한 모든
입출력 기능을 대충이라도 코드로 다 만든다. 이렇게 만들어진 테스트용 웹 애플리케
이션을 서버에 배치한 뒤， 웹 화면을 띄워 폼을 열고， 값을 입력한 뒤 버튼을 눌러 등록
해본다. 이를 위해서는 폼의 값을 받아서 따싱한 뒤에 User 오브젝트로 만들고 UserDao
를 호출해주는 기능이 이미 만들어져 있어야 한다. 여기까지 해서 에러가 없으면 이번
엔 검색 폼이나 파라미터를 지정할 수 있는 URL을 사용해서 방금 입력한 데이터를 다
시 가져올 수 있는지 테스트해본다. 역시 UserDao가 돌려주는 결과를 화면에 출력해주
는 기능이 만들어져 있어야 확인이 기능하다.
이렇게 웹 화변을 통해 값을 입력하고， 기능을 수행하고， 결괴를 확인하는 방법은 가
장 흔히 쓰이는 방법이지만. DAO에 대한 테스트로서는 단점이 너무 많다. DAO뿐만
아니라 서비스 클래스， 컨트롤러. JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테
스트가 가능하다는 점이 가장 큰 문제다. 테스트를 하는 중에 에러가 나거나 테스트가
실패했다면， 과연 어디에서 문제가 발생했는지를 찾아내야 하는 수고도 펼요하다. 하
나의 테스트를 수행하는 데 참여히는 클래스와 코드가 너무 많기 때문이다. 폼을 띄우
고 값을 입력하고 등록 버튼을 눌렀는데 에러 메시지가 폈다고 해보자. 에러 메시지와
호출 스택 정보만 보고 간단히 원인을 찾아낼 수 있을까? 아닌 경우가 더 많다. 등록이
실패하는 원인은 DB 연결 방법에 문제가 있어서일 수도 있고. DAO 코드가 잘못되어
JDBC API를 잘못 호출해서일 수도 있다. 또는 SQL 문법이 틀혔거나， 따라미터로 넘
어온 값을 잘못 바인딩했을 수도 었다. 정작 태스트할 대상인 DAO의 문제가 아니라 서
버환경에서 웹 화면을 통해 DAO를 태스트하려고 만든 다른 코드 때문에 에러가 나거
나 태스트가 실패할 수도 있다. 웹 계층에서 DAO를 바르게 호출하지 못했을 수도 있
고， 폼에서 넘어온 파라미터 값을 User 오브젝트에 파성해서 넣는 데 문제가 있었을 수
도 있다. 또는 MVC 컨트롤러의 설정에 문제가 있어서 정상적으로 원하는 컨트롤러가
실행되지 없t을 수도 있다. 모든 것이 다 성공했지만 최종적으로 결과 메시지를 출력
히는 JSP 뷰에 문제가 있어서 오류가 난 것처럼 보일 수도 있다. 사실 테스트하고 싶었
던 건 UserDao
였는데 다른 계층의 코드와 컴포넌트 심지어 서버의 설정 상태까지 모두
태스트에 영향을 줄 수 있기 때문에 이런 방식으로 테스트히는 것은 번거롭고， 오류가
있을 때 빠르고 정확하게 대응하기가 힘들다는 문제가 있다.
그렇다면 테스트를 어떻게 만들면 이런 문제를 피할 수 있고， 효율적으로 테스트를
활용할 수 있을지 생각해보자.


작은단위의테스트
테스트하그찌 하는 대상이 명확하다면 그 대상에만 집중해서 태스트히는 것이 바람직
하다. 한꺼번에 너무 많은 것을 몰아서 태스트하면 태스트 수행 과정도 복잡해지고， 오
류가 발생했을 때 정확한 원인을 찾기가 힘들어진다. 따라서 테스트는 가능하면 작은
단위로 쪼개서 집중해서 할 수 있어야 한다. 관심사의 분리라는 원리가 여기에도 적용
된다. 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
UserDaoTest는 한 가지 관심에 집중할 수 있게 작은 단위로 만들어진 테스트다.
UserDaoTest
의 테스트를 수행할 때는 웹 인터페이스나， 그것을 위한 MVC 클래스， 서
비스 오브젝트 등이 필요 없다. 서버에 배포할 펼요도 없다. 간단히 IDE나 도스칭벼l
서
도 태스트 수행이 가능하다. 에러가 나거나 원치 않는 결과가 나온다면， 그것은 UserDao
코드나 아니면 DB 연결 방법 정도에서 문제가 있는 것이니 원인을 빠르게 찾아낼 수 있
다. 영똥하게 UserDao 기능을 돌려보려고 만든 JSP나 서블릿에서 에러가 발생해서 그
것을 찾으려고 시간을 낭비할 필요가 없다.
이렇게 작은 단위의 묘드에 대해 태스트를 수행한 것을 단위 테스트unit test라고 한다.
여기서 밀하는 단위란 무엇인지， 그 크기와 범위가 어느 정도인지 딱 정해진 건 아니다.
크게는 사용자 관리 기능을 모두 통틀어서 하나의 단위로 볼 수도 있고， 작게 보자연
UserDao의 add() 메소드 하나만 가지고 하나의 단위라고 생각할 수도 있다. 충분히 하
나의 관심에 집중해서 효율적으로 테스트할 만한 범위의 단위라고 보면 된다.
일반적으로 단위는 작을수록 좋다. 단위를 넘어서는 다른 묘드들은 신경 쓰지 않고，
참여하지도 않고 테스트가 동작할 수 있으면 좋다. UserDao는 서비스. MVC 계층이 참
여하고 웹 화면과 서버까지 동원하지 않고도 테스트가 가능했다. DAO라는 기능과 DB
까지로 단위를 잡고 집중해서 테스트할 수 있었다. 그래서 UserDaoTest를 단위 태스트
라고 부를 수 있다. 어떤 개발자는 테스트 중에 DB가 샤용되면 단위 테스트가 아니라
고도 한다. 그럼 UserDaoTest는 단위 태스트가 아니라고 봐야 할까? 그렇지는 않다. 지
금까지 UserDaoTest를 수행할 때 매번 USER 테이블의 내용을 비우고 테스트를 진행했
다. 이렇게 사용할 DB의 상태를 테스트가 관장하고 있다면 이는 단위 태스트라고 해도
된다. 다만. DB
의 상태가 매번 달라지고， 태스트를 위해 DB를 특정 상태로 만들어줄
수 없다면 그때는 UserDaoTest가 단위 태스트로서 가치가 없어진다. 그런 차원에서 통
제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 태스트가 아니라고 보기도 하는
것이다.
때로는 웹 사용자 인터페이스부터 시작해서 DB
에 이르기까지의 애플리케이션 전 계

2징-테스트 149


층이 참여하고， 또 단순 사용자 등록 작업 하나가 아니라， 초기 등록에서부터 시작해서
등록이 성공하면 로그인하고， 각종 기능을 모두 사용한 다음에 로그아웃까지 하는 전
과정을 하나로 묶어서 태스트할 멸요가 있다. 각 단위 기능은 잘 동작하는데 묶어놓으
면 안 되는 경우가 종종 발생하기 때문이다. 따라서 이런 길고 많은 단위가 참여하는 테
스트도 언젠가는 필요하다.

때로는 단위 태스트 없이 바로 이런 긴 테스트만 하는 경우도 있다. 아마도 수많은
에러를 만나거나 에러는 안 나지만 제대로 기능이 동작하지 않는 경험을 하게 될 것이
다. 이때는 문제의 원인을 찾기가 매우 힘들다. 예외가 발생해도 그 이유를 찾는 데 많
은 시간이 걸릴 수 있다. 또， 예외가 발생하지 않고 정상적으로 동작했는데 막상 결과가
원하는 대로 나오지 않을 수도 있다. 문제의 원인을 찾기가 더욱 힘든 상횡어다. 서버가
연동하는디버거를돌려가며 각단계별로
DB와메모리 값을스랩별로확인해가면서 원
인을 찾는 수고를 하게 될지도 모르겠다. 그런데 각 단위별로 태스트를 먼저 모두 진행
하고 나서 이런 긴 테스트를 시작했다면 어떨까? 그래도 역시 예외가 발생하거나 테스
트가 실패할 수는 있겠지만 이미 각 단위별로 충분한 검증을 마치고 오류를 잡았으므
로훨씬나을것이다.

이렇게 작은 단위로 나눠서 테스트하는 단위 태스트가 펼요한 이유를 좀 더 생각해
보자. 단위 테스트를 하는 이유는 개발자가 설계하고 만든 묘드가 원래 의도한 대로 동
작하는지를 개발자 스스로 빨리 확인받기 위해서다. 이때 확인의 대상과 조건이 간단하
고 명확할수록 좋다. 그래서 작은 단위로 제한해서 태스트하는 것이 편리하다. 단위 태
스트는 주로 개발자가 만든 코드를 스스로 확인하기 위해 시용하는데， 그래서 이를 개
발자 태스트 또는 프로그래머 태스트라고도 한다. 물론 개발자가 아닌 전문 테스터나
고객이 직접 단위 태스트를 할 수도 있다. 물론 이때는 단위가 제법 커질 것이다. 테스
터나 고객이 태스트를 하는 시점이면 이미 개발자가 코드를 작성하고 나서 한참 뒤일
것이다. 그때서야 오류가 처음 발견되고 개발자에게 문제가 통보된다면 개발자는 오래
전에 만든 묘드를 뒤져서 버그를 수정해야 한다. 이런 경우와 코드를 만들자마자 빠르
게 태스트해서 오류를 발견했을 때 버그를 수정하는 경우를 비교해보자. 개발자 입%에
서 어떤 경우가 더 빠르고 쉽게 문제의 원인을 찾고 수정이 가능할까?

다시 말하지만 U
s
erDaoTest는 U
serDao라는 작은 단위의 데이터 액세스 기능만을 테
스트하기 위해 만들어졌고， 그 외의 계충이 참여하지 않기 때문에 이는 분명 단위 태스
트다. 또한 우리가 만들고 개선한 코드가 처음 설계하고 의도한 대로 바르게 동작했는
지를 확인하기 위해 개발자 입~에서 만든 것이므로 이를 개발자 태스트라고 부를 수도
있다.


자동수행테스트코드
UserDaoTest
의 한 가지 특정은 태스트할 데이터가 코드를 통해 제공되고， 테스트 작업
역시 코드를 통해 자동으로 실행한다는 점이다. 웹 화면에 폼을 띄우고 매번 User
의 등
록 값을 개발자 스스로 입력하고 버튼을 누르고， 또 조회를 위한 ID 값을 넣고 버튼을
누르는 등의 작업을 반복한다면 얼마나 지루하고 불편할까? 간혹 테스트 값 입력에 실
수가 있어서 오류가 나면 다시 테스트를 반복해야 하는 번거로움도 있다. 또한 태스트
를 실행하기 위해 서버를 띄우고 프로그램을 배치하고 태스트용으로 브라우저를 띄우
고 주소를 입력하고 들어가는 귀찮은 작업도 펼요하다. 한 4~5
번만 그런 작업을 반복
하고 나면， 귀찮아서라도 더 이상 코드를 수정하거나 개선하려는 마음을 접어버리고 그
냥잘돌아가겠지 하고넘어가고싶을지도모르겠다.
하지만 UserDaoTest는 자바 클래스의 main() 메소드를 실행하는 가장 간단한 방법
만으로 태스트의 전 과정이 자동으로 진행된다. User 오브젝트를 만들어 적절한 값을
넣고， 이미 DB 연결 준비까지 다 되어 있는 UserDao 오브젝트를 스프링 컨테이너에서
가져와서 add() 메소드를 호출하고 그 키 값으로 get()
을 호출하는 것까지 자동으로
진행된다. 번거롭게 매번 입력할 필요도 없고， 태스트를 시작하기 위해 서버를 띄우고，
브라우저를 열어야 하는 불편함도 없다. IDE에서 단축키를 사용하면 UserDaoTest의
main() 메소드를 시작히는 데 0.5초면 충분하다. 또한 화면이 뜨고 입력을 받기 위한
대기시간이 없기 때문에 테스트 진행시간도 매우 짧다.DB에 넣고 읽는 것까지 포함해
서 l
초미만이면충분하다. 하루에 100번을돌려도
2분도안걸린다. 그러니 테스트를
자주 수행해도 부담이 없다.
이렇게 태스트는 자동으로 수행되도록 코드로 만들어지는 것이 중요하다. 어떤 개발
지는 모든 클래스는 스스로 자신을 테스트히는 main() 메소드를 갖고 있어야 한다고 주
장하기도 한다. 굳이 모든 클래스의 mainO 메소드에 태스트 코드가 들어가 있을 필요까
지는 없겠지만， 어쨌든 태스트 자체가 사람의 수작업을 거치는 방법을 사용하기보다는
묘드로 만들어져서 자동으로 수행될 수 있어야 한다는 건 매우 중요하다.
그런데 애플리케이션을 구성하는 클래스 안에 테스트 코드를 포함시키는 것보다는
별도로 테스트용 클래스를 만들어서 테스트 코드를 넣는 편이 낫다. 처음엔 UserDao 클
래스 하나만 존재했으니， 그 안에 main() 메소드를 만들어 사용했지만， 클래스를 분리
하고 유연한 설계구조로 발전시키면서 태스트 묘드를 넣을 위치를 결정하기가 애매하
기 때문에 UserDaoTest라는 별개의 클래스를 만들고 그 안에 테스트 코드를 넣도록 했
던것이다.

2장-테스트 151


지동으로 수행되는 테스트의 장점은 지주 반복할 수 있다는 것이다. 번거로운 작업이
없고 테스트를 빠르게 실행할 수 있기 때문에 언제든 코드를 수정하고 나서 테스트를 해
볼 수 있다. 때로는 단 한 줄의 코드를 건드렸는데 전체 기능에 영향을 주기도 한다. 개
발이 완료될 즈음에， 또는 개발을 일단 완료하고 실전에서 운영 중인 상햄서 코드를
수정하려고 한다면 아무리 간단한 수정이라고 하더라도 이게 그럭저럭 돌아가는 전체
애플리케이션에 심각한 문제를 일으커지는 않을까 하는 두려움이 앞선다. 그럴 때 만들
어둔 기능에 대한 테스트가 었다면 수정 후 빠르게 전체 테스트를 수행해서 수정 때문에
다른 기능에 문제가 발생하지는 않는지 재빨리 확인하고 성공한다면 마음에 확신을 얻
을수있다.

지속적인 개선과 접진적인 개발을 위한 테스트
처음 만든 초난감 DAO 코드를， 스프링을 이용한 깔끔하고 완성도 높은 객체지향적 코
드로 발전시키는 과정의 일등 공신은 바로 이 테스트였다. 태스트가 없었다면， 다양한
방법을 동원해서 묘드를 수정하고 설계를 개선해나기는 과정이 그다지 미럽지 않을 수
도 있고， 그래서 미음이 불편해지면 이쯤에서 그만두자는 생각이 들 수도 있었기 때문
이다. 하지만 조금 난감하긴 해도 일단 자신 있게 만들 수 있는 가장 단순한 방법으로
DAO 코드를 만들자마자 바로 DAO로서의 기능에 문제가 없는지 검증해주는 테스트
코드를 만들어뒀기 때문에， 그때부터는 자신을 가지고 조금씩 코드를 개선해나가는 작
업을 진행할 수 있었다. 혹시 중간에 잘못 설계했거나 중요한 코드를 한 줄 빼먹었거
나， 수정에 실수가 있었다면 태스트를 통해 무엇이 잘못됐는지 바로 확인할 수 있었을
것이다.
만약 처음부터 스프링을 적용하고 XML로 설정을 만들고 모든 코드를 다 만들고 난
뒤에 이를 검증하려고 했다면， 아마 쏟아지는 에러 메시지에 기가 질려서 무엇을 해야
할지 몰라 막막해졌을지도 모르겠다. 스프링과 같은 프레임워크가 뿌려대는 희한한 에
러 메시지를 보고 나서， 이게 스프링을 잘못 λF용한 것인지
， 설정에 오류가 있는 것인
지，
DAO 코드 자체를 잘못 만들었는지 찾아내는 데 아마도 적지 않은 고민스러운 시간
을보내야했을것이다.
하지만 일단은 단순 무식한 방법으로 정상동작하는 코드를 만들고， 태스트를 만들어
뒀기 때문에 매우 작은 단계를 거쳐가면서 계속 코드를 개선해나갈 수 있었다. 오히려
그렇게 작은 단계를 거치는 동안 태스트를 수행해서 확신을 가지고 코드를 변경해갔기
때문에 전체적으로 코드를 개선하는 작업에 속도가 붙고 더 쉬워졌을 수도 있다.


또 UserDao의 기능을 추가하려고 할 때도 미리 만들어둔 테스트 묘드는 유용하게 쓰
일 수 있다. 일단은 가장 단순한 등록과 조회 기능을 만들고， 이를 태스트로 검증해서
만든 코드에 대한 확신을 갖는다. 그리고 거기에 조금씩 기능을 더 추가해가면서 그에
대한 태스트도 함께 추가하는 식으로 점진적인 개발이 기능해진다. 태스트를 이용하면
새로운 기능도 기대한 대로 동작히는지 확인할 수 있을 뿐 아니라， 기존에 만들어뒀던
기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하
는지를 확인할 수도 있다.

2.1.3 UserDaoTest의 문제점
앞에서 살펴봤듯이 UserDaoTest가 UI까지 동원되는 번거로운 수통 테스트에 비해 장점
이 많은 건 사실이다. 하지만 만족스럽지 못한 부분도 있다.

• 수동 확인 작업의 번거로움
UserDaoTest는 태스트를 수행히는 과정과 입력 데이터의 준비를 모두 자동으로 진
행하도록 만들어졌다. 하지만 여전히 사람의 눈으로 확인하는 과정이 펼요하다.
add()
에서 User 정보를 DB에 등록하고 이를 다시 get( )을 이용해 가져왔을 때 입
력한 값과 가져옹 값이 일치하는지를 테스트 코드는 확인해주지 않는다. 단지 콘솔
에 값만 출력해줄 뿐이다. 결국 그 콘솔에 나온 값을 보고 등록과 조회가 성공적으
로 되고 있는지를 확인히는 건 사람의 책임이다. 태스트 수행은 코드에 의해 자동으
로 진행되긴 하지만 태스트의 결과를 확인하는 일은 사람의 책임이므로 완전히 자동
으로 태스트되는 방법이라고 말할 수가 없다. 단지 몇 가지 필드의 값에 대해 등록한
것과 조회한 것이 일치하는지를 확인하는 일은 사람이 해도 별 수고가 아닐지 모르
겠지만， 검증해야동}는 양이 많고복챔}지면 역시 불면함을느낄 수밖에 없다. 또한
작은차이는미처 발견하지 못하고 넘어기는실수를할가능성도 있다.
• 싫행작업의번거로웅
아무리 간단히 실행 가능한 main() 메소드라고 하더라도 매번 그것을 실행하는 것은
제법 번거롭다. 만약 DAO가 수백 개가 되고 그에 대한 main() 메소드도 그만큼 만
들어진다면. 전체 기능을 테스트해보기 위해 main() 메소드를 수백 번 실행하는 수
고가 필요하다. 또한 그 결과를 눈으로 확인해서 기록하고， 이를 종합해서 전체 기능
을 모두 테스트한 결괴를 정리하려면 이것도 제법 큰 작업이 된다. 그래서 main() 메
소드를 이용하는 방법보다 좀 더 편리하고 체계적으로 테스트를 실행하고 그 결과를
확인하는 방법이 절실히 필요하다.
2징-터낱드 153


{ p'~""'~1#1
a"bt.i
ß.1J 개선 :폐|

UserDaoTest
의 두 가지 문제점을 개선해보자.

2.2.1 테스트 검증의 자동화
첫 번째 문제점인 태스트 결과의 검증 부분을 묘드로 만들어보자. 이 태스트를 통해 확
인하고 싶은 사항은. add()
에 전달한 User 오브젝트에 담긴 사용자 정보와 get()을 통
해 다시 DB에서 가져옹 User 오브젝트의 정보가 서로 정확히 일치하는가이다. 정확히
일치한다면 모든 정보가 빠짐없이 DB에 등록됐고 이를 다시 DB에서 정확히 가져왔다
는사실을알수있다.
태스트의 결과에 대해 먼저 생각해보자.
모든 태스트는 성공과 실패의 두 가지 결괴를 가질 수 있다. 또 테스트의 실패는 태
스트가 진행되는 동안에 에러가 발생해서 실패하는 경우와， 테스트 작업 중에 에러가
발생하진 않았지만 그 결과가 기대한 것과 다르게 나오는 경우로 구분해볼 수 있다. 여
기서 전자를 테스트 에러， 후자를 태스트 실패로 구분해서 부르겠다.
태스트 중에 에러가 발생하는 것은 쉽게 확인이 가능하다. 콘솔에 에러 메시지와 긴
호출 스택 정보가 출력되기 때문이다. 하지만 태스트가 실패하는 것은 별도의 확인 작
업과 그 결과가 있어야만 알 수 었다. 기존의 태스트 코드에서는 get()
에서 가져옹 결
과를 사람이 눈으로 확인하도록 단순히 콘솔에 출력하기만 했는데， 이번에는 태스트
코드에서 결과를 직접 확인하고， 기대한 결과와 달라서 실패했을 경우에는 “태스트 실
패”라는 메시지를 출력하도록 만들어보자. 그리고 모든 확인 작업을 통과하면 그때는
“태
스트 성공”이라고 출력하도록 하겠다. 그러고 보면 기존에 출력했던 “조회 성공”이
라는 메시지는 사실 get() 메소드가 에러 없이 끝났다는 의미이지 조회 테스트가 모두
성공했다는뭇은아니었다.
태스트 코드에서 리스트 2-2와 같은 부분을 리스트 2-3과 같이 수정한다.

리스트 2-2 수정 전 테스트 코드

System.out.println(user2.getName());
System.out.println(user2.getPassword());
System.out .println(user2 .getld() + " 조회 성공");

154


리스트 2-3 수정 후 테스트 코드

if (!user.getName().equals(user2 .getName())) {
System.out
.
println("
테스트 실패 (name) ‘);

else if (!user .getPassword().equals(user2 .getPassword())) (
System
.
out.println("
테스트 실패 (password)") ;

else (

System.out.println("
조회 테스트 성공’);


처음
add()에 전달한
User 오브젝트와
get()을통해 가져오는
User 오브젝트의 값을
비교해서 일치히는지 확인히는 것이다. 만약 다른 값이 있다면 그때는 테스트가 실패했
다고출력하고 태스트를 마치면 된다. name과
password 둘중 어떤 것 때문에 실패했는
지를 알 수 있도록 뒤에 간단히 필드 이름을 추가해서 표시해줬다. 그리고 모든 비교가
다 성공적으로 꿀나면 그때는 테스트가 성공했다고 메시지를 출력하도록 한다. 이제 다
시 태스트 main() 메소드를 실행하면 다음과 같이 성공 메시지가 출력될 것이다.

user13 등록 성공

user13 조회 성공

add( )를 통한 등록 자체는 별다르게 검증할 것이 없다. add()
를 호출하고 나서 에러
가 발생하지 않으면 일단 성공으로 간주한다. 그리고 get()
을 통한 검증 과정에서 사실
add()
의 작업도 함께 확인하는 것이다. 만약 add() 메소드의 잘못으로 등록이 안 된 게
었다면 뒤의 검증 코드를 통과하지 못할 것이다.

UserDaoTest가 실패하는 것을 보고 싶다면 UserDao의 get() 메소드 안의 코드를 하
니쯤 강제로 묘멘트 처리하고 다시 태스트를 돌려보면 된다. get() 메소드의 다음 라인
을코멘트로비꾸고

/ / user.setName(rs. getString( "name"));

다시 태스트를 돌려보면 아래와 같이 테스트 실패 메시지가 나올 것이다.

테스트 실패 (name)

이렇게 해서 테스트의 수행과 태스트 값 적용， 그리고 결과를 검증히는 것까지 모두

자동화했다. 이제 거의 모든 과정을 자동화한 태스트가 만들어졌다. 태스트를 수행하고

2징-테스트 155


나서 할 일은 마지막 출력 메시지가 “테스트 성공”이라고 나오는지 확인하는 것뿐이다.
혹시 예외가 발생하거나 실패 메시지가 나오면 그 원인을 찾아서 코드를 수정하고 다시
태스트를 실행해야 한다. 최종적으로 태스트 성공 메시지가 나오면 UserDao의 기능이
문제없이 완성됐다는 확신을 갖고 미음 편하게 다음 작업으로 넘어가면 된다.

이 테스트는 UserDao의 두 가지 기능이 정상적으로 동작하는지를 언제든지 손쉽게
확인할 수 있게 해준다. 따라서 이 코드의 동작에 영향을 미칠 수 있는 어떤 변화라도
생기면 언제든 다시 실행해볼 수 있다. 혹시 스프링 프레임워크 대신 다른 프레임워크
나 기술로 전환히는 큰 변화가 일어나더라도 UserDao가 전과 같이 정상적으로 동작하는
지 확인하는 것은 이 테스트 한 번이면 충분하다.

자동화된 태스트를 위한 xUnit 프레임워크를 만든 켄트 벡은 ‘페스트란 개발자가 마
음 편하게 잠자리에 들 수 있게 해주는 것”이라고 했다. 지저분한 코드를 정리한다고 조
금 손을 댔는데， 이것 때문에 혹시 기존 기능에 문제가 생기진 않을까라는 불안한 마음
으로 퇴근한 경험이， 개발자라면 한두 번쯤 있을 것이다. 또는 새로운 기능을 추가하고
적용하고 왔는데， 갑자기 회시에서 연락이 와서 그 기능 적용 이후로 다른 부분에서 많
은 문제가 생겼으니 당장 해결해달라는 긴급요청을 할 때도 있다. 나는 그런 경험을 셀
수도 없이 많이 했다. 모처럼 친구들을 만나서 즐거운 시간을 보내고 있을 때나 휴가로
여행을 떠나서도 종종 며칠 전에 손을 댔던 코드 때문에 어떤 문제가 생겼다고 연락이
오지 않을까 하는 불안감이 미음에서 떠나지 않을 때도 있었다. 그래서 핸드폰이 울릴
때마다 가슴이 철렁하기도 한다. 때론 가까운 PC방으로 뛰어가서 긴급하게 문제가 생
긴 코드를 찾아서 수정을 하기도 했다. 일단 급한 문제를 해결하고 나서도 여전히 마음
에 불안감이 사라지지 않았다. 그 오류를 수정하면서 또 다른 기능에 문제가 생겼을 수
도 있다는 생각이 들기 때문이다. 짧은 시간에 화면에서 하는 수동 태스트로는 당장 수
정한 기능의 가장 간단한 케이쇼를 확인하기에도 벅차기 때문에 전체 기능에 문제가 없
는지 점검하는 것은불가능에 기깝다.

하지만 만들어진 코드의 기능을 모두 점검할 수 있는 포괄적인 태스트comprehensive
test를 만들면서부터는， 개발한 애플리케이션은 이후에 어떤 과감한 수정을 하고 나서도
태스트를 모두 돌려보고 나면 안심이 된다. 혹은 태스트를 통해 그 변경에 영향을 받는
부분이 정확히 확인된다면 빠르게 조치를 취할 수 있다.

이렇게 개발 과정에서， 또는 유지보수를 하면서 기존 애플리케이션 코드에 수정을
할 때 미음의 평안을 얻고， 자신이 만지는 코드에 대해 항상 자신감을 가질 수 있으며，
새로 도입한 기술의 적용에 문제가 없는지 확인할 수 있는 가장 좋은 방법은 빠르게 실


행 기능하고 스스로 태스트 수행과 기대하는 결과에 대한 확인까지 해주는 묘드로 된
지동화된 태스트를 만들어두는 것이다.

2.2.2 테스트의 효율적인 수행과 결과 관리
이제 main() 메소드로 만든 테스트는 테스트로서 펼요한 기능은 모두 갖춘 셈이다. 하
지만 좀 더 편리하게 태스트를 수행하고 편리하게 결괴를 확인하려면 단순한 main() 메
소드로는 한계가 있다. 일정한 패턴을 가진 테스트를 만들 수 있고， 많은 태스트를 간단
히 실행시킬 수 있으며， 태스트 결괴를 종합해서 볼 수 있고 태스트가 실패한 곳을 빠
르게 찾을 수 있는 기능을 갖춘 태스트 지원 도구와 그에 맞는 태스트 작성 방법이 필요
하다. main() 메소드를 이용한 태스트 작성 방법만으로는 애플리케이션 규모가 커지고
태스트 개수가 많아지면 태스트를 수행히는 일이 점점 부담이 될 것이다.
이미 자바에는 단순하면서도 실용적인 테스트를 위한 도구가 여러 가지 존재한다.
그중에서도 프로그래머를 위한 자바 태스팅 프레임워크라고 불리는 JUnit은 자바 개발
자라면 한 번쯤 들어봤거나 사용해봤을 유명한 테스트 지원 도구다. JUnit은 이름 그대
로 자바로 단위 테스트를 만들 때 유용하게 쓸 수 있다.

JUnit 테스트로 전환
지금까지 만들었던 main() 메소드 테스트를 JUnit을 이용해 다시 작성해보겠다. JUnit
은 프레입워크다. 1장에서 프레임워크의 기본 동작원리가 바로 제어의 역전loC이라고
설명했던 것을 기억할지 모르겠다. 프레임워크는 개발자가 만든 클래스에 대한 제어 권
한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다. 개발자가 만든 클래스
의 오브젝트를 생성하고 실행히는 일은 프레임워크에 의해 진행된다. 따라서 프레임워
크에서 통작하는 코드는 main() 메소드도 필요 없고 오브젝트를 만들어서 실행시키는
코드를 만들 필요도 없다.

테스트메소드전환
기존에 만들었던 main () 메소드 태스트는 그런 변에서 프레임워크에 적용하기엔 적합
하지 않다. 태스트가 main() 메소드로 만들어졌다는 건 제어권을 직접 갖는다는 의미이
기 때문이다. 그래서 가장 먼저 할 일은 main() 메소드에 있던 테스트 코드를 일반 메소
드로 옮기는 것이다. 새로 만들 테스트 메소드는 JUnit 프레임워크가 요구하는 조건 두
가지를 따리야 한다. 첫째는 메소드가 pu
blic으로 선언돼야 히는 것이고， 다른 하나는
메소드에 @Test
라는 애노태이션을 붙여주는 것이다.

2징-테스트 157


리스트 2-4에서는 JUnit 프레임워크에서 동작하도록 태스트 메소드를 재구성했다.
리스트 2-4 JUnit 프레임워크에서 동작힐 수 있는 테스트 메소드로 전환

import org . junit .Test;
public class UserDaoTest (

r-JUnrtOl
I게 테스트용 메소드임을 일려준다
lJTest
~ JUnrt 테스트 메소드는 반드시
public void addAndGet() throws SQLException ( publ
k:으로 선언돼야 효빠，
ApplicationContext context = new
ClassPathXmlApplicationContext( 녀pplicationContext
.x
ml
")
;

UserDao dao = context.getBean("userDao" , UserDao.class) ;

main() 대신에 일반 메소드로 만들고 적절한 이름을 붙여준다. 이왕이면 태스트의
의도가 무엇인지 알 수 있는 이름이 좋다. 여기서는 add() 메소드와 get() 메소드에 대
한 테스트라는 의미로 addAndGet()
이라는 이름을 사용했다. public 액세스 권한을 주
는 것을 잊으면 안 된다. JUnit은 전통적으로 public 메소드만을 테스트 메소드로 허용
하고 있다. 마지막으로 @Test 애노테이션을 붙여주면 된다.

검증코드전환
태스트의 결과를 검증하는 if/else 문장을 JUnit이 제공하는 방법을 이용해 전환해
보자.
디음 if 문은 처음 add( )에 사용했던 user 오브젝트의 name 값과 get()
에서 가져
옹 user2 오브젝트의 name 값이 같으면 다음으로 넘어가고， 아니면 태스트가 실패하
게한다.

if (!user .getName () .equals(user2 .getName())) { ... }

이 if 문장의 기능을 JUnit이 제공해주는 assertThat이라는 스태틱 메소드를 이용
해 디음과 같이 변경할 수 있다.

assertThat(user2.getName() , is(user.getName())) ;


assertThat () 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처
matcher라고 불리
는 조건으로 비교해서 일치하면 다옴으로 넘어가고， 아니면 태스트가 실패하도록 만들
어준다. is()
는 매처의 일종으로 equals ()로 비교해주는 기능을 가졌다.

같은 방법으로 두 번째 if 문장도 다음과 같이 비꿀 수 있다.

assertThat(user2.getPassword() , is(user .getPassword()));

JUnit은 예외가 발생하거나 asser
tT
hat()
에서 실패하지 않고 태스트 메소드의 실행
이 완료되면 테스트가 성공했다고 인식한다. ‘페스트 성공”이라는 메시지를 굳이 출력
할 필요는 없다. JUnit이 태스트를 실행하고 나면 테스트 결과를 다OJ=한 방법으로 알려
주기때문이다.

리스트 2-5는 JUnit 프레임워크에서 실행될 수 있게 수정한 UserDaoTest 클래스다.

리스트 2-5 JUnit을 적용한 UserD∞ITest


import static org.hamcrest.CoreMatchers.is;
import static org.junit.Assert.assertThat;

public class UserDaoTest (
@Test
public void addAndGet() throws SQLException (

ApplicationContext context = new GenericXmlApplicationContext(
녀ppl icationContext .xml");

UserD딩o dao = context.getBean("userDao" , UserDao.class);
User user = new User();
user.setld ( “gyumee") ;

user.setName(" 박성 철 ");
J
니
nit 테스트로 전환히는 김에 새로운 기분으로
테스트 데이터도 바꿔보자

user.setPassword("springnol");

dao.add(user);

User user2 = dao.get(user .getld());

assertThat(user2.getName() , is(user.getName()));
assertThat(user2.getPassword() , is(user.getPassword()));

2징-태스트 159


*후가휠라이브러리

∞m.spring∞ur，∞.org.junn-4.7.0.jar

JUnit 테스트실행
JUnit 프레임워크를 이용해 앞에서 만든 테스트 메소드를 실행하도록 코드를 만들어보
자. 스프링 컨테이너와마찬가지로
JUnit
프레임워크도자바코드로만들어진프로그랩
이므로 어디선가 한 번은 JUnit 프레임워크를 시작시켜 줘야 한다.
어디에든 main() 메소드를 하나 추가하고， 그 안에 JUnitCore 클래스의 main 메소
드를 호출해주는 간단한 코드를 넣어주면 된다. 메소드 따라미터에는 @Test 테스트 메
소드를 가진 클래스의 이름을 넣어준다. UserDaoTest를 실행할 테니 리스트 2-6과 같
이 springbook.user.dao
.
UserDaoTest
라는 값을 넘겨준다.

리스트 HJU마울 이용해 테스트톨 싫행해주는 main() 메소드

import org.junit.runner.1UnitCore;
public static void main(String[] args) {

lUnitCore.main(
깨
pringbook.user.dao.UserDaoTest");

이 클래스를 실행하면 다음과 같은 메시지가 출력될 것이다.

JUnit version 4.7
Time : 0.578
OK (1 test)

테스트를 실행히는 데 걸린 시간과 테스트 결과， 그리고 몇 개의 태스트 메소드가 실

행됐는지를알려준다.

만약 묘드에 이상이 있어서 assertThat()의 검증에서 실패하면 다음과 같은 메시지

가나올것이다.

Time: 1.094
There was 1 failure:

1) addAndGet(springbook.dao.UserDaoTest)
java.lang .AssertionError:
Expected: is
박성철”
got: null


at springbook.dao.UserDaoTest.main(UserDaoTest.iava:36)
FAILURES!! !
Tests run: 1. Failures: 1

태스트가 실패하면 OK 대신 FAILURES!!
라는 내용이 출력되고， 총 수행한 태스트
중에서 몇 개의 태스트가 실패했는지 보여준다. 출력된 메시지를 잘 살펴보면 실패한
테스트는 UserDaoTest 클래스의 addAndGet() 메소드이고， 실패의 이유는 “박성철”이라
는 값을 원했는데 실행해보니 null
이 나왔다는 것임을 알 수 있다. 함께 출력된 호출 스
택을 살펴보면 실패한 원인이 무엇이고 테스트 코드에서 검증에 실패한 위치는 어디인
지도확인할수있다.

메시지의 앞부분을 보면 java
.
lang.AssertionError
가 던져졌음을 알 수 있
다. JUnit은 asser
tT
hat()
을 이용해 검증을 했을 때 기대한 결과가 아니면 이
AssertionError를 던진다. 따라서 asser
tThat()
의 조건을 만족하지 못하면 태스트는
더 이상 진행되지 않고 JUnit은 태스트가 실패했음을 알게 된다. 태스트 수행 중에 일반
예외가 발생한 경우에도 마찬가지로 테스트 수행은 중단되고 테스트는 실패한다.

I~ 개발자를 위한 테스팅 프레임워크 Ð1iIIJ 쉰

JUnit
프레임워크를좀더 자세히 살펴보자. JUnit은사실상자바의 표준태스팅 프레임
워크라고 불릴 만큼 폭넓게 사용되고 있다. 스프링을 학습하고 제대로 활용하려면 최소
한의 JUnit 테스트 작성 방법과 실행 방법은 알고 있어야 한다. 다시 말하지만 테스트 없
이는 스프링도 의미 없다. 스프링 프레임워크 자체도 JUnit 프레임워크를 이용해 테스트
를 만들어가며 개발됐다. 테스트를 만들지 않았다면 오늘날의 스프링 프레임워크는 존
재하지 않았을지도 모른다.

스프링의 핵심 기능 중 하나인 스프링 테스트 모률도 JUnit을 이용한다. 따라서 스
프링의 기능을 익히기 위해서라도 JUnit은 목 사용할 줄 알이야 한다. JUnit 테스트는
main() 메소드와 System
.
out.println()
으로 만든 태스트만큼 단순하기 때문에 빠르게
작성할 수 있다. 또， 태스트 작성 시 지주 필요한 편리한 여러 가지 부가기능도 제공한
다. 대부분의 자바 IDE는 JUnit 태스트를 손쉽게 실행할 수 있는 JUnit 태스트 지원 기
능을 내장하고 있어서 더욱 편리하게 JUnit 테스트를 만들고 활용할 수 있게 해준다.

2징-테스트 161



2.3.1 JUnit 테스트 실행 방법
JUnitCore를 이용해 태스트를 실행하고 콘솔에 출력된 메시지를 보고 결과를 확인히는
방법은 가장 간단하긴 하지만 테스트의 수가 많아지면 관리하기가 힘들어진다는 단점
이 있다. 가장 좋은 JUnit 테스트 실행 방법은 자바 IDE에 내장된 JUnit 태스트 지원 도
구를사용하는것이다.

IDE

대부분의 자바 개발자가 사용하고 있는 사실상의 표준 자바 IDE
인 이클립스는 오래전

부터 JUnit 태스트를 지원하는 기능을 제공하고 있다. @Test가 들어 있는 테스트 클래

스를 선택한 뒤에， 이클립스 run 메뉴의 Run As 항목 중에서 JUnit Test를 선택하면 테

스트가 자동으로 실행된다. JUni tCore를 이용할 때처럼 main() 메소드를 만들지 않아

도된다.

테스트가 시작되면 JUnit 태스트 정보를 표시해주는 뷰vlew가 나타나서 태스트 진행

상황을 보여준다. 테스트가 완료되면 테스트의 최종 결과가 그림 2-1
과 같이 깔끔하게

나타난다.

그림 2-1 이클립스 JUnit 테스트 결과. 테스트 성공

이 뷰에서 테스트의 총 수행시간， 실행한 태스트의 수， 태스트 에러의 수， 테스트 실패

의 수를 확인할 수 있다. 또한 어떤 테스트 클래스를 실행했는지도 알 수 있다. 태스트

클래스 내에 있는 @Test가 붙은 태스트 메소드의 이름도 모두 보여준다. 각 테스트 메

소드와 클래스의 테스트 수행에 걸린 시간도 보여준다.

태스트가 실패해서 코드를 수정한 뒤， 다시 태스트를 실행하려면 JUnit 테스트 뷰의

녹색 Rerun Test 버튼을 클릭하면 된다. 또 테스트 목록에서 테스트 클래스나 테스트

메소드를 더블클릭하면 해당 묘드를 편집기에 보여준다.

테스트 실패라면 그림 2-2와 같은 결과가 나타난다. 이번엔 한 개의 태스트 메소드

가 실패했음을 알 수 있다. 실패한 이유는 뷰의 아래 Failure Trace 항목에 자세히 나와

있다. 태스트 묘드에서 검증에 실패한 assertThat ()의 위치도 나와 있다.


a며

R‘.111 8: 1/1 a Errors: 0 a Fallures: 1

a 삐Il springbook, user‘dao‘UserDaoTesl [Runner: JUnil 41 (0, 782 s)
&깅 I ........π.........

‘


훌 Fallure Trace ::~I
t;!!I
'! java , lang,AssertionError:
Expecled : is 덩t잉철
”
gol: null

=

그림 2-2 이클립스 JUnit 테스트 결과: 테스트 실때

JUnit은 한 번에 여러 테스트 클래스를 동시에 실행할 수도 있다. 이클립스에서는 소
스 트리에서 특정 패커지를 선택하고 컨텍스트 메뉴의 [Run As] >[runit Test]를 실
행하면， 해당 패커지 아래에 있는 모든 JUnit 테스트를 한 번에 실행해준다. 소스 폴더
나 프로젝트 전체를 선택해서 모든 태스트를 한 번에 실행할 수도 있다. 이런 변에서
JUnitCore를 사용해 테스트를 실행하는 것보다 훨씬 편리하다. JUnit 태스트를 실행하
는 이클립스의 단축키를 기억해두면 더욱 빠르고 편하게 태스트를 실행할 수 있다.
1핀D

+
1략패+밍와 따를 순서대로 누르면 선택해둔 클래스나 패키지， 프로젝트의 태스트가
바로실행된다.
이렇게 JUnit 테스트의 실행과 그 결과를 확인하는 방법이 매우 간단하고 직관적이
며 소스와 긴밀하게 연동돼서 결과를 볼 수 있기 때문에， 개발 중에 테스트를 실행하고
자 할 때는 이클립스 같은 IDE의 지원을 받는 것이 가장 편리하다.

빌드툴

프로젝트의 빌드를 위해 ANT나 메이븐Maven 같은 빌드 툴과 스크립트를 사용하고 었
다면， 빌드 툴에서 제공하는 JUnit 플러그인이나 태스크를 이용해 JUnit 태스트를 실행
할 수 있다. 태스트 실행 결과는 옵션에 따라서 HTML이나 텍스트 파일의 형태로 보기

좋게만들어진다.

개발자 개인별로는 IDE에서 JUnit 도구를 활용해 태스트를 실행히는 게 가장 편리
하다. 그런데 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행해야 할 때도 었
다. 이런 경우에는 서버에서 모든 코드를 가져와 통합하고 빌드한 뒤에 테스트를 수행
하는 것이 좋다. 이때는 빌드 스크립트를 이용해 JUnit 태스트를 실행하고 그 결괴를 메
일 등으로 통보받는 방법을 사용하면 된다.

2장-테스트 163



2.3.2 테스트 결과의 일관성
지금까지 JUnit을 적용해서 깔끔한 태스트 코드를 만들었고， 편리하게 실행할 수 있는
툴의 사용 방법도 살며봤다. 하지만 아직도 좀 더 개선했으면 하는 아쉬운 점이 있다.
지금까지 테스트를 실행하면서 가장불편했던 일은， 매번 UserDaoTest 테스트를 실
행하기 전에 DB의 USER 테이블 데이터를 모두 삭제해줘야 할 때였다. 깜빡 잊고 그냥
태스트를 실행했다가는 이전 태스트를 실행했을 때 등록됐던 사용자 정보와 기본커가
중복된다면서 add() 메소드 실행 중에 에러가 발생할 것이다.
여기서 생각해볼 문제는 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 한
다는 점이다. DB 서버가 다운됐다거나 네트워크에 ÀJ-애가 생겨서 DB
에 접근하지 못하
는 예외적인 상황이라면 뭐 이해할 수 있겠는데 지금 발생히는 문제는 별도의 준비 작
업 없이는 성공해야 마땅한 태스트가 실패하기도 한다는 점이다. 반복적으로 태스트를
했을 때 테스트가 실패하기도 하고 성공하기도 한다면 이는 좋은 테스트라고 할 수가
없다. 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 내야 한다.
UserDaoTest의 문제는 이전 테스트 때문에 DB에 등록된 중복 데이터가 있을 수 있
다는 점이다. 가장 좋은 해결책은 addAndGet() 태스트를 마치고 나면 테스트가 등록한
시용자 정보를 삭제해서 테스트를 수행하기 이전 상태로 만들어주는 것이다. 그러면
테스트를 아무리 여러 번 반복해서 실행하더라도 항상 통일한 결과를 얻을 수 있다.

deleteAII()의 getCount( ) 추가
일관성 있는 결괴를 보장하는 테스트를 만들기 위해 준비할 게 있는데， 바로 UserDao에
새로운 기능을 추가해주는 일이다. 그러고 보니 I
징L에서 초난감 DAO를 만든 이후에
처음으로 UserDao에 새로운 기능을 추가하는 것이다.

• deleteAII
첫 번째 추가할 것은 deleteAll() 메소드로. USER 테이블의 모든 레코드를 삭제
해주는 간단한 기능이 있다. UserDao 클래스에 리스트 2-7
에 나오는 메소드를 추
가한다.

리스트 2-7delete，왜
I() 메소드

public void deleteAll() throws SQLException {
Connection c =dataSource.gètConnection();

PreparedStatement ps =c.prepareStatement( “delete from users ");


ps.executeUpdate();

ps . close();
c .close();


add() 메소드와 비슷한 구조인데 파라미터 바인딩이 없으므로 더 단순하다.

• getCount()
두 번째 추가할 것은 getCount() 메소드로. USER 테이블의 레코드 개수를 돌려준
다. 리스트 2-8에서 볼 수 있듯이 get() 메소드와 비슷한 구조다.

리스트 2-8 getCount( ) 메소드

public int getCount() throws SQLException
Connection c =dataSource.getConnection();

PreparedStatement ps = c. prepareStatement("select count(* ) from users");

ResultSet rs = ps .executeQuery();
rs .next();
int count = rs .getlnt(l);

rs . close();
ps. close();
c .close();

return count;

deleteAII()과 getCount( )의 테스트
새로운 기능을 추가했으니， 추가된 기능에 대한 태스트도 만들어야 한다.
그런데 deleteAll()
과 getCount() 메소드의 기능은 add()
와 get()
처럼 독립적으
로 자동 실행되는 테스트를 만들기가 좀 애매하다. 굳이 테스트를 하자면 USER 테이
블에 수통으로 데이터를 넣고 deleteAll ()을 실행한 뒤에 테이블에 남은 게 있는지 확
인해야 하는데， 사람이 태스트 과정에 참여해야 하니 자동화돼서 반복적으로 실행 가능
한 태스트 방법은 아니다. 그래서， 새로운 태스트를 만들기보다는 차라리 기존에 만든

양t 테스트 165


addAndGet () 태스트를 확장하는 방법을 사용하는 편이 더 나을 것 같다. addAndGet ()
테스트의 불편한 점은 실행 전에 수동으로 USER 테이블의 내용을 모두 삭제해줘야 하
는 것이었다. deleteAll ()을 이용하면 테이블의 모든 내용을삭제할수 있으니 이 메소
드를 태스트가 시작될 때 실행해주는 것은 어떨까? 만약 deleteAll() 이 잘 동작한다면
addAndGet() 태스트를 위해 매번 USER 테이블을 수동으로 삭제하는 수고를 하지 않아
도된다.

deleteAll()
을 넣는 것만으로는 조금 부촉하다. deleteAll () 자체도 아직 검증이
안 됐는데 무되대고 다른 태스트에 적용할 수는 없다. 그래서 getCount()
를 함께 적용
해보자. deleteAll ()이 기대한 대로 동작한다면. getCount ()로 례묘드의 개수를 가져
올 경우 0이 나와야 한다. 그러므로 deleteAll()을 실행한 직후에 getCount()의 결과
값을 검증하고 묘드를 넣어보자. 그런데 getCount()
는 잘 동작히는지 어떻게 믿을 수
있을까? getCount ( ) 메소드가 테이블의 레코드 숫자에 상관없이 항상 0을 돌려주는 버
그를 갖고 있다면. de leteAll () 기능을 검증하는 데 사용할 수 없다. 검증 안 된 두 개
를 붙였는데 우연히 태스트가통과한다고 안심하는 것은 바람직하지 못하다.

그래서 getCount()
에 대한 검증 작업을 하나 더 추가한다. 이미 앞에서 add() 메소
드가 정상적으로 DB 태이블에 데이터를 넣는 것을 확인했으니 add()
를 수행하고 나
면 레코드 개수가 0에서 l로 바뀌어야 한다. 그렇다면 add() 메소드를 실행한 뒤에
getCount()
의 결과를 한 번 더 확인해보자. deleteAll() 직후에는 0이 나오고 add()
직후에는 I
이 나온다면. getCount ()의 기능이 바르게 동작한다고 볼 수 있다. 그리고
getCount()
가바르게 동작한다는확신이 있다면. deleteAll() 직후에 항상
0이 나오는
것을 보고 deleteAll ( )의 기능도 바르게 동작한다고 생각할 수 있다.

물론 100% 확실하게 검증하려면 좀 더 꼼꼼하게 태스트를 해야 하겠지만 일단은 이
정도면 충분할 듯싶다. 그래도 미심쩍다면 한 번쯤 수동 테스트를 해보자.

리스트 2-9는 이렇게 deleteAll ()과 getCount()
를 기존 addAndGet () 테스트에 추
가한것이다.

리스트 2-9 delete.μI()과 getCωnt()가 추가된 addAnd(높!<<) 테스트

@Test
public void addAndGet() throws SQLException (

dao.deleteAll();
assertThat(dao.getCount() , is(0));


User user = new User();
user. setId( "gyumee");
user.setName( "박성 철 ");
user.setPassword("springnol");

dao.add(user) ;
assertThat(dao.getCount() , is(1));

User user2 =dao.get(user.getld());

assertThat(user2.getName() , is(user.getName()));
assertThat(user2 .getPassword() , is(user .getPassword()));


동일한 결과를 보짙띈}는 테스트
이제 태스트를 실행해보자. 이클럽스에서 실행했다면 JUnit 뷰에 독색 막대가 나타나면
서 태스트가 성공했다고 나올 것이다. 이번엔 DB
의 테이블을 삭제하는 작업 없이 다시
테스트를 실행해보자. 테스트를 반복해서 여러 번 실행해도 계속 성공할 것이다. 이전
에는 태스트를 하기 전에 매번 직접 DB에서 데이터를 삭제해야 했지만， 이제는 그런 번
거로운 과정이 필요 없어졌다. 태스트가 어떤 상횡에서 반복적으로 실행된다고 하더라
도 동일한 결과가 니올 수 있게 된 것이다. 설령 태스트 수행 직전에 DB에 작업을 하느
라 USER 태이블에 정보를 넣어뒀더라도 이제는 문제가 되지 않는다. addAndGet () 태
스트가 시작될 때 항상 기존의 데이터를 지우고 시작하기 때문이다. 단위 태스트는 코
드가 바뀌지 않는다면 매번 실행할 때마다 동일한 태스트 결괴를 얻을 수 있어야 한다.
동일한 태스트 결과를 얻을 수 있는 다른 방법도 있다. addAndGet () 태스트를 마치
기 직전에 태스트가 변경하거나 추가한 데이터를 모두 원래 상태로 만들어주는 것이다.
add()
를 호출해 데이터를 넣었으므로 검증이 끝나면 deleteAll ()을 실행해서 등록된
User 레코드를 삭제해주는 방법을 생각해볼 수 있다. 물론 이것도 나쁜 방법은 아니다.
하지만 addAndGet () 테스트 실행 이전에 다른 이유로 USER 테이블에 데이터가 들어가
있다면 이때는 태스트가 실패할 수도 있다. addAndGet () 태스트만 DB를 사용할 것이
아니라면 아무래도 이전에 어떤 작업을 하다가 태스트를 실행할지 알 수 없다. 따라서
태스트 후에 USER 테이블을 지워주는 것도 좋지만， 그보다는 태스트하기 전에 테스트
실행에 문제가 되지 않는 상태를 만들어주는 편이 더 나을 것이다.
스프령은 DB를 사용하는 코드를 테스트하는 경우 매우 편리한 테스트 방법을 제공

2장-터ι트 167


해준다. 하지만 아직은 스프링의 기능을 충분히 살펴보지 못했으므로 바로 적용하기는

어렵다. 일단은 이 방법을 당분간 시용하자.

단위 태스트는 항상 일관성 있는 결과가 보장돼야 한다는 점을 잊어선 안 된다. DB

에 남아 있는 데이터와 같은 외부 환경에 영향을 받지 말。바 하는 것은 물론이고， 테스

트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

2.3.3 포괄적인테스트
앞에서 getCount() 메소드를 태스트에 적용하긴 했지만， 기존의 태스트에서 확인할 수
있었던 것은 deleteAll ()을 실행했을 때 테이블이 비어 있는 경위이와 add()
를 한 번
호출한 뒤의 결과1)뿐이다. 두 개 이상의 레코드를 add() 했을 때는 getCount()
의 실행
결과가 어떻게 될까? 뭐，
0과 l 두 가지를 해봤으니 나머지도 당연히 잘될 것이라고 추
정할 수도 있겠지만 미처 생각L하지 못한 문제가 숨어 있을지도 모르니 더 꼼꼼한 태스
트를 해보는 것이 좋은 자세다. 태스트를 안 만드는 것도 위험한 일이지만， 성의 없이
테스트를 만드는 바람에 문제가 있는 코드인데도 태스트가 성공하게 만드는 건 더 위험
하다. 특히 한 가지 결과만 검증하고 마는 것은 상당히 위험하다. 이런 테스트는 마치
하루에 두번은정확히 맞는다는시계와같을수도 있다. 죽은시계 말이다.

getCount( } 테스트
getCount()
에 대한 좀 더 폼꼼한 태스트를 만들어보자. 이번에는 여러 개의 User
를 등록해가면서 getCount()
의 결과를 매번 확인해보겠다. 이 태스트 기능을 기존의
addAndGet () 메소드에 추가하는 건 별로 좋은 생각이 아니다. 태스트 메소드는 한 번
에 한 가지 검증 목적에만 충실한 것이 좋다. 그러므로 getCount()를 위한 새로운 태스
트 메소드를 만들어보자. JUnit은 하나의 클래스 안에 여러 개의 테스트 메소드가 들어
가는 것을 허용한다. @Test가 붙어 있고 public 접근자가 있으며 리턴 값이 void형이고
파라미터가 없다는 조건을 지키기만 하면 된다.
태스트 시나리오는 이렇다. 먼저 USER 테이블의 데이터를 모두 지우고 getCount()
로 레코드 개수가 0임을 확인한다. 그리고 3개의 사용자 정보를 하나씩 추가하면서 매
번 getCount()
의 결과가 하나씩 증가하는지 확인하는 것이다.
태스트를 만들기 전에 먼저 User 클래스에 한 번에 모든 정보를 넣을 수 있도록 리스
트 2-10과 같이 초기화가 가능한 생성자를 추가한다. User 오브젝트를 여러 번 만들고
값을 넣어야 하니， 한 번에 설정 가능한 생성자를 만들어두면 편리하다.


리스트 2-10 파라미터가 있는 User 클래스 생성자

public User(String id , String name , String password) (
this.id =id;
this.name = name;
this.password = password;

public User() (--을
자바빈의 규약을 따르는 클래스에 생성자륭 영시적으로 추가했을 때는
따라미터가 없는 디옳트 생성자도 함께 정의해주는 것올 잊지 말자


새로 만든 생성자를 이용하면 addAndGet () 태스트의 코드도 다음과 같이 간략히 수
정할수있다.

UserDao dao = context.getBean("userDao" , UserDao .class);
User user = new User( "gyumee" , "박성철
"springnol");

이렇게 태스트 코드를 수정한 뒤에도 잊지 말고 태스트를 다시 실행해본다. 모든 코
드의 수정 후에는 그 수정에 영향을 받을 만한 테스트를 실행하는 것을 잊지 말자.

이제 리스트
2-11
과같이 새로운 getCount()
에 대한태스트메소드를작성한다.

리스트 2-11 getCount() 테스트

@Test
public void count() throws SQLException {
ApplicationContext context = new GenericXmlApplicationContext (
"appl icationGontext .xml");

UserDao dao = context.getBean("userDao" , UserDao .class);
User userl = new User("gyumee" , "박성철“， "springnol ") ;
User user2 = new User("leegw700
’기 "01
길원 상
pringno2") ;
User user3 =new User("bumjin
’기 ”박범진" "springno3");

dao.deleteAll();
assertThat(dao.getCount() , is(0));

dao.add(userl);
assertThat (dao .getCount() , iS(l));

dao .add(user2);
assertThat (dao .getCount() , is (2));

2장-테스트 169


dao.add(user3);
assertThat(dao.getCount() , is(3)) ;

먼저 세 개의 User 오브젝트를준비해두고
deleteAll()
을불러 태이블의 내용을모
두 삭제한 뒤에 getCount()가 0임을 확인한다. 그리고 만들어둔 User 오브젝트들을 하
나씩 넣으면서 매번 getCount()
가 하나씩 증가되는지를 확인하면 된다.

이제 테스트를 실행해보면 별문제 없이 성공할 것이다. 태스트 결과를 살펴보면 두
개의 태스트가 모두 실행됐고 실패한 태스트는 하나도 없다고 나올 것이다. 이클립스의
JUnit 뷰에 나온 결과는 그림 2-3과 같다.

a며

R‘108: νe • Error‘: 0 • Fallurea: 0

a 뻐 springbook.user.dao.UserDaoTest [Runner: JUnit 4] (1.203 s)
용 andAndGet (0.719 s)
윌 count (0.484 s)

그림 2-3 JUnit 테스트 결과

주의해야 할 점은 두 개의 태스트가 어떤 순서로 실행될지는 알 수 없다는 것이다.
JUnit은 특정한 태스트 메소드의 실행 순서를 보장해주지 않는다. 태스트의 결과가 태
스트 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다. 예를 들어 addAndGet ()
메소드에서 등록한 사용자 정보를 count() 태스트에서 활용히는 식으로 태스트를 만들
면 안 된다. 모든 태스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결괴를 낼 수
있도록해야한다.

addAndGet( ) 테스트 보완
이번엔 addAndGet () 태스트를 좀 더 보완해보자. add() 후에 레코드 개수도 확인하도록
했고， get()
으로 읽어와서 값도 모두 비교해봤으니 add()
의 기능은 충분히 검증된 것
같다. 하지만 id를 조건으로 해서 사용자를 검색히는 기능을 가진 get()
에 대한 테스트
는 조금 부족한 감이 있다. get()
이 파라미터로 주어진 id
에 해당히는 사용자를 가져온
것인지， 그냥 아무거나 가져옹 것인지 테스트에서 검증하지는 못했다.
그래서 get() 메소드에 대한 태스트 기능을 좀 더 보완할 필요가 있다. User를 하나
더 추가해서 두 개의 User를 add( ) 하고， 각 User의 id를 파라미터로 전달해서 get()을


실행하도록 만들어보자. 이렇게 하면 주어진 id
에 해당하는 정확한 User 정보를 가져오
는지 확인할 수 있다. 리스트 2-12는 get()
에 대한 태스트 기능이 보완된 addAndGet( )
테스트코드다.

리스트 2-12 get() 테스트 기능율 보완한 add야1dGet() 테스트

@Test
public void addAndGet() throws SQLException (

UserDao dao =context .getBean("userDao" , UserDao
'springnol');
'springno2');
.class);
User userl =new User("gyumee ' , ，
박성철
User user2 = new User("leegw7ÐÐ" , .이길원，


dao .deleteAll(); 중복되지 않는 강올 가진 두 개의
assertThat(dao .getCount() , is(0)); User 오브젝딛룰 준비해둔다

dao.add(user1);
dao.add(user2);
assertThat(dao.getCount() , iS(2)); 첫 번째 user의 잉로 geO을 실행하면 첫 번째 User의

강을 가진 오브젝트를 돌려주는지 확인한다

User usergetl = dao .get(userl .getld());
assertThat(usergetl.getName() , is(userl.getName()));
assertThat(usergetl.getPassword() , is(userl.getPassword()));

User userget2 =dao.get(user2.getld());
assertThat(userget2.getName() , is(user2.getName()));
assertThat(userget2.getPassword() , is(user2.getPassword()));

두 번째 User에 대해서도 같은 방법으로 검증한다

이제 테스트를 실행해보자.

이렇게 해서 get() 메소드가 기대한 대로 동작하는지를 좀 더 확신할 수 있게 됐다.

get( ) 예외조건에 대한 테스트
한 가지 더 생각해볼 문제가 있다. get() 메소드에 전달된 id 값에 해당히는 시용자 정
보가 없다면 어떻게 될까? 이런 경우는 아직까지 생각해본 적이 없다. 이럴 땐 어떤 결
과가 나오면 좋을까? 두 가지 방법이 있을 것이다. 하나는 null과 같은 특별한 값을 리
턴하는 것이고， 다른 하나는 id에 해당하는 정보를 찾을 수 없다고 예외를 던지는 것이
다. 각기 장단점이 있다. 여기서는후자의 방법을써보자.

걷L 테스트 171


주어진 id
에 해당하는 정보가 없다는 의미를 가진 예외 클래스가 하나 필요하
다. 예외를 하나 정의할 수도 있지만 조금 귀찮은 관계로， 스프링이 미리 정의해
놓은 예외를 가져다 쓰도록 하겠다. 스프링이 정의한 데이터 액세스 예외 클래스
들이 있는데， 이에 대한 자세한 활용법은 나중에 다시 설명하겠다. 일단 스프링의
EmptyResultDataAccessException 예외를 이용하겠다.

UserDao의 get() 메소드에서 쿼리를 실행해 결과를 가져왔을 때 아무것도 없으면 이
예외를 던지도록 만들면 된다. 그런데 코드를 만들기 전에， 먼저 이런 경우를 어떻게 테
스트 묘드로 만들지 생킥해보자. 일반적으로는 태스트 중에 예외가 던져지면 테스트 메
소드의 실행은 중단되고 태스트는 실패한다. assertThat()을 통한 검증 실패는 아니고
테스트 에러라고 볼 수 있다. 그런데 이번에는 반대로 테스트 진행 중에 특정 예외가 던
져지면 테스트가 성공한 것이고 예외가 던져지지 않고 정상적으로 작업을 마치면 테스
트가 실패했다고 판단해야 한다. 문제는 예외 발생 여부는 메소드를 실행해서 리턴 값
을 비교하는 방법으로 확인할 수 없다는 점이다. 즉 assertThat () 메소드로는 검증이
불가능하다.

그런데 바로 이런 경우를 위해 JUnit은 예외조건 태스트를 위한 특별한 방

법을 제공해준다. 일단 테스트 메소드를 하나 더 추가하자. 테스트 방법은 간단

하다. 우선 모든 데이터를 지우고， 존재하지 않는 id로 get()을 호출한다. 이때

EmptyResultDataAccessException
이 던져지면 성공이고， 아니라면 실패다.

JUnit의 예외 태스트 기능의 이용하면 리스트 2-13과 같이 테스트를 만들 수 있다.

리스트 2• 13 get() 메소드의 예외상황에 대한 테스트

테스트 중에 벌생힐 것으로

@Test(expected
=E
mptyResultDataAccessException
.
class)-융 기대하는 예외 클래스톨 지정
public void getUserFailure() throws SQLException { 해중다
ApplicationContext context = new GenericXmlApplicationContext (
"applicationContext .xml");

UserDao dao = context.getBean("userDao" , UserDao.class);

dao.deleteAll();

assertThat(dao.getCount() , is(0));

dao.get( "unknown_id");---.. 이 메소드 실행 중에 예외가 잃생해야 한다

예외가 빌생하지 않으면 테스드가 싫때흔κt

태스트 코드는 간단하다. 모든 User 데이터를 지우고 존재하지 않는 id로 get() 메


견

i

g-g

뺑

뼈

랜뼈짧

으 켜〕
건

파

즉그;

값

고

드큰만

으

조

용

a


public User get(String id) throws SQLException {

ResultSet rs = pS .executeQuery();

User user =null; ~ User는 null 상태로 초기
화해놓는다
if (rs.next()) {
=new User(); d

있

기시과

나

소드를 실행히는 게 전부다. 이 태스트에서 중요한 것은 @Test 애노테이션의 expected
엘리먼트다. expected는 태스트 메소드 실행 중에 발생하리라 기대히는 예외 클래스를
넣어주면된다.

@Test
에 expected를 추가해놓으면 보통의 태스트와는 반대로， 정상적으로 테스트
메소드를 마치면 테스트가 실패하고. expected
에서 지정한 예외가 던져지면 태스트
가 성공한다. 예외가 반드시 발생해야 하는 경우를 태스트하고 싶을 때 유용하게 쓸
수있다.

자， 그런데 이 테스트를 실행시키변 어떻게 될까? 당연히 테스트는 실패한다. get()
메소드에서 쿼리 결과의 첫 번째 로우。w를가져오게 하는
rs .
next()
를실행할때 가져
올 로우가 없다는 SQLException
이 발생할 것이다. 아직 UserDao 코드에는 손을 대지 않
았으니 실패하는 것이 당연하다.

테스트률 성공시키기 위한 코드의 수정
이제부터 할 일은 이 태스트가 성공하도록 get() 메소드 코드를 수정하는 것이다. 코드
를 수정하고 나서 테스트를 실행해봐서 테스트가 성공한다면 원하는 기능을 가진 묘드
가 제대로 만들어졌다고 보면 된다. 태스트가 실패하면 원인을 파악해서 코드를 다시
수정하고 성공할 때까지 태스트를 돌려보자.
연구를 거듭한 끝에 주어진 i d
에 해당하는 데이터가 없으면
EmptyResultDataAccessException을 던지는 get() 메소드를 만들어냈다. 리스트 2-14
가바로그것이다.

리스트 2-14 데이터톨 찾지 못하면 예외톨 발생시키도록 수정한 get() 메소드

user

user.setId(rs.getString('id‘));
user.setName(rs.getString("name"));
user.setPassword(rs.getString("password"));

2징-터아트 173

rs. close();
ps .close();


c. c1 ose() ; 결과가없으연 뼈f는
null
상태그대로일 것이다
이훌 확인해서 예외훌 던져준다
4

if (user == null) throw new EmptyResultDataAccessException(l);
return user;

자， 이제 태스트를 다시 실행해보자. 이번엔 분명히 성공할 것이다. 태스트를 할 때
는 기존에 만들어둔 두 개의 태스트도 함께 실행한다. 세 개의 태스트가 모두 성공했다
면， 새로 만든 getUserFailure() 태스트뿐만 아니라 기존에 get()
으로 사용자 정보를
가져오는 addAndGet () 테스트도 성공한 것이다. 따라서 get()
으로 정상적인 결과를 가
져오는 경우와 예외적인 경우에 대해 모두 테스트가 성공한 셈이다. 만약 get() 메소드
에 예외를 발생시커는 기능을 추가하다가 기존 코드를 잘못 건드혔을 경우 정상적인 조
건하에서 get()
을 실행시켰을 때 문제가 발생할 수도 있다. 이때는 addAndGet () 태스트
가 실패할 테니， 이를 확인하고 다시 get() 메소드의 오류를 집。}주면 된다. 최종적으
로 모든 태스트가 성공하면， 새로 추가한 기능도 정상적으로 동작하고 기존의 기능에도
영향을 주지 않았다는 확신을 얻을 수 있다.

포괄적인테스트
사실 JDBC를 이용한 DAO를 개발해본 경험이 많은 개발자라면， 이 정도의 간단한
DAO는 굳이 이런 다양한 테스트를 하지 않고 코드만 살펴봐도 문제가 생기지 않으리
라고자신할수 있을지도모르겠다. 하지만 이렇게 DAO의 메소드에 대한포괄적인 태
스트를 만들어두는 편이 훨씬 안전하고 유용하다. 특히 평소에는 정상적으로 잘 동작
하는 것처럼 보이지만막상특별한상황이 되면 엉뚱하게 동작하는코드를 만들었는데
태스트도 안 해봤다면， 나중에 문제가 발생했을 때 원인을 찾기 힘들어서 고생하게 될
지도 모른다. 종종 단순하고 간단한 테스트가 치명적인 실수를 피할 수 있게 해주기도
한다.
개발까 태스트를 직접 만들 때 자주 하는 실수가 하나 있다. 바로 성공히는 테스트
만 골라서 만드는 것이다. 개발자는 머릿속으로 이 코드가 잘 돌아기는 케이스를 상상
하면서 코드를 만드는 경우가 일반적이다. 그래서 테스트를 작성할 때도 문제가 될 만
한 상황어나， 입력 값 등은 교묘히도 잘 피해서 묘드를 만드는 습성이 있다. 이건 태스
트 코드를 통한 자동 태스트뿐 아니라，
UI를 통한 수동 테스트를 할 때도 빈번하게 발생
하는 문제다. 개발자들은 “내 PC에서는 잘 되는데”라는 변명을 곧잘 히는데， 이는 사실


개발자 PC에서 테스트할 때는 예외적인 상황은 모두 피하고 정상적인 케이스만 테스트

해봤다는 뭇이다. 이런 이유 때문에 QA팀이나 고객의 인수담당자에 의해 꼼꼼하게 준

비된 시나리오를 따라 다OJ'한 경우에 대한 전문적인 테스트가 수행될 펼요가 있다.

하지만 개발자도 조금만 신경을 쓰면 자신이 만든 코드에서 발생할 수 있는 다양한

상황과 입력 값을 고려하는 포괄적인 테스트를 만들 수 있다. 스프링의 창시자인 로드

존슨은 “항상 네거티브 태스트를 먼저 만들라”는 조언을 했다. 개발자는 빨리 태스트를

만들어 성공히는 것을 보고 다음 기능으로 나。}가고 싶어하기 때문에， 긍정적인 경우를

골라서 성공할 만한 태스트를 먼저 작성하게 되기가 쉽다.

그래서 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

get() 메소드의 경우라면， 존재하는 id가 주어졌을 때 해당 레묘드를 정확히 가져오는

가를 테스트하는 것도 중요하지만， 존재하지 않는 id가 주어졌을 때는 어떻게 반응할지

를 먼저 결정하고， 이를 확인할 수 있는 태스트를 먼저 만들려고 한다면 예외적인 상황

을빠뜨리지 않는폼꼼한 개발이 가능하다.

2.3.4 테스트가 이끄는 개발
get() 메소드의 예외 태스트를 만드는 과정을 다시 돌아보면 한 가지 흥미로운 점을 발
견할 수 있다. 작업한 순서를 잘 생각해보면 새로운 기능을 넣기 위해 UserDao 코드를
수정하고， 그런 다음 수정한 묘드를 검증하기 위해 태스트를 만드는 순서로 진행한 것
이 아니다. 반대로 태스트를 먼저 만들어 테스트가 실패하는 것을 보고 나서 UserDao의
코드에 손을 대기 시작했다. 태스트할 묘드도 안 만들어놓고 테스트 코드부터 만드는
것은 좀 이상하다고 생각할지 모르겠다. 그런데 이런 순서를 따라서 개발을 진행하는
구체적인 개발 전략이 실제로 존재한다. 게다가 많은 전문적인 개발자가 이런 개발 방
법을 적극적으로 사용하고 있다.

기능설계를위한테스트
다시 우리가 한 작업을 돌이켜보자. 가장 먼저 ‘존재하지 않는 id로 get() 메소드를 실
행하면 특정한 예외가 던져져야 한다’는 식으로 만들어야 할 기능을 결정했다. 그러고
나서 UserDao 코드를 수정하는 대신 getUserFailure() 태스트를 먼저 만들었다. 테스
트할 코드도 없는데 어떻게 태스트를 만들 수 있었을까? 그것은 만들어진 묘드를 보고
이것을 어떻게 테스트할까라고 생각하면서 getUserFailure()
를 만든 것이 아니라， 추
가하고 싶은 기능을 코드로 표현하려고 했기 때문에 가능했다.

옆L 테스트 175


getUserFailure() 테스트에는 만들고 싶은 기능에 대한 조건과 행위， 결과에 대한
내용이 잘표현되어 있다. 태스트묘드의 내용을정리해보면표
2-1
과같다.
표 2-1 getUserFailure() 테스트 코드에 나타난 기능

; | 단계 | 내용 l 코드 |

조건 어떤조건을
가지고
가져올 사용자 정보가 존재하지
않는경우에
dao.deleteAII( );
assertThat(dao.getCount(). is(O));
행위 무엇을할때 존재하지 않는 id
로 get()
을
실행하면
get("unknown_id");
결과 어떤결과가
나온다
특별한예외가던져진다 @Test(expected=
EmptyResultDataAccessException.class)

이렇게 비교해보면 이 태스트 코드는 마치 잘 작성된 하나의 기능정의서처럼 보인
다. 그래서 보통 기능설계， 구현， 테스트라는 일반적인 개발 흐름의 기능설계에 해당하
는 부분을 이 테스트 코드가 일부분 담당하고 있다고 볼 수도 있다. 이런 식으로 추가하
고 싶은 기능을 일반 언어가 아니라 태스트 코드로 표현해서， 마치 코드로 된 설계문서
처럼 만들어놓은 것이라고 생각해보자. 그러고 나서 실제 기능을 가진 애플리케이션 코
드를 만들고 나면， 바로 이 테스트를 실행해서 설계한 대로 코드가 동작히는지를 빠르
게검증할수있다.

만약 테스트가 실패하면 이때는 설계한 대로 코드가 만들어지지 않았음을 바로 알
수 있다. 그리고 문제가 되는 부분이 무엇인지에 대한 정보도 테스트 결괴를 통해 얻을
수 있다. 다시 코드를 수정하고 태스트를 수행해서 태스트가 성공하도록 애플리케이션
코드를 계속 다듬어간다. 결국 태스트가 성공한다면 그 순간 코드 구현과 태스트라는
두 가지 작업이 동시에 끝나는 것이다. 흥미로운 방법이 아닌가?

테스트주도개발
만들고자 하는 기능의 내용을 담고 있으면서 만들어진 묘드를 검증도 해줄 수 있도록
테스트 코드를 먼저 만들고 태스트를 성공하게 해주는 코드를 작성히는 방식의 개발
방법이 있다. 이를 테스트 주도 개발'TDD. Test Driven Development이라고 한다. 또는 태스트를
묘드보다 먼저 작성한다고 해서 테스트 우선 개발Test First Development이라고도 한다.TDD

는 개발자가 태스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고
볼 수 있다. “실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다는
것이 TDD의 기본 원칙이다. 이 원칙을 따랐다면 만들어진 모든 코드는 빠짐없이 테스
트로 검증된 것이라고 볼 수 었다.


개발지들이 정신없이 개발을 하다 보면 사이사이 테스트를 만들어서 코드를 점검할
타이밍을 놓치는 경우가 많다. 빨리 기능을 완성하고 싶은 욕구 때문일 수도 있고， 한번
집중하면 정신없이 빠져드는 습성 때문이기도 하다. 문제는 코드를 만들고 나서 시간이
많이 지나면 테스트를 만들기가 귀찮아진다는 점이다. 또， 작성한 코드가 많기 때문에
무엇을 태스트해야 할지 막막할 수도 있다. 결국 테스트 작성은 자꾸 뒷전으로 밀려나
거나 점점 더 성의 없는 태스트를 만들게 될지도 모른다.

TDD
는 。애 태스트를 먼저 만들고 그 태스트가 성공하도록 하는 코드만 만드는 식
으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들어낼 수 있다. 또한 태스트
를 작성히는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아진다. 사실 코드
를 만들고 테스트를 수행할 때까지 걸리는 시간은 0에 기깝다. 이미 테스트를 만들어뒀
기 때문에 묘드를 작성하면 바로바로 태스트를 실행해볼 수 있기 때문이다. 그 덕분에
코드에 대한 피드백을 매우 빠르게 받을 수 있게 된다. 또， 매번 테스트가 성공히는 것
을 보면서 작성한 코드에 대한 확신을 가질 수 있어 가벼운 마음으로 다음 단계로 넘어
갈 수가 있다. 한편으로는 자신감을， 다른 한편으로는 미음의 여유를 주는 방법이다.

TDD에서는 테스트 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 기능
한 한 짧게 가져가도록 권장한다. 태스트를 반나절 동안이나 만들고 오후 내내 태스트
를 통과시키는 코드를 만드는 식의 개발은 그다지 좋은 방법이 아니다. 1
징F에서부터 지
금까지 U
ser
Dao를 만들고 태스트를 만들고 계속해서 코드를 개선하고 태스트도 추가
하면서 발전시켜온 과정을 한번 돌이켜보자. 매 단계 묘드를 수정하거나 추가한 다음에
태스트로 검증히는 작업을 반복했다. 각 단계를 진행하는 데는 보통 몇 분에서 길어야
10분 정도면 충분했다. 처음에는 UserDao 묘드를 먼저 만들고 나서 태스트를 만들긴 했
지만， 그 후에는 단위 태스트의 장점을 이용해 코드를 개선하는 동안 계속 테스트를 활
용할 수 있었다. 마지막 예외처 리 기능을 만들 때는 테스트를 먼저 만드는 것도 해봤다.

TDD를 하면 자연스럽게 단위 테스트를 만들 수 있다. 빠르게 자동으로 실행할 수
있는 단위 테스트가 아니고서는 이런 식의 개발은 거의 불기능하다. 태스트할 때마다
서버를 띄우고 재배치히는 시간이 필요하다면， 테스트를 지주 하기 귀찮을 태고 테스트
는 점점 뒤로 미뤄질 것이다.

사실 모든 개발자는 TDD
를 몰라도 이미 테스트가 개발을 이꿀어가는 방식으로 개
발을 하고 있다고 생각한다. 한번 생
ζL해보자. 새로운 기능을 가진 코드를 만들려고 하
는 순간， 개발자의 머릿속에서는 ‘이런 조건하에서 이런 작업을 하면 이런 결과가 나올
것
이
다’라는 식으로 기능을 먼저 정리하게 될 것이다. 그리고 코드를 작성히는 동안에도
코드를 눈으로 훌어보면서 ‘이런 조건의 값이 들어오면 묘드의 흐름과 조건을 따라 이

2징-테스트 177


렇게 진행돼서 이런 결과 값이 나오겠다’라는 식으로 시율레이션을 계속 하게 된다. 그
렇다면 개발자의 머릿속에서는 테스트가 미리 만들어지고 개발 중에 계속 실행된다고
볼 수도 있지 않을까? 코드를 살펴보다가 이런 경우에는 문제가 발생하겠다는 생각이
들면 코드를 수정할 것이다. 태스트가 실패했으니 테스트가 성공하도록 코드를 수정하
는것과다를바없다.

문제는 이렇게 머릿속에서 진행되는 태스트는 제약이 심하고， 오류가 많고， 나중에
다시 반복하기가 힘들다는 점이다. 그래서 차라리 머릿속에서 복잡하게 진행하던 작업
을 실제 묘드로 끄집어 내놓으면 이게 바로 TDD가 된다. TDD는 처음에는 이상하게
보일지 모르겠지만 사실은 매우 자연스러우며， 한번 익숙해지고 나면 TDD가 아니고
는 개발을 못하겠다고 할지도 모를 만큼 매력적인 방법이다.

TDD의 장점 중 하나는 코드를 만들어 태스트를 실행하는 그 사이의 간격이 매우 짧
다는 점이다. 개발한 코드의 오류는 빨리 발견할수록 좋다. 빨리 발견된 오류는 쉽게 대
응이 가능하기 때문이다. 테스트 없이 오랜 시간 동안 코드를 만들고 나서 태스트를 하
면， 오류가 발생했을 때 원인을 찾기가 쉽지 않다. 예외는 A라는 곳에서 발생했는데 사
실 원인은 Z에 있을 수도 있기 때문이다. 진작에 간단한 태스트를 해봤으면 미리미리
쉽게 발견할 수 있었던 사소한 문제도， 나중에 많은 묘드와 얽혀서 돌。}가는 상황11서
는 쉽게 찾지 못하는 경우가 많다. 개발자틀이 낭만이라고도 생
ζL하는 ‘눈물 젖은 커피
와 함께 며칠간 밤샘을 하며 오류를 잡으려고 애쓰다가 전혀 생각지도 못했던 곳에서
간신히 찾아낸 작은 버그 하나의 추억’이라는 건， 사실 ‘진작에 충분한 테스트를 했었다
면 쉽게 찾아냈을 것을 미루고 미루다 결국 커다란삽질로 만들어버린 어리석은 기억’일
뿐이다.

태스트는 코드를 작성한 후에 기능한 빨리 실행할 수 있어야 한다. 그러려면 테스트
없이 한 번에 너무 많은 코드를 만드는 것은 좋지 않다. 태스트를 먼저 만들어두면 코딩
이 끝나자마자바로 테스트를 실행할수 있으니 가장좋은 방법이다. 하지만 이런 방법
이 불편하다면 일정 분량의 코딩을 먼저 해놓고 빠른 시간 안에 테스트 코드를 만들어
태스트해도상관없다.

혹시 태스트를 만들고 지주 실행하면 개발이 지연되지 않을까 염려할지도 모르겠다.
그렇지 않다. 테스트는 애플리케이션 코드보다 상대적으로 작성하기 쉬운데다 각 태스
트가 독립적이기 때문에， 코드의 %에 비해 작성하는 시간은 얼마 걸리지 않는다. 게다
가 테스트 덕분에 오류를 빨리 집아낼 수 있어서 전체적인 개발 속도는 오히려 빨라진
다. 테스트 코드를 만들지 않아도 언젠가는 웹 화면을 통한 테스트라도 하게 될 것이다.
이런 테스트의 비효율성을 생각해보면 미리미리 단위 테스트를 만들어서 코드를 검증


해두는 편이 낫다. 일단 서버에 올려서 태스트를 하면 묘드 한 줄을 수정해도 다시 서버

를 재시작해야 하는 느리고 지루한 과정을 반복해야 히는데， 이때 걸리는 시간과 태스

트 코드를 미리 만드는 시간을 비교해보면 태스트 코드를 일찍 만들어서 테스트하는 편

이 더 낫다는 사실을 알게 될 것이다.

그럼에도 왜 개발자가 테스트를 잘 만들지 않는 것일까? 그 이유는 엔터프라이즈 애

플리케이션의 테스트를 만들기가 매우 어렵다고 생각하기 때문이다. 실제로 스프링이

등장하기 전에는 JavaEE 애플리케이션에 대한 태스트를 만들기가 매우 힘들었다. 또

는 단위 테스트를 만들기에는 구조가 어려웠던 애플리케이션 코드가 많았다. 하지만 이

제는 안심해도 된다. 스프링은 태스트하기 편리한 구조의 애플리케이션을 만들게 도와

줄 뿐만 아니라， 엔터프라이즈 애플리케이션 태스트를 빠르고 쉽게 작성할 수 있는 매

우 편리한 기능을 많이 제공하기 때문이다. 스프령이 제공하는 각종 태스트 지원 기능

에 대해서는 이 책 전반에 걸쳐 계속 설명할 것이다.

2.3.5 테스트코드개선
지금까지 세 개의 태스트 메소드를 만들었다. 이쯤 해서 태스트 코드를 리팩토링해보
자. 애플라케이션 코드만이 리팩토링의 대상은 아니다. 필요하다면 테스트 묘드도 언제
든지 내부구조와 설계를 개선해서 좀 더 깔끔하고 이해하기 쉬우며 변경이 용이한 묘드
로 만들 필요가 있다. 태스트 코드 자체가 이미 자신에 대한 테스트이기 때문에 태스트
결과가 일정하게 유지된다면 얼마든지 리팩토링을 해도 좋다.

UserDaoTest 묘드를 잘 살펴보면 기계적으로 반복되는 부분이 눈에 띈다. 디음과 같
이 스프링의 애플리케이션 컨텍스트를 만드는 부분과 컨돼스트에서 UserDao를 가져오
는부분이다.

ApplicationContext context =

new GenericXmlApplicationContext(
녀pplicationContext.xml");

User dao =context .getBean("userDao" , UserDao .class);

중복된 코드는 별도의 메소드로 뽑아내는 것이 가장 손쉬운 방법이다. 그런데 이번
에는 일반적으로 사용했던 메소드 추출 리패토링 방법 말고 JUnit이 제공하는 기능을
활용해보겠다. JUnit 프레임워크는 테스트 메소드를 실행할 때 부가적으로 해주는 작업
이 몇 가지 있다. 그중에서 테스트를 실행할 때마다 반복되는 준비 작업을 별도의 메소
드에 넣게 해주고， 이를 매번 테스트 메소드를 실행하기 전에 먼저 실행시켜주는 기능
이다.

2징-테스트 179


먼저 세 개의 테스트 메소드에 반복적으로 등장하는 앞의 코드를 제거한다.

@Before

중복됐던 코드를 넣을 setUp()
이라는 이름의 메소드를 만들고 테스트 메소드에서 제거
한 묘드를 넣는다. 그런데 문제는 태스트 메소드에서 필요한 dao 변수가 setUp() 메소
드의 로컬 변수로 되어 었다는 점이다. 그래서 이번엔 로컬 변수인 dao를 태스트 메소
드에서 접근할 수 있도록 인스턴스 변수로 변경한다. setUp()
에서는 getBean()
이 돌
려주는 UserDao 오브젝트를 인스턴스 변수로 선언한 dao에 저장하게 한다. 마지막으로
setUp() 메소드에 @Before라는 애노테이션을 추가해준다. 리스트 2-15는 이렇게 수정
한묘드다.

리스트 2-15 홍복 코드톨 제거한 UserD∞ITe51

import org.iunit.Before;

public class UserDaoTest (
setUP( ) 메소드에서 만드는 오브젝트톨 테스트 메소드에서private UserDao dao;-을
사용할 수 있도록 인스턴스 연수로 선언효
tcl

OBefore _ ~~rt이 저|공꿇 애노테이션 @TesI 머|소드가 실행되기
전에 먼저 실행돼야 하는 메소드툴 정의효tc-f.

public void setUp() (

ApplicationContext context =

new GenericXmlApplicationContext("applicationContext.xml");
this.dao = context.getBean("userDao" , UserDao.class);

각 테스트 메소드에 반목적으로 나타났던
코드를 제거하고 멸도의 메소드로 옳긴다

@Test
public void addAndGet() throws SQLException (

@Test
public void count() throws SQLException (

@Test(expected=타IptyResultDataAccessException.class)

public void getUserFailure() throws SQLException {


이렇게 수정한 뒤에 테스트를 실행해보자. 이전과 마찬가지로 태스트가 모두 성공할
것이다. 어떻게 된 것일까? 이를 이해하려면 JUnit 프레임워크가 태스트 메소드를 실행
히는 과정을 알아야 한다. 프레임워크는 스스로 제어권을 가지고 주도적으로 동작하고，
개발자가 만든 코드는 프레임워크에 의해 수동적으로 실행된다. 그래서 프레임워크에
사용되는 코드만으로는 실행 흐름이 잘 보이지 않기 때문에 프레임워크가 어떻게 사용
할지를잘이해하고있어야한다.

JUnit이 하나의 태스트 클래스를 가져와 테스트를 수행하는 방식은 다음과 같다.

1. 테스트 클래스에서 @Test가붙은 public이고 void형이며 파라미터가 없는 태스트
메소드를모두찾는다.
2. 테스트 클래스의 오브젝트를 하나 만든다.
3. @Before가 붙은 메소드가 있으면 실행한다.
4. @Test가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
5. @After가 붙은 메소드가 있으면 실행한다.
6. 나머지 테스트 메소드에 대해 2~5변을 반복한다.
7. 모든 테스트의 결과를 종합해서 돌려준다.
실제로는 이보다 더 복잡한데 간단히 정리하면 JUnit 태스트는 위의 7단계를 거쳐
서 진행된다고 볼 수 있다.

JUnit은 @Test가 붙은 메소드를 실행하기 전과 후에 각각 @Before와 @Af
ter
가 붙
은 메소드를 자통으로 실행한다. 보통 하나의 태스트 클래스 안에 있는 테스트 메소드
들은 공통적인 준비 작업과 정리 작업이 필요한 경우가 많다. 이런 작업들을 @Before,
@Af
ter
가 붙은 메소드에 넣어두면 JUnit이 자동으로 메소드를 실행해주니 매우 편리하
다. 각 테스트 메소드에서 직접 setUp( )과 같은 메소드를 호출할 필요도 없다.

대신 @BeforeLf @After 메소드를 태스트 메소드에서 직접 호출하지 않기 때문에 서
로 주고받을 정보나 오브젝트가 었다면 인스턴스 변수를 이용해야 한다. UserDaoTest
에서는스프링 컨테이너에서 가져온
UserDao 오브젝트를 인스턴스 변수
dao
에 저장해
뒀다가， 각 테스트 메소드에서 사용하게 만들었다.

또 한 가지 꼭 기억해야 할 사항은 각 테스트 메소드를 실행할 때마다 태스트 클래스
의 오브젝트를 새로 만든다는 점이다. 한번 만들어진 태스트 클래스의 오브젝트는 하나
의 테스트 메소드를 시용하고 나면 버려진다. 테스트 클래스가 @Test 테스트 메소드를
두 개 갖고 있다면， 테스트가 실행되는 중에 JUnit은 이 클래스의 오브젝트를 두 번 만
들 것이다. 그림 2-4는 JUnit이 이렇게 테스트를 실행하는 방법과 순서를 보여준다.

2징-테스트 181


XXXTest


@Before setUpO
@Test testMethodl0
@After tearDownO

JUnit
Framework


XXXTest

@Before setUpO
@Test testMethod20
@After tearDown()

、


‘
그림 2-4 JUnit의 테스트 메소드 실행 방법

/

/

그런데， 왜 테스트 메소드를 실행할 때마다 새로운 오브젝트를 만드는 것일까? 그냥 테
스트 클래스마다 하나의 오브젝트만 만들어놓고 사용하는 편이 성능도 낫고 더 효율적
이지 않을까? JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을
확실히 보장해주기 위해 매번 새로운 오브젝트를 만들게 했다. 덕분에 인스턴스 변수도
부담 없이 사용할 수 있다. 어차피 다음 태스트 메소드가 실행될 때는 새로운 오브젝트
가 만들어져서 다 초기화될 것이다.

테스트 메소드의 일부에서만 공통적으로 사용되는 묘드가 있다면 어떻게 해야 할까?
이때는 @Before를 사용하기보다는， 일반적인 메소드 추출 방법을 써서 메소드를 분리
하고 테스트 메소드에서 직접 호출해 사용하도록 만드는 편이 낫다. 아니면 아예 공통
적인 특징을 지닌 테스트 메소드를 모아서 별도의 태스트 클래스로 만드는 방법도 생각
해볼수있다.

픽스처
테스트를 수행히는 데 펼요한 정보나 오브젝트를 픽스처fixture라고 한다. 일반적으로 벽
스처는 여러 태스트에서 반복적으로 샤용되기 때문에 @Before 메소드를 이용해 생성해
두면 편리하다. UserDaoTest에서라면 dao가 대표적인 픽스처다. 태스트 중에 add() 메

소드에 전달히는 User 오브젝트들도 팩
스처라고 볼 수 었다. 이 부분도 테스트 메소드
에서 중복된 코드가 보인다. 중복을 제거하기 위해 @Before 메소드로 추출해보자. 그런
데 getUserFailure() 테스트에서는 이 User 오브젝트가 사용되진 않는다. 그럼에도 이
User 오브젝트들은 @Before에서 생성하도록 만드는 게 니을 것 같다. 앞으로 UserDao


의 기능이 계속 만들어지고 그에 따라 테스트 메소드도 계속 추가될 댄데 UserDao에 대
한 테스트라면 대부분 User 오브젝트를 사용할 것이기 때문이다.

먼저 userl , user2 , user3 세 가지 인스턴스 변수를 선언하고 오브젝트 생성은
@Before 메소드에서 진행한다. 어차피 매번 새로운 태스트 오브젝트가 만들어지니까
인스턴스 변수에서 바로 초기화해도 상관없다. 하지만 픽스처 생성 로직이 흩어져 있
는 것보다는 모여 있는 편이 니을 테니 가능한 한 @Before 메소드를 이용하자. 리스트
2-16은 이렇게 User 픽스처로 재구성한 태스트 코드다.

리스트 2-16 U똥r 픽스처툴 적용한 UserD∞，Test


public class UserDaoTest {
private UserDao dao;
private User userl;
private User user2;
private User user3;

OOefore

public void setUp() {

this.userl = new User( ’‘ gyumee" ’ "박성철’， .springnol");
this.user2 = new User("leegw7ØØ" , ‘이길원" "springno2");
this.user3 =new User("bumjin" , "박범진 깨
pringno3") ;

수정된 테스트를실행해서 성공하는지 확인해보자.

I~ 스프링 테스트 적용 펠; I

이제 태스트 코드도 어느 정도 깔끔하게 정리를 마쳤다. 하지만 아직 한 가지 찜찜한
부분이 남아 있는데， 바로 애플리케이션 컨텍스트 생성 방식이다
@Before 메소드가
태스트 메소드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트도 세 번 만들어진다.
지금은 설정도 간단하고 빈도 몇 개 없어서 별문제 아닌 듯하지만， 빈이 많아지고 복잡
해지변 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다. 애플리케이션
컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다. 단순히 빈 오브젝

2징-테스트 183


트를 만드는 정도라면 상관없지만 어떤 빈은 오브젝트가 생성될 때 자체적인 초기화

작업을 진행해서 제법 많은 시간을 펼요로 하기 때문이다. 또 한 가지 문제는 애플리케

이션 컨텍스트가초기화될 때 어떤 빈은독자적으로 많은 리소스를할당하거나독립적

인 스레드를 띄우기도 한다는 점이다. 이런 경우에는 태스트를 마칠 때마다 애플리케

이션 컨텍스트 내의 빈이 할당한 리소스 등을 깔끔하게 정리해주지 않으면 다음 테스

트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수도 있다.

테스트는 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어서 사용히는 것이 원

칙이다. 하지만 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우

에는 태스트 전체가 공유하는 오브젝트를 만들기도 한다. 이때도 테스트는 일관성 있는

실행 결과를 보장해야 하고 테스트의 실행 순서가 결과에 영향을 미치지 않아야 한다.

다행히도 애플리케이션 컨텍스트는 초기화되고 나면 내부의 상태가 바뀌는 일은 거의

없다. 빈은 싱글톤으로 만들었기 때문에 상태를 갖지 않는다. UserDao 빈을 가져다가

add (), get () 메소드 둥을 사용한다고 해서 UserDao 빈의 상태가 바뀌진 않는다. DB
의

상태는 각 테스트에서 알아서 관리할 것이므로 문제가 되지 않는다. 따라서 애플리케이

션 컨텍스트는 한 번만 만들고 여러 태스트가 공유해서 시용해도 된다.

문제는 JUnit이 매번 태스트 클래스의 오브젝트를 새로 만든다는 점이다. 따라서 여

러 테스트가 함께 참조할 애플리케이션 컨텍스트를 오브젝트 레벨에 저장해두면 곤란

하다. 그렇다면 스태틱 필드에 애플리케이션 컨텍스트를 저장해두면 어떨까? JUnit은

테스트 클래스 전체에 걸쳐 딱 한 번만 실행되는 @BeforeClass 스태틱 메소드를 지원한

다. 이 메소드에서 애플라케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 태스트

메소드에서 시용하게 할 수 있다. 하지만 이보다는 스프링이 직접 제공하는 애플라케이

션 컨텍스트 태스트 지원 기능을 사용히는 것이 더 편리하다.

2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리
스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다. 태스트 컨텍스트
의 지원을 받으면 간단한 애노테이션 설정만으로 태스트에서 필요로 히는 애플리케이
션 컨텍스트를 만들어서 모든 태스트가 공유하게 할 수 있다. UserDaoTest
에 스프링의
텍스트 컨텍스트 프레임워크를 적용해보자.

스프링 테스트 컨텍스트 프레임원크 적용
먼저 @Before 메소드에서 애플리케이션 컨텍스트를 생성히는 디음 코드를 제거한다.


ApplicationContext context =
new GenericXmlApplicationContext ("applicationContext .xml ") ;

그리고 이 ApplicationContext 타입의 인스턴스 변수를 선언하고 스프링이 제
공하는 @Autowired 애노태이션을 붙여준다. 마지막으로 클래스 레벨에 @RunWith와
@ContextConfiguration 애노테이션을 리스트 2-17과 같이 추가해준다.

리스트 2-17 스프링 테스트 컨텍스트를 적용한 UserDaoTest


@R unWith(SpringlUnit4ClassRunner.class) --• 스프링의 테스트 건택스트 프레임워크의

JUnít
확장기능지정

OContextConfiguration(locations="/applicationContext.xm1")

public class UserDaoTest ( ~‘ 터|스트 컨돼스트가 Ãf동으로 민들어줄
OAutowired -애를리케이션 컨택스트의 위치 지정

private ApplicationContext context;

니 테걷 뾰밸가 만들때고 나연 짚링 테토

컨텍스트에 의해 자동으로 값이 주입된디

OOefore
public void setUp() (
this .dao = this.context.getBean( "userDao'’, UserDao.class);

수정한 테스트를 실행해보자. 아무런 문제 없이 성공할 것이다.

그런데 인스턴스 변수인 context는 어디에서도 초기화해주는 묘드가 없다. 따라서
setUp() 메소드에서 context를 사용하려고 하면 NullPointerException이 발생해야 한
다. 하지만 테스트는 아무런 문제 없이 성공적으로 끝난다. context 변수에 애플리케이
션 컨텍스트가 들어 있기 때문이다. 스프링 컨텍스트 프레임워크의 JUnit 확장기능이
약간의 마법을 부린 것이다.

@RunWith는 JUnit 프레입워크의 테스트 실행 방법을 확장할 때 샤용히는 애노테이션
이다. SpringJUnit4ClassRunner라는 JUnit용 태스트 컨텍스트 프레임워크 확장 클래
스를 지정해주면 JUnit이 테스트를 진행히는 중에 태스트가 사용할 애플리케이션 컨텍
스트를 만들고 관리히는 작업을 진행해준다.

@ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일
위치를지정한것이다.

tÞ
후가훌라이브러리

org.Sαi때framewor1<.
lest-3.0.7.RELEASE.jar

2짐-테스트 185


테스트 메소드의 컨텍스트 공유
과연 어떤 일이 일어나고 있는지 확인해볼 필요가 있다. 리스트 2-18과 같이 setUp()
메소드에 다음 두 줄을 추가하고 태스트를 다시 실행해보자.
리스트 2-18 확인용 코드 추가

OOefore

public void setUp() {
System.out.println(this.context);
System.out.println(this);

setUp() 메소드는 @Before가 붙어 있으니 매 테스트 메소드가 실행되기 전에 한 번
씩 실행된다. 이때 인스턴스 변수인 context와 태스트 오브젝트 자신인 this를 콘솔에
출력하게 한다. 실행 결과는 디음과 같다.

org .springframework.context.support.GenericApplicationContext@d 3d6f:

springbook .dao.UserDaoTest@115dÐ6c

org.springframework.context.support .GenericApplication(ontext@d 3d6f:

springbook.dao.UserDaoTest@116318b

org .springframework.context.support .GenericApplicationContext@d 3d6f:

springbook.dao.UserDaoTest@15eÐc2b

출력된 context와 this의 오브젝트 값을 잘 살펴보면 context는 세 변 모두 동일하
다. 따라서 하나의 애플리케이션 컨텍스트가 만들어져 모든 태스트 메소드에서 사용되
고 있음을 알 수 있다. 반면에 UserDaoTest
의 오브젝트는 매번 주소 값이 다르다. 앞에
서 설명한 것처럼 JUnit은 테스트 메소드를 실행할 때마다 새로운 태스트 오브젝트를
만들기때문이다.

그렇다면 context 변수에 어떻게 애플리케이션 컨텍스트가 들어 있는 것일까? 스프
령의 JUnit 확장기능은 테스트가 실행되기 전에 딱 한 번만 애플리케이션 컨텍스트를
만들어두고， 태스트 오브젝트가 만들어질 때마다 특별한 방법을 이용해 애플리케이션
컨텍스트 자신을 태스트 오브젝트의 특정 펼드에 주입해주는 것이다. 일종의 DI라고 볼

수 있는데， 애플리케이션 오브젝트 사이의 관계를 관리하기 위한 DI와는 조금 성격이
다르다.

아무튼 스프링이 애플리케이션 컨텍스트 테스트 개수에 상관없이 한 번만 만들어서
공유하게 해줬기 때문에 테스트 수행 속도는 매우 빨라진다. 이렇게 만든 태스트를 돌
려보니 세 태스트의 수행시간이 각각 1.34초. 0.15초.0.06초 걸렸다. 첫 번째 테스트


가 실행될 때 최초로 애플리케이션 컨텍스트가 처음 만들어지면서 가장 오랜 시간이 소
모되고， 그 다음부터는 이미 만들어진 애플리케이션 컨텍스트를 재시용할 수 있기 때문
에 테스트 실행 시간이 매우 짧잉f지는 것이다.

이렇게 해서 하나의 태스트 클래스 내의 태스트 메소드는 같은 애플리케이션 컨텍스
트를 공유해서 시용할 수 있음을 확인했다.

테스트 클래스의 컨돼스트 공유
스프링 태스트 컨텍스트 프레임워크의 기능은 하나의 태스트 클래스 안에서 애플리케
이션 컨텍스트를 공유해주는 것이 전부가 아니다. 여러 개의 테스트 클래스가 있는데
모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면， 스프링은 태스트 클
래스 사이에서도 애플라케이션 컨텍스트를 공유하게 해준다. 디음과 같이 두 개의 테스
트 클래스가 같은 설정파일을 사용히는 경우에는 태스트 수행 중에 단 한 개의 애플리
케이션 컨텍스트만 만들어진다. 두 테스트 클래스의 모든 메소드가 하나의 애플리케이
션 컨텍스트 공유하게 되는 것이다.

@RunWith(SpringJUnit4ClassRunner.class)
@(ontextConfiguration(locations="'applicationContext.xm1") -------,
public class UserDaoTest { .. } J

/a때licationCαlte:

셔 xml

@RunWith(SpringJUnit4ClassRunner.class)

@(ontextConfiguration(locations="'applicationContext.xm1")~

public class GroupDaoTest { .. }

따라서 수백 개의 태스트 클래스를 만들었는데 모두 같은 설정파일을 사용한다고 해
도 테스트 전체에 걸쳐 단 한 개의 애플리케이션 컨텍스트만 만들어져 시용된다. 이 덕
분에 테스트 성능이 대폭 향상됨은 더 설명할 펼요도 없을 것이다.

물론 테스트 클래스마다 다른 설정파일을 사용하도록 만들어도 되고， 몇 개의 테스
트에서만 다른 설정파일을 시용할 수도 있다. 스프링은 설정파일의 종류만큼 애플리케
이션 컨텍스트를 만들고， 같은 설정파일을 지정한 태스트에서는 이를 공유하게 해준다.

@Autowired

@Autowired는 스프링의 DI
에 사용되는 특별한 애노테이션이다. @Autowired를 이용한
DI 방법에 대해서는 VoI. 2에서 자세히 설명할 것이다. 일단은 이렇게만 기억해두자.

양L 테스트 187


@Autowired가 붙은 인스턴스 변수가 있으면 태스트 컨텍스트 프레임워크는 변수 타입
과 일치하는 컨텍스트 내의 빈을 찾는다. 타입이 일치하는 빈이 있으면 인스턴스 변수
에 주입해준다. 일반적으로는 주입을 위해서는 생성자나 수정자 메소드 같은 메소드가
펼요하지만， 이 경우에는 메소드가 없어도 주입이 가능하다. 또 별도의 DI 설정 없이 필
드의 타입정보를 이용해 빈을 자동으로 가져올 수 있는데 이런 방법을 타입에 의한 자
동와이어령이라고한다.

그렇다면 이상한 점이 있다. 앞에서 만든 태스트 코드에서는 applicationContext.
xml 파일에 정의된 빈이 아니라， ApplicationContext라는 타입의 변수에 @Autowired
를 붙였는데 애플리케이션 컨텍스트가 DI됐다. 어찌 된 일일까? 스프링 애플리케이션
컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다. 따라서 애플리케이션 컨텍스트
에는 ApplicationContext 타입의 빈이 존재하는 셈이고 DI도 가능한 것이다.

@Autowired를 이용해 애플리케이션 컨텍스트가 갖고 있는 빈을 DI 받을 수 었다면
굳이 컨텍스트를 가져와 getBean()
을 사용히는 것이 아니라， 0
1"예 UserDao 빈을 직접
DI 받을 수도 있을 것이다. 이번엔 ApplicationContext 타입의 인스턴스 변수를 없애
고 리스트 2-19와 같이 수정해보자.

리스트 2-19 UserDao톨 직접 미 받도록 만든 테스트

public class UserDaoTest {

ltAutowired

UserDao dao; ~ ~∞ 티입 빈올 직접 g 받는다

애플리케이션 컨텍스트를 DI 받아서 다시 DL 방식으로 UserDao를 가져올 때보다 테
스트 코드가 더 깔끔해졌다. @Autowired를 지정하기만 하면 어떤 빈이든 다 가져올 수
있다.XML에 dataSource라는 이름으로 등록한 SimpleDriverDataSource 타입의 빈을
가져오고 싶다면， 디음과 같은 인스턴스 변수를 추가해주기만 하면 된다.

@Autowired

SimpleDriverDataSource dataSource;

@Autowired는 변수에 할당 가능한 타입을 가진 빈을 자동으로 찾는다. 따라서
SimpleDriverDataSource 클래스 타입은 물론이고， 인터페이스인 DataSource 타입으로
변수를 선언해도 된다. 단， @Autowired는 같은 타입의 빈이 두 개 이상 있는 경우에는
타입만으로는 어떤 빈을 가져올지 결정할 수 없다. 예를 들어 DataSource 타입의 빈이


두 개 이상 설정되어 있다면 다음과 같은 선언은 문제가 될 수 있다. @Autowired는 타입

으로 가져올 빈 하나를 선택할 수 없는 경우에는 변수의 이름과 같은 이름의 빈이 있는

지 확인한다. DataSource 타입의 빈이 두 개 있는데 하나는 dataSource이고 다른 하나

는 dataSource2라면 첫 번째 빈이 주입될 것이다. 변수 이름으로도 빈을 찾을 수 없는

경우에는 예외가 발생한다.

@Autowired

DataSource dataSource;

그런데 SimpleDriverDataSource 타입의 변수로 선언하는 방법과 DataSource 타입
으로 선언하는 방법 중 어떤 것이 나을까? 그건 태스트에서 빈을 어떤 용도로 사용하
느냐에 따라 다르다. 단순히 DataSource에 정의된 메소드를 태스트에서 사용하고 싶
은 경우라면 DataSource 타입으로 받는 게 좋다. UserDao
의 DI용 수정자 메소드가
DataSource 타입의 따라미터를 가진 것과 마찬가지 이유다. DataSource로 선언해두면
dataSource 빈의 구현 클래스를 변경하더라도 태스트 코드를 수정할 펼요가 없다.

반면에 태스트에서 SimpleDriverDataSource
라는 타입의 오브젝트 자체에 관심

이 있는 경우가 있을 수도 있다. 이때는 SimpleDriverDataSource 타입으로 선언해

야 한다. 예를 들어 XML에서 프로퍼티로 설정한 DB 연결정보를 확인하고 싶다거나

SimpleDriverDataSource 클래스의 메소드를 직접 이용해서 테스트를 해야 할 경우도

있다. 태스트는 필요하다면 얼마든지 애플리케이션 클래스와 밀접한 관계를 맺고 있어

도 상관없다. 개발자가 만드는 태스트는 코드 내부구조와 설정 등을 알고 있고 의도적

으로 그 내용을 검증해야 할 펼요가 있기 때문이다. 하지만 콕 펼요하지 않다면 태스트

에서도 가능한 한 인터페이스를 시용해서 애플리케이션 코드와 느슨하게 연결해두는

편이좋다.

2.4.2 미와테스트
UserDao와 DB 커넥션 생성 클래스 사이에는 DataSource라는 인터페이스를 뒀다. 그
래서 UserDao는 자신。l 사용하는 오브젝트의 클래스가 무엇인지 알 펼요가 없다. 또한

DI를 통해 외부에서 사용할 오브젝트를 주입받기 때문에 오브젝트 생성에 대한 부담을
지지 않아도 된다. 코드의 수정 없이도 얼마든지 의존 오브젝트를 바꿔가며 사용할 수
있다.

그런데 이렇게 반문할 수도 었다. “우리는 절대로 DataSource의 구현 클래스를 바꾸
지 않을 것이다. 우리가 개발하는 시스댐은 운영 중에 항상 SimpleDriverDataSource

2장-테스드 189


를 통해서만 DB 커넥션을 가져올 것이다. 그런데도 굳이 DataSource 인터페이스
를 사용하고 DI를 통해 주입해주는 방식을 이용해야 하는가? 그냥 UserDao에서 직접
SimpleDriverDataSource를 생성하고 사용하면 안 될까?" 일리 있는 주장처럼 들린다.

그래도 인터페이스를 두고 DI를 적용해야 한다. 그래야 동l는 이유를 한번 생각해
보자.

첫째， 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문이다. 클래스 대신 인
터페이스를 사용하고. new를 이용해 생성히는 대신 DI를 통해 주입받게 히는 건 아주
단순하고 쉬운 작업이다. 당징써l는 클래스를 바꿔서 사용할 계획이 전혀 없더라도， 언
젠가 변경이 펼요한 상황이 닥쳤을 때 수정에 들어가는 시간과 비용의 부담을 줄여줄
수 있다면， 인터페이스를 사용하고 DI를 적용히는 작은 수고를 하지 않을 이유가 없다.

둘째， 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI
를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문이다. 1
장에
서 만들어봤던 DB 커넥션의 개수를 카운팅하는 부가기능이 그런 예다. UserDao와
ConnectionMaker 사이에 자연스럽게 부가기능을 추가할 수 있었던 건 DI를 적용해둔
덕분이다. 새로운 기능을 넣기 위해 기존 묘드는 전혀 수정할 펼요도 없었다. 추가했
던 기능이 펼요 없어지면 언제든지 설정따일을 간단히 수정해서 제거해버릴 수도 있다.
6장에서 설명하겠지만 스프링은 이런 기법을 일반화해서 AOP라는 기술로 만들어주기
도 한다. 그런데 DI를 적용하지 않았다면 처음부터 불가능했을 것이다.

세 번째 이유는 테스트 때문이다. 단지 효율적인 테스트를 손쉽게 만들기 위해서라
도 DI를 적용해야 한다. 테스트를 잘 활용하려면 지동으로 실행 가능하며 빠르게 동작
하도록 테스트 코드를 만들어야 한다. 그러기 위해서는 가능한 한 작은 단위의 대상에
국한해서 테스트해야 한다. 태스트할 대상의 범위가 넓어지면 태스트를 작성하기가 어
려워진다.DI는 태스트가 작은 단위의 대^cf에 대해 독립적으로 만들어지고 실행되게 하
는 데 중요한 역할을 한다.

테스트에 DI를 이용하는 방법을 몇 가지 살펴보자.

테스트코드에의한미
DI는 애플리케이션 컨텍스트 같은 스프링 컨테이너에서만 할 수 있는 작업이 아니다.
이미 오브젝트 팩토리인 DaoFactory를 이용해서 프레임워크의 도움 없이 직접 DI를 적
용해보기도 했다. UserDao에는 DI 컨테이너가 의존관계 주입에 사용하도록 수정자 메
소드를 만들어뒀다. 이 수정자 메소드는 명범한 자바 메소드이므로 태스트 코드에서도

얼마든지 호출해서 사용할 수 있다. 따라서 테스트 묘드 내에서 이를 이용해서 직접 DI


해도 된다. UserDao가 사용할 DataSource 오브젝트를 테스트 코드에서 변경할 수 있다
는뭇이다.

애플리케이션이 사용할 applicationContext. xml
에 정의된 DataSource 빈은 서버
의 DB 풀 서비스와 연결해서 운영용 DB 커넥션을 돌려주도록 만들어져 있다고 해
보자. 태스트할 때 이 DataSource를 이용해도 될까? UserDaoTest를 실행하는 순간
deleteAll ()에 의해 운영용 DB
의 시용자 정보가 모두 삭제된다면? 결코 일어나서는
안 되는 일이다. 그렇다고 applicationContext.xml 설정을 개발자가 태스트할 때는 테
스트용 DB를 이용하도록 DataSource 빈을 수정했다가， 서버에 배치할 때는 다시 운영
용 DB를 사용하는 DataSource로 수정히는 방법도 있겠지만 번거롭기도 하고 위험할
수도 있다. 이런 경우엔 테스트 코드에 의한 DI를 이용해서 테스트 중에 DAO가 사용
할 DataSource 오브젝트를 바꿔주는 방법을 이용하면 된다.

테스트용 DB
에 연결해주는 DataSource를 테스트 내에서 직접 만들 수 있
다. DataSource 구현 클래스는 스프링이 제공하는 가장 빠른 DataSource
인
SingleConnectionDataSource를 사용해보자. SingleConnectionDataSource는 DB
커넥션을 하나만 만들어두고 계속 사용하기 때문에 매우 빠르다. 다중 사용자 환
경에서는 사용할 수 없겠지만 순차적으로 진행되는 태스트에서라면 문제없다. 연
결할 DB 이름도 testdb로 변경한다
@Before 메소드에서 이렇게 준비된 태스트용
DataSource 오브젝트를 생성하고 애플리케이션 컨텍스트에서 가져옹 dao 오브젝트의
setDataSource() 메소드를 통해 DI 해줄 수 있다. 이렇게 해두면 태스트가 진행되는
동안에는 UserDao가 태스트용 DataSource를 사용해서 동작하게 된다. 리스트 2-20은
태스트 코드를 이용해 DI를 적용한 테스트 코드다.

리스트 2-20 테스트를 위한 수동 미를 적용한 UserDaoTest


를 테스트 메소드에서 애툴리케이션 컨텍스트의 구성이나 상태훌ClDirtiesContext
변경한다는 것을 테스트 컨텍스트 프레임원크에 알려훈다

public class UserDaoTest (
@Autowired
UserDao dao;

OOefore
public void setUp() ( r 터|뜨에서 빼∞가 A땅할 Da뼈ce

오브젝트률 직접 생성한다

DataSource dataSource = new SingleConnectionDataSource(
"jdbc:mysql:lllocalhost/testdb" , "spring" ’ "book" , true);

옆L 테스트 191


dao.setDataSource(dataSource);--률 코드에 의한수동 대

이 방법의 장점은 XML 설정파일을 수정하지 않고도 테스트 코드를 통해 오브젝트
관계를 재구성할 수 있다는 것이다. 예외적인 상횡을 만들기 위해 일부러 영뚱한 오브
젝트를 넣거나， 위와 같이 태스트용으로 준비된 오브젝트를 사용하게 할 수 있다.

하지만 이 방식은 매우 주의해서 시용해야 한다. 이미 애플라케이션 컨텍스트에서
applicationContext.xml 따일의 설정정보를 따라 구성한 오브젝트를 가져와 의존관계
를 강제로 변경했기 때문이다. 스프링 테스트 컨텍스트 프레임워크를 적용했다면 애
플리케이션 컨텍스트는 테스트 중에 딱 한 개만 만들어지고 모든 테스트에서 공유해
서 시용한다. 따라서 애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하
지 않는 것이 원칙이다. 그런데 위의 태스트 코드는 애플리케이션 컨돼스트에서 가져온
UserDao 빈의 의존관계를 강제로 변경한다. 한 번 변경하면 나머지 모든 테스트를 수행
하는 동안 변경된 애플리케이션 컨텍스트가 계속 시용될 것이다. 이는 별로 바람직하지
못하다.

그래서 UserDaoTest에는 @DirtiesContext라는 애노테이션을 추가해췄다. 이 애노
태이션은 스프링의 태스트 컨텍스트 프레임워크에게 해당 클래스의 태스트에서 애플리
케이션 컨텍스트의 상태를 변경한다는 것을 알려준다. 태스트 컨텍스트는 이 애노테이
션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다. 태스트
메소드를 수행하고 나면 매번 새로운 애플리케이션 컨텍스트를 만들어서 다음 테스트
가 사용하게 해준다. 태스트 중에 변경한 컨텍스트가 뒤의 태스트에 영향을 주지 않게
하기 위해서다.

@DirtiesContext를 이용하면 일단 테스트에서 빈의 의존관계를 강제로 DI 하는 방
법을 시용했을 때 문제는 피할 수 있다. 하지만 이 때문에 애플리케이션 컨텍스트를 매
번 만드는 건 조금 점찜하다.

활 메:똥 혜톨의 @때얘esContext At용하71
@oi매esContext는 클래스에만 적용할 수 있는 건 아니다. 하나의 메소드애서만 건돼스트 상태
톨 변경힌다면 메소드 레밸애 @Dir빼sContext톨 를여추는 편이 낫다. 해당 메소드의 실행이 풀
나고 나면 이후에 진행되는 테스트톨 위해 변경된 애를리케이션 건돼스트는 폐기되고 새로훌
애를리케이션 컨텍스트가 만톨어진다.


테스트를 위한 별도의 01 설정
테스트 코드에서 빈 오브젝트에 수동으로 DI 하는 방법은 장점보다 단점이 많다. 코드
가 많아져 번거롭기도 하고 애플리케이션 컨텍스트도 매번 새로 만들어야 하는 부담이
었다. 이 방법 외에 DI의 장점을 살려서 DAO가 태스트에서만 다른 DataSource를 시용
하게 할 수 있는 방법이 또 있을까? 물론 있다.
아예 테스트에서 시용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정파일
을 따로 만들어두는 방법을 이용해도 된다. 즉 두 가지 종류의 설정따일을 만들어서 하
나에는 서버에서 운영용으로 시용할 DataSource를 빈으로 등록해두고， 다른 하나에는
태스트에 적합하게 준비된 DB를 사용히는 가벼운 DataSource가 빈으로 등록되게 만드
는 것이다. 그리고 테스트에서는 항상 테스트 전용 설정파일만 시용하게 해주면 된다.
먼저 기존의 app licationContext. xml을 복사해서 test-applicationContext. xml이라
고 만들자
. 이제 두 개의 설정파일이 생겼다.
다른 빈 설정은 그대로 두고 dataSource 빈의 설정을 테스트용으로 바꿔주자. 이번
에는 리스트 2-21
과 같이 클래스는 SimpleDriverDataSource를 그대로 두고 사용할
DB만 태스트용으로 바꿔보자.

리스트 2-:낀 테스트 DB 변경 설정


<bean id="dataSource"
class="org.springframework.jdbc.datasource .SimpleDriverDataSource" >
<property name="driverClass" value="com .mysql . jdbc.Driver“ />
(property name="url" value="jdbc:mysql:lllocalhost/testdb" 1>
<property name="username" value="spring" />
<property name="password" value="book" />

</bean>

그리고 UserDaoTest
의 @ContextConfiguration 애노테이션에 있는 locations 엘
리먼트의 값을 리스트 2-22와 같이 새로 만든 태스트용 설정파일로 변경해준다. 이
제 테스트는 이 설정파일 정보률 이용하는 애플라케이션 컨텍스트를 사용할 수 있
게 됐다. 나머지 테스트 코드는 수정하지 않아도 된다. 번거롭게 수동 DI 하는 코드나
@DirtiesContext도 펼요 없다.

2장-테스트 193


리스트 2-22 테스트용 설정 파일 적용

@R unWith(SpringJUnit4ClassRunner .class)
OContextConfiguration(locations='/test-applicationContext.xml')
public class UserDaoTest {

이제 테스트 환경에 적합한 구성을 가진 설정파일을 이용해서 태스트를 진행하면 된
다. 애플리케이션 컨텍스트도 한 개만 만들어서 모든 태스트에서 공유할 수 있다. 설정
파일을 하나 더 작성하고 태스트에 맞게 수정해주는 수고만으로 태스트에 적합한 오브
젝트 의존관계를 만들어 사용할 수 있게 됐다. 모두 01를 할 수 있도록 준비해둔 덕분
이다.

컨테이너 없는 01 테스트
마지막으로 살펴볼，
01를 테스트에 이용하는 방법은 아예 스프링 컨테이너를 사용
하지 않고 태스트를 만드는 것이다. 과연 이게 가능할까? 물론 가능하다. UserDao나
DataSource 구현 클래스 어디에도 스프링의 API를 직접 사용한다거나 애플리케이션
컨텍스트를 이용히는 묘드는 존재하지 않는다. 스프링 01 컨테이너에 의존하지 않는다
는 말이다. 따라서 원한다면 스프링 컨테이너를 이용해서 IoC 방식으로 생성되고 01 되
도록 하는 대신， 태스트 묘드에서 직접 오브젝트를 만들고 01 해서 사용해도 된다.
UserDaoTest는 사실 UserDao 코드가 DAO로서 DB에 정보를 잘 등록하고 잘 가
져오는지만 확인하면 된다. 스프링 컨테이너에서 UserDao가 동작함을 확인하는 일은
UserDaoTest
의 기본적인 관심사가 아니다. DaoFactory를 만들어 의존관계 설정 책임을
분리하기 직전에 테스트 코드에서 01 작업을 직접 했던 것을 기억할지 모르겠다. 바로
그 방법을 사용해서 UserDao가 동작하게 만들고 테스트할 수 있다.
스프링 컨테이너 없이 태스트 코드의 수동 01만을 이용해 만들어진 테스트 코드를
살펴보자. 리스트 2-23은 이 방식으로 작성한 UserDaoTest 코드다. @RunWith를 시용
해서 스프링 테스트 컨텍스트 프레임워크를 적용하지도 않았고， @Autowired를 시용해
서 애플리케이션 컨텍스트에서 UserDao를 가져오지도 않았다. 대신 @Before 메소드에
서 직접 UserDao의 오브젝트를 생성하고 테스트용 DataSource 오브젝트를 만들어 직
접
01
해췄다.


리스트 2-23 애풀리케이션 컨텍스트 없는 미 테스트

public class UserDaoTest (
UserDao dao;_ @뻐。
wt
r，잉가 없다

OOefore

public void setUp() {

dao = new UserDao();
DataSource dataSource =new SingleConnectionDataSource(
"jdbc:mysql :lllocalhost/testdb" , 닝
pring"
’ "book" , true);
dao.setDataSource(dataSource);

오브젝트 생성， 관계설정 둥을 모두 직접 해준다


태스트를 위한 DataSource를 직접 만드는 번거로움은 있지만 애플리케이션 컨텍스
트를 아예 시용하지 않으니 코드는 더 단순해지고 이해하기 편해졌다. 애플리케이션 컨
텍스트가 만들어지는 번거로웅이 없어졌으니 그만큼 태스트시간도 절약할 수 있다. 하
지만 mnit은 매번 새로운 태스트 오브젝트를 만들기 때문에 매변 새로운 UserDao 오브
젝트가 만들어진다는 단점도 있다. 그래 봤자 UserDao는 가벼운 오브젝트이니 별 부담
은없다.

이 태스트는 지금까지 만들었던 세 개의 UserDao 테스트를 완벽하게 통과한다.
UserDao가 스프링의 API
에 의존하지 않고 자신의 관심에만 집중해서 깔끔하게 만들어
진 코드이기 때문에 가능한 일이다. 바로 이런 가볍고 깔끔한 태스트를 만들 수 있는 이
유도 DI를 적용했기 때문이다.
DI는 객체지향 프로그래밍 스타일이다. 따라서 DI를 위
해 컨테이너가 반드시 필요한 것은 아니다.DI 컨테이너나 프레임워크는 DI를 편하게
적용하도록 도움을 줄 뿐， 컨테이너가 DI를 가능하게 해주는 것은 아니다.

響
힘루쩍 기*과 비힘루쩍 기흩
침투적(inv앓ve) 기솔은 기솔올 적용했율 때 애풀리케이션 코드에 기솔 관련 API가 동장하거
나， 륙정 인터떼이스나 클래스톨 사용하도록 강저|하는 기솔율 말한다. 첨투적 기슬율 사용하면
애풀리케이션 코드가 해당 기슐에 종속되는 결과톨 가져온다. 반연에 비침투적(때뻐업ve)인
기술은 애훌리케이션 로직율 담온 코드에 아무런 영향울 주지 않고 적용이 가능하다. 따라서 기
슐에 종속적이지 않은 순수한 코드훌 유지할 수 있게 해훈다. 스프링은 이런 비침투적인 기슐의

대표적인 예다. 그래서 스프링 컨테이너 없는 미 테스트도 가능한 것이다.

2징-싹트 195


DI가 적용된 코드는 태스트에서도 다양한 방식으로 활용할 수 있을 만큼 유연하다.
어디에 DI를 적용할지 고민되는 경우， 효과적 인 테스트를 만들기 위해서는 어떤 필요가

있을지를 생각해보면 도움이 된다. 두 개의 모률이 강하게 결합되어 있어 DI가 불기능
한 구조로 만든다면 태스트할 때 불편해진다거나， 자동화된 테스트가 아예 불기능하지
않을까 의심해보자. 일반적으로 태스트하기 좋은 코드가 좋은 묘드일 가능성이 높다.
그 반대도 마찬가지다. 나는 이제까지 테스트하기 불편하게 설계된 좋은 코드를 본 기

억이없다.

01를 이용한 테스트 방법 선택

그렇다면 DI를 테스트에 이용하는 세 가지 방법 중 어떤 것을 선돼해야 할깨 세 가지
방법 모두 장단점이 있고 상황11 따라 유용하게 쓸 수 있다.

항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자. 이
방법이 태스트 수행 속도가 가장 빠르고 태스트 자체가 간결하다. 테스트를 위해 필요

한 오브젝트의 생성과 초기화가 단순하다면 이 방법을 가장 먼저 고려해야 한다.

여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 태스트해야 할 경우가 있
다. 이때는 스프링의 설정을 이용한 DI 방식의 태스트를 이용하면 편리하다. 태스트에
서 애플리케이션 컨텍스트를 사용히는 경우에는 테스트 전용 설정따일을 따로 만들어
사용하는 편이 좋다. 보통 개발환경과 태스트환경， 운영환경이 차이가 있기 때문에 각
각 다른 설정파일을 만들어 사용히는 경우가 일반적이다. 물론 개발자가 테스트할 때는
개발환경에 맞춰서 만든 설정파일을 사용한다.

테스트 설정을 따로 만들었다고 하더라도 때로는 예외적인 의존관계를 강제로 구성
해서 테스트해야 할 경우가 었다. 이때는 컨텍스트에서 DI 받은 오브젝트에 다시 태스
트 코드로 수동 DI 해서 테스트하는 방법을 사용하면 된다. 테스트 메소드나 클래스에
@DirtiesContext 애노테이션을 붙이는 것을 잊지 말자.

스프링의 태스트 지원 기능은 지금까지 설명한 수준 이상으로 다OJ'하고 강력하다.
다OJ'한 테스트 지원 기능에 대해서는 Vol. 2에서 좀 더 자세히 소개하겠다.


n 학습 테스트로 배우는 스프링 ;편|

개발자가 자신이 만든 묘드가 아닌 다른 사람이 만든 묘드와 기능에 대한 테스트를 작
성할 필요가 있을깨 일반적으로 애플리케이션 개발자는 자신이 만들고 있는 묘드에
대한 테스트만 작성하면 된다. 하지만 때로는 자신이 만들지 않은 프레임워크나 다른
개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 한다. 이런

테스트를 학습 테스트learning test라고 한다.

학습 테스트의 목적은 자신이 시용할 API나 프레임워크의 기능을 테스트로 보면서
사용 방법을 익히려는 것이다. 따라서 태스트이지만 프레임워크나 기능에 대한 검증이
목적이 아니다. 오히려 자신이 테스트를 만들려고 하는 기술이나 기능에 대해 얼마나
제대로 이해하고 있는지， 그 시용 방법을 바로 알고 있는지를 검증하려는 게 목적이다.
또， 테스트 코드를 작성해보면서 빠르고 정확하게 시용법을 익히는 것도 학습 태스트를
작성하는 하나의 목적이다.

나는 새로운 프레임워크를 λ}용하게 되거나 새로운 기술을 공부할 때는 항상 태스트
묘드를 먼저 만들어본다. 태스트 코드를 만드는 과정을 통해 API
의 사용 방법도 익히고
내가 가진 기술에 대한 지식도 검증할 수 있다. 때로는 어설프게 알고 있거나 오해하고
있던 지식을 테스트를 만드는 과정을 통해 바로잡기도 한다. 잘못 이해하고 었던 기술
의 시용 방법을 테스트로 만들어서 돌려보면 금세 확인이 되기 때문이다. 학습 테스트
는 테스트 대상보다는 테스트 묘드 자체에 관심을 갖고 만들어야 한다.

2.5.1 학습 테스트의 장점
굳이 테스트는 아니더라도 간단한 예제를 하나 만들어보면서 새로운 기술을 익히는 방
법도 있다. 하지만 태스트를 작성하면서 학습하면 다음과 같은 장점이 었다.

• 다양한 조건에 따른 기능줄 손쉽게 확언해불 수 있다
지동화된 테스트의 모든 장점이 학습 테스트에도 그대로 적용된다. 예제를 만들면
서 학습하는 것은 수동 테스트와 성격이 비슷하다. 다O，{한 조건에 따라 어떻게 기능
이 다르게 동작하는지 확인해보려면 수동으로 값을 입력하거나 코드를 계속 수정해
가며 예제를 다시 실행해야 한다. 결과도 콘솔에 메시지를 출력하거나 UI 화면에 나
타내주는 방법밖에 없다. 반면에 학습 테스트는 자동화된 테스트 묘드로 만들어지기
때문에 다양한 조건에 따라 기능이 어떻게 통작하는지 빠르게 확인할 수 있다.

앉L 테스트 197


• 학습 테스트 코드툴 개발 중에 참고할 수 있다
수동으로 예제를 만드는 방법은 코드를 계속 수정해가면서 기능을 확인해보기 때문
에 결국 최종 수정한 예제 묘드만 남아 있다. 반면에 학습 태스트는 다양한 기능과
조건에 대한 테스트 묘드를 개별적으로 만들고 남겨둘 수 있다. 이렇게 태스트로 새
로운 기술의 다OJ=한 기능을 사용히는 묘드를 만들어두면 실제 개발에서 샘플 묘드로
참고할 수 있다. 복잡한 기능이라면 태스트에 관련된 설정파일도 만들어질 것이고，
초기화는 어떻게 하는지 API 호출 방법은 어떤 것인지， 결과는 어떻게 가져와야 하
는지에 대한 생플 코드가 테스트 안에 모두 만들어진다. 아직 익숙하지 않은 기술을

사용해야 하는 개발자에게는 이렇게 미리 만들어진 다OJ=한 기능에 대한 태스트 코드

가 좋은 참고 자료가 된다
.

나는 새로운 프레임워크나 기술을 사용할 때면 먼저 팀원들과 함께 학습 태스트
를 만들면서 사용법을 익힌다. 그리고 이렇게 만든 학습 태스트를 애플라케이션 태
스트 패키지의 일부로 추가해둔다. 개발자들은 필요하다면 언제든지 학습 테스트로
만들었던 묘드를 참고해볼 수 있다. 또는 좀 더 나은 사용 방법을 발견했다면 학습
테스트의 코드를 수정해서 다른 개발자와 공유할 수 있다.

• 프레입워크나 저품을 업그레이드할 때 호흰성 검증률 도와준다
요즘은 모든 제품이 매우 빠르게 업데이트된다. 오픈소스 프레임워크뿐 아니라 상용
제품도 인터넷을 통해 자주 업데이트가 공개된다. 문제는 이렇게 새로운 버전으로
업그레이드를 할 때 API 사용법에 미묘한 변화가 생긴다거나， 기존에는 잘 통작하
던 기능에 문제가 발생할 수도 있다는 점이다. 보통 마이너 버전 업그레이드는 버그
수정이나 성능 개선 같은 미미한 수정인 경우가 많으므로 상대적으로 부담 없이 업
그레이드하기도 히는데， 그 과정에서 버그가 추가된 경우가 가끔 있어서 업그레이드
후에 시스댐이 미묘한 문제를 일으킬 수 있다. 이런 경우에는 문제가 없던 이전 버전
으로 다운그레이드해야 한다. 그런데， 이렇게 적용을 하지 않고도 기존에 사용하던
API가 기능에 문제가 없다는 사실을 미리 확인해볼 수 있는 방법이 있다. 바로 학습
테스트를 이용하는 것이다. 학습 테스트에 애플리케이션에서 지주 사용히는 기능에
대한 태스트를 만들어놓았다면 새로운 버전의 프레임워크나 제품을 학습 태스트에
만 먼저 적용해본다. 기존에 사용했던 API나 기능에 변화가 있거나 업데이트된 제품
에 버그가 있다면， 학습 테스트를 통해 미리 확인할 수가 있다. 버그가 있어서 테스
트가 실패하면 업그레이드 일정을 늦추거나. API
의 사용 방법에 변화가 발생한 경우
라면 그에 맞춰서 애플리케이션 코드를 수정할 계획을 세울 수 있을 것이다. 물론 애


플리케이션 개발에 사용히는 주요 기능에 대한 학습 태스트를 충분히 만들어뒀어야
가능하다.

• 테스트 작성에 대한 훌은 혼련이 된다
개발자가 태스트를 작성하는 데 아직 충분히 훈련되어 있지 않거나 부담을 갖고 있
다면， 먼저 학습 태스트를 작성해보면서 테스트 코드 작성을 연습할 수 있다. 프레임
워크의 학습 태스트는 실제로 프레임워크를 사용히는 애플리케이션 코드의 태스트
와 비슷하게 만들어진다. 또한 학습 태스트는 한두 가지 간단한 기능에만 초점을 맞
추면 되기 때문에 테스트도 대체로 단순하다. 따라서 애플리케이션 개발 중에 작성
하는 태스트보다는 한결 작성하기가 수월하고 부담도 적다. 학습 태스트를 테스트
작성의 훈련 기회로 삼는 것도 좋다. 또는 새로운 테스트 방법을 연구히는 데도 도움
이 된다. 기술에 따라서 테스트가 까다로운 것도 있는데 이럴 때 먼저 학습 태스트를
만들어보면서 간결한 테스트 작성 방법을 연구해보면 도움이 된다.
l 새로운 기슐올 공부하는 과정이 줄거워진다
책이나 레퍼런스 문서 등을 그저 읽기만 하는 공부는 쉽게 지루해진다. 지루함은 학
습의 능률도 떨어뜨린다. 그에 비해 태스트 코드를 만들면서 하는 학습은 홍미롭고
재미있다. 문서에 딱딱하게 쓰여진 기능이 태스트 코드를 통해 실제로 통작히는 모
습을 보는 건 즐겁다. 개발한 코드가 동작하는 것을 봤을 때의 그 짜릿함을 학습 과
정에서도 느낄 수 있으니 얼마나 좋겠는가! 또한 즐겁게 학습한 것은 지루함을 참으
며 억지로 했을 때보다 훨씬 오래 기억에 남을 것이다.

학습 테스트는 당장 적용할 일부 기능의 사용법을 익히기 위해서만이 아니라 새로운
프레임워크나 기술을 전반적으로 공부히는 과정에서도 유용하다. 스프링 레퍼런스 매
뉴얼이나 관련 서적을 가지고 공부하면서 설명이 잘 이해가 안 된다거나 자세한 사용
방법이 궁금하다면 직접 학습 태스트로 만들어보는 것도 도움이 된다. 혼자서 하기엔
조금 벅차다면 스터디 그룹을 만들거나 함께 학습할 동료들을 모아서 공동으로 학습 테
스트를 만들어가는 방법도 좋다.

스프링 학습 태스트를 만들 때 참고할 수 있는 가장 좋은 소스는 바로 스프링 자신
에 대한 테스트 코드다. 스프링은 꼼꼼하게 태스트를 만들어가며 개발해온 프레임워크
다. 거의 모든 기능에 대해 방대한 양의 태스트가 만들어져 있다. 스프링 배포판의 압축
을 풀어보면 프레입워크 소스코드와 함께 태스트 코드도 발견할 수 있을 것이다. 스프
링 태스트를 잘 살펴보면 레퍼런스 문서에서는 미처 설명되지 않았던 중요한 정보도 많
이 얻을 수 있다. 또， 테스트 작성 방법에 대한 좋은 탑을 얻을 수 있을 것이다.

얄L 테스트 199


이 책 전반에 걸쳐서 학습 태스트를 이용해 스프링을 공부히는 방법을 설명하고， 학
습 태스트 묘드를 만드는 과정을 보여줄 것이다. 이 책에서 설명하는 내용의 대부분은
학습 태스트를 통해 미리 확인한 것들이다. 이렇게 만들었던 학습 테스트는 CD
에 담긴
예제 프로젝트 내의 springbook.learningtest 때커지 안에서 찾아볼 수 있다. 혹시 학
습 테스트 코드가 제공되지 않은 내용이 있다면 직접 학습 테스트를 만들어보는 것을
권장한다.

2.5.2 학습테스트예제
지금까지 소개했던 기능에 대해 학습 테스트를 만들어보자.
JUnit 테스트 오브젝트 테스트
JUnit은 태스트 메소드를 수행할 때마다 새로운 오브젝트를 만든다고 했다. 그런데 정
말 매번 새로운 오브젝트가 만들어질까? 혹시 잘못 알고 있는 것은 아닐까? 혹시 최신
버전에서는 달라지지 않았을까? 궁금하다면 JUnit에 대한 학습 테스트를 만들어보자.
JUnit으로 만드는 JUnit 자신에 대한 테스트다
.
테스트 방법은 이렇다. 새로운 테스트 클래스를 만들고 적당한 이름으로 세 개의 테
스트 메소드를 추가한다. 테스트 클래스 자신의 타입으로 스태틱 변수를 하나 선언한
다. 매 태스트 메소드에서 현재 스태틱 변수에 담긴 오브젝트와 자신을 비교해서 같지
않다는 사실을 확인한다. 그리고 현재 오브젝트를 그 스태틱 변수에 저장한다. 리스트
2-24는 이렇게 만들어진 학습 태스트 코드다.

리스트 2-24 JUnit 테스트 오브젝트 생성에 대한 학습 테스트

package springbook.learningtest.junit;

import static org .hamcrest .CoreMatchers .is;
import static org.hamcrest.CoreMatchers.not;
import static org.hamcrest.CoreMatchers .samelnstance;
import static org.junit .Assert.assertThat;

lmport org.junit.Test;

public class JUnitTest (
static JUnitTest testObject;

@Test public void testl() {


assertThat(this, is(not(samelnstance(testObject))));
testObject =this;

@Test public void test2() (
assertThat(this, is(not(samelnstance(testObject))));
testObject =this;

@Test public void test3() (
assertThat(this, is(not(samelnstance(testObject))));
testObject =this;


assertThat()에서 사용히는 몇 가지 매처가 추가됐다. not()은 뒤에 나오는 결과를
부정히는 매처다. is()
는 equals() 비교를 해서 같으면 성공이지만 is(not())은 반대
로 같지 않이야 성공한다. samelnstance()는 실제로 같은 오브젝트인지를 비교한다. 물
론 JUni
tTest는 equals()를 오버라이드하지 않았으므로 Object 클래스에 정의된 대로
주소 값을 갖는 동일한 오브젝트인지를 비교하겠지만 테스트의 의도를 명확하게 드러
내기 위해 samelnstance()
라는 동일성 비교 매처를 명시적으로 시용히는 것이 좋다.

테스트를 돌려보면 성공할 것이다. 테스트 메소드가 실행될 때마다 스태틱 변수인
testObject
에 저장해둔 오브젝트와 다른 새로운 테스트 오브젝트가 만들어졌음을 확인
할 수 있다. 한 가지 찜찜한 사실은 이 방식으로는 직전 테스트에서 만들어진 태스트 오
브젝트와만 비교한다는 점이다. 만약 첫 번째와 세 번째 테스트 오브젝트가 같은 경우
가 있다면 그것은 검증이 안 된다. 이 정도로도 충분할 듯싶지만 이왕 히는 김에 좀 더
꼼꼼한 테스트를 위해 테스트 방법을 조금 개선해보자. 세 개의 태스트 오브젝트 중 어
떤 것도 중복이 되지 않는다는 것을 확인하도록 검증 방법을 바문다. 리스트 2-25는 이
렇게 개선한 JUnit에 대한 학습 태스트다.

리스트 2-25 개선한 JUnit 테스트 오브젝트 생성에 대한 학습 테스트

import static org.junit.matchers.JUnitMatchers.hasItem;

public class JUnitTest (
static Set<JUnitTest> testObjects = new HashSet<JUnitTest>();
@Test public void testl() {

2징-테스트 201


assertThat(testObjects , not(hasltem(this)));
testObjects.add(this);

@Test public void test2() (
assertThat(testObjects , not(hasltem(this)));
testObjects.add(this);

@Test public void test3() (
assertThat(testObjects , not(hasltem(this)));
testObjects.add(this);

먼저 스태틱 변수로 태스트 오브젝트를 저장할 수 있는 컬렉션을 만들어둔다. 태스
트마다 현재 테스트 오브젝트가 컬렉션에 이미 등록되어 있는지 확인하고， 없으면 자기
자신을 추가한다. 이 과정을 반복한다. 이 방법을 이용하면 테스트가 어떤 순서로 실행
되는지에 상관없이 오브젝트 중복 여부를 확인할 수 있다. 이번에는 컬렉션의 원소인지
를 검사하는 has Item( ) 매처를 사용했다.

이렇게 만들어진 학습 태스트를 이용하면 JUnit이 매번 새로운 테스트 오브젝트를
만든다는 사실을 분명히 확인할 수 있다. 테스트 메소드 개수를 더 늘려도 통일한 결과
가 나올 것이다. 앞에서 콘솔에 출력해서 눈으로 확인해보긴 했지만 이렇게 검증까지
해주는 태스트를 만드는 편이 훨씬 깔끔하다.

이 학습 테스트는 JUnit의 사용 방법을 익히기 위해 묘드를 만든 것은 아니었다. 하
지만 JUnit의 특성을 분명히 이해할 수 있게 됐고， 또 테스트를 만드는 방법에 대한 공
부도 되니 일석이조다. 테스트를 만드는 동안 세 개의 새로운 매처를 시용해봤고， 오브
젝트 중복에 대한 태스트를 만드는 방법도 여러 가지로 적용해볼 수 있었다.

스프링 테스트 컨텍스트 테스트
이번에는 스프링 태스트 컨텍스트 프레임워크에 대한 학습 태스트를 만들어보자. JUnit
과 반대로 스프링의 테스트용 애플리케이션 컨텍스트는 테스트 개수에 상관없이 한 개
만 만들어진다. 또 이렇게 만들어진 컨텍스트는 모든 태스트에서 공유된다고 했다. 정
말 그런지 검증히는 학습 태스트를 만들어보자.
태스트에서 사용할 설정따일이 하나 펼요하다. 앞에서 만들었던 applicationContext.


xml이 있긴 하지만 학습 태스트는 가능하면 독립적으로 만드는 것이 좋으니 새로운 설
정파일을 만들어보자. 이 설정파일에는 아무런 빈을 등록할 필요가 없다.
DI 기능이 아
니라 애플리케이션 컨텍스트가 만들어지는 방식을 확인해보려는 것이기 때문이다.

JUni tTest 같은 패키지 안에 리스트 2-26과 같은 설정파일을 생성한다.

리스트 2-26JU떼 테스트톨 위한 빈 설정파일
:junit.xml

(?xml version=="1 .0" encoding=="UTF-8"?>

<beans x
mlns==
개ttp
:
//www
.
springframework
.
org/schema/beans
"

xmlns: xsi=="http://www .w3.org/2001/XMLSchema-instance’

xsi :schemaLocation==''http://www .springframework. org/schema/beans

http://www.springframework.org/schema/beans/spring-beans .xsd">

</beans>


이제 앞에서 만들었던 JUni
tTest에 @RunWith와 @ContextConfiguration 애노테이
션을 추가하고， 방금 만든 설정파일을 사용히는 태스트 컨텍스트를 적용한다. 그리고
@Autowired로 주입된 context 변수가 같은 오브젝트인지 확인하는 코드를 추가한다.
리스트 2-27은 기존 JUni
tTest에 태스트 컨텍스트의 컨텍스트 생성 방식을 확인하는
기능이추가된것이다.

리스트 2-'ZJ 스프링 테스트 컨텍스트에 대한 학습 테스트

import static org.hamcrest.CoreMatchers.nullValue;
import static org.junit.Assert .assertTrue;
import static org.junit.matchers.JUnitMatchers.either;

@RunWith(SpringJUnit4ClassRunner.class)
OContextConfiguration
public class JUnitTest (

테스트 킨텍스트가 매번 주입해주는 애을리케

OAutowired ApplicationContext context;~ 이션 컨텍스트는 항상 같은 오브젝트인지 테
스트로확인해본다

static Set<JUnitTest> testObjects == new HashSet<JUnitTest>();
static Ap plicationContext contextObject == null;

@Test public void testl() (
assertThat (testObjects , not(hasltem(this)));
testObjects .add(this);

2징-따트 203


assertThat(contextObject == null ’ contextObject == this.context ,

is(true)) ;
contextObject = this.context;

@Test public void test2() (
assertThat(testObjects , not(hasltem(this)));
testObjects .add(this);

assertTrue(contextObject == null 11 contextObject == this.context);
contextObject =this.context;

@Test public void test3() (
assertThat(testObjects , not(hasltem(this)));
testObjects .add(this);

assertThat(contextObject ,
either(is(nullValue())).or(is(this.context)));
contextObject = this.context;

테스트 메소드에서 매번 통일한 애플리케이션 컨돼스트가 context 변수에 주입
됐는지 확인해야 한다. 확인 방법은 간단하다. 먼저 context를 저장해툴 스태틱 변
수인 contextObject가 null
인지 확인한다. null
이라면 첫 번째 테스트일 테니까 일
단 통과. 그리고 contextObject에 현재 context를 저장해둔다. 다옴부터는 저장된
contextObject가 null
이 아닐 테니 현재의 context가 같은지 비교할 수 있다. 한 번이
라도 다른 오브젝트가 나오면 태스트는 실패한다.

이 검증 로직을 코드로 만드는 방법을 생각해보자. 예제 2-2에서는 다OJ"한 검증 방
법을 연습해볼 수 있도록 각 태스트 메소드마다 다른 방법을 사용했다. 코드는 다르지
만 모두 같은 내용을 검증한다.

첫 번째 방법은 assertThat()을 이용히는 것이다. 매처와 비교할 대상인 첫 번째 따
라미터에 Boolean 타입의 결과가 나오는 조건문을 넣는다. 그리고 그 결과를 is() 매처
를 써서 true와 비교하면 된다. 지금까지 사용했던 assertThat()과 is()를 적절히 사
용한 방법이다. is()
는 타입만 일치하면 어떤 값이든 검증할 수 있다.

두 번째 방법은 조건문을 받아서 그 결과가 true
인지 false
인지를 확인하도록 만들


어진 assertTrue( )라는 검증용 메소드를 assertThat() 대신에 사용한 것이다. 묘드가
assertThat () 방식보다는 조금 간결해지는 장점이 있다.

세 번째 방법도 assertThat ()을 시용한다. 이번엔 조건문을 넣어서 그 결과를 true

와 비교하는 대신 매처의 조합을 이용하는 방법을 사용했다. ei ther()는 뒤에 이어서

나오는 or()와 함께 두 개의 매처의 결과를 OR 조건으로 비교해준다. 두 가지 매처 중

에서 하나만 true로 나와도 성공이다. 새롭게 사용한 매처가 있는데 바로 null Value()

다. nullValue()는 이름 그대로 오브젝트가 null
인지를 확인해준다.

학습 테스트를 만들어보면서 세 가지 방법 중 사용하기 편리하다고 생각되는 것을

선택해서 사용하면 된다. 학습 테스트는 이렇게 같은 기능이지만 다른 방법으로 사용하

는 묘드를 만들어서 비교하는 데도 유용하다.

l
장부터 지금까지 설명한 내용 중에서 어떤 것을 학습 테스트로 만들어볼 수 있을

까? 1
징L에 소개된 내용 중에서 스프링이 싱글톤 방식으로 빈의 오브젝트를 만든다는 것

을 검증해보는 테스트를 만들어볼 수 있다. 또 태스트 컨텍스트를 이용한 테스트에서

@Autowired로 가져온 빈 오브젝트가 애플리케이션 컨텍스트에서 직접 getBean()
으로

가져오는 것과 동일한지도 한번 확인해보면 좋겠다. XML에서 스트링 타입의 프로퍼

티 값을 설정한 것이 정말 빈에 잘 주입되는지도 테스트로 만들어볼 수 있다. 그 과정에

서 기능에 대한 검증뿐 아니라 다OJ=한 ApplicationContext 구현 클래스의 사용 방법，

getBean()
의 사용 방법 등을 연습해볼 수 있을 것이다. getBean()
을 사용했는데 주어

진 이름의 빈이 발견되지 않으면 어떤 결과가 나올까? 학습 테스트를 만들어가면서 한

번확인해보자.

어떤 기술이든 마찬가지지만 특히 스프링은 문서만 가지고 공부해서는 쉽게 이해하

고 익히기 힘들다. 실전에 적용하기 전에 스프링의 기능을 사용한 테스트를 기능한 한

많이만들어보자.

2.5.3 버그테스트
버그 테스트bug test란 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 태스트

를 말한다. QA팀의 테스트 중에 기능 오류가 발견됐다고 하자. 또는 사용자가 버그가

있다고 알려온 경우라고 생각해도 좋다. 이때 무턱대고 코드를 뒤져가면서 수정하려고

하기보다는 먼저 버그 테스트를 만들어보는 편이 유용하다.

버그 테스트는 일단 실패하도록 만들어야 한다. 버그가 원인이 되서 테스트가 실패

하는 코드를 만드는 것이다. 그러고 나서 버그 테스트가 성공할 수 있도록 애플리케이

션 코드를 수정한다. 태스트가 성공하면 버그는 해결된 것이다.

2징-터ι트 205


버그 태스트의 펼요성과 장점을 생각해보자.

• 테스트의 완성도를 높여준다
기존 테스트에서는 미처 검증하지 못했던 부분이 있기 때문에 오류가 발생한 것이
다. 이에 대해 태스트를 만들면 불충분했던 태스트를 보완해준다. 또， 이후에 비슷한
문제가 다시 등장하더라도 이전에 만들었던 버그 태스트 덕분에 쉽게 추적이 가능해
진다.
-버그의 내용을 명확하게 분석훌때| 해준다
버그가 있을 때 그것을 테스트로 만들어서 실패하게 하려면 어떤 이유 때문에 문제
가 생겼는지 명확히 알아야 한다. 따라서 버그를 좀 더 효과적으로 분석할 수 있다.
그 과정에서 그 버그로 인해 발생할 수 있는 다른 오류를 함께 발견할 수도 있다. 예
를 들어 예외적인 상황이나 입력 값 때문에 발생히는 오류였다면， 테스트 코드를 만
들면서 오류를 발생시키는 값의 범위가 어떤 것인지 분석해볼 기회가 주어진다. 테
스트의 중요한 기법 중의 하나인 동등분할이나 경계값 분석을 적용해볼 수도 있다.

• 71솔적인 문제를 해결하는 데 도움이 된다
때로는 버그가 있다는 건 알겠지만 그 원인이 무엇인지 정확하게 파악송}기 힘들 때
가 있다. 아무리 코드와 설정 등을 살펴봐도 별다른 문제가 없는 것 같이 느껴지거
나 또는 기술적으로 다루기 힘든 버그를 발견하는 경우도 었다. 이렬 맨 통일한 문
제가 발생히는 가장 단순한 코드와 그에 대한 버그 태스트를 만들어보면 도움이 된
다. 또한 외부의 전문가나 포렴， 메일링 리스트 등 커뮤니티의 도움을 받을 때도 도
움이된다.

활 톨톨톨휠t뼈uiva뼈nce pa폐때li빼)
갈은 결과톨 내는 강의 범위톨 구분해서 각 대표 값으로 테스트톨 하는 방법율 말한다. 어떤 작
업의 결과의 종류가 뼈. false 또는 예외발생 세 가지라면 각 결과톨 내는 입력 값이나 상횡의
조합율 만들어 모든 경우에 대한 테스트훌 해보는 것이 훌다.

홉 경째강 톨석(없Jr념ary value analysis)
에러는 동둥분할 범위의 경계에서 주로 많이 발생효빠는 륙징올 이용해서 경계의 근처애 있는
값율 이용해 테스트하는 방법이다. 보통 훗자의 입력 값인 경우 001나 그 주변 값 또는 정수의
최대값， 최소값 둥으로 테스트해보면 도움이 될 때가 많다.

‘


[ ~ 정리

2장에서는 다음과 같이 테스트의 펼요성과 작성 방법을 살펴봤다.

• 태스트는 자동화돼야 하고， 빠르게 실행할 수 있어야 한다.
• main() 테스트 대신 JUnit 프레임워크를 이용한 태스트 작성이 편리하다.
• 태스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 태스트 실행 순서에 따라
서 결과가달라지면안된다.
• 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나뿔
수있다.
• 묘드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
• 테스트하기 쉬운 코드가 좋은 코드다.
• 태스트를 먼저 만들고 태스트를 성공시키는 코드를 만들어가는 태스트 주도 개발 방법도 유
용하다.
• 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토령이 필요하다.
• OOefore, @A
fter를 사용해서 태스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수
있다.
• 스프링 태스트 컨텍스트 프레임워크를 이용하면 태스트 성능을 향상시킬 수 있다.
• 통일한 설정파일을 사용하는 태스트는 하나의 애플리케이션 컨텍스트를 공유한다.
• @Autowired를 사용하면 컨텍스트의 빈을 태스트 오브젝트에 DI 할 수 있다.
• 기술의 사용 방법을 익히고 이혜를 돕기 위해 학습 태스트를 작성하자.
• 오류가 발견될 경우 그에 대한 버그 태스트를 만들어두면 유용하다.
스프링을 사용하는 개발자라면 자신이 만든 코드를 태스트로 검증하는 방법을 알고
있어야 하며， 테스트를 개발에 적극적으로 활용할 수 있어야 한다.

앉L 테스트 207


I

장에서는 초난감 DAO 끈에 DI를 적용해나괜 과정을 햄서 관심이 빨 코
드를 다양한 방법으로 분리하고 확장과 변경에 용이하게 대응할 수 있는 설계구조
로 개선하는 작업을 했다.

확징에는 자유롭게 열려 있고 변경에는 굳게 닫혀 있다는 객체지향 설계의 핵심 원
칙인 개방 패쇄 원칙
OCP을 다시 한번 생각해보자. 이 원칙은 코드에서 어떤 부분은 변
경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고 어떤 부분은 고정되어 있고
변하지 않으려는 성질이 었음을 말해준다. 변화의 특성이 다른 부분을 구분해주고， 각
각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구
조를 만들어주는 것이 바로 이 개방 패쇄 원칙이다.

랩플릿이란 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며
일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으
로부터 독립시켜서 효과적으로 활용할 수 있도록 하는 방법이다.

3
장에서는 스프링에 적용된 템플릿 기법을 살펴보고 이를 적용해 완성도 있는
DAO 코드를 만드는 방법을 알아보겠다.

EI 다시보는초난감


UserDao의 코드에는 아직 문제점이 남아 있다.DB 연결과 관련된 여러 가지 개선 작업
은했지만， 다른변에서 심각한문제점이 있다. 바로예외상햄 대한처리다.

3장-템을릿 209


3.1.1 예외처리 기능을 갖춘 DAO
DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서벼에서 동작하는 JDBC 코드에
는반드시 지켜야할원칙이 었다. 바로예외처리다. 정상적인
JDBC 코드의 흐름을따르
지 않고 중간에 어떤 이유로든 예외가 발생했을 경우에도 시용한 리소스를 반드시 반환하
도록 만들어야 하기 때문이다. 그렇지 않으면 시스탱에 심각한 문제를 일으킬 수 있다.

JDBC 수정 기능의 예외처리 코드
리스트
3-1
에 나온
UserDao의 가장단순한메소드인
deleteAll ()을살펴보자.

리스트 3-1 JDBC API틀 이용한 DAO 코드인 delete.씨I()

public void deleteAll() throws SQLException {
Connection c =dataSource.getConnection();

PreparedStatement ps = c.prepareStatement("delete from users") ;
pS .executeUpdate();

여기서 예외가 발생하면 바로 메소드
ps .close(); 실행이중단된다


c. close() ;
이 메소드에서는 Connection과 PreparedStatement
라는 두 개의 공유 리소스를 가져
와서 사용한다. 물론 정상적으로 처리되면 메소드를 마치기 전에 각각 close( )를 호출해
리소스를 반환한다. 그런데 PreparedStatement를 처리히는 중에 예외가 발생하면 어떻
게 될까? 이때는 메소드 실행을 끝마치지 못하고 바로 메소드를 빠져나가게 된다. 이때
문제는 Connection과 PreparedStatement
의 close( ) 메소드가 실행되지 않아서 제대로
리소스가 반환되지 않을 수 있다는 점이다.

일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 풀로
관리한다. DB 풀은 매번 getConnection( )으로 가져간 커넥션을 명시적으로 close( )
해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다.
그런데 이런 식으로 오류가 날 때마다 미처 반환되지 못한 Connection
이 계속 쌓이면
어느 순간에 커넥션 풀에 여유가 없어지고 리소스가 모자란다는 심각한 오류를 내며 서
버가 중단될 수 있다. 따라서 위의 묘드는 한 번 실행되고 애플리케이션 전체가 종료되
는 간단한 예제에서는 괜찮겠지만， 장시간 운영되는 다중 시용자를 위한 서버에 적용하
기에는 치명적인 위험을 내포하고 있다.


響
리소스 반환과 C뼈e()
ConnectionO I나 PreparedStatement에는 close() 메소드가 있다. 이룸으로 보면 열린 것울 닫
는다는 의미다. 단순하게 생각하면 만들어진 걸 종료하는 것이라고 불 수도 있지만 보통 리소스
훌 반환한다는 의미로 이해하는 것이 훌다. Connection과 Prepar，잉얹atement는 보통 폴(α)()I)
방식으로 운영된다. 미리 정해진 풀 안에 제한된 수의 리소스(Connection， Statement)훌 만들어
두고 필요할 때 이를 할듭념t고， 반환하먼 다시 풀에 넣는 방식으로 운영된다. 요청이 매우 많은
서버환경에서는 매번 새로운 리소스훌 생성하는 대신 롤에 미리 만돌어둔 리소스훌 돌려가며
사용하는 편이 훨씬 유리하다. 대신， 사용한 리소스는 빼르게 반환해야 한다. 그렇지 않으면 풀
에 있는 리소스가 고갈되고 결국 문제가 발생한다. cl∞e() 메소드는 시용한 리소스훌 플로 다
시 돌려주는 역할을 한다.


그래서 이런 JDBC 코드에서는 어떤 상황11서도 가져온 라소스를 반환하도록 try/
catch/finally 구문 사용을 권장하고 있다. 예외상황11서도 리소스를 제대로 반환할 수
있도록 try/catch/finally를 적용해보자. 적용된 deleteAll () 메소드는 리스트 3-2에
서 볼 수 있다. JDBC를 사용해본 경험
이 있는 개발자라면 아마 눈에 익을 것이다.

리스트 3-2 예외 발생 시에도 리소스를 반환하도록 수정한 delete.

셰I()

public void deleteAll( ) throws SQLException {
Connection c =null ;
PreparedStatement ps =null ;

try (

r c = dataSource.getConnection();

예외가 발생할 기능성이 있는 코드를ps = c. prepareStatement( "delete from users");
모두 W블록으로 욱어준다‘

Ps .executeUpdate ();
} catch (SQLException e) {

예외가 발생했을 때 부가적인 작업을 해줄 수 있도록 catch 블록을 둔다
아직은 예외를 다시 메소드 밖으로 던지는 것밖에 없다

throw e;

} finally { -률 finallyOI므로 W 블록에서 예외가 발생했을 때나 안 했을 때나 모두 실행된다

if (ps != null) {
try (

ps . close();
ps.cl∞e() 메소드에서도 밍머X∞ptbnOI 발생할 수 있기 때문
} catch (SQLException e) ( -률 에 이를 뿜집야 한다 그렇지 않으면 Connectbn을 cbse() iif
} 지 못하고 메설를 빠져나갈 수 있다

if (c != null) {
try (
c.close(); -. Connectbn
빈환
} catch (SQLException e) {

3장-템을릿 211


이제 예외상황에서도 안전한 코드가 됐다. finally는 try 블록을 수행한 후에 예외
가 발생하든 정상적으로 처리되든 상관없이 반드시 실행되는 코드를 넣을 때 사용한다.
일단 try 블록으로 들어섰다면 반드시 Connection이나 PreparedStatement의 c1 ose( )
호출을 통해 가져옹 리소스를 반환해야 한다. 그런데 문제는 예외가 어느 시점에 나는
가에 따라서 Connection과 PreparedStatement 중 어떤 것의 c1ose( ) 메소드를 호출해
야 할지가 달라진다는 점이다.

만약 getConnection( )에서 DB 커넥션을 가져오다가 일시적인 DB 서벼 문제
나， 네트워크 문제 또는 그 밖의 예외상황 때문에 예외가 발생했다면 ps는 물론이
고 변수 C도 아직 null 상태다. null 상태의 변수에 close() 메소드를 호출하면
NullPointerException
이 발생할 테니 이럴 땐 close( ) 메소드를 호출하면 안 된다.
PreparedStatement를 생성하다가 예외가 발생했다면 그때는 [ 변수가 커넥션 객체를
갖고 있는 상태이니 C는 close( ) 호출이 가능한 반면 ps는 아니다. 만약 ps를 실행하다
가 예외가 발생한 경우라면， ps와 C 모두 c1ose( ) 메소드를 호출해줘야 한다. 어느 시점
에서 예외가 발생했는지에 따라서 c1ose( )를 사용할 수 있는 변수가 달라질 수 있기 때
문에 finally에서는 반드시 c와 ps가 null
이 아닌지 먼저 확인한 후에 c1 ose( ) 메소드
를호출해야한다.

문제는 이 close( )도 SQLException
이 발생할 수 있는 메소드라는 점이다. 따라서
try/catch 문으로 처리해줘야 한다. 물론 close( )가 실패했을 때는 특별히 해줄 수 있
는 조치가 없기 때문에 catch 블록은 비어 있다. 이미 deleteAll
에 SQLException
이 던
져진다고 선언되어 있으니 c1ose( )에는 try/catch가 없어도 되지 않을까 생각할 수도
있다. 하지만 반드시 있어야 한다. try/catch 블록 없이 ps .close()를 처리하다가 예외
가 발생하면 아래 c. close() 부분이 실행되지 않고 메소드를 빠져나가는 문제가 발생
하기 때문이다. 마지막에 실행되는 c.close()
의 경우는 try/catch가 굳이 필요하지는
않지만 혹시 예외처리가 펼요할 수도 있으니 try/catch 블록을 추가해뒀다.

현재 catch 블록에서는 메소드 밖으로 SQLException을 다시 던지는 것 외에는 하는
일이 없다. 따라서 catch 블록을 빼버려도 상관없다. 하지만 예외가 발생한 경우에 보
통 로그를 남기는 등의 부가작업이 필요할 수 있으니 catch 블록은 일단 만들어두는 편
이좋다.


JDBC 조회 기능의 예외처리
조회를 위한 JDBC 코드는 좀 더 복잡해진다. Connection, PreparedStatement 외에도
ResultSet
이 추가되기 때문이다. 구성은 마찬가지다. 다만 ResultSet도 반환해야 하는
리소스이기 때문에 예외상횡에서도 이 ResultSet
의 close( ) 메소드가 반드시 호출되도
록만들면된다.
등록된 User의 수를 가져오는 getCount() 메소드에 예외처리 블록을 적용해보면 리
스트 3-3과 같은 코드가 만들어진다.

리스트 3-3JDBC 예외처리톨 적용한 getCount() 메소드


public int getCount() throws SQLException (
Connection c = null;
PreparedStatement ps =null;
ResultSet rs =null;

try (
c = dataSource.getConnection();

ps = c.prepareStatement('’select count(*) frαn users ' );

Resu
ltSet도 다양한 so낸xce미
ion
OI 발생할 수 있는rs.nextO; 코드이므로 W 블록 안에 뭔야 한다

return rS.getlnt(1);
} catch (SQLException e) {
throw e;
} finally {
if (rs != null) {
try {

rs .closeO;
L.,... 만률어진 Resu~Set을 닫아주는 기능 l∞e(}는

} catch (SQLException e) { I ~별어진 순서의 반대로 하는 것이 원칙이다 (c)

if (ps != null) {
try (
ps . close();
} catch (SQLException e) {

if (c != null) {
try (

c. close();
3장-템훌릿 213


} catch (SQLException e) {

이제 UserDao의 모든 메소드에 동일한 방식으로 try/catch/finally 블록을 적용했
다. 모든 작업을 마쳤으면 UserDaoTest 테스트를 수행해보고 이상이 없는지 확인한다.

이렇게 예외상뺑 대한처리까지 모두마쳤으니， 드디어 초난감
DAO라는모든오
명에서 벗어날 수 있게 됐다. 이제 서버환경에서도 안정적으로 수행될 수 있으면서 DB
연결 기능을 자유롭게 확장할 수 있는 이상적인 DAO가 완성됐다. 이 정도면 실전에 적
용해도 문제가 없는 잘 설계된 DAO다.

하지만! 여전히 뭔가 아쉬움이 남아 있다.

[ ~ 변등판 것과 변하지 않는 것 Et I

3.2.1 JDBC try / catch/finally 코드의 문제접
이제 try/catch/finally 블록도 적용돼서 완성도 높은 DAO 코드가 된 UserDao이지
만， 막상 코드를 훌어보면 한숨부터 나온다. 복잡한 try/catch/finally 블록이 2중으
로 중첩까지 되어 나오는데다， 모든 메소드마다 반복된다.
이런 코드를 작성할 때 사용할 수 있는 가장 효과적인 방법은 복사해서 붙이기， 일명
Copy&Paste 신공이다. Result5et
이 있는 것과 없는 두 가지 종류의 메소드가 있으니，
각각 하나씩 만들어두고 계속 묘드를 복사해서 새로운 메소드를 만들고， 메소드마다 달
라지는 try 블록의 일부 코드만 수정하는 것이다. 익숙해지면 복잡한 코드 속에서 펼요
한 부분만 바꾸는 일은 식은 죽 먹기일 수 있다. 그런데 그렇게 속도를 내서 작업하다
가 어느 순간 한 줄을 빼먹고 복사했거나 몇 줄을 잘못 삭제했다면 어떻게 될까? 괄호
를 잘못 닫은 게 아니라면 당^.}에 검파일 에러가 나지는 않을 것이다. 기능도 잘 동작하
는것처럼 보인다. finally
블록의 c. close() 라인하나빼먹은것과같은실수를했어
도 테스트를 돌려보면 별문제가 없어 보인다. 그러나 해당 메소드가 호출되고 나면 커
넥션이 하나씩 반환되지 않고 쌓여가게 된다. 서버에 배치해서 사용하면 언젠가 DB 풀

214


에 설정해놓은 최대 DB 커넥션 개수를 넘어설 것이고， 서버에서 리소스가 꽉 갔다는 에
러가나면서 서비스가중단되는상황이 발생한다.

실제로 어떤 기업의 인터넷 서비스 시스댐은 목 서버를 새로 시작시킨지 일주일만
지나면 DB 커넥션 풀이 꽉 갔다는 에러를 내면서 중단되는 일이 발생하기도 했다. 그
일주일 동안 정기적으로 사용되는 어떤 DAO 메소드에서 DB 커넥션을 반환해주지 않
다 보니 평균적으로 일주일 정도 지나면 풀이 가득 차벼리는 현상이 일어난 것이다. 이
기업에서는 트러블슈팅을 위한 전문 컨설턴트를 불렀고， 상황을 파악한 컨설턴트는 수
백 개의 DAO 소스코드를 A4지 수천 징F에 출력하고 하루 종일 앉아서 형광펜으로 코드
에 줄을 그어가면서 체크히는 방법으로 catch/finally가 빠진 곳이 없는지 close( ) 메
소드 호출을 빼먹은 부분이 없는지 뒤졌다고 한다. 결국 몇 군데 try/catch/finally 블
록과 close( ) 처리가 제대로 되어 있지 않은 부분을 찾아냈고， 그것을 수정한 뒤에 문
제는 해결됐다고 한다. 일단 급한 불은 꼈지만 안심할 수 있는 것은 아니다.

설령 실수를 하지 않고 처음엔 완벽하게 작성했더라도 이런 코드는 계속 폭탄이 될
가능성을 지니고 있다. 누군가 DAO 로직을 수정하려고 했을 때 복잡한 try/catch/
finally 블록 안에서 필요한 부분을 찾아서 수정해야 하고， 언젠가 폭 필요한 부분을
잘못 삭제해버리면 역시 같은 문제가 반복된다. 언제 터질지도 모르는 폭탄과 같은 코
드가되는것이다.

그렇다면 테스트를 통해 DAO마다 예외상황에서 리소스를 반닙송f는지 체크하게 했
으면 어쨌을까? 좋은 생각이긴 한데 막상 적용하기는 쉽지 않을 것이다. 예외상황을 처
리하는 코드는 태스트하기가 매우 어렵고 모든 DAO 메소드에 대해 이런 태스트를 일
일이 한다는 건 매우 번거롭기 때문이다. 강제로 예외상황을 만들려면 태스트를 위해
특별히 개발한 Connection
이나 PreparedStatement 구현 클래스가 필요하다. 이런 기
능은 구현하기도 쉽지 않다. 어떻게 적용했다고 하더라도 테스트 묘드의 양이 엄청나게
늘어날 것이다. 차라리 코드를 열심히 살펴보면서 빠진 부분은 없는지 확인히는 편이
나을지도모르겠다.

이런 묘드를 효과적으로 다룰 수 있는 방법은 없을까? 개발자라면 당연히 이런 의문
을 가져야 한다. 물론 이런 문제를 효과적으로 다룰 수 있는 방법이 있다. 이 문제의 핵
심은 변하지 않는， 그러나 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자
주 변하는 코드를 잘 분리해내는 작업이다. 자세히 살펴보면 I
징에서 살펴봤던 것과 비
슷한 문제이고 같은 방법으로 접근하면 된다. 다만 이변 코드는 DAO와 DB 연결 기능
을 분리하는 것과는 성격이 다르기 때문에 해결 방법이 조금 다르다.

3징-템을릿 215


3.2.2 분리와 재사용를 위한 디자인 꽤턴 적용
UserDao의 메소드를 개선히는 작업을 시작해보자. 가장 먼저 할 일은 변히는 성격이 다
른 것을 찾아내는 것이다. 리스트 3-4에 나와 있는 deleteAll() 메소드의 코드를 다시
살며보자.

리스트 3-4 개선힐 $농，te.셰Kl 메소드

Connection c = null;
PreparedStatement ps = null;

변하지않는부분

try {
c = dataSource .getConnection();

ps = c.prepareStatement("delete from users"); ~ 핸반부분

pS .executeUpdate();

} catch (SQLException e) {
throw e;

} finally {
if (ps != null) { try { ps .close(); } catch (SQLException e) {} }
if (c != null) { try {c .close(); } catch (SQLException e) {} }

PreparedStat메ent를 만들어서 업데이트용 쿼리를 실행하는 메소드라면 deleteAll ()
메소드와 구조는 거의 비슷할 것이다. 비슷한 기능의 메소드에서 동일하게 나타날 수 있
는 변하지 않고 고정되는 부분과 각 메소드마다 로직에 따라 변하는 부분을 위와 같이 구
분해볼수있다.

만약 add( ) 메소드라면 리스트 3-4에서 변하는 부분으로 표시한 코드를 리스트 3-5
와 같이 비꾸기만 하면 된다. 나머지 코드는 전핵 수정하지 않아도 된다.

리스트 3-5 add() 메소드에서 수정힐 부폼

ps =c.prepareStatement("insert into users(id , name , password) values(? ,?,?)");
pS.setString(l , user.getld());
pS .setString(2 , user.getName());
pS .setString(3 , user.getPassword());


그렇다면 이 로직에 따라서 변히는 부분을 변하지 않는 나머지 코드에서 분리히는
것이 어떨까? 그렇게 할 수 있다면 변하지 않는 부분을 재시용할 수 있는 방법이 있지
않을까?

메소드추출
먼저 생각해볼 수 있는 방법은 변하는 부분을 메소드로 빼는 것이다. 변하지 않는 부분
이 변하는 부분을 감싸고 있어서 변하지 않는 부분을 추출하기가 어려워 보이기 때문
에 반대로 해봤다. 리스트 3-6은 이렇게 수정한 deleteAll( ) 메소드다.

리스트 3~ 변하는 부분율 메소드로 추훌한 후의 delete.셰I()


public void deleteAll() throws SQLException {

try (
c = dataSource.getConnection();

ps = makeStatement(c);
--을 변하는 부분을 메소드로 추출하고 변히지 않는

부분에서 호훌하도록 만돌었다

pS.executeUpdate();
} catch (SQLException e)

private PreparedStatement makeStatement(Connection c) throws SQLException {
PreparedStatement ps;
ps = c.prepareStatement("delete from users'’) ;
return ps;

지주 바뀌는 부분을 메소드로 독립시켰는데 당장 봐서는 별 이득이 없어 보인다. 왜
냐하면 보통 메소드 추출 리팩토링을 적용히는 경우에는 분리시킨 메소드를 다른 곳에
서 재시용할 수 있어야 동}는데 이건 반대로 분리시키고 남은 메소드가 재사용이 필요
한 부분이고， 분리된 메소드는 DAO 로직마다 새롭게 만들어서 확장돼야 동}는 부분이
기 때문이다. 뭔가 반대로 됐다.

3장-탱플릿 217


템풀릿 메소드 꽤턴의 적용

다음은 댐플릿 메소드 패턴을 이용해서 분리해보자. 템플릿 메소드 패턴은 상속을 통해
기능을 확장해서 사용하는 부분이다. 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부
분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해 쓰도록

하는것이다.

추출해서 별도의 메소드로 독립시킨 makeStatement() 메소드를 다음과 같이 추상
메소드 선언으로 변경한다. 물론 UserDao 클래스도 추상 클래스가 돼야 할 것이다.

abstract protected PreparedStatement makeStatement(Connection c) throws
SQLException;

그리고 이를 상속히는 서브클래스를 만들어서 거기서 이 메소드를 구현한다. 고정된
JDBC try/catch/finally 블록을 가진 슈퍼클래스 메소드와 필요에 따라서 상속을 통
해 구체적인 PreparedStatement를 바꿔서 사용할 수 있게 만드는 서브클래스로 깔끔하

게 분리할 수 있다. 라스트 3-7은 UserDao를 상속해서 만든 클래스다.

리스트 3-7 mak싫latement(}톨 구현한 UserD∞ 서브클래스

public class UserDaoDeleteAll extends UserDao (

protected PreparedStatement makeStatement(Connection c) throws SQLException (
PreparedStatement ps = c.prepareStatement("delete from users");
return ps;

이제 UserDao 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할
수 있고， 확장 때문에 기존의 상위 DAO 클래스에 불필요한 변화는 생기지 않도록 할
수 있으니 객체지향 설계의 핵심 원리인 개방 패쇄 원칙
OCP을 그럭저럭 지키는 구조를
만들어낼 수는 있는 것 같다. 하지만 템플릿 메소드 패턴으로의 접근은 제한이 많다. 가
장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점이다. 만
약 이 방식을 사용한다면 UserDao의 JDBC 메소드가 4개일 경우 그림 3-1과 같이 4개
의 서브클래스를 만들어서 시용해야 한다. 이래서는 장점보다 단점이 더 많아 보인다.


그림 3-1 템풀릿 메소드 때턴의 적용 그림 3-1 템풀릿 메소드 때턴의 적용
또 확장구조가 이미 클래스를 설계하는 시점에서 고정되어 버린다는 점이다. 변
하지 않는 코드를 가진 UserDao
의 JDBC try/catch/finally 블록과 변하는
PreparedStatement를 담고 있는 서브클래스들이 이미 클래스 레벨에서 검따일 시점에
이미 그 관계가 결정되어 있다. 따라서 그 관계에 대한 유연성이 떨어져 버린다. 상속을
통해 확장을 꾀하는 템플릿 메소드 패턴의 단점이 고스란히 드러난다.

전략꽤턴의적용
개방 패쇄 원칙
OCP을 잘 지키는 구조이면서도 댐플릿 메소드 패턴보다 유연하고 확
장성이 뛰어난 것이， 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스
를 통해서만 의존하도록 만드는 전략 패턴이다. 전략 패턴은 OCP 관점에 보면 확장
에 해당히는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위
임하는 방식이다. 그림 3-2는 전략 패턴의 구조를 나타낸다. 좌측에 있는 Context
의
contextMethod()
에서 일정한 구조를 가지고 동작하다가 특정 확장 기능은 Strategy 인
터페이스를 통해 외부의 독립된 전략 클래스에 위임히는 것이다.


건엑스트 (Context)
contextMethod ()

전량(Strategy)
algorithmMethod ()
써r …’ ’
c。.ncreteStrategyA
algorithmMethod ()
…
ConcrateStrataqyB
al gori thmMethod( )
그림 3-2 전략 때턴의 구조

deleteAll () 메소드에서 변하지 않는 부분이라고 명시한 것이 바로 이 contextMethod()
가 된다. deleteAll()은 JDBC를 이용해 DB를 업데이트히는 작업이라는 변하지 않는
맥릭。ontext을 갖는다. deleteAll()
의 컨텍스트를 정리해보면 다음과 같다.

3장-탱플릿 219


• DB
커넥션가져오기
• PreparedStatement를 만들어줄 외부 기능 호출하기
• 전달받은 PreparedStatement 실행하기
• 예외가 발생하면 이를 다시 메소드 밖으로 던지기
• 모든 경우에 만들어진 Prepar때Statement와 Connection을 적절히 닫아주기
두 번째 작업에서 사용히는 PreparedStatement를 만들어주는 외부 기능이 바로 전
략 패턴에서 말하는 전략이라고 볼 수 있다. 전략 패턴의 구조를 따라 이 기능을 인터페
이스로 만들어두고 인터페이스의 메소드를 통해 PreparedStatement 생성 전략을 호출
해주면 된다. 여기서 눈여걱볼 것은 이 PreparedStatement를 생성히는 전략을 호출할
때는 이 컨텍스트 내에서 만들어둔 DB 커넥션을 전달해야 한다는 점이다. 커넥션이 없
으면 PreparedStatement도 만들 수가 없을 테니 말이다.

PreparedStatement
를 만드는 전략의 인터페이스는 컨텍스트가 만들어둔
Connection을 전달받아서 PreparedStatement를 만들고 만들어진 PreparedStatement
오브젝트를 돌려준다. 이 내용을 인터페이스로 정의하면 리스트 3-8과 같다.

리스트 3-8 StatementStrategy 인터페이스

package springbook .user .dao;

public interface StatementStrategy (
PreparedStatement makePreparedStatement(Connection c) throws SQLException;

이 인터페이스를 상속해서 실제 전략， 즉 바뀌는 부분인 PreparedStatement를 생성
히는 클래스를 만들어보자. deleteAll() 메소드의 기능을 위해 만든 전략 클래스는 리
스트
3-9와같다.

리스트 3-9 delet앙II() 메소드의 기능율 구현한 StatementStrategy 전략 률래스

package springbook .user .dao;

public class DeleteAllStatement implements StatementStrategy (
public PreparedStatement makePreparedStatement(Connection c) throws

SQLException (
PreparedStatement ps =c.prepareStatement("delete from users");
return ps;


이제 확장된 PreparedStrategy 전략인 DeleteAllStatement가 만들어졌다. 이것을
리스트 3-10과 같。
1 contextMethod()
에 해당하는 UserDao의 deleteAll() 메소드에서
사용하면 그럭저럭 전략 패턴을 적용했다고 볼 수 있다.

리스트 3-10 전략 때턴을 따라 Delete.셰IStatement가 적용된 delete.에
I() 메소드

public void deleteAll() throws SQLException (

try (
c = dataSource.getConnection();

StatementStrategy strategy = new DeleteAllStatement();
ps =strategy.makePreparedStatement(c);

ps.executeUpdate();
} catch (SQLException e) {


하지만 전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서
(OCP의 폐쇄 원칙) 전
략을 바꿔 쓸 수 있다(OCP의 개방 원칙)는 것인데 이렇게 컨텍스트 안에서 이미 구체
적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정되어 있다면 뭔가 이
상하다. 컨텍스트가 StatementStrategy 인터페이스뿐 아니라 특정 구현 클래스인
DeleteAllStatement를 직접 알고 있다는 건 전략 패턴에도 OCP에도 잘 들어맞는다고
볼수없기때문이다.

이 적용을 위한 클라이언트/컨텍스트 분리
이 문제를 해결하기 위해 전략 패턴의 실제적인 시용 방법을 좀 더 살펴보자.
전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 시용하
는 앞단의 Client가 결정하는 게 일반적이다. Client가 구체적인 전략의 하나를 선택하
고 오브젝트로 만들어서 Context
에 전달히는 것이다. Context는 전달받은 그 Strategy
구현 클래스의 오브젝트를 시용한다. 그림 3-3은 이를 표현한 것이다.

3장-템플릿 221


현빽스트 (Context) lf량(Strat형y)
contextMethod () algorithmMethod()
……r’ ’
C:oncr.teStrateqyA
algorithmMethod ()
C:oncreteStrateqyB
algorithmMethod()
현빽스트 (Context) lf량(Strat형y)
contextMethod () algorithmMethod()
……r’ ’
C:oncr.teStrateqyA
algorithmMethod ()
C:oncreteStrateqyB
algorithmMethod()
그림 3-3 전략 때턴에서 Client의 역할

그런데 이건 어디서 많이 보던 그림이 아닌가?장에서 처음 UserDao
와
ConnectionMaker를 독립시키고 나서 UserDao가 구체적인 ConnectionMaker 구현 클
래스를 만들어 사용하는 데 문제가 있다고 판단됐을 때 적용했던 바로 그 방법이
다. 그때는 컨텍스트(UserDao
)가 필요로 하는 전략(ConnectionMaker
)의 특정 구현 클래스

φ(DConne따다띠
빼

C
tion1

했다.

결국 이 구조에서 전략 오브젝트 생성과 컨텍스트로의 전달을 담당히는 책임을 분리
시킨 것이 바로 ObjectFactory
이며， 이를 일반화한 것이 앞에서 살펴봤던 의존관계 주
입미이었다. 결국 DI란 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든
구조라고볼수있다.

아무튼 여기서 이 패턴 구조를 코드에 적용해보자. 중요한 것은 이 컨텍스트에 해당
하는 JDBC try/catch/finally 묘드를 클라이언트 묘드인 StatementStrategy를 만드
는 부분에서 독립시켜야 한다는 점이다. 현재 deleteAll () 메소드에서 다음 묘드는 클
라이언트에 들어가야 할 묘드다. deleteAll ()의 나머지 코드는 컨돼스트 코드이므로
분리해야한다.

StatementStrategy strategy = new DeleteAllStatement();

컨텍스트에 해당하는 부분은 별도의 메소드로 독립시격보자. 클라이언트는
DeleteAllStatement 오브젝트와 같은 전략 클래스의 오브젝트를 컨텍스트의 메소드를
호출하며 전달해야 한다. 이를 위해 전략 인터페이스인 StatementStrategy를 컨텍스트
메소드 파라미터로 지정할 필요가 있다. 리스트 3-11
은 컨텍스트를 메소드로 분리한
것이다.


리스트 3-11 메소드로 분리한 try/<∞tch/finally 컨텍스트 코드

public void jdbcContextWithStatementStrategy(StatementStrategy stmt) throws
SQLException { •
Connection c = null; 클라이언트가 컨텍스트를 호출할 때
PreparedStatement ps = null; 넘겨줄전략따라미터

try (
c =dataSource.getConnection();

ps = stmt.makePreparedStatement(c);

pS .executeUpdate();
} catch (SQLException e) {
throw e;

} finally {
if (ps != null) { try { ps .close(); } catch (SQLException e) {} }
if (c != null) { try {c.close(); } catch (SQLException e) {} }


이 메소드는 컨텍스트의 핵심적인 내용을 잘 담고 있다. 클라이언트로부터
StatementStrategy 타입의 전략 오브젝트를 제공받고 JDBC try/catch/finally
구조로 만들어진 컨텍스트 내에서 작업을 수행하다. 제공받은 전략 오브젝트는
PreparedStatement 생성이 필요한 시점에 호출해서 사용한다. 모든 JDBC 코드의 틀에
박힌 작업은 이 컨텍스트 메소드 안에 잘 담겨 있다.

다음은 클라이언트에 해당하는 부분을 살펴보자. 컨텍스트를 별도의 메소드
로 분리했으니 deleteAll( ) 메소드가 클라이언트가 된다. deleteAll()
은 전략 오
브젝트를 만들고 컨텍스트를 호출하는 책임을 지고 있다. 사용할 전략 클래스는
DeleteAllStatement
이므로 이 클래스의 오브젝트를 생성하고， 컨텍스트로 분리한
jdbcContextWithStatementStrategy() 메소드를 호출해주변 된다. 리스트 3-12는 클
라이언트 책임을 갖도록 재구성한 deleteAll () 메소드다.

리스트 3-12 클라이언트 책임을 담당할 delete.셰I() 메소드

public void deleteAll() throws SQLException {
StatementStrategy st = new DeleteAllStatement();
-을 선정한 전략 클래스의 오브젝트 생성
jdbcContextWithStatementStrategy(st);~ 컨텍스트 호출 전략 오브젝트 전달

3장-템플릿 223


이제 구조로 볼 때 완벽한 전략 패턴의 모습을 갖췄다
. 비록 클라이언트와 컨텍스트
는 클래스를 분리하진 않았지만， 의존관계와 책임으로 볼 때 이상적인 클라이언트/컨텍
스트 관계를 갖고 있다. 특히 클라이언트가 컨텍스트가 사용할 전략을 정해서 전달한다
는 면에서 DI 구조라고 이해할 수도 있다. 아직까지는 이렇게 분리한 것에서 크게 장점
이 보이지 않는다. 하지만 지금까지 해옹 관심사를 분리하고 유연한 확장관계를 유지하
도록 만든 작업은 매우 중요하다. 이 구조가 기반이 돼서 앞으로 진행할 UserDao 묘드
의 본격적인 개선 작업이 가능한 것이다.

웰
Dtol꿇매
의존관계 주입(마은 다양한 형태로 적용할 수 있다. 미의 가장 충요한 개념온 채3자의 도용율
흥해 두 오브젝트 사이의 유언한 관계가 싫정되도혹 만든다는 것이다. 이 개냄만 따룰다면 대톨
이루는 오브젝트와 구성요소의 구조나 관계는 다양하게 만률 수 있다.

일반적으로 α는 의존관계에 있는 두 개의 오브젝트와 이 판계톨 다이내믹하게 혈정해주는 오
브젝트 팩토리(마 컨테이네. 그리고 01톨 사용하는 롤라이언트라는 4개의 오브젝트 사이때서
일어난다. 하지만 때로는 월시적인 전략 때턴 구조톨 따라 률라이언트가 오브젝트 팩토리의 책
임옳 함께 지고 있옳 수도 있다. 또는 롤라이언트와 전랙의존 오브젝트)이 걸합휠 수도 있다.
심지어는 물라이언트와 미 관계에 있는 두 개의 오브젝트가 모두 하나의 쿨래스 요뻐| 담킬 수도
있다.

이런 경우에는 미가 매우 작은 단위의 표드와 메소드 사이에서 얼어나기도 한다. 잃핏 보면 DI
앓아 보이지 않지만. 세밀하게 관찰해보면 작은 단위지만 엄연히 대가 이획지고 있융흩 알 수
있다. 이훨게 대의 장점옳 단순화해서 IOC 컨테이너의 도용 없이 코드 내에서 적용한 경우톨 마
이크로 미라고도 한다. 또는 코드에 의한 미라는 의미로 수동 마라고 부톨 수도 있다.

[ ~3JI]:rï] 전략 패턴의 최적화 괜; I

지금까지 기존의 deleteAll() 메소드에 담겨 었던 변하지 않는 부분， 자주 변하
는 부분을 전략 패턴을 사용해 깔끔하게 분리해냈다. 독립된 JDBC 작업 흐름
이 담긴 jdbcContextWithStatementStrategy()
는 DAO 메소드들이 공유할 수
있게 됐다. DAO 메소드는 전략 패턴의 클라이언트로서 컨텍스트에 해당하는
jdbcContextWithStatementStrategy() 메소드에 적절한 전략， 즉 바뀌는 로직을 제 .
공해주는 방법으로 사용할 수 있다. 여기서 컨텍스트는 PreparedStatement를 실행
하는 JDBC의 작업 흐름이고， 전략은 PreparedStatement를 생성하는 것이다.

224


3.3.1 전략 클래스의 추가 정보
이번엔 add( ) 메소드에도 적용해보자. 먼저 add( ) 메소드에서 변하는 부분인
PreparedStatement를 만드는 코드를 AddStatement 클래스로 옮겨 담는다. 이렇게 만
틀어진 클래스는 리스트 3-l3과 같다.

l

리스트 3-13 잉d{) 메소드의 Prepar영S떠tement 생성 로직흩 봄리한 롤래스

public class AddStatement implements StatementStrategy {

public PreparedStatement makePreparedStatement(Connection c)

throws SQLException {

PreparedStatement ps =

c.prepareStatement('insert into users(id , name , password)

values(?,?,?)");

ps.setString(l , user.getld());

ps.setString(2, user.getName());

ps.setString(3, user.getPassword());
--을 그런
데 ‘짧는 어디서 가져올까?

return ps;


그런데 이렇게 클래스를 분리하고 나니 컴파일 에러가 난다. deleleAll()
과는 달리
add()
에서는 PreparedStatement를 만들 때 user라는 부가적인 정보가 필요하기 때문
이다. 등록할 사용자 정보는 클라이언트에 해딩히는 add() 메소드가 갖고 있다. 따라서
클라이언트가 AddStatement
의 전략을 수행하려면 부가정보인 user를 제공해줘야 한다.

클라이언트로부터 User 타입 오브젝트를 받을 수 있도록 리스트 3-14와 같이
AddStatement
의 생성자를 통해 제공받게 만들자.

리스트 3-14 User 정보톨 생성자로부터 제공받도록 만든 AddS
녀，ternent

package springbook .user .dao;

public class AddStatement implements StatementStrategy {
User user;

public AddStatement(User user) {
this.user =user;

3징-템를릿 225


public PreparedStatement makePreparedStatement (Connection c) (

pS.setString(l , user.getld());
ps.setString(2, user.getName());
ps.setString(3, user.getPassword());

이제 컴파일 에러는 나지 않을 것이다. 다음은 클라이언트인 UserDao의 add() 메소
드를 리스트 3-15와 같이 user 정보를 생성자를 통해 전달해주도록 수정한다.

리스트 3-15 user 정보톨 A여Statement에 전달해주는 add() 메소드

public void add(User user) throws SQLException (
StatementStrategy st =new AddStatement(user);
jdbc(ontextWithStatementStrategy(st);

잊지 말고 태스트를 돌려보자. 역시 성공이다. 상당히 과감한 코드 개선 작업을 하고
나서 테스트를 돌렸는데 JUnit 뷰에서 성공을 뭇하는 녹색 막대가 나오면 기분이 좋다.
미리 준비해둔 태스트가 있기 때문에 이렇게 DAO 코드를 자유롭게 개선할수 있다는
사실을잊지말자.

이렇게 해서 deleteAll ()과 add( ) 두 군데에서 모두 PreparedStatement
를 실행하는 JDBC try/catch/finally 컨텍스트를 공유해서 사용할 수 있게 됐
다. 앞으로 비슷한 기능의 DAO 메소드가 필요할 때마다 이 Statement 전략과
jdbcContextWithStratementStategy() 컨텍스트를 활용할 수 있으니 try/catch/
finally로 범벅된 코드를 만들다가 실수할 염려는 없어졌다. DAO 묘드도 간결해졌다.
DAO 묘드의 OJ=-을 많게는 70~80o/o7l}지 줄일 수 있다.

3.3.2 전략과 클라이언트의 동거
지금까지 해옹 작업만으로도 많은 문제점을 해결하고 코드도 깔끔하게 만들긴 했지만，
그래도여기서 만족하지 말고좀더 개선할부분을찾아보자.
나는 현재 만들어진 구조에 두 가지 불만이 있다. 먼저 DAO 메소드마다 새로운
StatementStrategy 구현 클래스를 만들어야 한다는 점이다. 이렇게 되면 기존 UserDao


때보다 클래스 파일의 개수가 많이 늘어난다. 이래서는 런타임 시에 다이내믹하게 DI
해준다는 점을 제외하면 로직마다 상속을 사용하는 댐플릿 메소드 패턴을 적용했을 때
보다 그다지 나을 게 없다. 또 다른 불만은 DAO 메소드에서 StatementStrategy
에 전
달할 User와 같은 부가적인 정보가 있는 경우 이를 위해 오브젝트를 전달받는 생성자
와 이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점이다. 이 오브젝트가
사용되는 시점은 컨텍스트가 전략 오브젝트를 호출할 때이므로 잠시라도 어딘가에 다
시 저장해둘 수밖에 없다.

이 두 가지 문제를 해결할 수 있는 방법을 생각해보자.

로컬클래스
클래스 파일이 많아지는 문제는 간단한 해결 방법이 있다. StatementStrategy 전략 클
래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의해버
리는 것이다. DeleteAllStatement나 AddStatement는 UserDao 밖에서는 사용되지 않는
다. 둘 다 UserDao에서만 사용되고. UserDao의 메소드 로직에 강하게 결합되어 었다.
특정 메소드에서만 사용되는 것이라면 리스트 3-16과 같이 로컬 클래스로 만들 수
도있다.

리스트 3-16 add() 메소드 내의 로컬 클래스로 이전한 AddStatement


public void add(User user) throws SQLException {
class AddStatement implements StatementStrategy (---기
User user; ’

add() 메소드 내부에 선언된
로컬클래스다

public AddStatement(User user) (
this.user =user;

public PreparedStatement makePreparedStatement(Connection c)
throws SQLException (
PreparedStatement ps =
c.prepareStatement("insert into users(id , name , password)

values(?,?,?)") ;
ps.setString(l , user.getld());
ps.setString(2, user.getName());
ps.setString(3, user.getPassword());

return ps;

3~ι 템을릿 227


StatementStrategy st = new AddStatement(user);
jdbcContextWithStatementStrategy(st);

響
훌혐톨래쇄를휴
다훌 훌래스 내부에 정의되는 훌래스톨 종첩 훌래스(nested class)라고 효봐. 충챔 톨래스는 혹
립적으로 오브젝트로 E흩어질 수 있는 스태퇴 쿨래스(없liccl홉)와 자신이 정의된 를래스의
오브책트 요뼈|서만 만률어질 수 있는 내부 훌래스Onner class)로 구톨된다.

내부 롤래스는 다시 범위(scope)어| 따라 셰 가지로 구붐된다. 맹버 뭘드처혐 오브책트 랙밸얘
정의되는 멤버 내부 훌래스(member inner class)와 메소드 레뱉애 정의되는 로혐 훌래스(10<냉
cIass), 그리고 이를옳 갖지 않는 익명 내부 훌래스(anonymous 뼈r class)다. 익명 내부 훌래
스의 범위는 선언된 위치에 따라서 다르다.

AddStatement 클래스를 로컬 클래스로서 add( ) 메소드 안에 집어넣은 것이다. 이런
식으로 클래스를 정의히는 방식이 생소할지 모르겠지만 자바 언어에서 허용하는 클래
스 선언 방법의 하나다. 마치 로컬 변수를 선언히듯이 선언하면 된다. 로컬 클래스는 선
언된 메소드 내에서만 사용할 수 있다. AddStatement가 시용될 곳이 add( ) 메소드뿐이
라면， 이렇게 사용하기 전에 바로 정의해서 쓰는 것도 나쁘지 않다. 덕분에 클래스 파일
이 하나줄었고， add() 메소드 안에서 PreparedStatement 생성 로직을함께 볼수 있으
니 묘드를 이해하기도 좋다.

로컬 클래스에는 또 한 가지 장점이 있다. 바로 로컬 클래스는 클래스가 내부 클래
스이기 때문에 자신이 선언된 곳의 정보에 접근할 수 있다는 점이다. AddStatement는
User 정보를 필요로 한다. 이를 위해 생성자를 만들어서 add( ) 메소드에서 이를 전달해
주도록 했다. 그런데 이렇게 add() 메소드 내에 AddStatement 클래스를 정의하면 번거
롭게 생성자를 통해 User 오브젝트를 전달해줄 펼요가 없다.

내부 메소드는 자신이 정의된 메소드의 로컬 변수에 직접 접근할 수 있기 때문이다.
메소드 파라미터도 일종의 로컬 변수이므로 add() 메소드의 user 변수를 AddStatement
에서 직접 사용할 수 있다. 다만， 내부 클래스에서 외부의 변수를 사용할 때는 외부 변
수는 반드시 final로 선언해줘야 한다. user 따라미터는 메소드 내부에서 변경될 일이
없으므로 final
로 선언해도 무빛}하다.


이렇게 내부 클래스의 장점을 이용하면 user 정보를 전달받기 위해 만들었던 생성자
와 인스턴스 변수를 제거할 수 있으므로 AddStatement는 리스트 3-17과 같이 간결해
진다.

리스트 3-17 혀d() 메소드의 로컬 변수룰 직접 사용하도록 수정한 AddStatement

public void add(final User user) throws SQLException {
class AddStatement implements StatementStrategy {
public PreparedStatement makePreparedStatement(Connection c)
throws SQLException {
PreparedStatement ps =c.prepareStatement(
insert into users(id, name , password) values(7, 7, 7)");
pS.set5tring(1 , user.getld()); 기

pS.set5tring(2 , user.getName());
|
>
로컬(내부) 클래스의 코드에서 외부의 메소드
pS.set5tring(3, user.getPassword());J 로걸 연수에 직접 접근할 수 있다，

return ps;

StatementStrategy st = new AddStatement();--을 생성자 따라미터로 user를 전달하지

않아도된다

jdbcContextWith5tatement5trategy(st);


로컬 클래스로 만들어두니 장점이 많다. AddStatement는 복잡한 클래스가 아니므로
메소드 안에서 정의해도 그다지 복잡해 보이지 않는다. 메소드마다 추가해야 했던 클래
스 따일을 하나 줄일 수 있다는 것도 장점이고 내부 클래스의 특징을 이용해 로컬 변수
를 바로 가져다 사용할 수 있다는 것도 큰 장점이다.

익명내부클래스
한 가지 더 욕심을 내보자. AddStatement 클래스는 add() 메소드에서만 사용할 용도로
만들어졌다. 그렇다면 좀 더 간결하게 클래스 이름도 제거할 수 있다. 자바에는 이름조
차 필요 없는 익명 내부 클래스가 있지 않은가.

3장-템을릿 229


뿔
익명내뿌톨래스
익명 내부 클래스(anonyr따JS inner cIass)는 이륨올 갖지 않는 클래스다. 률래스 선언과 오브
젝트 생성이 컬합된 형태로 만둘어지며. 상속할 률래스나 구현할 인터때이스톨 생성자 대신 사
용해서 다읍과 갈은 형태로 만훌어 사용한다. 룰래스톨 재사용힐 필요가 없고. 구현한 인터왜|이
스 타입으로만 사용할 경우에 유용하다.

r뺑 인터페이스이를() { 클래스 본문 };

AddStatement를 익명 내부 클래스로 만들어보자. 익명 내부 클래스는 선언과 동시에
오브젝트를 생성한다. 이름이 없기 때문에 클래스 자신의 타입을 가질 수 없고， 구현한
인터페이스 타입의 변수에만 저장할 수 있다. 리스트 3-18은 AddStatement를 익명 내
부 클래스로 전환한 것이다.

리스트 3-18
AddS
원tement톨 익명 내부 클래스로 전환

• 익영 내부 클래스는 구현핸 인
터페이스를
생성자처럼 이용해서 오브젝트로 만든다
StatementStrategy st = new StatementStrategy() {
public PreparedStatement makePreparedStatement(Connection c)
throws SQLException {

PreparedStatement ps =
c.prepareStatement( “insert into users(id, name , password)

values(? ,?,?)");
pS .setString(1 , user.getld());
ps .setString(2 , user .getName());
pS.setString(3, user .getPassword());

return ps;

만들어진 익명 내부클래스의 오브젝트는딱한번만사용할테니 굳이 변수에 담아
두지 말고 jdbcContextWithStatementStrategy() 메소드의 파라미터에서 바로 생성하
는 편이 낫다. 이렇게 정리하면 add() 메소드는 리스트 3-19와 같이 더욱 간결해진다.

리스트 3-19 메소드 따라미터로 이전한 익명 내부 클래스

public void add(final User user) throws SQLException {
idbcContextWithStatementStrategy(
new StatementStrategy() {
public PreparedStatement makePreparedStatement(Connection c)


throws SQLException {
PreparedStatement ps =

c. prepareStatement("insert into users (id, name ,
password) values(ζ
7.7)’);
pS .setString(1 , user .getld());
pS
.
setString(ι user .getName());
pS .setString(3, user .getPassword());

return ps;

마찬가지로 DeleteAllStatement도 deleteAll () 메소드로 가져와서 익명 내부 클래
스로 처리하면 리스트 3-20과 같이 간략하게 만들 수 있다.

리스트 3-20 익명 내부 클래스톨 적용한 delete.이I() 메소드


public void deleteAll() throws SQLException {
jdbcContextWithStatementStrategy(
new StatementStrategy() (
public PreparedStatement makePreparedStatement(Connection c)
throws SQLException {
return c.prepareStatement("delete from users");

[ ~~ 컨텍스트와 이 f펠 I

3.4.1 Jd
bcContext의 분리
전략 패턴의 구조로 보자면 UserDao의 메소드가 클라이언트이고， 익명 내부 클래스로
만들어지는 것이 개별적인 전략이고. jdbcContextWithStatementStrategy() 메소드
는 컨텍스트다. 컨텍스트 메소드는 UserDao 내의 PreparedStatement를 실행히는 기능

3장-템플릿 231


을 가진 메소드에서 공유할 수 있다. 그런데 JDBC
의 일반적인 작업 흐름을 담고 있
는 jdbcContextWithStatementStrategy()는 다른 DAO에서도 시용 가능하다. 그러
니 jdbcContextWithStatementStrategy()
를 UserDao 클래스 밖으로 독립시켜서 모
든 DAO가 사용할 수 있게 해보자.

클래스분리
분리해서 만들 클래스의 이름은 JdbcContext라고 하자. JdbcContext에 UserDao에 있
던 컨돼스트 메소드를 workWithStatementStrategy()
라는 이름으로 옮겨놓는다. 그
런데， 이렇게 하면 DataSource가 필요한 것은 UserDao가 아니라 JdbcContext가 돼
버린다. DB 커넥션을 펼요로 하는 묘드는 JdbcContext 안에 있기 때문이다. 따라서
JdbcContext가 DataSource에 의존하고 있으므로 DataSource 타입 빈을 DI 받을 수 있
게해줘야한다.
리스트 3-21
은 새로 만든 JdbcContext 클래스다.

리스트 3....，낀 JDBC 작업 효톰율 본리해서 만든 JdbcContext 쿨래스

package springbook .user.dao;

public class JdbcContext (

private DataSource dataSource;

public void setDataSource(DataSource dataSource) ( ~늦 며앉30ur∞ 타입 빈을 α 받을 수

this.dataSource =dataSource; 「
있게훈비해둔다‘

public void workWithStatementStrategy(StatementStrategy stmt) throws

SQLException { 니 때bcConte씨 클래스 안옆 옮겼면로
Connection c =null; 이릉도 그에 맞게 수정했다
PreparedStatement ps =null;

try (
c =this .dataSource .getConnection();

ps =stmt.makePreparedStatement(c);

ps .executeUpdate();
} catch (SQLException e) {
throw e;
} finally {


if (ps != null) { try ( pS.close(); } catch (SQLException e) {} }
if (c != null) { try (c .close(); } catch (SQLException e) {} }

디음은 리스트 3-22처럼 UserDao가 분리된 JdbcContext를 DI 받아서 사용할 수 있
게만든다.

리스트 3-22 JdbcContext를 미 받아서 사용하도록 만든 UserDao

public class UserDao (


private JdbcContext jdbcContext;

public void setJdbcContextOdbcContext jdbcContext) ( L JdbcC。미ext률 01
this.jdbcContext =jdbcContext; 받도록 만든다

public void add(final User user) throws SQLException (

this.jdbcContext.workWithStatementStrategy( -을 미 받은 JdbcConlext의 컨텍스트
new StatementStrategy( ) { ... } 메소드를 시용하도록 변경효삐

public void deleteAll() throws SQLException (
this.jdbcContext.workWithStatementStrategy(
new StatementStrategy( ) { . .. }

빈의존관계변경
새롭게 작성된 오브젝트 간의 의존관계를 살며보고 이를 스프링 설정에 적용해보자.
UserDao는 이제 JdbcContext에 의존하고 있다. 그런데 JdbcContext는 인터페이스인
DataSource와는 달리 구체 클래스다. 스프링의 DI는 기본적으로 인터페이스를 사이에
두고 의존 클래스를 바꿔서 사용하도록 하는 게 목적이다. 하지만 이 경우 JdbcContext
는 그 자체로 독립적인 JDBC 컨텍스트를 제공해주는 서비스 오브젝트로서 의미가 있
을 뿐이고 구현 방법이 바뀔 가능성은 없다. 따라서 인터페이스를 구현하도록 만들지

3장-탱플릿 233


않았고， UserDao와 JdbcContext는 인터페이스를 λ에에 두지 않고 DI를 적용하는 특별
한 구조가 된다. 그림 3-4는 JdbcContext가 추가된 의존관계를 나타내주는 클래스 다
이어그램이다.

U••rDa。
JdbcCont.",t
add() contextMethod ()
deleteAll ()


그림 3-4 JdbcContext톨 적용한 U똥rDao의 의존판계

스프링의 빈 설정은 클래스 레벨이 아니라 런타임 시에 만들어지는 오브젝트 레벨의 의
존관계에 따라 정의된다. 빈으로 정의되는 오브젝트 사이의 관계를 그려보면 그림 3-5
와 같다. 기존에는 userDao 빈이 dataSource 빈을 직접 의존했지만 이제는 jdbcContext
빈이 그 사이에 끼게 된다.

us.rOao:Us.rOa。

jdbcContext


그림 3 -5의 빈 의존관계를

織-


鍵

그립 3-5 JdbcContext가 적용된 빈 오브젝트 관계

따라서
applicationContext. xml 파일을 리스트 3-23과 같이 수정한다.

리스트 3-23
JdbcCαltext 빈율 추가하도록 수정한 설정파일

XML


dataSource

:S보pleD
rivarOS

driverClass
url
username

pass
써。
rd

설정파일을 수정하자. text


<?xml version='’1.0" encoding="UTF-8"?)

<beans xmlns='http://www.springframework.org/schema/beans"
xmlns:xsi=‘ http ://www.w3 .org/2001/XMLSchema-instance'
xsi:schemaLocation='http://www.springframework.org/schema/beans
http://www .springframework .org/schema/beans/spring-beans .xsd “

<bean id='userDao' class='springbook.user.dao.UserDao')
UserDao 내에 아직 J따℃에ext톨

<property name='dataSource' ref='dataSource' /)~ 적용하지 않은 머|소드가 있어서 제
(property name='jdbcContext' ref='jdbcContext' /> 거하지 않았다</
bean>


(bean id='jdbcContext’ class='springbook.user.dao.JdbcContext'>
<property name="dataSource" ref="dataSource" 1>

</bean>
추가된 JdbcContext 타입 빈

(bean id="dataSource"
class="org.springframework.jdbc.datasource.SimpleDriverDataSource" >

〈이/매bea뻐n>

</beans>

아직은 userDao의 모든 메소드가 JdbcContext를 시용하는 것은 아니니， 기존 방법을
사용해서 동작하는 메소드를 위해 UserDao가 아직은 dataSource를 DI 받도록 하고 있
음에 주의하자. 일단은 JdbcContext와 이를 사용하는 UserDao 메소드에만 집중해서 코

이제 JdbcContext를 UserDao로부터 완전히 분리하고 DI를 통해 연결될 수 있도록
설정을 마쳤다. UserDaoTest 태스트를 실행해서 이 JdbcContext를 분리해서 사용하도
록 하는 코드 수정 작업에 이싼l 없는지 확인해보자.

자
3.4.2 01JdbcCo의 특별한ntext
보

JdbcContext를 분리하면서 시용했던 DI 방법에 대해 좀 더 생각해보자. UserDao와

댈
JdbcContext 사이에는 인터페이스를 샤용하지 않고 DI를 적용했다. 지금까지 적용했던

DI에서는 클래스 레벨에서 구체적인 의존관계가 만들어지지 않도록 인터페이스를 사

용했다. 인터페이스를 적용했기 때문에 묘드에서 직접 클래스를 사용하지 않아도 됐고，

그 덕분에 설정을 변경하는 것만으로도 얼마든지 다양한 의존 오브젝트를 변경해서 사

용할수있게됐다.

그런데 UserDao는 인터페이스를 거치지 않고 코드에서 바로 JdbcContext 클래스를

사용하고 있다. UserDao와 JdbcContext는 클래스 레벨에서 의존관계가 결정된다. 비록

런타임 시에 DI 방식으로 외부에서 오브젝트를 주입해주는 방식을 사용하긴 했지만， 의

존 오브젝트의 구현 클래스를 변경할 수는 없다.

스프링번으로
01

이렇게 인터페이스를 사용하지 않고 DI를 적용하는 것은 문제가 있지 않을까? 스프링

DI의 기본 의도에 맞게 JdbcContext의 메소드를 인터페이스로 뽑아내어 정의해두고，

3장-템율릿 235



이를 UserDao에서 사용하게 해야 하지 않을까? 물론 그렇게 해도 상관은 없다. 하지만
쪽그렬필요는없다.

의존관계 주입이이라는 개념을 충실히 따르자연 인터페이스를 사이에 둬서 클래스
레벨에서는 의존관계가 고정되지 않게 하고， 런타임 시에 의존할 오브젝트와의 관계를
다이내믹하게 주입해주는 것이 맞다. 따라서 인터페이스를 시용하지 않았다면 엄밀히
말해서 온전한 01라고 볼 수는 없다. 그러나 스프링의 01는 넓게 보자면 객체의 생성과
관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC라는 개념
을 포괄한다. 그런 의미에서 JdbcContext를 스프링을 이용해 UserDao 객체에서 사용하
게 주입했다는 건 01의 기본을 따르고 있다고 볼 수 있다.

인터페이스를 사용해서 클래스를 자유롭게 변경할 수 있게 하지는 않았지만，
JdbcContext를 UserDao와 01 구조로 만들어야 할 이유를 생각해보자.

첫째는 JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤
빈이 되기 때문이다. JdbcContext는 그 자체로 변경되는 상태정보를 갖고 있지 않다.
내부에서 시용할 dataSource라는 인스턴스 변수는 있지만. dataSource는 읽기전용이
므로 JdbcContext가 싱글톤이 되는 데 아무런 문제가 없다. JdbcContext는 JDBC 컨텍
스트 메소드를 제공해주는 일종의 서비스 오브젝트로서 의미가 있고， 그래서 싱글톤으
로 등록돼서 여러 오브젝트에서 공유해 시용되는 것이 이상적이다.

둘째는 JdbcContext가 01를 통해 다른 빈에 의존하고 있기 때문이다. 이 두 번째 이
유가 중요하다. JdbcContext는 dataSource 프로퍼 티를 통해 DataSource 오브젝트를
주입받도록 되어 었다.01를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모
두 스프링 빈으로 등록돼야 한다. 스프링이 생성하고 관리하는 IoC 대상이어야 01에
참여할 수 있기 때문이다. 따라서 JdbcContext는 다른 빈을 01 받기 위해서라도 스프링
빈으로등록돼야한다.

실제로 스프링에는 드물지만 이렇게 인터페이스를 사용하지 않는 클래스를 직접 의
존히는 01가 등장하는 경우도 었다.

여기서 중요한 것은 인터페이스의 시용 여부다. 왜 인터페이스를 사용하지 않았을
까? 인터페이스가 없다는 건 UserDao와 JdbcContext가 매우 긴밀한 관계를 가지고 강
하게 결합되어 있다는 의미다. UserDao는 항상 JdbcContext 클래스와 함께 시용돼
야 한다. 비록 클래스는 구분되어 있지만 이 둘은 강한 응집도를 갖고 있다. UserDao
가 JDBC 방식 대신 lPA나 하이버네이트 같은 ORM을 사용해야 한다면 JdbcContext
도 통째로 바뀌어야 한다. JdbcContext는 DataSource와 달리 태스트에서도 다른 구현
으로 대체해서 사용할 이유가 없다. 이런 경우는 굳이 인터페이스를 두지 말고 강력한


결합을 가진 관계를 허용하면서 위에서 말한 두 가지 이유인 싱글톤으로 만드는 것과

JdbcContext
에 대한 DI 필요성을 위해 스프링의 빈으로 등록해서 UserDao에 DI 되도
록만들어도좋다.

단， 이런 클래스를 바로 시용하는 코드 구성을 DI에 적용히는 것은 가장 마지막 단계
에서 고려해볼 사항임을 잊지 말자. 그저 인터페이스를 만들기가 귀찮으니까 그냥 클래
스를 사용해}는 건 잘못된 생각이다. 굳이 원한다면 JdbcContext
에 인터페이스를 두
고 UserDao에서 인터페이스를 사용하도록 만들어도 문제 될 것은 없다.

코드를 이용하는 수동 01
JdbcContext를 스프링의 빈으로 등록해서 UserDao에 DI 히는 대신 사용할 수 있는 방
법이 있다. UserDao 내부에서 직접 DI를 적용하는 방법이다.
이 방법을 쓰려면 JdbcContext를 스프링의 빈으로 등록해서 사용했던 첫 번째 이유
인 싱글톤으로 만들려는 것은 포기해야 한다. 물론 스프링의 도움을 받아서 싱글톤으로
만드는 걸 포기했다고 해서 DAO 메소드가 호출될 때마다 JdbcContext 오브젝트를 새
로 만드는 무식한 방법을 사용해야 한다는 뭇은 아니다. 조금만 타협을 해서 DAO마다
하나의 JdbcContext 오브젝트를 갖고 있게 하는 것이다. DAO 메소드에서 매번 만들어
사용한다면 수만， 수백만의 JdbcContext 오브젝트가 만들어지겠지만， DAO마다 하나

씩만 만든다면 기껏해야 DAO 개수만큼， 웬만큼 대형 프로젝트라고 하더라도 수백 개

변 충분할 것이다. JdbcContext에는 내부에 두는 상태정보가 없다. 따라서 오브젝트 수
십， 수백 개가 만들어진다고 해도 메모리에 주는 부담은 거의 없다. 또한 자주 만들어졌
다가 제거되는 게 아니기 때문에 GC에 대한 부담도 없다.

JdbcContext를 스프링 빈으로 등록하지 않았으므로 다른 누군가가 JdbcContext의
생성과 초기화를 책임져야 한다. JdbcContext
의 제어권은 UserDao가 갖는 것이 적당하
다. 자신이 시용할 오브젝트를 직접 만들고 초기화하는 전통적인 방법을 사용하는 것이
다. 어차피 JdbcContext 클래스의 정체도 알고 있으니 문제 될 것은 없다.

남은 문제는 JdbcContext를 스프링 빈으로 등록해서 사용했던 두 번째 이유다.
JdbcContext는 다른 빈을 인터페이스를 통해 간접적으로 의존하고 있다. 다른 빈을 의
존하고 있다면， 의존 오브젝트를 DI를 통해 제공받기 위해서라도 자신도 빈으로 등록돼
야 한다고 했다. 그렇다면 UserDao에서 JdbcContext를 직접 생성해서 사용하는 경우에
는 어떻게 해야 할까? 여전히 JdbcContext는 DataSource 타입 빈을 다이내믹하게 주입
받아서 사용해야 한다. 그렇지 않으면 DataSource 구현 클래스를 지쉬롭게 바꿔가면서

3징-템을릿 237


적용할 수 없다. 하지만 JdbcContext 자신은 스프링의 빈이 아니니 DI 컨테이너를 통해
DI
받을수는없다.

이런 경우에 사용할 수 있는 방법이 한 가지 있다. 그것은 JdbcContext
에 대한 제어
권을 갖고 생성과 관리를 담당하는 UserDao에게 DI까지 맡기는 것이다. 오브젝트를 생
성하고 그 의존 오브젝트를 수정자 메소드로 주입해주는 것이 바로 DI
의 동작원리가 아
닌가? 그렇다면 UserDao가 임시로 DI 컨테이너처럼 통작하게 만들면 된다.

JdbcContext에 주입해줄 의존 오브젝트인 DataSource는 UserDao가 대신 DI 받도
록 하면 된다. UserDao는 직접 DataSource 빈을 필요로 하지 않지만 JdbcContext
에 대
한 DI 작업에 사용할 용도로 제공받는 것이다. UserDao는 주입받은 DataSource 빈을
JdbcContext를 만들고 초기화하는 과정에만 사용하고 버리면 된다.

JdbcContext를 UserDao에서 코드를 통해 DI 해주는 방식으로 변경하면 빈의 의존관
계는 그림 3-6과 같이 재구성된다.

driverClass
ðat&Source
>| :S듭굶i굶료강eroS
코드에 의한 DI
u.erOao:U.erOa。
:
스프링을 룡한 DI

c

한

뾰

m

=

그림 3-6 코드톨 홍한 JdbcContext 미 구조

스프링의 설정파일에 userDao와 dataSource 두 개만 빈으로 정의한다. 그리고
userDao 빈에 DataSource 타입 프로퍼티를 지정해서 dataSource 빈을 주입받도록
한다. UserDao는 JdbcContext 오브젝트를 만들면서 DI 받은 DataSource 오브젝트
를 JdbcContext
의 수정자 메소드로 주입해준다. 만들어진 JdbcContext 오브젝트는
UserDao의 인스턴스 변수에 저장해두고 시용한다.

뭔가 조금 복잡한 것 같지만 코드를 보면 간단히 이해할 수 있다. 먼저 설정따일에
퉁록했던 JdbcContext 빈을 제거한다. UserDao의 jdbcContext 프로퍼티도 제거한다.
그리고 UserDao는 DataSource 타입 프로퍼티만 갖도록 한다. 리스트 3-24는 이렇게 수
정한설정파일이다.

뼈-짜

-i

=

e

=

‘

a

c

빼빼

=

랴


리스트 3-24 jdbcContext 빈옳 제거한 설정파일

<beans>
<bean id="userDao" class="springbook.user.dao.UserDao">
(property name="dataSource" ref="dataSource" />
</bean>

<bean id="dataSource"
class="org.springframework.jdbc.datasource .SimpleDriverDataSource'’ >

</bean>
</beans>


설정따일만 보자면 UserDao가 직접 DataSource를 의존하고 있는 것 같지만， 내부
적으로는 JdbcContext를 통해 간접적으로 DataSource를 λF용하고 있을 뿐이다. 하
지만 JdbcContext를 UserDao와 묶어서 userDao 빈이라고 생각해보면 빈 레벨에서는
userDao 빈이 dataSource 빈에게 의존하고 있다고 말할 수도 있다.

UserDao는 이제 JdbcContext를 외부에서 주입받을 펼요가 없으니 setJdbcContext()
는 제거한다. 그리고 setDataSource() 메소드를 리스트 3-25와 같이 수정해준다.

리스트 3-25 JdbcConte.

셔 생성과 미 작업을 수행핸 똥tDa떠없Jrl∞( 대|소드

public class UserDao (

수정자 메소드이면서 JdbcConte셔에 대한private ldbcContext jdbcContext;
생성. 대 ξ엉올 동시에 수행한다
뻐blic void setDataSource(DataSource dataSource) (~
this.jdbcContext = new ldbcContextO;_ JdbcConte잉 생성(α)
this.jdbcContext.setDataSource(dataSource); --늦 의존 오브젝트 주입(대)
this.dataSource = dataSource; -송-아직 JdbcContext률 적용하지 않은 메소드흩 위해

저장해둔다

setDataSource() 메소드는 DI 컨테이너가 DataSource 오브젝트를 주입해줄 때 호
출된다. 이때 JdbcContext
에 대한 수동 DI 작업을 진행하면 된다. 먼저 JdbcContext
의
오브젝트를 만들어서 인스턴스 변수에 저장해두고 JdbcContext에 UserDao가 DI 받은
DataSource 오브젝트를 주입해주면 완벽한 DI 작업이 완료된다. UserDao의 메소드에

3장-탱플릿 239


서는 JdbcContext가 외부에서 빈으로 만들어져 주입된 것인지， 내부에서 직접 만들고
초기화한 것인지 구분할 필요도 없고 구분할 수도 없다. 필요에 따라 JdbcContext를 사
용하기만하면된다.

이 방법의 장점은 굳이 인터페이스를 두지 않아도 될 만큼 긴밀한 관계를 갖는 DAO
클래스와 JdbcContext를 어색하게 따로 빈으로 분리하지 않고 내부에서 직접 만들어
시용하면서도 다른 오브젝트에 대한 DI를 적용할 수 있다는 점이다. 이렇게 한 오브젝
트의 수정자 메소드에서 다른 오브젝트를 초기화하고 코드를 이용해 DI 하는 것은 스프
링에서도종종사용되는기법이다.

지금까지 JdbcContext와 같이 인터페이스를 사용하지 않고 DAO와 밀접한 관계를
갖는 클래스를 DI에 적용히는 방법 두 가지를 알아봤다. 두 가지 방법 모두 장단점이 있
다. 인터페이스를 사용하지 않는 클래스와의 의존관계이지만 스프링의 DI를 이용하기
위해 빈으로 등록해서 사용하는 방법은 오브젝트 A에의 실제 의존관계가 설정파일에
명확하게 드러난다는장점이 있다. 하지만
DI
의 근본적인 원칙에 부합하지 않는구체적
인 클래스와의 관계가 설정에 직접 노출된다는 단점이 었다.

반면에 DAO의 코드를 이용해 수동으로 DI를 하는 방법은 JdbcContext가 UserDao
의 내부에서 만들어지고 시용되면서 그 관계를 외부에는 드러내지 않는다는 장점이 있
다. 펼요에 따라 내부에서 은밀히 DI를 수행하고 그 전략을 외부에는 감출 수 있다. 하
지만 JdbcContext를 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고.DI 작
업을 위한 부가적인 코드가 필요하다는 단점도 있다.

일반적으로는 어떤 방법이 더 낫다고 말할 수는 없다. 상햄 따라 적절하다고 판단
되는 방법을 선택해서 시용하면 된다. 다만 왜 그렇게 선택했는지에 대한 분명한 이유
와 근거는 있어야 한다. 분명하게 설명할 자신이 없다면 차라리 인터페이스를 만들어서
평범한 DI 구조로 만드는 게 나을 수도 있다.

경건펠플따콜백 띈|

지금까지 UserDao와 StatementStrategy. JdbcContext를 이용해 만든 코드는 일종의
전략 패턴이 적용된 것이라고 볼 수 있다. 복잡하지만 바뀌지 않는 일정한 때턴을 갖는
작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 히는 경우에 적합한 구조
다. 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다. 이런 방식을 스프링

240


에서는 템플릿/콜백 패턴이라고 부른다. 전략 패턴의 컨텍스트를 뱀플릿이라 부르고， 익
명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 부른다.

월폼
탬톨릿
템훌릿(template띈 어떤 목적을 위해 미리 만들어둔 모양이 있는 툴을 가리킨다. 학생돌이 도
형을 그릴 때 사용하는 도형자 또는 모양자가 바로 템플릿이다. 프로그래밍에서는 고정된 훌 안
에 바꿀 수 있는 부분올 넣어서 사용하는 경우에 템플릿이라고 부른다. JSP는 HTML이라는 고
정된 부분에 EL과 스크립릿이라는 변하는 부분을 넣은 일종의 템플릿 파일이다. 램풀릿 메소드
때턴은 고정된 훌의 로직율 가진 템풀릿 메소드톨 슈퍼클래스에 두고， 바뀌는 부분을 서브클래
스의 메소드에 두는 구조로 이뤄진다.

월폼
롤백
콜백(callback연 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트훌 말
한다. 파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드훌 실행
시키기 위해 시용한다. 자바에선 메소드 자체훌 파라미터로 전달훨 방법은 없기 때문에 메소드
가 담긴 오브젝트훌 전달해야 한다. 그래서 펑셔널 오브젝트(functiα1a
lobject)라고도 한다.


3.5.1 템플릿/콜백의 동작원리
댐플릿은 고정된 작업 흐름을 가진 묘드를 재사용한다는 의미에서 붙인 이름이다. 콜백
은 댐플릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 말한다.

템플릿/콜백의특징
여러 개의 메소드를 가진 일반적인 인터페이스를 시용할 수 있는 전략 패턴의 전략과
달리 랩플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다. 템플릿의
작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다. 하나의 랩
플릿에서 여 러 가지 종류의 전략을 사용해야 한다면 하나 이상의 콜백 오브젝트를 사용
할 수도 있다. 콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내
부 클래스로 만들어진다고 보면 된다.
콜백 인터페이스의 메소드에는 보통 파라미터가 있다. 이 파라미터는 템플릿의 작
업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용된다. JdbcContext
에서
는 뱀플릿인 workWithStatementStrategy() 메소드 내에서 생성한 Connection 오브젝
트를 콜백의 메소드인 makePreparedStatement()
를 실행할 때 파라미터로 넘겨준다.
PreparedStatement를 만들기 위해서는 JDBC 컨텍스트/탱플릿 안에서 만들어진 DB

3장-멈를릿 241


커넥션이 필요하기 때문이다. 그림 3-7은 댐플릿/콜백 패턴의 일반적인 작업 흐름을
보여준다.

롤라이언트(client)
(2) Callback 전 달 / Template 호출
댐톨릿“emplate)
(1) Callback 생 성 (3) Workflow 시작
(5) Callback 호출 / (4) 잡조정보 생성
롤백
(callback)
참조정보 전달
(6) Client 에
nal 변수 장조
(기 작업수행 (8) Callback 작업 결과
(9) Workflow 진행
(10) Workflow 마무리
(11) Template 작업 결과

그림 3-7 템플릿/롤백의 작업 흐름

• 클라이언트의 역할은 댐플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고， 콜백이
참조할 정보를 제공하는 것이다. 만들어진 콜백은 클라이언트가 댐플릿의 메소드를 호출할
때 따라미터로 전달된다.
• 댐플릿은 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고
콜백 오브젝트의 메소드를 호출한다. 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제
공한 참조정보를 이용해서 작업을 수행하고 그 결괴를 다시 댐플릿에 돌려준다.
• 댐플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행한다. 경우에 따라 최종 결과를
클라이언트에 다시 돌려주기도 한다.
조금 복잡해 보이지만 DI 방식의 전략 패턴 구조라고 생각하고 보면 간단하다. 클라
이언트가 렘플릿 메소드를 호출하면서 콜백 오브젝트를 전달히는 것은 메소드 레벨에
서 일어나는 DI
다. 템플렷이 사용할 콜백 인터페이스를 구현한 오브젝트를 메소드를
통해 주입해주는
DI 작업이 클라이언트가댐플릿의 기능을호출하는 것과동시에 일어
난다. 일반적인 DI라면 탬플릿에 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를
수정자 메소드로 받아서 사용할 것이다. 반면에 댐플릿/콜백 방식에서는 매번 메소드
단위로 사용할 오브젝트를 새롭게 전달받는다는 것이 특정이다. 콜백 오브젝트가 내부
클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다는 것도 댐플
릿/콜백의 고유한 특정이다. 클라이언트와 콜백이 강하게 결합된다는 면에서도 일반적
인
DI와조금다르다.

템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한
독특한 활용법이라고 이해할 수 있다. 단순히 전략 패턴으로만 보기엔 독특한 특정이


많으므로 탬플릿/콜백을 하나의 고유한 디자인 패턴으로 기억해두면 펀리하다. 다만 이
패턴에 녹아 있는 전략 패턴과 수통 DI를 이해할 수 있어야 한다.

Jd
bcConte.차에 적용된 템플릿/콜백
앞에서 만들었던 UserDao, JdbcContext와 StatementStrategy의 코드에 적용된 랩플
릿/콜백 패턴을 한번 살펴보자. 그림 3-8은 UserDao. JdbcContext를 템플릿/콜백 패턴
의 구조에서 살펴본 것이다. 탱플릿과 클라이언트가 메소드 단위인 것이 특정이다. 그

림 3-7과 비교해서 보면 각 오브젝트 사이에서 만들어지고 전달되는 정보와 오브젝트
들이 어떤 역할인지 생각해보자.


<<1얹emp빠late))

<<clienl>> UserDao.add()

JdbcContext.workWith5tatement5trateQVO

final User

익명 Callback 오닙젝
E
JDBC t잊/catch/finally workflow

’

l

try {

l

<<callback>> 5tatement5trategy

Connection 준비

‘

Connection

‘

connectlon과 user훌
사용해서 Prepared5tatement

장‘조-.

PreparedStatemen!

만들기

Prepared5tatement 사용
void

} catch {}

finallY {}

그림 3-8 UserDao/JdbcContext/StatementStrategy에 적용된 템플릿/콜빽 때턴

JdbcContext
의 workWithStatementStrategy() 탱플릿은 리턴 값이 없는 단순한 구조
다. 조회 작업에서는 보통 탱플릿의 작업 결과를 클라이언트에 리턴해준다. 뱀플릿의
작업 흐름이 좀 더 복잡한 경우에는 한 번 이상 콜백을 호출하기도 하고 여러 개의 콜백
을 클라이언트로부터 받아서 사용하기도 한다.

3.5.2 편리한 콜백의 재활용
댐플릿/콜백 방식은 템플릿에 담긴 묘드를 여기저기서 반복적으로 사용히는 원시적인
방법에 비해 많은 장점이 있다. 당징벼1 JdbcContext를 사용하기만 해도 기존에 JDBC
기반의 코드를 만들었을 때 발생했던 여러 가지 문제점과불편한 점을 제거할수 있다.
클라이언트인 DAO의 메소드는 간결해지고 최소한의 데이터 액세스 로직만 갖고 있게
된다.
그런데 템플릿/콜백 방식에서 한 가지 아쉬운 점이 있다. DAO 메소드에서 매번 익

3장-템을릿 243


명 내부 클래스를 시용하기 때문에 상대적으로 코드를 작성하고 읽기가 조금 불편하다
는 점이다. IDE의 편리한 코드 생성 기능을 잘 활용하면 익명 내부 클래스 코드 작성도
그리 불편한 건 아니지만 그래도 익숙하지 않은 코드 스타일에 적지 않게 중첩된 괄호
를 보면 조금 답답해 보일 수 있다.

콜백의분리와재활용
그래서 이번에는 복잡한 익명 내부 클래스의 사용을 최소화할 수 있는 방법을 찾아보
자. JDBC의 try/catch/finally에 적용했던 방법을 현재 UserDao의 메소드에도 적용
해보는 것이다. 만약 분리를 통해 재시용이 기능한 코드를 찾아낼 수 있다면 익명 내부
클래스를 사용한 코드를 간결하게 만들 수도 있다.
리스트 3-26에 나옹 클라이언트인 deleteAll() 메소드와 익명 내부 클래스로 만든
콜백 오브젝트의 구조를 다시 잘 살펴보자.

리스트 3-26 억명 내부 클래스톨 사용한 클라이언트 코드

public void deleteAll () throws SQLException (
this .j dbcContext.workWithStatementStrategy(
r new StatementStrategy () (
public PreparedStatement makePreparedStatement(Connection c)
throws SQLException (
return c. prepareStatement("delete from users" );

~ 연하는
SOL
문장

•
변하지 않는 콜액 클래스 정의와
오브젝트생성

StatementStrategy 인터페이스의 makePreparedStatement() 메소드를 구현한 콜
백 오브젝트 코드를 살펴보면 그 내용은 간단하다. 고정된 SQL 쿼리 하나를 담아서
PreparedStatement를 만드는 게 전부다. 바인딩할 따라미터 없이 미리 만들어진 SQL
을 이용해 PreparedStatement를 만들기만 하면 되는 콜백이 적지는 않을 것이다. 즉
deleteAll()
과유사한내용의 콜백 오브젝트가반복될 기능성이 높다.

그렇다면， 언제나 그랬듯이 중복될 기능성이 있는 자주 바뀌지 않는 부분을 분리해
보자. deleteAll () 메소드의 내용을 통틀어서 바뀔 수 있는 것은 오직 “delete from
users
"라는 문자열뿐이다. 단순 SQL을 필요로 하는 콜백
이라면 나머지 코드는 매번 통
일할 것이다. 그렇다면 SQL 문장만 따라미터로 받아서 바꿀 수 있게 하고 메소드 내용


전체를 분리해 별도의 메소드로 만들어보자. de leteAll ()을 이렇게 분리해보면 리스트
3-27과 같이 만들어진다.

리스트 3-Zl 변하지 않는 부분올 분리시킨 delete왜I() 머|소드

public void deleteAll() throW5 SQLException (
executeSql(‘ delete from users"); • 변응}는없
문장
분리 A
private void executeSQl(final String Query) throws SQLException (
this.jdbcContext.workWithStatementStrategy(
*

new StatementStrategy() (
public PreparedStatement makePreparedStatement(Connection c)
throws SQLException {
return c.prepareStatement(Query);


변하지 않는콜액 클래스
정의와오브젝트생성

바뀌지 않는 모든 부분을 빼내서 executeSql() 메소드로 만들었다. 바뀌는 부분인
SQL 문장만 파라미터로 받아서 사용하게 만들었다.SQL을 담은 파라미터를 final로 선
언해서 익명 내부 클래스인 콜백 안에서 직접 사용할 수 있게 히는 것만 주의하면 된다.

이렇게 해서 재활용 가능한 콜백을 담은 메소드가 만들어졌다. 이제 모든 고정된
SQL을 실행하는 DAO 메소드는 deleteAll () 메소드처럼 executeSql()
을 호출히는 한
줄이면 끝이다. 복잡한 익명 내부 클래스인 콜백을 직접 만들 필요조차 없어졌다. 처음
try/catch/finally를 다 갖춰서 만들었던 리스트 3-2
의 deleteAll() 메소드와 리스트
3-27
의 한줄짜리 deleteAll () 메소드를 비교해보자. 격세지감을느낄지도모르겠다.

변하는 것과 변하지 않는 것을 분리하고 변하지 않는 건 유연하게 재활용할 수 있게
만든다는 간단한 원리를 계속 적용했을 때 이렇게 단순하면서도 안전하게 작성 가능한
JDBC 활용 코드가 완성된다. 바로 이런 게 객체지향 언어와 설계를 사용하는 매력이
아닐까.

콜백과템플릿의결합
한 단계 더 나아가 보자. executeSql ( ) 메소드는 UserDao만 사용하기는 아깝다. 이
렇게 재사용 가능한 콜백을 담고 있는 메소드라면 DAO가 공유할 수 있는 템플릿 클

3장-탱을릿 245


래스 안으로 옮겨도 된다. 엄밀히 말해서 템플릿은 JdbcContext 클래스가 아니라
workWithStatementStrategy() 메소드이므로 JdbcContext 클래스로 콜백 생성과 댐플
릿 호출이 담긴 executeSql () 메소드를 옮긴다고 해도 문제 될 것은 없다.

먼저 리스트 3-28과 같。
1 executeSql 메소드를 옮긴다. 메소드 접근자는 public으
로 바꿔서 외부에서 바로 접근이 가능하게 한다.

리스트 3-28 JdbcContext로 옳긴 exec:띠t야써I() 머|소드

public class JdbcContext {

public void executeSql(final String query) throws SQLException (
workWithStatementStrategy(
new StatementStrategy() (
public PreparedStatement makePreparedStatement(Connection c)
throws SQLException (
return c.prepareStatement(query);

executeSql() 메소드가 JdbcContext로 이동했으니 UserDao의 메소드에서도 리스트
3-29와 같이 jdbcContext를 통해 executeSql() 메소드를 호출하도록 수정해야 한다.

리스트 3-29 JdbcConte차로 옳긴 exec띠명QI()을 사용하는 delete.셰I() 메소드

public void deleteAll() throws SQLException {
this.jdbcContext.executeSql("delete from users");

이제 모든 DAO 메소드에서 executeSql() 메소드를 사용할 수 있게 됐다. 익명 내
부 클래스의 사용으로 조금 복잡해 보였던 클라이언트 메소드는 이제 깔끔하고 단순해
졌다. 그림 3-9에서 볼 수 있듯이 결국 JdbcContext 안에 클라이언트와 랩플릿， 콜백이
모두 함께 공존하면서 동작하는 구조가 됐다.


JdbcContext

〈이emplate
"

UserDa。
work.. O

deleteAIIO 템훌릿 호훌
SQL 쿼 리 I ，이
lienÞ>

executeSql(query)

<<callback>>

익명 내부 클래스

그림 3-9 롤백 재훨용율 적용한 JdbcContext

일반적으로는 성격이 다른 묘드들은 가능한 한 분리하는 편이 낫지만， 이 경우는 반대

다. 하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 웅집력이 강한 코드들이기

때문에 한 군데 모여 있는 게 유리하다. 구체적인 구현과 내부의 전략 패턴， 묘드에 의

한 DI, 익명 내부 클래스 등의 기술은 최대한 감춰두고， 외부에는 콕 필요한 기능을 제

공하는 단순한 메소드만 노출해주는 것이다.

콜백의 작업이 좀 더 복잡한 add()
에도 같은 방법을 적용할 수 있다. add() 메소드

의 콜백에서는 SQL 문장과 함께 PreparedStatement
에 바인딩될 따라미터 내용이 추가

돼야 한다. 바인딩 따라미터의 개수는 일정하지 않으므로 자바 5
에서 추가된 가변인자

varargs로 정의해두는 것이 좋다. 콜백에서 PreparedStatement를 만든 뒤에 바인딩할 따

라미터 타입을살며서 적절한설정 메소드를호출해주는작업이 조금복잡할수는 있겠

지만， 한 번 만들어두면 매우 편리하게 사용할 수 있으니 도전해볼 만하다.

3.5.3 템플릿/콜백의 응용
지금까지 살펴본 댐플릿/콜백 패턴은 사실 스프링에서만 사용할 수 있다거나 스프링만
이 제공해주는 독점적인 기술은 아니다. 하지만 스프링만큼 이 패턴을 적극적으로 활

용하는 프레임워크는 없다. 스프링의 많은 API나 기능을 살펴보면 뱀플릿/콜백 패턴을

적용한 경우를 많이 발견할 수 있다.

따지고 보면 DI도 순수한 스프링의 기술은 아니다. 기본적으로는 객체지향의 장점을

잘 살려서 설계하고 구현하도록 도외주는 여러 가지 원칙과 패턴의 활용 결과일 뿐이

다. 스프링은 단지 이를 편리하게 사용할 수 있도록 도와주는 컨테이너를 제공하고， 이

런 패턴의 사용 방법을 지지해주는 것뿐이다. 랩플릿/콜백 패턴도 DI와 객체지향 설계

를 적극적으로 응용한 결과다. 스프링에는 다
OJ=한 자바 엔터프라이즈 기술에서 사용할

수 있도록 미리 만들어져 제공되는 수십 가지 탱플릿/콜백 클래스와 API가 있다.

3장-템플릿 247



스프링을 사용하는 개발자라면 당연히 스프링이 제공히는 템플릿/콜백 기능을 잘 사
용할 수 있어야 한다. 동시에 템플릿/콜백이 필요한 곳이 있으면 직접 만들어서 시용할
줄도 알。빠 한다. 스프링에 내장된 것을 원리도 알지 못한 채로 기계적으로 사용하는
경우와 적용된 패턴을 이해하고 사용하는 경우는 큰 차이가 있다. 스프링이 제공하는
대부분의 기술은 그 구조를 이해하면 손쉽게 확장해서 쓸 수 있다. 기본적으로 OCP를
지키고， 전략 패턴과 DI를 바탕에 깔고 있으니 원한다면 언제든지 확장해서 편리한 방
법으로 사용할 수 있다. 그런 면에서 스프링의 기본이 되는 전략 패턴과 DI는 물론이고
댐플릿/콜백 패턴도 익숙해지도록 학습할 필요가 있다.

고정된 작업 흐름을 갖고 있으면서 여기저기서 지주 반복되는 코드가 있다면， 중복
되는 묘드를 분리할 방법을 생
ζ벼}보는 습관을 기르자. 중복된 묘드는 먼저 메소드로
분리히는 간단한 시도를 해본다. 그중 일부 작업을 펼요에 따라 바꾸어 사용해야 한다
면 인터페이스를 사이에 두고 분리해서 전략 패턴을 적용하고 DI로 의존관계를 관리하
도록 만든다. 그런데 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들
어질 수 있다면 이번엔 랩플릿/콜백 패턴을 적용하는 것을 고려해볼 수 있다.

가장 전형적인 랩플릿/콜백 패턴의 후보는 try/catch/finally 블록을 사용하는 코
드다. 일정한 리소스를 만들거나 가져와 작업하면서 예외가 발생할 가능성이 있는 코드
는 보통 try/catch/finally 구조로 코드가 만들어질 가능성이 높다. 예외상황을 처리
하기 위한 catch와 리소스를 반납하거나 제거히는 finally가 필요하기 때문이다. 이런
코드가 한두 번 사용되는 것이 아니라 여기저기서 지주 반복된다면 댐플릿/콜백 패턴을
적용하기적당하다.

테스트와 try/catch/finally
간단한 댐플릿/콜백 예제를 하나 만들어보자.
파일을 하나 열어서 모든 라인의 숫^t를 더한 합을 돌려주는 묘드를 만들어보겠다.
개발하면서 테스트를 해야 하니까 숫자가 담긴 파일을 먼저 만들어둔다. 다음과 같이
네 개의 숫자를 담고 있는 numbers.txt 파일을 하나 준비한다.

A아

모든 라인의 숫자의 합은 10
이다. numbers. txt 따일 경로를 주면 10을 돌려주도

1ι 「그


록 만들면 된다. 이를 그대로 코드로 표현하면 리
스트 3-30과 같은 테
스트로 만들
수있다.

리스트 3-30 파일의 옷자 합올 겨
I~하는 코드의 테스트

package springbook .learningtest .template;

public class CalcSumTest (
@Test
public void sumOfNumbers() throws IOException (

Calculator calculator = new Calculator();
int sum = calculator.calcSum(getClass().getResource(
"numbers.txt").getPath());
assertThat(sum , iS(lÐ));


클래스 이름은 Calculator 메소드는 스트링으로 된 파일 경로를 파라미터로 받는
calcSum()
으로 정했다. 아직 테스트 코드만 있으니 컴따일도 안 될 것이다. 간단한 기능
이니 바로 코드로 만들어보자. 파일을 열어서 각 라인을 순차적으로 읽는 코드만 만들
줄 안다면 간단히 구현할 수 있다. 리스트 3-31
은 이렇게 만든 Calculator 클래스다.

리스트 3-31 처음 만든 Calculatα 클래스 쿄드

package springbook.learningtest.template;

public class Calculator (
public Integer calcSum(String filepath) throws IOException (
BufferedReader br = new BufferedReader(new FileReader(filepath));
Integer sum = 0; 니 한 줄씩 읽71 면하게 빼er，잉R없er로

String line = null; 따일올
가져온다
while((line = br .readLine()) != null) (-융마지막
라인까지
한줄씩읽어가면서

숫자훌더한다

sum += Integer .valueOf (line );

br. close(); -용 한
번 언 따일은반드시 딛아준다，

return sum;

3장-템플릿 249


파일을 한 줄씩 읽어올 수 있는 BufferedReader를 만들고 마지막 줄까지 반복해서
읽으면서 미리 만들어둔 sum 변수에 값을 더해주는 간단한 코드다. 이제 태스트를 돌려
보자. 결과는 성공일 것이다. 좀 더 확실하게 검증하고 싶다면 숫자를 담은 파일을 몇
개 더 만들어서 각각다른합이 나오는지 검증해보면된다.

초난감 DAO와 마찬가지로 calcSum() 메소드도 따일을 읽거나 처리하다가 예외가
발생하면， 파일이 정상적으로 닫히지 않고 메소드를 빠져나가는 문제가 발생한다. 따라
서 try/finally 블록을 적용해서 어떤 경우에라도 따일이 열렸으면 반드시 딛。}주도록
만들어야 한다. 그리고 파일을 처리하다가 예외상횡어 발생하면 로그를 남기는 기능도
추가해보자. 그러려면 catch 블록도 펼요하다.

calcSum() 메소드에 try/catch/finally를 모두 적용해보면 리스트 3-32와 같이 만
들어진다.

리스트 3-32 try/calch/finally톨 적용한 calcSum(} 메소드

public Integer calcSum(String filepath) throws IOException {
BufferedReader br =null;

try {
br = new BufferedReader(new FileReader(filepath));
Integer sum =0;
String line =null;
while((line = br .readLine()) != null) {

sum += Integer.valueOf(line);

return sum;

catch(IOException e) {
System.out.println(e.getMessage());
throw e;

finally {

BufferedReader 오브젝트가 생성되기 전에 예외가 발생할 수도
if (br != null) {--• 있으으로반드시
null
떠훌먼저해야
한다
try { br .close(); }
catch(IOException e) { System.out.println(e .getMessage()); }


DAO의 JDBC 코드에 적용했던 것과 기본 개념은 같다. 만들어진 모든 리소스는 확
실히 정리하고 빠져나오도록 만드는 것과 모든 예외상햄 대해서는 적절한 처리를 해
주도록 하는 것 두 가지다. 만들어야 할 기능이 이게 전부라면， 태스트도 만들었고 예외
상햄 대한 처리도 모두 해줬으니 이좀에서 만족하고 마무리해도 좋을 것이다.

중복의 제거와 템플릿/콜백 설계
그런데 이번엔 따일에 있는 모든 숫자의 곱을 계산하는 기능을 추가해야 한다는 요구가
발생했다. Calculator라는 클래스의 이름에 걸맞게 앞으로 많은 따일에 담긴 숫자 데이
터를 여러 가지 방식으로 처리하는 기능이 계속 추가될 것이라는 소식도 들려왔다고 생
각해보자.
파일을 읽어서 처리하는 비슷한 기능이 새로 필요할 때마다 앞에서 만든 코드를 복
사해서 시용할 것인가? 물론 아니어야 한다. 한두 번까지는 어떻게 넘어간다고 해도，
세 번 이상 반복된다면 본격적으로 코드를 개선할 시점이라고 생각해야 한다. 객체지향
언어를 사용하고 객체지향 설계를 통해 코드를 작성하는 개발자의 기본적인 자세다.
랩플릿/콜백 패턴을 적용해보자. 먼저 탱플릿에 담을 반복되는 작업 흐름은 어떤 것
인지 살펴보자. 템플릿이 콜백에게 전달해줄 내부의 정보는 무엇이고， 콜백이 램플릿에
게 돌려줄 내용은 무엇인지도 생각해보자. 이번에는 템플릿이 작업을 마친 뒤 클라이언
트에게 전달해줘야 할 것도 있을 것이다. 템플릿/콜백을 적용할 때는 템플릿과 콜백의
경계를 정하고 템플릿이 콜백에게， 콜백이 템플릿에게 각각 전달히는 내용이 무엇인지
파악히는 게 가장 중요하다. 그에 따라 콜백의 인터페이스를 정의해야 하기 때문이다.
가장 쉽게 생ζ벼}볼 수 있는 구조는 댐플릿이 따일을 열고 각 라인을 읽어올 수 있는
BufferedReader를 만들어서 콜백에게 전달해주고 콜백이 각 라인을 읽어서 알아서 처
리한 후에 최종 결과만 템플릿에게 돌려주는 것이다. 이것을 인터페이스의 메소드로 표
현하면 리스트 3-33
처럼 될 것이다.

리스트 3-33 BufferedReé회er톨 전달받는 콜백 인터페이스


package springbook.learningtest.template;

public interface BufferedReaderCallback {
Integer doSomethingWithReader(BufferedReader br) throws IOException;

3장-템플릿 251


이제 템플릿 부분을 메소드로 분리해보자. 댐플릿에서는 BufferedReaderCallback
인터페이스 타입의 콜백 오브젝트를 받아서 적절한 시점에 실행해주면 된다. 콜백이 돌
려준 결과는 최종적으로 모든 처리를 마친 후에 다시 클라이언트에 돌려주면 된다. 리
스트 3-34는 BufferedReaderCallback을 적용한 템플릿 묘드다.

리스트 3-34 BufferedRI앓derCallback율 사용하는 템플릿 메소드

public Integer fileReadTemplate(String filepath , BufferedReaderCallback callback)

throws IOException {
BufferedReader br =null;
try (

br = new BufferedReader(new FileReader(filepath));
int ret = callback.doSomethingWithReader(br);-을 콜액 오브젝트 호흩 템률릿에서 만든 건
return ret; 텍스트 정보인 BufferedReader'톨 전달해
주고 콜백의 ξ엠 걸과훌 받아둔다‘

catch(IOException e) (
System.out .println(e .getMessage());
throw e;

finally {

if (br != null) {
try ( br.close(); }
catch(IOException e) ( System .out.println(e .getMessage()); }

BufferedReader를 만들어서 넘겨주는 것과 그 외의 모든 번거로운 작업에 대한 작업
흐름은 댐플릿에서 진행하고， 준비된 BufferedReader를 이용해 작업을 수행하는 부분
은콜백을호출해서 처리하도록만들었다.

이렇게 준비된 fileReadTemplate()을 사용하도록 calcSum( ) 메소드를 수정해보자.
댐플릿으로 분리한 부분을 제외한 나머지 코드를 BufferedReaderCallback 인터페이스
로 만든 익명 내부클래스에 담는다. 처리할파일의 경로와함께 준비된 익명 내부클래
스의 오브젝트를 랩플릿에 전달한다. 코드를 읽기 편하도록 콜백 오브젝트를 일단 변수
에 저장해뒀다가 사용하게 했다. 탱플릿이 리턴하는 값을 최종 결과로 사용하면 된다.
리스트 3-35는 이렇게 수정된 calcSum() 메소드다.


리스트 3-35 템풀릿/콜백울 적용한 calcSum() 메소드

public Integer calcSum(String filepath) throws IOException (

BufferedReaderCallback sumCallback =

new BufferedReaderCallback() {

public Integer doSomethingWithReader(BufferedReader br) throws

IOException {

Integer sum =ø;

String line = null;

while((line = br .readLine()) != null) (

sum += Integer.valueOf(line);

return sum;

return fileReadTemplate(filepath , sumCallback);


이제 파일에 있는 숫자의 곱을 구하는 메소드도 이 랩플릿/콜백을 이용해 만들면 된다.

먼저 테스트를 만들어보자. 테스트 메소드가 두 개가 됐는데 λ}용할 클래스의 오브
젝트와파일 이름이 공유된다. 그렇다면 @Before 메소드에서 미리 픽스처로 만들어두
는 게 좋겠다. 두 개쯤이야 그냥 중복돼도 그만일지 모르겠지만， 앞으로 계속 유사한 태
스트가 늘어날 것을 생각한다면 미리 테스트 코드도 깔끔하게 정리히는 편이 좋다.

리스트 3-36은 곱을 계산하는 기능의 테스트 메소드를 추가한 테스트 클래스다.

리스트 3-36 새로운 테스트 메소드톨 추가한 CalcSumTest

package springbook.learningtest.template;

public class CalcSumTest (
Calculator calculator;
String numFilepath;

OBefore public void setUp() {
this.calculator = new Calculator();
thi s . numF ilepath =getClas s0 .getResource ("numbers .txt. ).getPathO ;

@Test public void sumOfNumbers() throws IOException (
assertThat(calculator.calcSum(this.numFilepath) , is(1Ð));

3장-템플릿 253


@Test public void multiplyOfNumbers() throws IOException (
assertThat(calculator.calclultiply(this.numFilepath) , is(24));

이제 이 태스트를 성공시키는 묘드를 만들어보자. 리스트 3-37과 같이 앞에서 만든
sumCallback과 거의 비슷하지만 각 라인의 숫자를 더하는 대신 곱하는 기능을 담은 콜
백을 사용하도록 만들어주면 된다.

리스트 3-37 곱을 겨IWo
f는 콜백을 가진 calcMultipl이 ) 메소드

public Integer calcMultiply(String filepath) throws IOException {

BufferedReaderCallback multiplyCallback =

new BufferedReaderCallback() {

public Integer doSomethingWithReader(BufferedReader br) throws

IOException (

Integer multiply = 1;

String line =null;

while((line = br.readLine()) != null) (

multiply *= Integer.valueOf(line);

return multiply;

return fileReadTemplate(filepath , multiplyCallback);

이제 테스트를 돌려보고 두 개의 태스트가 모두 성공하는지 확인해보자.

템플릿/콜백의재설계
댐플릿/콜백 패턴을적용해서 파일을읽어 처리히는코드를상당히 깔끔하게 정리할수
있었다. 이제 try/catch/finally 블록 없이도 파일을 안전하게 처리히는 코드를 사용
할수있게됐다.
그런데 위에서 만든 calcSum()
과 calcMul tiply()
에 나오는 두 개의 콜백을 비교해
보자. 여기서 또다시 어떤 공통적인 패턴이 발견되진 않는지 주의 김게 관찰해보자.

calcMultiply()

calcSum()

Integer multiply = 1;

Integer sum =0;


String line = null; String line =null;
while((line = br .readLine()) != null) ( while((line = br .readLine()) != null) (
multiply *= Integer.valueOf(line); sum += Integer.valueOf(line);

return multiply; return sum;

조금만 살펴봐도 두 개의 코드가 아주 유사함을 알 수 있다. 먼저 결괴를 저장할 변
쉬jnul tiply. sum)를 초기화하고 BufferedReader를 이용해 파일의 마지막 라인까지 순차

적으로 읽으면서 각 라인에서 읽은 내용을 결과를 저장할 변수의 값과 함께 계산하다
가， 파일을 다 읽었으면 결과를 저장하고 있는 변수의 값을 리턴한다.
댐플릿과 콜백을 찾아낼 때는 변하는 묘드의 경계를 찾고 그 경계를 사이에 두고

주고받는 일정한 정보가 있는지 확인하면 된다고 했다. 여기서 바뀌는 코드는 실제로

네 번째 줄뿐이다. 앞에서 네 번째 라인으로 전달히논 정보는 처음에 선언한 변수 값
인 mul tiply 또는 sum이다. 그 네 번째 라인을 처리하고 다시 외부로 전달되는 것은
multiply 또는 sum과 각 라인의 숫자 값을 가지고 계산한 결과다.

이를 콜백 인터페이스로 정의해보면 리스트 3-38과 같다.

리스트 3-38 라인벌 작업율 정의한 롤백 인터페이스


package springbook.learningtest.template;

public interface LineCallback (
Integer doSomethingWithLine(String line, Integer value);

LineCallback은 파일의 각 라인과 현재까지 계산한 값을 넘겨주도록 되어 있다. 그
리고 새로운 계산 결과를 리턴 값을 통해 다시 전달받는다. 이 콜백을 기준으로 코드를
다시 정리해보면 템플릿에 포함되는 작업 흐름은 더 많아지고 콜백은 단순해질 것이다.
리스트 3
-39는 새로 만든 LineCallback 인터페이스를 경계로 해서 만든 새로운 댐플
릿이다.

리스트 3-39 니neCallback옳 사용하는 템플릿

public Integer lineReadTemplate(String filepath , LineCallback callback, int

inRtVal) throws IOException { =계신 결과률 저장할 연수의 초기값

BufferedR
try (
br =new BufferedReader(new FileReader(filepath));

3장-템을릿 255


Integer res = initVal;
String line =null;

따일의 각 라인율 루프훌 돌연서 가져

while((line = br.readLine()) != null) ( --융 오는 것도 탱율릿
이 담당흔빠.
res =callback.doSomethingWithLine(line, res);

~을 콜백이 계산한 값옳 저챔뒀다가 L 각 라인의 내뚫 기지고 계생}는

return res; }용 라인 겨|스뻐| 디시 사용효κ 작업인 콜백에게 맡긴다

catch(IOException e) { ... }
finally { ... }

댐플릿에 파일의 각 라인을 읽는 작엽이 추기됐다. 계산 결괴를 담을 변수를 초기화
할 값도 따라미터도 전달받게 만들었다. 새로 만든 탬플릿이 기존에 만들었던 템플릿들
과 다른 점은 while 루프 안에서 콜백을 호출한다는 점이다. 콜백을 여러 번 반복적으로
호출하는 구조가 된 것이다.

이번엔 이렇게 수정한 템플릿을 시용하는 코드를 만들어보자. 리스트 3-40에서 볼
수 있듯이 코드는 이전보다 간결해졌다. 익명 내부 클래스 때문에 라인 수가 많아 보이
긴 하지만사실 핵심 코드는딱한줄뿐이다.

리스트 3-40 lineReadTemplate()율 사용하도혹 수정한 caISum(). calcMultipl이 ) 메소드

public Integer calcSum(String filepath) throws IOException (

LineCallback sumCallback =

new LineCallback () (

public Integer doSomethingWithLine(String line, Integer value) (

return value + Integer.valueOf(line);

}};

return lineReadTemplate(filepath , sumCallback, e);

public Integer calcMultiply(String filepath) throws IOException (
LineCallback multiplyCallback =
new LineCallback() (
public Integer doSomethingWithLine(String line, Integer value) (
return value * Integer.valueOf(line);
}};
return lineReadTemplate(filepath , multiplyCallback, 1);


앞에서 만들었던 코드보다 깔끔하고 보기 좋다. 여타 로우레벨의 파일 처리 코드가
범플릿으로 분리되고 순수한 계산 로직만 남아 있기 때문에 코드의 관심이 무엇인지 명
확하게 보인다. Calculator 클래스와 메소드는 데이터를 가져와 계산한다는 핵심 기능
에 충실한 코드만 갖고 있게 됐다.

간단한 예제를 통해 살펴봤듯이， 템플릿/콜백 패턴은 다OJ=한 작업에 손쉽게 활용할
수 있다. 콜백이라는 이름이 의미하는 것처럼 다시 불려지는 기능을 만들어서 보내고
랩플릿과 콜백， 클라이언트 사이에 정보를 주고받는 일이 처음에는 조금 복잡하게 느
껴질지도 모르겠다. 하지만 코드의 특성이 바뀌는 경계를 잘 살피고 그것을 인터페이
스를 사용해 분리한다는， 가장 기본적인 객체지향 원칙에만 충실하면 어렵지 않게 템
플릿/콜백 패턴을 만들어 활용할 수 있을 것이다.

제네릭스를 이용한 콜백 인터페이스
자바 5
에서 추가된 언어적인 특정을 잘 활용하면 좀 더 강력한 댐플릿/콜백 구조를 만
들 수 있다. 지금까지 사용한 Li
neCallback과 lineReadTemplate()
은 템플릿과 콜백이
만들어내는 결과가 Integer 타입으로 고정되어 있다. 만약 파일을 라인 단위로 처리해
서 만드는 결과의 타입을 다OJ=하게 가져가고 싶다면， 자바 언어에 타입 파라미터라는
개념을 도입한 제네릭스Generics를 이용하면 된다. 제네릭스를 이용하면 다양한 오브젝
트 타입을 지원히는 인터페이스나 메소드를 정의할 수 있다.
파일의 각 라인에 있는 문자를 모두 연결해서 하나의 스트링으로 돌려주는 기능을
만든다고 생각해보자. 이번에는 템플릿이 리턴히는 타입이 스트링이어야 한다. 콜백의
작업 결과도스트링이어야한다. 기존에 만들었던 Integer 타입의 결과만다루는콜백
과 템플릿을 스트링 타입의 값도 처리할 수 있도록 확장해보자.
먼저 리스트 3-41
과 같이 콜백 인터페이스를 수정한다. 콜백 메소드의 리턴 값과 파
라미터 값의 타입을 제네력 타입 파라미터 T로 선언한다.

리스트 3-41 타입 파라미터톨 적용한 니neCa
lltκ:lC
k


public interface LineCallback<r> (
T doSomethingWithLine(String line, T value);

다음은 탬플릿인 lineReadTemplate() 메소드도 리스트 3-42와 같이 타입 파라미
터를 시용해 제네릭 메소드로 만들어준다. 콜백의 타입 따라미터와 초기값인 initVal
의 타입 그리고 템플릿의 결과 값 타입을 모두 동일하게 선언해야 한다.

3장-템을릿 257


리스트 3-42 타입 따라미터를 추가해서 제네릭 메소드로 만든 line~않dTemp녕t허 )

public σ> T lineReadTemplate(String filepath , LineCallback<T> callback, T initVal)
throws IOException {
BufferedReader br =null;
try (
br =new BufferedReader(new FileReader(filepath));
T res =initVal;
String line = null;
while(( line = br .readLine () ) != null) (
res =callback.doSomethingWithLine(line , res);

return res;

catch(IOException e) { . .. }

finally {. .. }

lineReadTemplate() 메소드는 이제 타입 파라미터 T
를 갖는 인터페이스
LineCallback 타입의 오브젝트와 T 타입의 초기값 initVal을 받아서
， T 타입의 변수
res를 정의하고. T 타입 파라미터로 선언된 LineCallback의 메소드를 호출해서 처리
한 후에 T 타입의 결과를 리턴히는 메소드가 되는 것이다. 이제 LineCallback 콜백과
lineReadTemplate() 댐플릿은 파일의 라인을 처리해서 T 타입의 결과를 만들어내는 범
용적인 탱플릿/콜백이 됐다. 제네릭스 코드에 익숙하지 않으면 타입 파라미터가 많아서
처음 보기에는 복잡해 보일 수 있다. 이럴 땐 타입 파라미터 T를 Integer나 String 같은
특정 타입으로 모두 바꿔서 생각해보면 이해히는 데 도움이 될 것이다.

이제 파일의 모든 라인의 내용을 하나의 문자열로 길게 연결하는 기능을 가진 메소드
를 추가해보자. 리스트 3-43
에서처럼 콜백을 정의할 때 사용할 타입을 지정하면 된다.

리스트 3-43 문자얼 연결 기능 콜백율 이용해 만든 ∞ncatenate‘ )메소드

public String concatenate(String filepath) throws IOException (

LineCallback<String> concatenateCallback =

new LineCallback<String>() (

public String doSomethingWithLine(String line, String value) {

}};
return value + line;
,.... 탱울릿 메쇼도의 T는 모두 스트링
01 된다
return lineReadTemplate(filepath, concatènateCallback, "“);


각 메소드의 파라미터 타입을 잘 살펴보기 바란다. 최종적으로 lineReadTemplate(}
메소드의 결과도스트링 타입이 돼서 concatenate(} 메소드의 리턴 타입도스트링으로
정의할수있게된다.

concatenate(} 메소드에 대한 테스트를 리스트 3-44와 같이 만들 수 있다.

리스트 3-44 ∞n∞tenat허 ) 메소드에 대한 테스트

@Test
public void concatenateStrings() throws IOException (
assertThat(calculator.concatenate(this.numFilepath) , is("1234"));


파일의 각 라인의 내용을 숫자로 바꾸지 않고 스트링으로 연결하기 때문에 최종 결

과가 “
1234"가 돼야 한다. 테스트를 수행하면 물론 성공이다.
기존에 만들었던 calcSum(}
과 calcMul tiply(}
는 다음과 같이 Integer 타입 파라미
터를 가진 인터페이스로 정의해주기만 하면 그대로 시용할 수 있다.

LineCallback<Integer> sumCallback =
new LineCallback<Integer>() { ... };

이렇게 범용적으로 만들어진 템플릿/콜백을 이용하면 파일을 라인 단위로 처리하는

다양한 기능을 편리하게 만들 수 있다.
새롭게 살펴본 리턴 값을 갖는 템플릿이나 뱀플릿 내에서 여러 번 호출되는 콜백 오
브젝트， 또 제네릭스 타입을 갖는 메소드나 콜백 인터페이스 등의 기법은 스프령의 댐

플릿/콜백 패턴이 적용된 곳에서 종종 사용되고 있다.

[ ~ 스프링의 JdbcTemplate 젤 l

템플릿과 콜백의 기본적인 원리와 동작방식 만드는 방법을 알아봤으니 이번에는 스프
링이 제공하는 댐플릿/콜백 기술을 살펴보자. 스프링은 JDBC를 이용히는 DAO에서
사용할 수 있도록 준비된 다OJ'한 랩플릿과 콜백을 제공한다. 거의 모든 종류의 JDBC
코드에 시용 가능한 탱플릿과 콜백을 제공할 뿐만 아니라 지주 사용되는 패턴을 가진
콜백은 다시 랩플릿에 결합시켜서 간단한 메소드 호출만으로 시용이 가능하도록 만들

어져 있기 때문에 댐플릿/콜백 방식의 기술을 사용하고 있는지 모르고도 쓸 수 있을 정
도로편리하다.

3장-템을릿 259


스프링이 제공하는 JDBC 코드용 기본 탱플릿은 JdbcTemplate이다. 앞에서 만들었
던 JdbcContext와 유사하지만 훨씬 강력하고 편리한 기능을 제공해준다. 아쉽지만 지
금까지만 만들었던 JdbcContext는 버리고 스프링의 JdbcTemplate으로 바꿔보자.

현재 UserDao는 DataSource를 DI 받아서 JdbcContext
에 주입해 댐플릿 오브젝트로
만들어서 사용한다. 이제 JdbcContext를 리스트 3-45와 같이 JdbcTemplate으로 변경
하자. JdbcTemplate은 생성자의 파라미터로 DataSource를 주입하면 된다.

리스트 3-45 Jd
bcTemplate의 초기화톨 위한 코드

public class UserDao (
private JdbcTemplate jdbcTemplate;
public void setDataSource(DataSource dataSource) (

this.jdbcTemplate = new JdbcTemplate(dataSource);
this.dataSource =dataSource;

이제 템플릿을사용할준비가됐다.

3.6.1 update()
deleteAll( )에 먼저 적용해보자. deleteAll() 에 처음 적용했던 콜백은
StatementStrategy 인터페이스의 makePreparedStatement() 메소드다. 이
에 대응되는 JdbcTemplate
의 콜백은 PreparedStatementCreator 인터페이스
의 createPreparedStatement() 메소드다. 템플릿으로부터 Connection
을 제
공받아서 PreparedStatement
를 만들어 돌려준다는 면에서 구조는 동일하다.
PreparedStatementCreator 타입의 콜백을 받아서 시용하는 JdbcTem띠
ate의 템플릿 메
소드는 updateO다.
리스트 3-46은 JdbcTemplate의 콜백과 댐플릿 메소드를 사용하도록 수정한
deleteAll () 메소드다.

리스트 3-46 Jd
bcTemplate
옳 적용한 delete.꾀I() 머|소드

public void deleteAll() {
this.jdbcTemplate.update(


new PreparedStatementCreator() (
public PreparedStatement createPreparedStatement(Connection con)
throws SQLException (
return con.prepareStatement( ’delete from users");

앞에서 만들었던 executeSql()
은 SQL 문장만 전달하면 미리 준비된 콜백을 만들
어서 탬플릿을 호출히는 것까지 한 번에 해주는 편리한 메소드였다. JdbcTemplate에도
기능이 비슷한 메소드가 존재한다. 콜백을 받는 update( ) 메소드와 이름은 통일한데
파라미터로 SQL 문장을 전달한다는 것만 다르다. 리스트 3-47은 JdbcTemplate의 내
장 콜백을 사용히는 메소드를 호출하도록 수정했다.

리스트 3-47 내장 훌빽율 사용하는 updat러 )로 변경한 delete.셰I() 메소드


public void deleteAll() (
this.jdbcTemplate.update( ’‘delete from users');

JdbcTemplate은 앞에서 구상만 해보고 만들지는 못했던 add( ) 메소드에 대한 편리
한 메소드도 제공된다. 치환재7
)를 가진 SQL로 PreparedStatement를 만들고 함께 제
공히는 파라미터를 순서대로 바인딩해주는 기능을 가진 update( ) 메소드를 시용할 수
있다.SQL과 함께 가변인자로 선언된 파라미터를 제공해주면 된다.

현재 add() 메소드에서 만드는 콜백은 리스트 3-48과 같이 PreparedStatement를
만드는 것과 파라미터를 바인딩하는 두 가지 작업을 수행한다.

리스트 3-48 add() 메소드의 콜백 내부

Prepared5tatement ps =

c. prepare5tatement("insert into users(id , name , password) values(? ,?,?)");
pS.set5tring(1 , user.getld());
pS .set5tring(2, user .getName());
pS .set5tring(3, user .getPassword());
이를 JdbcTemplate에서 제공하는 편리한 메소드로 바꿔보면 다음과 같이 간단하게

3장-댐율릿 261


바꿀 수 있다. PreparedStatement를 만들 때 사용히는 SQL은 동일하며 바인딩할 파라

미터는 순서대로 넣어주면 된다.

this.jdbcTemplate.update("insert into users(id , name , password) values(? ,?,?)",
user.getld() , user .getName() , user .getPassword());

JdbcContext를 이용하던 UserDao 메소드를 모두 스프링이 제공하는 JdbcTemplate
으로 변경했다. 이쯤에서 태스트를 수행해보자. 물론 깔끔하게 성공할 것이다.

3.6.2 QueryForlnt()
다음은 아직 댐플릿/콜백 방식을 적용하지 않았던 메소드에 JdbcTemplate을 적용해

보자.

getCount()
는 SQL 쿼리를 실행하고 ResultSet을 통해 결과 값을 가져오는 코드다.
이런 작업 흐름을 가진 묘드에서 사용할 수 있는 랩플릿은 PreparedStatementCreator
콜백과 ResultSetExtractor 콜백을 파라미터로 받는 query() 메소드다.

PreparedStatementCreator는 update( )에서 사용해봤으니 그 용도를 잘 알 것이다.

ResultSetExtractor는 PreparedStatement
의 쿼리를 실행해서 얻은 ResultSet을 전달

받는 콜백이다. Resul tSetExtractor 콜백은 탱플릿이 제공히는 ResultSet을 이용해 원
하는 값을 추출해서 댐플릿에 전달하면 템플릿은 나머지 작업을 수행한 뒤에 그 값을
query() 메소드의 리턴 값으로돌려준다.

콜백이 두 개 등장하는 조금 복잡해 보이는 구조이지만 탬플릿/콜백의 동작방식
을 잘 생각해보면 어렵지 않게 이해할 수 있다. 첫 번째 PreparedStatementCreator
콜백은 댐플릿으로부터 Connection을 받고 PreparedStatement를 돌려준다. 두 번째

ResultSetExtractor는 댐플릿으로부터 ResultSet을 받고 거기서 추출한 결과를 몰려
준다. 잘 이해가 안 되면 기존의 getCount() 메소드에서 각 콜백에 해탕하는 부분이 어
떤 것이고， 뱀플릿 메소드와 어떤 정보를 주고받는지를 잘 생각해보기 바란다.

리스트 3-49는 JdbcTemplate을 사용하도록 수정한 getCount() 메소드다.

리스트 3-49 Jd
bcTemplate을 이용해 만든 getCoun<<)
public int getCount() ( 첫 --번째 -. 를
-백 ... Slaternent 생성

return this.jdbcTemplate .Query(new PreparedStatementCreator() (
public PreparedStatement createPreparedStatement(Connection con)
throws SQLException (
return con.prepareStatement(
닝elect count(*) from users");


}, new ResultSetExtractor<Integer>() (
--융 두 번째 콜액 R얹uttSet9.로부터 강 추출
public Integer extractData(ResultSet rs) throws SQLException ,

DataAccessException (
rs .next();
return rs.getlnt(l);

}

} ) ·/


콜백을 만드느라 익명 내부 클래스가 두 번이나 등장을 하니 조금 정신이 없겠지
만 꼼꼼히 묻어보기 바란다. 원래 getCount() 메소드에 있던 코드 중에서 변히는 부
분만 콜백으로 만들어져서 제공된다고 생각하면 이해하기 쉽다. 앞에서 만들었던
lineReadTem띠
ate
()과 유사하게 두 번째 콜백에서 리턴하는 값은 결국 댐플릿 메소
드의 결과로 다시 리턴된다. 원래 클라이언트/템플릿/콜백의 3단계 구조이니， 콜백이
만들어낸 결과는 템플릿을 거쳐야만 클라이언트인 getCount() 메소드로 넘어오는 것
이다.

또 한 가지 눈여겨볼 것은 ResultSetExtractor는 제네릭스 타입 따라미터를 갖는
다는 점이다. lineReadTemplate()
과 LineCallback
에 적용해봤던 방법과 동일하다.
ResulSet
에서 추출할 수 있는 값의 타입은 다
OJ하기 때문에 타입 파라미터를 사용한 것
이다. ResultSetExtractor 콜백에 지정한 타입은 제네릭 메소드에 적용돼서 Query()
템플릿의 리턴 타입도 함께 바뀐다.

리스트 3--49
의 콜백 오브젝트 코드는 재사용하기 좋은 구조다. SQL을 가지고
PreparedStatement를 만드는 첫 번째 콜백은 이미 재사용 방법을 알아봤다. 두 번째
콜백도 간단하다. SQL의 실행 결과가 하나의 정수 값이 되는 경우는 지주 볼 수 있
다. 클라이언트에서 콜백의 작업을 위해 특별히 제공할 값도 없어서 단순하다. 손쉽게
ResultSetExtractor 콜백을 댐플릿 안으로 옮겨 재활용할 수 있다.

JdbcTemplate은 이런 기능을 가진 콜백을 내장하고 있는 QueryForlnt()
라는 면리한
메소드를 제공한다. Integer 타입의 결과를 가져올 수 있는 SQL 문장만 전달해주면 된
다. 이를 이용하면 리스트 3--49처럼 이중 콜백을 사용히는 제법 복잡해 보이는 메소드
를 리스트 3--50과 같이 한 줄로 바꿀 수 있다.

3장-댐플릿 263


리스트 3동o queryForint( )톨 사용하도록 수정한 geεount( )

public int getCount() {
return this .jdbcTemplate.queryForlnt("select count(*) from users'’);

리스트 3-3
의 34라인짜리 getCount() 메소드가 이제 단 한 줄로 바뀌었다. 물
론 예외처리와 안전한 리소스 반환 DI 된 DataSource를 이용하는 것까지 기능은 모
두 동일하다. 템플릿/콜백을 사용하지 않을 이유가 없다. JdbcTemplate은 스프링
이 제공하는 클래스이지만 DI 컨테이너를 굳이 펼요로 하지 않는다. UserDao에서처
럼 직접 JdbcTemplate 오브젝트를 생성하고 필요한 DataSource를 전달해주기만 하면
JdbcTemplate의 모든 기능을 자유롭게 활용할 수 있다.

3.6.3 QueryForObject()
이번엔 get() 메소드에 JdbcTemplate을 적용해보자. get() 메소드는 지금까지 만들
었던 것 중에서 가장 복잡하다. 일단 SQL은 바인딩이 필요한 치환자를 갖고 있다. 이
것까지는 add()
에서 사용했던 방법을 적용하면 될 것 같다. 남은 것은 ResultSet
에
서 getCount()
처럼 단순한 값이 아니라 복잡한 User 오브젝트로 만드는 작업이다.
ResultSet
의 결과를 User 오브젝트를 만들어 프로퍼티에 넣어줘야 한다.

이를 위해， getCount()
에 적용했던 ResultSetExtractor 콜백 대신 RowMapper 콜

백을 사용하겠다. ResultSetExtractor와 RowMapper 모두 댐플릿으로부터 ResultSet

을 전달받고， 필요한 정보를 추출해서 리턴하는 방식으로 통작한다. 다른 점은

ResultSetExtractor는 ResultSet을 한 번 전달받아 알아서 추출 작업을 모두 진행하고

최종 결과만 리턴해주변 되는 데 반해 RowMapper는 ResultSet
의 로우 하나를 매핑하

기 위해 사용되기 때문에 여러 번 호출될 수 있다는 점이다.

기본키 값으로 조회하는 get() 메소드 SQL의 실행 결과는 로우가 하나인 ResultSet
이다. ResultSet
의 첫 번째 로우에 RowMapper를 적용하도록 만들면 된다. RowMapper
콜백은 첫 번째 로우에 담긴 정보를 하나의 User 오브젝트에 매핑하게 해주면 된다.

이번에 시용할 탬플릿 메소드는 queryForObject()
다. queryForObject와 RowMapper
를 적용한 리스트 3-51
의 코드를 살펴보자.


리스트 3-51queryForObject()와 RowMapper톨 적용한 get() 메소드

public User get(String id ) {
return this.jdbcTemplate.QueryForObject("select * from users where id = 7" ,
new Obj ect [1 (idl, -SOL에 바인딩힐 따라미터 값 가변인자 대신 배얼올 사용효따
new RowMapper(User>() (
public User mapRow(ResultSet rs , int rowNum)
throws SQLException (
User user = new User();
user.setld(rs.getString("id"));
user.setName(rs.getString("name'’ ));
user.setPassword(rs.getString("password"));
return user;

”
}

.

”,

4 Resuh앓 한 로우의 결과를 오브젝트에 매잉해뜯 Row뻐P어 콜백


첫 번째 파라미터는 PreparedStatement를 만들기 위한 SQL이고， 두 번째는 여기에
바인딩할 값들이다. update()
에서처럼 가변인자를 사용하면 좋겠지만 뒤에 다른 파라
미터가 있기 때문에 이 경우엔 가변인자 대신 Object 타입 배열을 사용해야 한다. 배열
초기화 블록을 사용해서 SQL의 ?에 바인딩할 id 값을 전달한다. queryForOb j ect () 내
부에서 이 두 가지 파라미터를 사용하는 PreparedStatement 콜백이 만들어질 것이다.

queryForObject()
는 SQL을 실행하면 한 개의 로우만 얻을 것이라고 기대한다. 그
리고 ResultSet
의 next()
를 실행해서 첫 번째 로우로 이동시킨 후에 RowMapper 콜백을
호출한다. 이미 RowMapper가 호출되는 시점에서 ResultSet은 첫 번째 로우를 가리키고
있으므로 다시 rs.next()를 호출할 필요는 없다. RowMapper에서는 현재 ResultSet이
가리키고 있는 로우의 내용을 User 오브젝트에 그대로 담아서 리턴해주기만 하면 된다.
RowMapper가 리턴한 User 오브젝트는 queryForObject() 메소드의 리턴 값으로 get()
메소드에전달된다.

이렇게만 해도 일단 User 오브젝트를 조회히는 get() 메소드의 기본 기능은 충분히
구현됐다. 하지만 get() 메소드에는 한 가지 더 고려해야 할 게 있다. 기존의 get() 메
소드는 조회 결과가 없을 때 EmptyResultDataAccessException을 던지도록 만들었다.
이 예외상황에 대한 태스트까지 만들어뒀다.

그렇다면 queryForObject()
를 이용할 때는 조회 결과가 없는 예외상황을 어떻게 처
리해야 할까? 이를 위해 특별히 해줄 것은 없다. 이미 queryForObject()
는 SQL을 실
행해서 받은 로우의 개수가 하나가 아니라면 예외를 던지도록 만들어져 있다. 이때 던

3장 템플릿 265


져지는 예외가 바로 EmptyResultDataAccessException
이다. 기존의 get() 메소드에서
시용하던 것과 동일한 예외다. 원래 EmptyResultDataAccessException은 JdbcTemplate
의 queryForObject() 등에서 사용하려고 만든 것인데 이를 미리 가져다 썼던 것이다.

따라서 리스트 3-49의 get() 메소드에 별다른 예외처리를 추가하지 않아도， 조회가
실패했을 경우를 태스트하려고 만든 UserDaoTest
의 getUserFailure() 테스트는 여전
히성공할것이다.

3.6.4 query()
기능정의와테스트작성
RowMapper를 좀 더 사용해보자. 현재 등록되어 있는 모든 사용자 정보를 가져오는
getAll() 메소드를 추가한다. getAll()
은 테이블의 모든 로우를 다 가져오면 된다. 그
렇다면 어떤 포뱃으로 변환하는 것이 좋을까? get() 메소드는 하나의 로우를 User 오
브젝트에 담았으니 여러 개라면 User 오브젝트의 컬렉션으로 만든다. List<User> 타
입으로 돌려주는 게 가장 나을 것 같다. 리스트에 담는 순서는 어떻게 할까? 순서를 지
정하지 않고 가져올 수도 있겠지만 그보다는 기본키인 id 순으로 정렬해서 가져오도록
만들자.
이번에도 태스트를 먼저 만들어보자. 방금 결정한 두 가지 기능을 그대로 코드화하면
태스트가 된다. 태스트를 하려면 검증이 필요하니까 검증이 기능한 예를 가지고 다시 구
체적으로 정리해보자. User 타입의 오브젝트인 userl , user2, user3 세 개를 DB에 등록
하고 getAll()을 호출하면 List<User> 타입으로 결과를 돌려받。}야 한다. 리스트의 크
기는 3이어야 하고， userl , user2, user3와 동일한 내용을 가진 오브젝트가 id 순서대로
담겨 있어야 한다. 저장할 때의 User 오브젝트와 getAll()
로 가져온 User 오브젝트를
비교할 때는 통일성 비교가 아니라 동등성 비교를 해야 한다는 점에 주의하자.
꼼꼼하게 테스트하기 위해 userl , user2, user3를 하나씩 추가하면서 매번 getAll()
을 실행해서 결과를 확인해보자. 불필요하게 태스트를 복잡하게 히는 건 별로 좋은 습
관은 아니지만， 성의 없이 결과 한 가지만 검사해보는 것도 위험하다. 최소한 두 가지
이상의 태스트 조건에 대해 기대한 결괴를 확인해봐야 한다.
getAll( )에 대한 정리 내용을 코드로 표현해보면 리스트 3-52와 같이 만들어질 것
이다.


리스트 3-52ge예I()에 대한 테스트

@Test
public void getAll() (
dao.deleteAll();

dao .add(user1); // Id: gyumee
List<User> users1 = dao.getAll();
assertThat(users1.size() , is(1));
checkSameUser(user1 , users1.get(Ð));

dao .add(user2); // Id: leegw7ÐÐ
List<User> users2 = dao.getAll();
assertThat(users2.size() , iS(2));
checkSameUser(user1 , users2 .get(Ð));
checkSameUser(user2 , users2.get(1));

dao.add(user3); // Id: bumjin
List<User> users3 =dao.getAll();
assertThat(users3 .size() , is(3));
checkSameUser(user3 , users3.get(Ð));
--늘 user3의
잉
값이
알띠벗만으로가장빠르므로

checkSameUser(user1 , users3.get(1));
ge띠10의 첫 번째 엘리먼트여야 효따

checkSameUser(user2 , users3.get(2));

r

뼈 얼빨의 내뚫 비교핸 검증 또 테프에서
번목적으로 시용되므로 분리해놓았다

private void checkSameUser(User user1 , User user2) (
assertThat(user1 .getld() , is(user2 .getld()));
assertThat(user1 .getName() , is(user2 .getName()));
assertThat(user1 .getPassword() , is(user2.getPassword()));


UserDaoTest 안에 픽스처로 준비해둔 user1 , user2 , user3를 차례로 추가하면서
getAll()
이 돌려주는 리스트의 크기와 리스트에 담긴 User 오브젝트의 내용을 픽스처
와 비교한다. 이때 Id 순서대로 정렬된다는 점을 주의하자. 그래서 user3는 가장 마지
막에 추가되지만 getAll()
의 결과에선 가장 첫 번째여야 한다. User의 값을 비교히는
코드가 반복되기 때문에 별도의 메소드로 분리한다. @TestL} @Before 등의 애노테이션
이 붙지 않는 메소드에 태스트 묘드에서 반복적으로 나타나는 코드를 담아두고 재사용
히는 건 좋은 습관이다. 여러 테스트 클래스에 걸쳐 재사용되는 묘드라면 별도의 클래
스로 분리하는 것도 고려해볼 수 있다.

3장-템플릿 267


Query( ) 템플릿을 이용하는 getAlI( ) 구현
이제 이 테스트를 성공시키는 getAll() 메소드를 만들어보자. 이번에는 JdbcTemplate
의 query() 메소드를 시용하겠다. 앞에서 사용한 queryForObject()
는 쿼리의 결과가
로우 하나일 때 시용하고 query()
는 여러 개의 로우가 결과로 나오는 일반적인 경우에
쓸 수 있다. query()
의 리턴 타입은 List(T)
다. query()
는 제네릭 메소드로 타입은 따
라미터로 넘기는
RowMapper(T) 콜백 오브젝트에서 결정된다.
리스트 3-53은 query()를 이용해 만든 getAll() 메소드다.

리스트 3-53 ge띠II() 메소드

public List<User) getAll() (
return this.jdbcTemplate.Query("select * from users order by id" ,
new RowMapper<User)() (
public User mapRow(ResultSet rs , int rowNum)

throws SQLException (
User user =new User();
user.setld(rs.getString("id"));
user .setName(rs .getString("name"));
user.setPassword(rs .getString("password"));
return user;

}
n

.

” ,

첫 번째 파라미터에는 실행할 SQL 쿼리를 넣는다. 바인딩할 파라미터가 었다면 두
번째 따라미터에 추가할 수도 있다. 따라미터가 없다면 생략할 수 있다. 마지막 따라미
터는 RowMapper 콜백이다. query() 템플릿은 SQL을 실행해서 얻은 ResultSet
의 모든
로우를 열람하면서 로우마다 RowMapper 콜백을 호출한다
.SQL 쿼리를 실행해 DB에서
가져오는 로우의 개수만큼 호출될 것이다. RowMapper는 현재 로우의 내용을 User 타입
오브젝트에 매핑해서 돌려준다. 이렇게 만들어진 User 오브젝트는 템플릿이 미리 준비
한 니
st(User) 컬렉션에 추가된다. 모든 로우에 대한 작업을 마치면 모든 로우에 대한
User 오브젝트를 담고 있는 List(User) 오브젝트가 리턴된다.

이제 테스트를 수행해보자. getAll() 태스트가 깔끔하게 성공하는 모습을 볼 수 있
을것이다.


테스트보완
성공적인 태스트 결괴를 보면 빨리 다음 기능으로 넘어가고 싶겠지만 너무 서두르는 것
은 좋지 않다. 항상 꼼꼼하게 빠진 것은 없는지 더 개선할 부분은 없는지 한 번쯤 생각
해보자.
get()
과 마찬가지로 getAll()
에서도 예외적인 조건에 대한 테스트를 빼먹지 말이.0]:
한다. 보통은 getAll()
을 테스트하라고 하면 레코드 몇 개를 추가하고서 그 결과만 확
인하고 말기 쉽다. 긍정적인 결과만 테스트히는 것이다. 현명한 개발자가 되려면 그보
다좀부정적인자세가펼요하다.
네거티브태스트라고불리는 예외상햄 대한태스트는항상빼먹기 쉽다. get()
이
라면 Id가 없을 때는 어떻게 되는지， getAll
()이라면 결과가 하나도 없는 경우에는 어
떻게 되는지를 검증하는 것이 네거티브 태스트다.
품질팀이나 고객이 가끔 히는 불평 중의 하나는 개발자들은 수동 태스트를 할 때 재
주 좋게도 실패할 만한 상황은 요리조리 잘 피해간다는 것이다. 그래서 개발자가 잘 동
작할 것이라고 자신 있게 가져오는 코드를 QA팀이나 고객이 몇 분만 테스트해보면 각
종 에러와 오류가 줄줄 발견되기도 한다. 어떻게 하면 자신이 만든 코드가 정상적인 흐
름에 따라 동작할지를 잘 알고 있는 개발자와는 달리 전문 태스터는 숫자를 입력해야
할 곳에 문자를 넣고， 생일에 음수 값을 넣고， 또는 아무것도 입력하지 않고 폼의 저장
버튼을 누르기도 한다. DB
에 아무런 데이터가 없는 채로 조회하거나， 엉터리 검색 조
건을 넣는 것도 테스트에서 자주 사용하는 방법이다. 문제는 개발지들은 이런 예외적인
상횡에 대한 검증을 잘 안 하려는 습관이 있다는 점이다. 그래서 태스트도 정상적인 조
건에 대한 검증만 하고 넘어가기 쉽다.
만약 getAll()
에서 결과가 없다면 어떻게 해야 할까? 이런 질문은 항상 마지막
에 나오는 경향이 있다. 또는 아예 고려조차 안 하기도 한다. 그래서 문제가 발생하
는 경우는 주로 이런 예외적인 조건과 결과 때문이다. 그래서 같은 개발자가 만든 조
회용 메소드인데도 어떤 메소드는 데이터가 없으면 null
을 리턴하고， 어떤 메소드
는 빈 리스트 오브젝트를 리턴하고， 어떤 메소드는 예외를 던지고， 어떤 메소드는
Null PointerException 같은 런타임 예외가 발생하면서 뻗어버리기도 하는 것이다. 그
래서 미리 예외상햄l 대한 일관성 있는 기준을 정해두고 이를 태스트로 만들어 검증해
둬야한다.
스프링의 개발자인 로드 존슨은 태스트를 작성할 때 항상 네거티브 테스트부터 만드
는 습관이 있다고 한다. 정상적인 조건의 태스트부터 만들면 태스트가 성공하는 것을

3장-탱플릿 269


보고 쉽게 만족해서 예외적인 상황은 빼먹고 넘어가기가 쉽기 때문이다. 예외상햄 대
한 테스트를 자꾸 빼먹는 개발자라면 의도적으로 예외적인 조건에 대해 먼저 태스트를
만드는 습관을 들이는 것도 좋다.

그렇다면 getAll()
의 쿼리를 실행했는데 아무런 데이터가 없다면 어떻게 할 것
인가? 정하기 나름이다. 일단 query()
라는 댐플릿을 사용했으니 query()
가 이
런 경우 어떤 결과를 돌려주는지를 알아야 한다. query()
는 결과가 없을 경우에
queryForObject()
처럼 예외를 던지지는 않는다. 대신 크기가 0
인 List(T> 오브젝트를
돌려준다. getAll()
은 query( )가 돌려주는 결과를 그대로 리턴하도록 만들자. 테스트
에는리
스트
3-54와같이 검증묘드를추가한다. getAll ()에 대한태스트코드인동시
에 getAll()
의 기능을 설명해주는 묘드이기도 하다.

리스트 3• 54 데이터가 없는 경우에 대한 검증 코드가 추가된 ge여II() 테스트

public void getAll() (
dao .deleteAll();

List<User> usersÐ =dao.QetAll();

데이터가 없율 때는 크기가 0인 리스트

assertThat(usersÐ.size() , is(Ð));
--을

오브젝트가 리턴돼야 한다

태스트를 돌려보면 결과는 성공이다.

이쯤에서 한 가지 질문을 해볼 수 있다. 이미 JdbcTemplate의 query() 메소드가 예
외적인 경우에는 크기가 0
인 리스트 오브젝트를 리턴하는 것으로 정해져 있다. 그런데
getAll()
에서 query()
의 결과에 손댈 것도아니면서 굳이 검증묘드를추가해야할까?

물론이다. 태스트 코드를 만드는 것이 좋다. UserDao를 사용하는 쪽의 입징에서 생
각해본다면 getAll()
이 내부적으로 JdbcTemplate을 사용하는지， 개발자가 직접 만든
JDBC 묘드를 사용히는지 알 수 없고 알 필요도 없다. getAll()
이라는 메소드가 어떻
게 동작하는지에만 관심이 있는 것이다. UserDaoTest 클래스의 태스트는 UserDao
의
getAll()
이라는 메소드에 기대히는 동작방식에 대한 검증이 먼저다. 따라서 그 예상되
는 결과를 모두 검증하는 게 옳다. 이렇게 해두면 나중에 JdbcTemplate의 query() 대신
다른 방법으로 구현을 바꿔도 동일한 기능을 유지히는 UserDao인지 확인이 가능하다.

또 내부적으로 query()
를 시용했다고 하더라도 getAll() 메소드가 다른 결괴를 리
턴하게 할수도 있기 때문이다. query()
의 결과를무조건 getAll()
에서 리턴해야할 이
유는 없다. query()
에서 빈 리스트가 오면 null로 바꿔서 리턴할 수도 있다. 또는 예외


를 던지게 할 수도 있다. 그런 면에서 query()
의 결과와 상관없이 getAll( ) 메소드의
예외상뺑 대한 태스트는 반드시 필요하다.

getAll() 메소드의 내부 구조를 속속들이 아는 개발자 입조L에서도 JdbcTemplate의
query() 메소드에 대한 학습 테스트로서 의미가 있다. 정말 query()
는 결과가 없을 때
빈 리스트를 리턴하는지 한 번쯤은 직접 확인해볼 필요도 있기 때문이다.

3.6.5 재사용 가능한 콜백의 분리
태스트는 이제 충분한 듯하니 이쯤에서 UserDao 코드를 한번 살펴보자. UserDao 전체

가 처음 try/catch/finally를 덕지덕지 붙여가며 만들었을 때의 메소드 한 개 분량밖

에는안된다. 코드의 양이 줄었을뿐아니라각메소드의 기능을파익F하기도 쉽게 되어

있다. 핵심적인 SQL 문장과 파라미터， 그리고 생성되는 결과의 타입정보만 남기고 모

든 판에 박힌 로우레벨 중복 코드는 깔끔하게 제거됐기 때문이다.

아직 몇 가지 할 일이 남았다.

01를위한코드정리
이제 필요 없어진 DataSource 인스턴스 변수는 제거하자. UserDao의 모든 메소드가
JdbcTemplate을 이용하도록 만들었으니 DataSource를 직접 사용할 일은 없다. 단지
JdbcTemplate을 생성하면서 직접 DI 해주기 위해 펼요한 DataSource를 전달받아-OF 하
니 수정자 메소드는 남겨둔다. 정리하고 나면 리스트 3-55와 같이 JdbcTemplate 인스
턴스 변수와 DataSource 타입 수정자 메소드만 깔끔하게 남는다. 수정자 메소드에서 이
렇게 다른 오브젝트를 생성하는 경우는 종종 있으니 이런 코드에 익숙해지도록 하자.

리스트 3-55 불필요한 Data없Jr，∞ 변수를 제거하고 남은 U똥rDa。의 미 코드


private JdbcTemplate jdbcTemplate;
public void setDataSource(DataSource dataSource) (
this.jdbcTemplate = new JdbcTemplate(dataSource);
•
DalaSource 오브젝트는
Jd
bcTemptale
올 만든 후
에는 A
용하지 않으니 저
ε「해두지
않아도된다

JdbcTemplate
을 직접 스
프링 빈으로 등록하는 방식을 사용하고 싶다면
setDataSource를 setJdbcTemplate으로 바꿔주기만 하면 된다.

3장-템플릿 271


풍복제거
다음은 중복된 코드가 없나 살펴보자. 웬만한 JDBC의 댐플릿성 코드나 반복적인 콜백
코드도 모두 JdbcTemplate의 도움으로 제거했으니 메소드 단위에서 보자면 줄일 만한
것은 없다. 하지만 get()과 getAll()을 보면 사용한 RowMapper의 내용이 똑같다는 사
실을 알 수 있다. 사용되는 상황은 다르지만 Result5et 로우 하나를 User 오브젝트 하
나로 변환해주는 동일한 기능을 가진 콜백이다.
겨우 두 번 나왔는데 이것도 중복이라고 생각하고 분리할 필요가 있을까? 만약 두 개
가 전부이고 UserDao의 기능이 더 추가되지 않을 것이라면 그냥 넘어가도 문제 될 것은
없다. 하지만 UserDao에 앞으로 추가될 기능을 예%빼보면 RowMapper의 사용이 여기서
끝날 것 같지는 않다. 다OJ=한 조건으로 시용자를 조회하는 검색 기능이 추가될 것이다.
이름으로 검색할 수도 있고 로그인을 위해 아이디와 비밀번호로 검색할 수도 있다. 이
런 메소드에서 매번 동일한 RowMapper를 시용하게 될 것이다. 또한 User의 필드가 추가
되거나 수정되는 경우도 충분히 예상할 수 있다. User 태이블의 필드를 추가하고 수정
하면， 매핑 작업을 해주는 RowMapper 콜백의 코드도 함께 수정해야 한다. 두 개 이상의
RowMapper가 있는데 모두 정확하게 수정해주지 않으면 문제가 발생한다.
따라서 User용 RowMapper 콜백을 메소드에서 분리해 중복을 없애고 재사용되게
만들어야 한다. 먼저 매번 RowMapper 오브젝트를 새로 만들어야 할지 생각해보자.
RowMapper 콜백 오브젝트에는 상태정보가 없다. 따라서 하나의 콜백 오브젝트를 멀티
스레드에서 동시에 사용해도 문제가 되지 않는다. RowMapper 콜백은 하나만 만들어서
공유하자.
리스트 3-56과 같이 userMapper라는 이름으로 인스턴스 변수를 만들고 사용할 매핑
용 콜백 오브젝트를 초기화하도록 만든다. 익명 내부 클래스는 클래스 안에서라면 어디
서든만들수있다.

리스트 3-56 채사용 가능하도록 독립시킨 RowMapper

public class UserDao (
private Ro빼apper
(U
ser> userMapper =
new Ro빼apper(U
ser>() (

public User mapRow(ResultSet rs , int rowNum) throws SQLException (
User user =new User();
user.setld(rs.getString("id"));
user.setName(rs.getString("name"));
user.setPassword(rs.getString( ‘ password")) ;
return user;


인스턴스 변수에 저장해둔 userMapper 콜백 오브젝트는 리스트 3-57과 같이 get()
과
getAll()
에서 사용하면 된다.

리스트 3•)l 공유 userMap야r률 사용하도록 수정한 get(), ge예I()

public User get(String id) (
return this.jdbcTemplate.QueryForOb ject(“ select * frαn users where id = 7" ,
new Object[) {id} , this ,userMapper);

public List<User> getAll() (
return this.jdbcTemplate.Query( 연elect * from users order by id" ,
this , userMapper);


UserDaoTest 테스트를 실행해서 기능을 점검해보자. 문제없이 성공이다.

템플릿/콜백 때턴과 UserDao
리스트 3-58은 최종적으로 완성된 UserDao 클래스다. 랩플릿/콜백 패턴과 DI를 이용
해 예외처리와 리소스 관리 유연한 DataSource 활용 방법까지 제공하면서도 군더더기
하나 없는 깔끔하고 간결한 코드로 정리할 수 있게 됐다.

리스트 3냉8 JdbcTemplate울 적용한 U똥rDa。 클래스

public class UserDao (
public void setDataSource(DataSource dataSource) (
this.jdbcTemplate =new JdbcTemplate(dataSource);

private JdbcTemplate jdbcTemplate;

private RowMapper<User> userMapper =
new RowMapper<User>() (

public User mapRow(ResultSet rs , int rowNum) throws SQLException (
User user = new User();
user.setld(rs .getString( “id") );
user.setName(rs.getString("name"));

3장-댐룰릿 273


user.setPassword(rs.getString("password"));
return user;

public void add(final User user) {
this.jdbcTemplate .update("insert into users(id , name , password)
values(7，
ζ7)"， user. getId() , user. getName() , user. getPassword());

public User get(String id) {
return this.jdbcTemplate.QueryForObject(
닝
elect * from users where id = 7" ,
new Object[] {id} , this.userMapper);

public void deleteAll() {
this.jdbcTemplate.update("delete from users");

public int getCount() {
return this.jdbcTemplate.QueryForlnt(
갱elect count(*) from users");

public List<User> getAll() {
return this.jdbcTemplate.Query(
갱
elect * from users order by
id ‘’ , this.userMapper);

UserDao에는 User 정보를 DB
에 넣거나 가져오거나 조작하는 방법에 대한 핵심적인
로직만 담겨 있다. User라는 자바오브젝트와 USER 태이블 사이에 어떻게 정보를 주
고받을지， DB와 커뮤니케이션하기 위한 SQL 문장이 어떤 것인지에 대한 최적화된 코
드를 갖고 있다. 만약 사용할 태이블과 펼드정보가 바뀌면 UserDao의 거의 모든 코드가
함께 바뀐다. 따라서 응집도가 높다고 볼 수 있다.

반면에 JDBC API를 사용히는 방식， 예외처리， 리소스의 반납， DB 연결을 어떻게
가져올지에 관한 책임과 관심은 모두 JdbcTemplate에게 있다. 따라서 변경이 일어난다
고 해도 UserDao 묘드에는 아무런 영향을 주지 않는다. 그런 면에서 책임이 다른 묘드와
는 낮은 결합도를 유지하고 있다. 다만 JdbcTemplate이라는 템플릿 클래스를 직접 이용


한다는 변에서 특정 템플릿/콜백 구현에 대한 강한 결합을 갖고 있다. JdbcTemplate
이
스프링에서 JDBC를 이용해 DAO를 만드는 데 사용되는 사실상 표준 기술이고，
JDBC
대신 다른 데이터 액세스 기술을 사용하지 않는 한 바뀔 리도 없겠지만， 그래도 더 낮은
결합도를 유지하고 싶다면 JdbcTemplate을 독립적인 빈으로 등록하고 JdbcTemplate
이
구현하고 있는 JdbcOperations 인터페이스를 통해 DI 받아 시용하도록 만들어도 된다.

JdbcTemplate은 DAO 안에서 직접 만들어 사용하는 게 스프링의 관례이긴 하지만
원한다면 얼마든지 독립된 싱글톤 빈으로 등록하고 DI 받아 인터페이스를 통해 사용할
수있다.

그런데 UserDao를 여기서 더 개선할 수도 있을까? 일단은 이 정도에서 만족하는 것
이 타당할 듯싶지만， 장기적으로 많은 DAO가 만들어지고 UserDao도 더 많은 기능이
추가될 것이라고 생각해보면 두 가지 정도 더 욕심을 내고 싶은 부분이 눈에 띈다.

첫째는 userMapper가 인스턴스 변수로 설정되어 있고 한 번 만들어지면 변경되
지 않는 프로퍼티와 같은 성격을 띠고 있으니 이예 UserDao 빈의 DI용 프로퍼티로 만
들어버리면 어떨까? UserMapper를 독립된 빈으로 만들고 XML 설정에 User 태이블
의 펼드 이름과 User 오브젝트 프로퍼티의 매핑정보를 담을 수도 있을 것이다. 이렇게
UserMapper를 분리할 수 있다면 User의 프로퍼티와 User 테이블의 필드 이름이 바뀌거
나 매핑 방식이 바뀌는 경우에 UserDao 코드를 수정하지 않고도 매핑정보를 변경할 수
있다는장점이있다.

둘째는 DAO 메소드에서 사용히는 SQL 문장을 UserDao 코드가 아니라 외부 리소스
에 담고 이를 읽어와 싸용하게 히는 것이다. 이렇게 해두면 DB 테이블의 이름이나 펼
드 이름을 변경하거나 SQL 쿼리를 최적화해야 할 때도 UserDao 묘드에는 손을 댈 펼요
가 없다. 어떤 개발팀은 정책적으로 모든 SQL 쿼리를 DBA들이 만들어서 제공하고 관
리하는 경우가 있다. 이럴 때 SQL이 독립된 파일에 담겨 있다면 펀리할 것이다.

이 두 가지 기능 개선도 당장 해보고 싶긴 하지만 일단 다른 스프링의 기술을 먼저
살펴보고 손을 대보기로 하자.

스프령이 지원하는 JDBC 개발을 위한 기술은 11장에서 좀 더 자세히 설명할 것이
다. 스프링에는 JdbcTemplate 외에도 십여 가지의 댐플릿/콜백 패턴을 적용한 API가
존재한다. 클래스 이름이 Template으로 끝나거나 인터페이스 이름이 Callback으로 끝
난다면 템플릿/콜백이 적용된 것이라고 보면 된다.

3장-템플릿 275


3~ 정리

3징써l서는 예외처리와 안전한 리소스 반환을 보장해주는 DAO 코드를 만들고 이를 객
체지향 설계 원리와 디자인 패턴
.
DI 등을 썩용해서 깔끔하고 유연하며 단순한 코드로
만드는 방법을 살펴봤다.3^cÌ에서 다룬 내용은 다음과 같다 •

• JDBC와 같은 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시
try/catch/finally 블록으로 관리해야 한다.
• 일정한 작업 흐름이 반복되면서 그중 일부 기능만 바뀌는 코드가 존재한다연 전략 때턴을
적용한다. 바뀌지 않는 부분은 컨돼스트로 바뀌는 부분은 전략으로 만들고 인터페이스를
통해 유연하게 전략을 변경할 수 있도록 구성한다.
• 같은 애플리케이션 안에서 여러 가지 종류의 전략을 다이내믹하게 구성하고 시용해야 한다
변 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의하고 제공하게 만든다.
• 클라이언트 메소드 안에 익명 내부 클래스를 사용해서 전략 오브젝트를 구현하면 코드도 간
결해지고 메소드의 정보를 직접 사용할 수 있어서 편리하다.
• 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도
록만든다.
• 컨텍스트는 별도의 빈으로 등록해서 DI 받거나 클라이언트 클래스에서 직접 생성해서 사용
한다. 클래스 내부에서 컨텍스트를 사용할 때 컨텍스트가 의존하는 외부의 오브젝트가 있다
면 코드를 이용해서 직접 DI 해줄 수 있다.
• 단일 전략 메소드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로
만들어 사용하고， 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 댐플릿/콜백 때턴이
라고한다.
• 콜백의 묘드에도 일정한 때턴이 반복된다면 콜백을 댐플릿에 넣고 재활용히는 것이 면리
하다.
• 댐플릿과 콜백의 타입이 다OJ'하게 바뀔 수 있다면 제네릭스를 이용한다.
• 스프링은 JDBC 코드 작성을 위해 JdbcTemplate을 기반으로 하는 다양한 템플릿과 콜백을
제공한다.
• 댐플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고， 하나의 콜백을 여러 번 호출할 수
도있다.
• 랩플릿/콜백을 설계할 때는 템플릿과 콜백 사이에 주고받는 정보에 관심을 둬야 한다.

탱플릿/콜백은 스프링이 객체지향 설계와 프로그래밍에 얼마나 가치를 두고 있는지
를 잘 보여주는 예다. 스프링이 제공하는 랩플릿/콜백을 잘 사용해야 히는 것은 물론이
며 직접 랩플릿/콜백을만들어 활용할수도 있어야한다.

3징-탱플릿 277


여l오l
‘

쐐휠
..


:E윗혈E
. ~. ‘

X바 개발자가 까 신경 쓰71 귀찮O다냥 것 중의 하나가 랜 예외처리다 정상

’적인 결과와 흐름을 보여주는 코드를 만들기도 버거운데 예외상황까지 처리해야
한다는 사실이 부담스러울 수도 있다. 그래서 예외와 관련된 코드는 지주 엉망이 되거
나 무성의하게 만들어지기 쉽다. 때론 잘못된 예외처리 코드 때문에 찾기 힘든 버그를
낳을 수도 있고， 생각지 않았던 예외상황이 발생했을 때 상상 이상으로 난처해질 수도

있다.

4장에서는 JdbcTemplate을 대표로 하는 스프링의 데이터 액세스 기능에 담겨 있는

예외처리와 관련된 접근 방법에 대해 알아본다. 이를 통해 예외를 처리하는 베스트 프

랙티스도살펴본다.

4iJ 사라진 t:I']1ij!(íI#l,m,líj 편|

3장에서 JdbcContext로 만들었던 묘드를 스프링의 JdbcTemplate을 적용하도록 바꾸면

서 설명하지 않고 얼렁뚱땅 넘 어간 부분이 있다. JdbcTemplate으로 바꾸기 전과 후의

deleteAll () 메소드를 비교해보고 무엇이 달라졌는지 찾아보자.

public void deleteAll() throws SQLException {
this. jdbcContext .executeSql ("delete from users");

Jd
bcTem이ate 적용 전

public void deleteAll() ( Jd
bcTe뼈녕r
te 적용 후
this . jdbcTemplate.update("delete from users");

4장-예외 279


얼핏 보면 달라진 게 없는 것 같지만 자세히 메소드의 정의를 들여다보면
JdbcTemplate 적용 이전에는 있었던 throws SQLException 선언이 적용 후에는 사라졌
음을 알 수 있다. SQLException은 JDBC API
의 메소드들이 던지는 것이므로 당연히 있
어야 한다. 비록 로그를 남기기 위해 catch를 했다고 해도 다시 JDBC 탱플릿 메소드
밖으로 던져서 예외상황이 발생했다는 사실을 알려야 한다. 그런데 JdbcTemplate을 적
용한 코드에서는 모두 이 SQLException
이 사라졌다.

그렇다면 이 SQLException은과연 어디로간것일까?

4.1.1 초난감 예외처리
JdbcTemplate
이 어떤 짓을 했길래 SQLException
이 사라졌는지 알아보기 전에 먼저 개
발자들의 코드에서 종종발견되는초난감예외처리의 대표선수들을살펴보자.

예외블랙흩
리스트 4-1은 자바의 기초를 배우는 학생들이 만들어낸 JDBC 코드에서 흔히 볼 수 있
는코드다.

리스트 4-1 초난갑 예외처리 코드 1

try (

예외훌 잡고는 아무것도 하지 않는다 예외 발생을 무시해버리고 정상적인 상횡인 것처

catch(SQLException e) {--률 렁 다음 라인으로 넘어가겠다는 룬영한 의도가 있는 게 아니라면 언슴 중에도 절대 만

들어서는 안 되는 코드다


JDBC API를 썼더니 IDE가 친절하게도 빨간 줄을 그어주며 ‘처리되지 않은 예외가
있다고 에러 표시를 해준다. 이를 보고 자바 언어 기초 시간에 배운 대로 try/catch 블
록을 둘러씨주는 것으로 해결한다. 컴파일러 에러 메시지도 없어지고 간단한 예제에서
라면 별문제 없이 잘 동작한다.

아직 자바에 익숙하지 않은 초보자만 이러면 모르겠는데 이런 식의 코드가 자바 서
적의 예제나 강의 자료에도 심심치 않게 등장하고， 유명 오픈소스 제품의 코드나 실전
프로젝트에서 작성된 묘드에도 나타나는 것을 보면 그냥 초보자의 실수라고만 볼 수는
없다. 처음 예외처리용 묘드를 만들면서 생긴 잘못된 습관이 계속 남아 있는 게 문제의
원인일것이다.


예외가 발생하면 그것을 catch 블록을 써서 잡아내는 것까지는 좋은데 그리고 아
무것도 하지 않고 별문제 없는 것처럼 넘어가 버리는 건 정말 위험한 일이다. 원치 않
는 예외가 발생하는 것보다도 훨씬 더 나쁜 일이다. 왜냐하면 프로그램 실행 중에 어디
선가 오류가 있어서 예외가 발생했는데 그것을 무시하고 계속 진행해버리기 때문이다.
결국 발생한 예외로 인해 어떤 기능이 비정상적으로 동작하거나， 메모리나 리소스가
소진되거나， 예상치 못한 다른 문제를 일으킬 것이다. 최종적으로 오작동을 하거나 시
스템 오류가 나서 운영자가 알아차렸을 때는 이미 조치를 취하기엔 너무 늦었다. 더 큰
문제는 그 시스템 오류나 이상한 결과의 원인이 무엇인지 찾아내기가 매우 힘들다는
점이다.

어떤 경우에도 위와 같은 코드를 만들면 안 된다. 습관이 되면 무서우니 코딩 연습이
나 예제를 잠깐 만드는 경우라도 그래선 안 된다.
리스트 4-2나 리스트 4-3과 같은 코드도 마찬가지다.

리스트 4-2 초난감 예외처리 코드 2


} catch (SQLException e) (
System.out.println(e);

리스트 4-3 초난감 예외처리 코드 3

} catch (SQLException e) (
e.printStackTrace();

예외가 발생하면 화면에 출력해주는데 뭐가 문제일까? 개발 중에는 IDE 콘솔이나
서버 실행정L에 이 메시지가 눈에 확 띄게 보이니 문제가 생겨도 금방 알아차리고 뭔가
조취를 취할 수 있을지 모르겠다. 그래 봤자 다른 로그나 메시지에 금방 묻혀버리면 놓
치기 쉽상이다. 운영서버에 올라가면 더욱 심각하다. 콘솔 로그를 누군가가 계속 모니
터렁하지 않는한이 예외 코드는심각한폭탄으로남아있을것이다. 예외는처리돼야
한다. 그런데 리스트 4-2와 리스트 4-3
에서 catch 블록을 이용해 화면에 메시지를 출
력한것은예외를처리한게 아니다.

예외를처리할때 반드시 지켜야할핵심 원칙은한가지다. 모든예외는적절하게 복
구되든지 아니면 작업을중단시키고운영자또는 개발자에게 분명하게 통보돼야한다.

4장-예외 281


SQLException이 발생하는 이유는 SQL에 문법 에러가 있거나 DB에서 처리할 수 없
을 정도로 데이터 액세스 로직
에 심각한 버그가 있거나， 서버가 죽거나 네트워크가 끊
기는 등의 심각한 상황이 벌어졌기 때문이다. 그런데 그냥 예외를 무시하고 정상적으로
동작하고 있는 것처럼 모른 척 다음 코드로 실행을 이어간다는 건 말이 되지 않는다. 콘
솔이나 로그에 예외 메시지를 출력하는 건 아무런 도움이 되지 않는다.

이럴 바엔 차라리 리스트 4-4와 같이 만드는 게 백 배 낫다.

리스트 4-4 그나마 나은 예외처리

} catch (5QLException e) (
e.print5tackTrace();
System.exit(l);

물론 실전에서 이렇게 만들라는 건 아니다. 예외를 무시하거나 잡아먹어 버리는 묘
드는 만들지 말라는 뭇이
다. 굳이 예외를 집아서 뭔가 조치를 취할 방법이 없다면 잡지
말아야 한다. 메소드에 throws SQLException을 선언해서 메소드 밖으로 던지고 자신을
호출한코드에 예외처리 책임을전가해버려라.

무의미하고 무책임한 throws
catch 블록으로 예외를 잡。}봐야 해결할 방법도 없고 JDK API나 라이브러리가 던지는
각종 이름도 긴 예외들을 처리하는 묘드를 매번 throws로 선언하기도 귀찮아지기 시작
하면， 리스트 4-5와 같이 메소드 선언에 throws Exception을 기계적으로 붙이는 개발
자도있다.

리스트 4-5 초난감 예외처리 4

꿇

public void methodl () throws Exception ( /'
" 예외
method2 ();

예외

““
호훌

public void n돼od2(
) throws Exception (
method3 () ;

‘ -‘ 예외

-‘

‘

‘

‘

、

、

‘

” 1 *‘‘””

’’↓川

*l·m”” {

)

’

x m I ?

FF

mm ‘

때

nuF li

띠

셔ω

때


EJB가 한창 쓰이던 시절에 흔히 볼 수 있던 코드다. API 등에서 발생하는 예외를 일

일이 catch하기도 귀찮고 별 필요도 없으며 매번 정확하게 예외 이름을 적어서 선언하

기도 귀찮으니 아예 throws Exc
ep
tion
이라는， 모든 예외를 무조건 던져버리는 선언을

모든 메소드에 기계적으로 넣는 것이다. 예외를 흔적도 없이 먹어치우는 예외 블랙홀보

다는 조금 낫긴 하지만 이런 무책임한 throws 선언도 심각한 문제점이 있다.

자신이 사용하려고 하는 메소드에 throws Exception
이 선언되어 있다고 생각해보

자. 그런 메소드 선언에서는 의미 있는 정보를 얻을 수 없다. 정말 무엇인가 실행 중

에 예외적인 상황이 발생할 수 있다는 것인지， 아니면 그냥 습관적으로 복사해서 붙여

놓은 것인지 알 수가 없다. 결국 이런 메소드를 시용히는 메소드에서도 역시 throws

Exceptio
n을 따라서 붙이는 수밖에 없다. 결과적으로 적절한 처리를 통해 복구될 수 있

는 예외상황도 제대로 다룰 수 있는 기회를 박탈당한다.

예외를 무시해버리는 첫 번째 문제보다는 낫다고 하지만 이런 코드도 매우 안 좋은

예외처리방법이다.

이 두 가지 나쁜 습관은 어떤 경우에도 용납하지 않이야 한다.

4.1.2 예외의종류와특징
그렇다면 예외를 어떻게 다휘야 할까? 예외처리에 관해서는 자바 개발자들 사이에서도
오랫동안 많은 논쟁이 있었다. 가장 큰 이슈는 처|크 예외checked exception
라고 불리는 명
시적인 처리가 펼요한 예외를 사용하고 다루는 방법이다.
자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세 가지가 있다.

• Error
첫째는 java.lang. Error 클래스의 서브클래스들이다. 에러는 시스템에 뭔가 비정상
적인 상황이 발생했을 경우에 사용된다. 그래서 주로 자바 VM에서 발생시키는 것이
고 애플리케이션 코드에서 잡으려고 하면 안 된다. OutOfMemory
E
rror나 ThreadDeath
같은 에러는 catch 블록으로 잡이봤자 아무런 대응 방법이 없기 때문이다.

따라서 시스랩 레벨에서 특별한 작업을 히는 게 아니라면 애플리케이션에서는 이
런 에러에 대한처리는신경 쓰지 않아도된다.

4장-예외 283



• Exception과 체크 예외
java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들은 에러와 달리
개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 시용
된다.
Exception 클래스는 다시 체크 예외와 언체크 여|외
unchecked exception로 구분된
다. 전자는 Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상
속하지 않은 것들이고， 후자는 RuntimeException을 상속한 클래스들을 말한다.
RuntimeException은 Exception
의 서브클래스이므로 Exception
의 일종이긴 하지
만 자바는 이 RuntimeException과 그 서브클래스는 특별하게 다룬다. 그림 4-1
은
Exception 클래스의 서브클래스를 체크 예외와 언체크 예외로 구분한 것이다.

Except ion

연체크 체크예외

.. Except ion

예외
그림 4-1 Exception의 두 가지 종류

일반적으로 예외라고 하면 Exception 클래스의 서브클래스 중에서
RuntimeException을 상속하지 않은 것만을 말히는 체크 예외라고 생각해도 된다. 체
크 예외가 발생할 수 있는 메소드를 샤용할 경우 반드시 예외를 처리핸 코드를 함
께 작성해야 한다. 시용할 메소드가 체크 예외를 던진다면 이를 catch 문으로 잡든
지， 아니면 다시 throws를 정의해서 메소드 밖으로 던져야 한다. 그렇지 않으면 컴파
일에러가발생한다.

자바 언어와 JDK의 초기 설계자들은 체크 예외를 발생 가능한 예외에 모두 적용
하려고 했던 것 같다. 그래서 IOException이나 SQLException을 비롯해서 예외적인
상황에서 던져질 가능성이 있는 것들 대부분이 체크 예외로 만들어져 있다.

• Runtime
Exception과 언체크l련타임 예외
java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제
하지 않기 때문에 언체크 예외라고 불린다. 또는 대표 클래스 이름을 따서 런타임 예

외라고도 한다. 에러와 마찬가지로 이 런타임 예외는 catch 문으로 잡거나 throws로
선언하지 않아도 된다. 물론 명시적으로 잡거나 throws로 선언해줘도 상관없다.

런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다. 대
표적으로 오브젝트를 할당하지 않은 레퍼런스 변수를 사용하려고 시도했을 때 발생
하는 NullPointerException
이나， 허용되지 않는 값을 사용해서 메소드를 호출할 때
발생히는 IllegalArgumentException 등이 있다. 이런 예외는 묘드에서 미리 조건을
체크하도록 주의 깊게 만든다면 피할 수 있다. 피할 수 있지만 개발자가 부주의해서
발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외다. 따라서 런타임 예외는
예상하지 못했던 예외상황에서 발생하는 게 아니기 때문에 굳이 catchL.j-throws를
사용하지 않아도 되도록 만든 것이다.

그런데 자바 언어를 설계하고 JDK를 개발한 사람들의 이런 설계의도는 현실과 잘
맞지 않았고 비난의 대상이 되기도 했다. 특히 체크 예외의 불필요성을 주장히는 사람
들이 늘어갔다. 체크 예외가 예외처리를 강제히는 것 때문에 예외 블랙홀이나 무책임한
throws 같은 코드가 남발됐다. 최근에 새로 등장히는 자바 표준 스펙의 API들은 예상
기능한 예외상횡을 다루는 예외를 체크 예외로 만들지 않는 경향이 있기도 하다.

4.1.3 예외처리 방법
먼저 예외를 처리하는 일반적인 방법을 살펴보고 나서 효과적인 예외처리 전략을 생각
해보겠다.

예외복구
첫 번째 예외처리 방법은 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는
것이다.
예를 들어 사용자가 요청한 파일을 읽으려고 시도했는데 해당 파일이 없다거나 다른
문제가 있어서 읽히지가 않아서 IOException
이 발생했다고 생각해보자. 이때는 사용자
에게 상황을 알려주고 다른 파일을 이용하도록 안내해서 예외상황을 해결할 수 있다.
예외로 인해 기본 작엽 흐름이 불가능하면 다른 작업 흐름으로 자연스럽게 유도해주는
것이다. 이런 경우 예외상황은 다시 정상으로 돌아오고 예외를 복구했다고 볼 수 있다.
단. IOException 에러 메시지가 사용자에게 그냥 던져지는 것은 예외 복구라고 볼 수
없다. 예외가 처리됐으면 비록 기능적으로는 시용자에게 예외상황으로 비쳐도 애플리
케이션에서는 정상적으로 설계된 흐름을 따라 진행돼야 한다.

4장-예외 285


네트워크가 불안해서 가끔 서버에 접속이 잘 안 되는 열악한 환경에 있는 시스템이
라면 원격 DB 서버에 접속하다 실패해서 SQLException
이 발생하는 경우에 재시도를
해볼 수 있다. 네트워크 접속이 원활하지 않아서 예외가 발생했다면 일정 시간 대기했
다가 다시 접속을 시도해보는 방법을 시용해서 예외상황으로부터 복구를 시도할 수 있
다. 물론 정해진 횟수만큼 재시도해서 실패했다면 예외 복구는 포기해야 한다.

예외처리 코드를 강제히는 체크 예외들은 이렇게 예외를 어떤 식으로든 복구할 가능
성이 있는 경우에 시용한다. API를 사용히는 개발자로 하여금 예외상황이 발생할 수 있
음을 인식하도록 도외주고 이에 대한 적절한 처리를 시도해보도록 요구하는 것이다.

리스트 4-6은 통제 불가능한 외부 요인으로 인해 예외가 발생하면 MAX_RETRY만큼
재시도를 하는 간단한 예다. 사전에 미리 성공 여부를 확인할 수 없고， 재시도가 의미
있는 경우라면 이렇게 최대 횟수만큼 반복적으로 시도함으로써 예외상횡11
서 복구되게
할수있다.

리스트 4--6 재시도틀 통해 예외톨 복구하는 코드

int maxretry = MAX_RETRY;
while(maxretry -->Ð) {
try {

// 예외가 발생활 가능성이 있는 시도
return; // 작업 성공

catch(SomeException e) {

// 로그 출력 . 정해진 시간만큼 대기

finally {

// 리소스 반납
. 정리 작업

throw new RetryFailedException(); // 최대 재시도 횟수를 넘기면 직접 예외 발생

예외처리회피
두 번째 방법은 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
이다
throws 문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 catch 문으로
일단 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는rethrow 것이다.
예외를 자신이 처리하지 않고 회피하는 방법이다. 빈 catch 블록으로 잡아서 예외가
발생하지 않은 것처럼 만드는 경우는， 드물지만 특별한 의도를 가지고 예외를 복구했


거나 아무 개념이 없어서 그런 것이지 회피한 것은 아니다. 예외처리를 회피하려면 반
드시 다른 오브젝트나 메소드가 예외를 대신 처리할 수 있도록 리스트 4-7
이나 리스트
4-8처럼 던져줘야한다.

리스트 4-7 예외처리 회피 1

public void add() throws SQLException (
/ / JDBC API

리스트 4-8 여|외처리 회nl 2

public void add() throws SQLException {
try {
// JDBC API

catch(SQLException e) (

// 로그 출력

throw e;


JdbcContext
나 JdbcTemplate
이 사용하는 콜백 오브젝트는 메소드 선언을 보
면 알겠지만 ResultSet
이나 PTepaTedStatement 등을 이용해서 작업하다 발생하는
SQLException을 자신이 처리하지 않고 뱀플릿으로 던져버린다. 콜백 오브젝트의 메소
드는 모두 thTOWS SQLException
이 붙어 있다. SQLException을 처리히는 일은 콜백 오
브젝트의 역할이 아니라고 보기 때문이다. 콜백 오브젝트의 메소드는 SQLException
에
대한 예외를 회피하고 템플릿 레벨에서 처리하도록 던져준다.

하지만 콜백과 랩플릿처럼 긴밀하게 역할을 분담하고 있는 관계가 아니라면 자신
의 코드에서 발생히는 예외를 그냥 던져버리는 건 무책임한 책임회피일 수 있다. 만
약 DAO가 SQLException을 생각 없이 던져버리면 이떻게 될까?DAO를 사용히는 서
비스 계층이나 웹 컨트롤러에서 과연 SQLException을 제대로 처리할 수 있을까? 아마
도 이런 경우라면 DAO에서 던진 SQLException을 서비스 계층 메소드가 다시 던지고，
컨트롤러도 다시 던지도록 선언해서 예외는 그냥 서버로 전달되고 말 것이다. 아마도
thTOWS SQLException과 같이 구체적인 예외를 던지도록 선언하기가 귀찮아서 모든 예
외를 생각없이 던져버리게 하는 thTOWS Exception을 사용할 가능성이 높다.

4장-여1외 287


예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다. 콜백/랩플
릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나，
자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확신이 있어야
한다.

예외전환

마지막으로 예외를 처리하는 방법은 예외 전환exception translation을 하는 것이다. 예외 회
피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드
밖으로 던지는 것이다. 하지만 예외 회피와 달리， 발생한 예외를 그대로 넘기는 게 아니
라 적절한 예외로 전환해서 던진다는 특정이 있다.

예외 전환은 보통 두 가지 목적으로 사용된다.

첫째는 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의
미를 부여해주지 못히는 경우에 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해
서다. API가 발생하는 기술적인 로우레벨을 상횡에 적합한 의미를 가진 예외로 변경하
는것이다.

예를 들어 새로운 사용자를 등록하려고 시도했을 때 아이디가 같은 사용자가 있어
서 DB 에러가 발생하면 JDBC API는 SQLException을 발생시킨다. 이 경우 DAO 메
소드가 SQLException을 그대로 밖으로 던져버리면 DAO를 이용해 사용자를 추가하려
고 한 서비스 계충 등에서는 왜 SQLException
이 발생했는지 쉽게 알 방법이 없다. 로그
인 에디 중복 같은 경우는 충분히 예상 가능하고 복구 가능한 예외상황이다. 이렬 땐
DAO에서 SQLException의 정보를 해석해서 DuplicateUserldException 같은 예외로
바꿔서 던져주는 게 좋다. 의미가 분명한 예외가 던져지면 서비스 계충 오브젝트에는
적절한 복구 작업을 시도할 수가 있다. 서비스 계층 오브젝트에서 SQLException의 원인
을 해석해서 대응하는 것도 불기능하지는 않지만， 특정 기술의 정보를 해석하는 묘드를
비즈니스 로직을 담은 서비스 계충에 두는 건 매우 어색하다. 따라서 DAO 메소드에서
기술에 독립적이며 의미가 분명한 예외로 전환해서 던져줄 펼요가 있다.

리스트 4-9는 사용자 정보를 등록하려고 시도해보고 만약 중복된 아이디 값 때문에
에러가 나는 경우에는 이를 확인해서 좀 더 의미 있는 DuplicateKeyException으로 전
환해주는 DAO 메소드의 예다.


리스트 4-9 예외 전환 기능을 가진 DAO 메소드

public void add(User user) throws DuplicateUserldException, SQLException {

try (
// JDBC를 이용해 user 정보를 DB에 추가하는 코드 또는
// 그런 기능을 가진 다른 SQLException을 던지는 메소드를 호출하는 코드

catch(SQLException e) (
// ErrorCode가 MySQL의 "Duplicate Entry(1062)
“
01
면 예외 전환
if (e.getErrorCode() == MysqlErrorNumbers.ERJDUP_ENTRY)

throw DuplicateUserldException();
else
throw e; // 그 외의 경우는 SQLException 그대로


보통 전환하는 예외에 원래 발생한 예외를 담아서 중칩 예외nested exception로 만드는

것이 좋다. 중첩 예외는 getCause( ) 메소드를 이용해서 처음 발생한 예외가 무엇인지
확인할수 있다. 중첩 예외는 리스트
4-10이나 리스트
4-11
처럼 새로운 예외를만들면
서 생성자나 initCause() 메소드로 근본 원인이 되는 예외를 넣어주면 된다.

리스트 4-10 중접 예외 1

catch(SQLException e) (
throw DuplicateUserldException(e);

리스트 4-11 충접 예외 2

catch(SQLException e) (
throw DuplicateUserldException().initCause(e);

두 번째 전환 방법은 예외를 처리하기 쉽고 단순하게 만들기 위해 포쟁rap하는 것이
다. 중첩 예외를 이용해 새로운 예외를 만들고 원인cause이 되는 예외를 내부에 담아서
던지는 방식은 같다. 하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니
다. 주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우
에사용한다.

4장-예외 289


대표적으로 EJBException을 들 수 있다. EJB 컴포넌트 코드에서 발생하는 대부분의
체크 예외는 비즈니스 로직으로 볼 때 의미 있는 예외이거나 복구 가능한 예외가 아니
다. 이런 경우에는 런타임 예외인 EJBException으로 포장해서 던지는 편이 낫다. 예를
들면 리스트
4-12와같은식이다.

리스트 4-12 예외 포장

try {
OrderHome orderHome = EJBHomeFactory.getlnstance().getOrderHome();
Order order = orderHome.findByPrimaryKey(Integer id);

} catch (NamingException ne) {
throw new EJBException(ne);
} catch (SQLException se) {
throw new EJBException(se);
} catch (RemoteException re) {
throw new EJBException(re);

EJBException은 RuntimeException 클래스를 상속한 런타임 예외다. 이렇게 런타임
예외로 만들어서 전달하면 EJB는 이를 시스뱀 익셉션으로 인식하고 트랜잭션을 자동으
로 롤백해준다. 런타임 예외이기 때문에 EJB 컴포넌트를 사용하는 다른 EJB나 클라이
언트에서 일일이 예외를 잡거나 다시 던지는 수고를 할 필요가 없다. 이런 예외는 잡아
도복구할만한방법이 없기 때문이다.

반대로 애플리케이션 로직상에서 예외조건이 발견되거나 예외상황이 발생할 수도
있다. 이런 것은 API가 던지는 예외가 아니라 애플리케이션 코드에서 의도적으로 던지
는 예외다. 이때는 체크 예외를 사용하는 것이 적절하다. 비즈니스적인 의미가 있는 예
외는 이에 대한 적절한 대응이나 복구 작업이 필요하기 때문이다.

일반적으로 체크 예외를 계속 throws를 사용해 넘기는 건 무의미하다. 메소드 선언
은 지저분해지고 아무런 장점이 없다.DAO에서 발생한 SQLException이 웹 컨트롤러
메소드까지 명시적으로 전달된다고 해서 무슨 소용이 있을까? 웹 컨트롤러 메소드에
throws SQLException 선언이 달려 있다면 이를 도대체 어떻게 해석해야 할까? 어차피
복구가 불가능한 예외라면 가능한 한 빨리 런타임 예외로 포장해 던지게 해서 다른 계
층의 메소드를 작성할 때 불필요한 throws 선언이 들어가지 않도록 해줘야 한다.

대부분 서버환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일
괄적으로 다룰 수 있는 기능을 제공한다. 어차피 복구하지 못할 예외라면 애플리케이션


코드에서는 런타임 예외로 포장해서 던져버리고， 예외처리 서비스 등을 이용해 자세한
로그를 남기고， 관리자에게는 메일 등으로 통보해주고， 사용자에게는 친절한 안내 메시
지를 보여주는 식으로 처리하는 게 바람직하다.

4.1.4 예외처리 전략
사실 자바의 예외를 이용하는 것은 간단하다. 하지만 예외를 효과적으로 사용하고， 예
외가발생하는코드를깔끔하게 정리하는데는여러 가지 신경 써야할사항이 많다. 지
금까지 살펴본 예외의 종류와 처리 방법 등을 기준으로 일관된 예외처리 전략을 정리해
보자.

런타임예외의보편화
일반적으로는 체크 예외가 일반적인 예외를 다루고， 언제크 예외는 시스템 장애나 프로
그램상의 오류에 사용한다고 했다. 문제는 체크 예외는 복구할 가능성이 조금이라도 있
는， 말 그대로 예외적인 상황이기 때문에 자바는 이를 처리하는 catch 블록이나 throws
선언을 강제하고 있다는 점이다. 이렇게 예외처리를 강제히는 것은 예외가 발생할 가능
성이 있는 API 메소드를 사용하는 개발자의 실수를 방지하기 위한 배려라고 볼 수도 있
겠지만， 실제로는 예외를 제대로 다루고 싶지 않을 만큼 찌증나게 만드는 원인이 되기
도한다.
자바가 처음 만들어질 때 많이 λF용되던 애플릿이나 AWT, 스왕Swing을 사용한 독립
형 애플리케이션에서는 통제 불가능한 시스템 예외라고 할지라도 애플리케이션의 작업
이 중단되지 않게 해주고 상황을 복구해야 했다. 예를 들어 워드의 파일 열기 기능에서
사용자가 입력한 이름에 해당하는 파일을 찾을 수 없다고 애플리케이션이 종료돼버리
게할수는없다.
하지만 자바 엔터프라이즈 서버환경은 다르다. 수많은 사용자가 동시에 요청을 보내
고 각 요청이 독립적인 작업으로 취급된다. 하나의 요청을 처리하는 중에 예외가 발생
하면 해당 작업만 중단시키면 그만이다. 독립형 애플리케이션과 달리 서버의 특정 계층
에서 예외가 발생했을 때 작업을 일시 중지하고 사용자와 바로 커뮤니케이션하면서 예
외상황을복구할수있는방법이 없다.
차라리 애플리케이션 차원에서 예외상황을 미리 파악하고， 예외가 발생하지 않도
록 차단하는 게 좋다. 또는 프로그램의 오류나 외부 환경으로 인해 예외가 발생하는 경
우라면 빨리 해당 요청의 작업을 취소하고 서버 관리자나 개발자에게 통보해주는 편이

4~L 예외 291


낫다. 자바의 환경이 서버로 이동하면서 체크 예외의 활용도와 가치는 점점 떨어지고
있다. 자칫하면 throws Exception으로 점철된 아무런 의미도 없는 메소드들을 낳을 뿐
이다. 그래서 대응이 불가능한 제크 예외라면 빨리 런타임 예외로 전환해서 던지는 게
낫다.

자바 초기부터 있었던 JDK의 API와 달리 최근에 등장하는 표준 스펙 또는 오픈소
스 프레임워크에서는 API가 발생시키는 예외를 체크 예외 대신 언체크 예외로 정의
히는 것이 일반화되고 있다. 예전에는 복구할 가능성이 조금이라도 있다면 체크 예외
로 만든다고 생각했는데
， 지금은 항상 복구할 수 있는 예외가 아니라면 일단 언체크 예
외로 만드는 경향이 있다. 언체크 예외라도 필요하다면 얼마든지 catch 블록으로 잡
아서 복구하거나 처리할 수 있다. 하지만 대개는 복구 불가능한 상황이고 보나마나
RuntimeException 등으로 포장해서 던져야 할 테니 아예 API 차원에서 런타임 예외를
던지도록 만드는 것이다.

add() 메소드의 예외처리
리스트 4-9에 나온 add() 메소드는 DuplicatedUserldException과 SQLException,
두 가지의 체크 예외
를 던지게 되어 있다. JDBC 코드에서 SQLException
이 발생할 수 있는데， 그 원인이 ID 중복이라면 좀 더 의미 있는 예외인
DuplicatedUserldException으로 전환해주고， 아니라면 SQLException을 그대로 던지
게 했다. DuplicatedUserldException은 충분히 복구 기능한 예외이므로 add() 메소드
를 사용히는 쪽에서 잡아서 대응할 수 있다. 하지만 SQLException은 대부분 복구 불가
능한 예외이므로 잡아봤자 처리할 것도 없고 결국 throws를 타고 계속 앞으로 전달되
다가 애플리케이션 밖으로 던져질 것이다. 그럴 바에는 그냥 런타임 예외로 포장해 던
져버려서 그 밖의 메소드들이 신경 쓰지 않게 해주는 편이 낫다.
DuplicatedUserldException
도 굳이 체크 예외로 둬야 하는 것은 아니
다. DuplicatedUserldException
처럼 의미 있는 예외는 add( ) 메소드를 바
로 호출한 오브젝트 대신 더 앞단의 오브젝트에서 다룰 수도 있다. 어디에서
든 DuplicatedUserldException
을 잡아서 처리할 수 있다면 굳이 체크 예외
로 만들지 않고 런타임 예외로 만드는 게 낫다. 대신 add() 메소드는 명시적으로
DuplicatedUserldException을 던진다고 선언해야 한다. 그래야 add() 메소드를 사
용하는 코드를 만드는 개발자에게 의미 있는 정보를 전달해줄 수 있다. 런타임 예외도
throws로 선언할 수 있으니 문제 될 것은 없다.


이 방법을 이용해 리스트 4-9에 나온 add() 메소드를 수정해보자.

먼저 사용자 아이디가 중복됐을 때 사용하는 DuplicateUserldException을 만든다.
필요하면 언제든 잡아서 처리할 수 있도록 별도의 예외로 정의하기는 하지만， 펼요 없
다면 신경 쓰지 않아도 되도록 RuntimeException을 상속한 런타임 예외로 만든다. 중
첩 예외를 만들 수 있도록 생성자를 추가해주는 것을 잊지 말자. 메시지나 예외상황을
전달하는 데 필요한 정보를 더 넣을 수도 있다. 리스트 4-]3은 이렇게 만들어진 예외
클래스다.

리스트 4-13 아이디 종복 시 사용하는 예외

public class DuplicateUserldException extends RuntimeException {
public DuplicateUserldException(Throwable cause) {
super( cause);


이제 add() 메소드를 수정하자. 리스트 4-9에서는 SQLException을 직접 메소드 밖
으로 던지게 했는데， 이제는 런타임 예외로 전환해서 던지도록 만든다. 기존의 아이디
중복 때문에 SQLException
이 발생한 경우에는 DuplicateUserldException을 던지게 하
는 코드는 그대로 두면 된다.

이제 특별한 의미를 가지는 DuplicatedUserldException 외에 시스댐 예외에 해
당하는 SQLException은 언체크 예외가 됐다. 따라서 메소드 선언의 throws
에 포함시
킬 필요가 없다. 반면에 역시 언체크 예외로 만들어지긴 했지만 add( ) 메소드를 사용
하는 쪽에서 아이디 중복 예외를 처리하고 싶은 경우 활용할 수 있음을 알려주도록
DuplicatedUserldException을 메소드의 throws 선언에 포함시킨다. 리스트 4-14는
이렇게 정리한
add() 메소드다.

리스트 4-14 예외처리 전략을 적용한 add()

public void add() throws DuplicateUserldException {

try {

// JDBC를 이용해 user 정보를 DB에 추가하는 코드 또는

// 그런 기능이 있는 다른 SQLException을 던지는 메소드를 호출하는 코드

catch (SQLException e) {
if (e .getErrorCode() == MysqlErrorNumbers .ER_DUP_ENTRY)
throw new DuplicateUserldException(e); 1/ 예외 전환

4장-예외 293


else
throw new RuntimeException(e); /1 예외 포장

이제 이 add( ) 메소드를 샤용하는 오브젝트는 SQLException을 처리하기 위해 불필
요한 throws 선언을 할 필요는 없으면서 필요한 경우 아이디 중복 상황을 처리하기 위
해 DuplicatedUserldException을 이용할 수 있다. DuplicatedUserldException
이 발
생한 경우라면 사용자가 요청한 아이디 대신 사용할 수 있는 추천 아이디를 만들어 아
이디 중복 메시지와 함께 제공해주는 방법을 시용하면 좋을 듯하다.

이렇게 런타임 예외를 일반화해서 사용하는 방법은 여러모로 장점이 많다. 단， 런타
임 예외로 만들었기 때문에 사용에 더 주의를 기울일 필요도 있다. 컴파일러가 예외처
리를 강제하지 않으므로 신경 쓰지 않으면 예외상황을 충분히 고려하지 않을 수도 있기
때문이다. 런타임 예외를 시용하는 경우에는 API 문서나 레퍼런스 문서 등을 통해， 메
소드를 사용할 때 발생할 수 있는 예외의 종류와 원인， 활용 방법을 자세히 설명해두자.

애플리케이션예외
런타임 예외 중심의 전략은굳이 이름을붙이자면 닥관적인 예외처리 기법이라고할수
있다. 일단 복구할 수 있는 예외는 없다고 가정하고 예외가 생겨도 어차피 런타임 예외
이므로 시스랩 레벨에서 알아서 처리해줄 것이고， 꼭 필요한 경우는 런타임 예외라도
잡아서 복구하거나 대응해줄수 있으니 문제 될 것이 없다는낙관적인 태도를 기반으로
하고 있다. 이런 변에서 직접 처리할 수 없는 예외가 대부분이라고 하더라도 혹시 놓치
는 예외가 있을 수 있으니， 일단 잡고 보도록 강제히는 체크 예외의 비관적인 접근 방법
과대비된다.
반면에 시스댐 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에
의해 의도적으로 발생시키고 반드시 catch 해서 무엇인가 조치를 취하도록 요구히는
예외도 있다. 이런 예외들을 일반적으로 애플리케이션 예외라고 한다.
예를 들어 사용자가 요청한 금액을 은행계좌에서 출금히는 기능을 가진 메소드가 있
다고 생각해보자. 무턱대고 출금을 허용하고， 현재 잔고가 얼마인지 상관없이 요청한
금액만큼 계좌 잔액을 차감하도록 만드는 개발자는 없을 것이다. 당연히 현재 잔고를
확인하고， 허용하는 범위를 넘어서 출금을 요청하면 출금 작업을 중단시키고， 적절한
경고를 사용자에게 보내야 한다.


이런 기능을 담은 메소드를 설계하는 방법이 두 가지 있다.

첫 번째 방법은 정상적인 출금처리를 했을 경우와 잔고 부족이 발생했을 경우에 각
각 다른 종류의 리턴 값을 돌려주는 것이다. 리턴 값을 일종의 결과 상태를 나타내는
정보로 활용한다. 예를 들어 정상적인 출금이 처리된 경우에는 요청금액 자체를 리턴
하고， 잔고가 부족한 경우라면 O 또는 -) 같은 특별한 값을 리턴한다. 이 메소드를 호
출한 쪽은 반드시 리턴 값을 확인한다. 경우에 따라 작업 흐름이 달라져야 하기 때문이
다. 물론 이것은 시스템 오류가 아니므로 기술적으로 보면 두 가지 경우 모두 정상 흐
름이다. 하지만 이렇게 리턴 값으로 결과를 확인하고， 예외상황을 체크하면 불편한 점
도있다.

우선 예외상황에 대한 리턴 값을 명확하게 코드화하고 잘 관리하지 않으면 흔란이
생길수있다. 정상적인 처리가안됐을때 전딜히는값의 표준같은것은없다. 어떤 개
발자는 0을 생각할 수도 있고. -)이나 -999를 돌려주는 개발자도 있다. 일관된 예외상
황에서의 결과 값에 대한 정책이 완벽하게 갖춰져 있고 사전에 상수로 정의해둔 표준
코드를 사용하지 않는다면 자칫 개발자 사이의 의사소통 문제로 인해 제대로 동작하지
않을 위험이 있다. 또 한 가지 문제는 결과 값을 확인하는 조건문이 자주 등장한다는 점
이다. 이런 식으로 결과를 돌려주는 메소드를 연이어 사용하는 경우라면 if 블록이 범
벅된 코드가 이어질지 모른다. 코드는 지저분해지고 흐름을 파악하고 이해하기가 힘틀
어질것이다.

두 번째 방법은 정상적인 흐름을 따르는 묘드는 그대로 두고， 잔고 부족과 같은 예외
상황에서는 비즈니스적인 의미를 띤 예외를 던지도록 만드는 것이다. 잔고 부족인 경우
라면 InsufficientBalanceException 등을 던진다. 예외상황을 처 리하는 catch 블록을
메소드 호출 직후에 둘 펼요는 없다. 정상적인 흐름을 따르지만 예외가 발생할 수 있는
코드를 try 블록 안에 깔끔하게 정리해두고 예외상황11 대한 처리는 catch 블록에 모아
둘 수 있기 때문에 묘드를 이해하기도 편하다. 번거로운 if 문을 남발하지 않아도 된다.

이때 사용하는 예외는 의도적으로 체크 예외로 만든다. 그래서 개발자가 잊지 않고
잔고 부족처럼 지주 발생 가능한 예외상횡에 대한 로직을 구현하도록 강제해주는 게 좋
다. 무책임하게 throws Exception을 습관적으로 달아놓은 경우라면 이마저도 놓칠 가
능성이 있긴 하지만， 기본적으로 런타임 예외로 만들어두는 것보다는 상대적으로 안전
하다.

리스트 4-)5는 예금을 인출해서 처리하는 코드를 정상 흐름으로 만들어두고， 잔
고 부족을 애플리케이션 예외로 만들어 처리하도록 만든 코드다
. 애플라케이션 예외인
InsufficientBalanceException을 만들 때는 예외상황에 대한 상세한 정보를 담고 있

4장-예외 295


도록 설계할 펼요가 었다. 잔고가 부족한 경우라면 현재 인출 기능한 최대 금액은 얼마
인지를 확인해서 예외 정보에 넣어준다면 좋을 것이다.

리스트 4-15 애풀리케이션 예외룰 사용한 코드

try {
BigDecimal balance =account .withdraw(amount);

// 정상적인 처리 결과를 출력하도록 진행

catch(InsufficientBalanceException e) { // 체크 예외
// InsufficientBalanceException
어| 담긴 인출 가능한 잔고금액 정보를 가져옴
BigDecimal availFunds = e.getAvailFunds();

// 잔고 부족 안내 메시지를 준비하고 이를 출력하도록 진행

4.1.5 SQLException은 어떻게 됐나?
지금까지 다룬 예외처리에 대한 내용은 JdbcTemplate을 적용하는 중에 throws
SQLException 선언이 왜 사라졌는가를. 설명하는 데 필요한 것이었다. 스프링의 예외처
리 전략과 원칙을 알고 있어야 하기 때문이다. 지금까지 살펴본 예외처리에 관한 내용
을 바탕으로，
DAO에 존재하는 SQLException에 대해 생각해보자.
먼저 생각해볼 사항은 SQLException은 과연 복구가 기능한 예외인가이다.
99%의
SQLException은 코드 레벨에서는 복구할 방법이 없다. 프로그램의 오류 또는 개발자의
부주의 때문에 발생하는 경우이거나 통제할 수 없는 외부상황 때문에 발생히는 것이
다. 예를 들어 SQL 문법이 틀렸거나， 제약조건을 위반했거나， DB 서벼가 다운됐다거
나， 네트워크가 불안정하거나， DB 커넥션 풀이 꽉 차서 DB 커넥션을 가져올 수 없는
경우등이다.
시스뱀의 예외라면 당연히 애플리케이션 레벨에서 복구할 방법이 없다. 관리자나 개
발자에게 빨리 예외가 발생했다는 사실이 알려지도록 전달하는 방법밖에는 없다. 마찬
가지로 애플라케이션 코드의 버그나 미처 다루지 않았던 범위를 벗어난 값 때문에 발생
한 예외도 역시 복구할 방법이 없다. INSERT 문에 넣을 따라미터 값을 미리 체크하지 않
아서 발생하는 SQLException을 어떻게 복구할 것인가? 입력 단계에서 검증을 강화해야
한다는 사실을 개발자가 빨리 인식할 수 있도록 발생한 예외를 빨리 전달하는 것 외에
는할수있는게없다.


앞에서 잠깐 살펴본 ID 중복 문제를 시행착오 기법으로 확인히는 조금 무식한 접근
방법 정도라면 모를까， 대부분의 SQLException은 복구가 불가능하다. 더군다나 DAO
밖에서 SQLException을 다룰 수 있는 가능성은 거의 없다. 따라서 예외처리 전략을 적
용해야 한다. 필요도 없는 기계적인 throws 선언이 등장하도록 방치하지 말고 가능한
한 빨리 언체크/런타임 예외로 전환해줘야 한다.

스프링의 JdbcTemplate은 바로 이 예외처리 전략을 따르고 있다. JdbcTemplate 뱀플
릿과 콜백 안에서 발생히는 모든 SQLException을 런타임 예외인 DataAccessException
으로 포장해서 던져준다. 따라서 JdbcTemplate을 사용히는 UserDao 메소드에선 쪽 멸요
한 경우에만 런타임 예외인 DataAccessException을 잡아서 처리하면 되고 그 외의 경우
에는무시해도된다. 그래서 DAO 메소드에서 SQLException
이 모두사라진 것이다.

JdbcTemplate
의 update(). queryForlnt(). query() 메소드 선언을 잘 살펴보면
다음과 같이 모두 throws DataAccessException
이라고 되어 있음을 발견할 수 있다.
throws로 선언되어 있긴 하지만 DataAccessException이 런타임 예외이므로 update()
를 사용히는 메소드에서 이를 잡거나 다시 던질 의무는 없다.

public int update(final String sql) throws DataAccessException { .. . }

그 밖에도 스프링의 API 메소드에 정의되어 있는 대부분의 예외는 런타임 예외다.
따라서 발생 가능한 예외가 있다고 하더라도 이를 처리하도록 강제하지 않는다.

[후2 며l오| 전환 •

예외를 다른 것으로 바꿔서 던지는 예외 전환의 목적은 두 가지라고 설명했다. 하나는
앞에서 적용해본 것처럼 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws를
줄여주는 것이고， 다른 하나는 로우레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바
꿔서 던져주는것이다.

스프링의 JdbcTemplate이 던지는 DataAccessException은 일단 런타임 예외로
SQLException을 포장해주는 역할을 한다. 그래서 대부분 복구가 불가능한 예외인
SQLException
에 대해 애플리케이션 레벨에서는 신경 쓰지 않도록 해주는 것이다. 또한
DataAccessException은 SQLException
에 담긴 다루기 힘든 상세한 예외정보를 의미 있
고 일관성 있는 예외로 전환해서 추상화해주려는 용도로 쓰이기도 한다.

4장-예외 297


4.2.1 JDBC의 한계
JDBC는 자바 표준 JDK에서도 가장 많이 사용되는 기능 중의 하나다. DB를 이용해 데
이터를 저장하고， 펼요한 정보를 조회하는 기능은 대부분의 프로그램에서 필요하기 때
문이다. 만약 DB별로 다른 API를 제공하고 이를 시용해야 한다고 상%빼보자. DB가
바뀔 때마다 DAO 코드도 모두 바뀔 것이고， 제각각 다른 APl 시용법을 익혀야 할 태
니 상상만 해도 끔찍하다.
JDBC는 자바를 이용해 DB
에 접근히는 방법을 추상화된 API 형태로 정의해놓고，
각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해준다. 내부 구현
은 DB마다 다르겠지만 JDBC의 Connection. Statement. Resul tSet 등의 표준 인터페
이스를 통해 그 기능을 제공해주기 때문에 자바 개발자들은 표준화된 JDBC
의 API
에
만 익숙해지면 DB
의 종류에 상관없이 일관된 방법으로 프로그램을 개발할 수 있다. 인
터페이스를 사용하는 객체지향 프로그래밍 방법의 장점을 잘 경험할 수 있는 것이 바로
이 JDBC
다.
하지만 DB 종류에 상관없이 사용할 수 있는 데이터 액세스 코드를 작성하는 일은 쉽
지 않다. 표준화된 JDBC API가 DB 프로그램 개발 방법을 학습하는 부담은 확실히 줄
여주지만 DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 보장해주지는 못한
다. 현실적으로 DB를 자유롭게 바꾸어 사용할 수 있는 DB 프로그램을 작성히는 데는
두가지 걸림돌이 있다.

비표준
SQL
첫째 문제는 JDBC 코드에서 사용히는 SQL이다.SQL은 어느 정도 표준화된 언어이고
몇 가지 표준 규약이 있긴 하지만 대부분의 DB는 표준을 따르지 않는 비표준 문법과
기능도 제공한다. 이런 비표준 특정 DB 전용 문법은 매우 폭넓게 사용되고 있다. 해당
DB
의 특별한 기능을 사용하거나 최적화된 SQL을 만들 때 유용하기 때문이다.
대용량 데이터를 처리하는 경우 성능을 향상시키기 위해 최적화 기법을 SQL에 적용
하거나， 웹 화면의 페이지 처리를 위해 가져오는 로우의 시작 위치와 개수를 지정하거
나， 쿼리에 조건을포함시킨다거나， 특별한기능을제공하는함수를
SQL에 사용하려면
대부분 비표준 SQL 문장이 만들어진다. 이렇게 작성된 비표준 SQL은 결국 DAO 코드
에 들어가고， 해당 DAO는 특정 DB
에 대해 종속적인 코드가 되고 만다. 다른 DB로 변
경하려면 DAO에 담긴 SQL을 적지 않게 수정해야 한다. 보통은 DB가 지주 변경되지
도 않고， 사용하는 DB
에 최적화하는 것이 중요하므로 비표준 SQL을 거리낌없이 사용


한다. 하지만 DB
의 변경 가능성을 고려해서 유연하게 만들어야 한다면 SQL은 제법 큰
걸림돌이된다.

이 문제의 해결책을 생각해보면， 호환 가능한 표준 SQL만 사용하는 방법과. DB
별
로 별도의 DAO를 만들거나 SQL을 외부에 독립시걱서 DB
에 따라 변경해 사용하는 방
법이 있다. 표준 SQL만을 사용할 경우， 당징벼l 웹 프로그램에서 자주 필요로 하는 페이
정 쿼리에서부터 문제가 된다. 따라서 표준 SQL만 사용히는 방법은 간단한 예제 프로
그램이라면 모를까 그다지 현실성이 없다. 결국 사용할 수 있는 방법은 DAO를 DB
별
로 만들어 사용하거나 SQL을 외부에서 독립시켜서 바꿔 쓸 수 있게 하는 것이다. 스프
링의 DI를 적용하기 좋은 이런 방법들은 7장에서 직접 시도해보겠다.

호환성 없는 SQLException의 DB 에러정보
두 번째 문제는 바로 SQLException
이다. DB를 사용하다가 발생할 수 있는 예외의 원인
은 다0.1하다.SQL의 문법 오류도 있고. DB 커넥션을 가져오지 못했을 수도 있으며， 테
이블이나 펼드가 존재하지 않거나， 키가 중복되거나 다양한 제약조건을 위배하는 시도
를 한 경우， 데드락에 걸렸거나 락을 얻지 못했을 경우 등 수백여 가지에 이른다.
문제는 DB마다 SQL'il 다른 것이 아니라 에러의 종류와 원인도 제각각이라는 점이
다. 그래서 JDBC는 데이터 처리 중에 발생하는 다0.1한 예외를 그냥 SQLException 하
나에 모두 담아버린다. JDBC API는 이 SQLExcePtion 한 가지만 던지도록 설계되어 있
다. 예외가 발생한 원인은 SQLException 안에 담긴 에러 묘드와 SQL 상태정보를 참조
해봐.o
þ 한다. 그런데 SQLException
의 getErrorCode()
로 가져올 수 있는 DB 에러 묘드
는 DB
별로 모두 다르다. DB 벤더가 정의한 고유한 에러 묘드를 사용하기 때문이다.

앞에서 만든 add() 메소드에선 새로운 사용지를 등록하다가 키가 중복돼서 예외가
발생하는 경우를 확인하기 위해 다음과 같은 방법을 시용했다.

if (e.getErrorCode() == MysQIErrorNumbers.ER_DUP_ENTRY) ( .

SQLException
의 에러 묘드를 이용해 중복된 값의 등록이 원인인지 확인하는 것이다.
그런데 여기서 사용한 에러 묘드는 MySQL 전용 코드일 뿐이다. DB가 MySQL에서
오라클이나 SQLServer로 바뀐다면 에러 묘드도 달라지므로 이 코드는 기대한 대로 동
작하지못할것이다.

그래서 SQLException은 예외가 발생했을 때의 DB 상태를 담은 SQL 상태정보를 부
가적으로 제공한다. getSQLState() 메소드로 예외상뺑 대한 상태정보를 가져올 수
있다. 이 상태정보는 DB별로 달라지는 에러 묘드를 대신할 수 있도록. Open Group의

4장-예외 299


XOPEN SQL 스펙에 정의된 SQL 상태 코드를 따르도록 되어 었다. XOPEN SQL 상
태 코드 외에도 JDBC 3.0에서는 SQL 99의 관례를， JDBC 4.0에서는 SQL2003의 관

례를 따르도록 정의되어 있기는 하다.

예를 들면 통신장애로 DB 연결에 실패했을 경우에는 08S01 , 테이블이 존재하지 않

는경우에는
42S02와같은식으로
DB
독립적인표준상태코드가정의되어 있다. 앞의

두 자리는 클래스 코드， 뒤의 세 자리는 서브클래스 코드로 분류되어 있기도 하다.

SQLException
이 이러한 상태 묘드를 제공하는 이유는 DB
에 독립적인 에러정보를

얻기 위해서다. 그런데 문제는 DB
의 JDBC 드라이버에서 SQLException을 담을 상태

코드를 정확하게 만들어주지 않는다는 점이다. 어떤 경우에는 이에 표준 코드와는 상

관없는 엉뚱한 값이 들어 있기도 하고， 어떤 DB는 클래스 코드까지는 바로 오지만， 서

브클래스 코드는 일체 무시하고 값을 다 0으로 넣는다거나 히는 식이다. 결과적으로 이

SQL 상태 코드를 믿고 결과를 파악하도록 코드를 작성하는 것은 위험하다.

결국 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 묘드를 가진

SQLException만으로 DB에 독립적인 유연한 코드를 작성하는 건 불가능에 기깝다.

4.2.2 DB 에러 코드 매핑을 통한 전환
DB 종류가 바뀌더라도 DAO를 수정하지 않으려면 이 두 가지 문제를 해결해야 한
다. SQL과 관련된 부분은 뒤에서 다루기로 하고， 여기서는 SQLException
의 비표준
에러 코드와 SQL 상태정보에 대한 해결책을 알아보자.

SQLException
에 담긴 SQL 상태 코드는 신뢰할 만한 게 아니므로 더 이상 고려하지
않겠다. 차라리 DB 업체별로 만들어 유지해오고 있는 DB 전용 에러 묘드가 더 정확한
정보라고 볼 수 있다. SQL 상태 묘드는 JDBC 드라이버를 만들 때 들어가는 것이므로
같은 DB라고 하더라도 드라이버를 만들 때마다 달라지기도 하지만，
DB 에러 코드는
DB에서 직접 제공해주는 것이니 벼전이 올라가더라도 어느 정도 일관성이 유지된다.

해결 방법은 DB
별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해
주는 기능을 만드는 것이다. 커 값이 중복돼서 중복 오류가 발생하는 경우에 MySQL
이라면 1062, 오리클이라면 I，
DB2
라면 -803
이라는 에러 코드를 받게 된다. 이
런 에러 코드 값을 확인할 수 었다면， 키 중복 때문에 발생하는 SQLException을
DuplicateKeyException이라는 의미가 분명히 드러나는 예외로 전환할 수 있다. DB 종
류에 상관없이 동일한 상황11서 일관된 예외를 전달받을 수 있다면 효과적인 대응이 가
능하다.


스프링은 DataAccessException이라는 SQLException을 대체할 수 있는 런타임 예외
를 정의하고 있을 뿐 아니라 DataAccessException
의 서브클래스로 세분화된 예외 클래
스들을 정의하고 있다. SQL 문법 때문에 발생히는 에러라면 BadSqlGrammarException
을. DB 커넥션을 가져오지 못했을 때는 DataAccessResourceFailureException
을， 데이터의 제약조건을 위배했거나 일관성을 지키지 않는 작업을 수행했을 때는
DatalntegrityViolationException을， 그중에서도 중복 커 때문에 발생한 경우는
DuplicatedKeyException을 사용할 수 있다. 이 외에도 데이터 액세스 작업 중에 발생
할 수 있는 예외상황을 수십 가지 예외로 분류하고 이를 추상화해 정의한 다O<f한 예외
클래스를제공한다.

문제는 DB마다 에러 코드가 제각각이라는 점이다. DAO 메소드나 JdbcTemplate
등의 코드에서 일일이 DB
별로 에러 코드의 종류를 확인히는 작업을 수행하는 건 부담
이 너무 크다. 대신 스프링은 DB
별 에러 코드를 분류해서 스프링이 정의한 예외 클래스
와 매핑해놓은 에러 코드 매핑정보 테이블을 만들어두고 이를 이용한다. 예를 들면 오
리클용으로 리스트 4-16과 같은 내용의 에러 코드 정보가 매핑 파일에 담겨 있다.

리스트 4-16 오라클 에러 코드 매핑 파일


<bean id="Orac1e" class="org.springframework.jdbc.support.SQLErrorCodes")
<property name="badSqlGrammarCodes ") ~ 예외 클래스 종류

<value)9ÐÐ ,9Ð3 ,9Ð4 ,917 ,936 ,942 ,17ÐÐ6</value> •
</property) 매잉되는 DB 에러 코드 에러 코드가 세분화된
<property name="invalidResultSetAccessCodes") 경우에는 여러 개가 들어가기도 한다

<value>17ÐÐ3</value>
</property>
(property name="duplicateKeyCodes">

<value>1</value>
</property>
<property name="datalntegrityViolationCodes")

<value>14ÐÐ ,1722 ,2291 ,2292</value>
</property>
<property n1념삐
딘.닝
야
urceFailujπreCodes"

떠arme=
dataAc
cessRes
Ol애
따


<v뻐리a
lue>17ÐÐ2ι，
17447</value)

</property>

JdbcTemplate은 SQLException을 단지 런타임 예외인 DataAccessException
으로 포장하는 것이 아니라 DB의 에러 코드를 DataAccessException 계충구조

4장-예외 301


의 클래스 중 하나로 매핑해준다. 전환되는 JdbcTemplate에서 던지는 예외는 모두
DataAccessException
의 서브클래스 타입이다. 드라이버나 DB 메타정보를 참고해서
DB 종류를 확인하고 DB
별로 미리 준비된 리스트 4-16과 같은 매핑정보를 참고해서
적절한 예외 클래스를 선택하기 때문에 DB가 달라져도 같은 종류의 에러라면 동일한
예외를 받을 수 있는 것이다.

중복 키 에러를 따로 분류해서 예외처리를 해줬던 리스트 4-9
의 add( ) 메소드
를 스프링의 JdbcTemplate을 시용하도록 바꾸면 리스트 4-17과 같이 간단해진다.
JdbcTemplate은 체크 예외인 SQLException을 런타임 예외인 DataAccessException
계층구조의 예외로 포장해주기 때문에 add( ) 메소드에는 예외 포장을 위한 코드
가 따로 필요 없다. 또.DB
의 종류와 상관없이 중복 키로 인해 발생하는 에러는
DataAccessException
의 서브클래스인 DuplicateKeyException으로 매핑돼서 던
져진다. add() 메소드를 사용하는 쪽에서 중복 키 상황에 대한 대응이 펼요한 경우
에 참고할 수 있도록 DuplicateKeyException을 메소드 선언에 넣어주면 편리하다.
DuplicateKeyException은 리스트 4-9의 경우와 달리 DB를 변경하더라도 동일한 예
외가 던져지는 것이 보장된다. JdbcTemplate 안에서 DB
별로 미리 준비된 에러 코드와
비교해서 적절한 예외를 던져주기 때문이다.

리스트 4-17 JdbcTemplateOI 제공하는 예외 전환 기능을 이용하는 add() 메소드

public void add() throws DuplicateKeyException {

// JdbcTemplate을 이용해 User를 add 하는 코드

JdbcTemplate을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 거의 신경 쓰지
않아도된다.

그런데 중복커 에러가 발생했을 때 애플라케이션에서 직접 정의한 예외를 발생시
키고 싶을 수 있다. 개발 정책 때문일 수도 있고， 스프링 DuplicateKeyException
의 런
타임 예외이기 때문에 예외처리를 강제하지 않는 것이 불안해서 그럴 수도 있다. 아무
튼 애플리케이션 레벨의 체크 예외인 DuplicateUserldException을 던지게 하고 싶다
면 리스트 4-18과 같이 스프링의 DuplicateKeyException 예외를 전환해주는 코드를
DAO 안에 넣으면 된다.


리스트 4-18 중복 키 예외의 전환

public void add() throws DuplicateUserldException {
try ( L. oH툴리케01션 레웰의 체크 예외
// jdbcTemplate을 이용해 User를 add 하는 코드

catch(DuplicateKeyException e) (

// 로그를 남기는 등의 팔요한 작업
throw new DuplicateUserldException(e); ~ 예외를 전환할 때는 원인이 되는 예외훌

중접하는것이좋다

lDK 1.6
에 포함된 JDBC 4.0부터는 기존에 lDBC
의 단일 예외 클래스였던
SQLException을 스프링의 DataAccessException과 비슷한 방식으로 좀 더 세분화해서
정의하고 있다. SQL 문법 오류인 경우는 SQLSyntaxErrorException , 제약조건 위반인
경우는 SQLlntegrityConstraintViolationException과 같은 식으로 세분화된 예외를
시용하도록 만들었다. 이 규약을 따르는 드라이버의 경우 좀 더 상세한 예외를 만들어
서전달할수있게됐다.

하지만 SQLExecption
의 서브클래스이므로 여전히 체크 예외라는 점과 그 예외를 세
분화히는 기준이 SQL 상태정보를 이용한다는 점에서 여전히 문제점이 있다. 시간이 더
많이 지나고 10K 6.0 이상을 사용하며， 10BC 4.0의 스펙을 충실히 따라 정확한 상태
정보를 가지고 일관성 있는 예외를 만들어주는 10BC 드라이버가 충분히 보급된다면
모르겠지만， 아직은 스프링의 에러 코드 매핑을 통한 DataAccessException 방식을 사
용하는 것이 이상적이다.

4.2.3 DAO 인터페이스와 DataAccessException 계층구조
DataAccessException은 10BC의 SQLException을 전환히는 용도로만 만들어진 건 아
니다.1OBC 외의 자바 데이터 액세스 기술에서 발생하는 예외에도 적용된다. 자바에
는 10BC 외에도 데이터 액세스를 위한 표준 기술이 존재한다.100나 lPA는 10BC와
마찬가지로 자바의 표준 퍼시스턴스 기술이지만 10BC와는 성격과 시용 방법이 크게
다르다. 또한 오라클의 TopLink 같은 상용 제품이나 오픈소스인 하이버네이트 같은 표
준을 따르긴 하지만 독자적인 프로그래밍 모댈을 지원하는 ORM 기술도 있다.1O
BC
를 기반으로 하고， 성격도 비슷하지만 사용 방법과 API , 발생하는 예외가 다른 iBatis
도있다.

4장-예외 303



DataAccessException은 의미가 같은 예외라면 데이터 액세스 기술의 종류와 상관없
이 일관된 예외가 발생하도록 만들어준다. 데이터 액세스 기술에 독립적인 추상화된 예
외를 제공히는 것이다. 스프링이 왜 이렇게 DataAccessException 계충구조를 이용해
기술에 독립적인 예외를 정의하고 사용하게 하는지 생각해보자.

DAO 인터페이스와 구현의 분리
DAO를 굳이 따로 만들어서 시용하는 이유는 무엇일까? 가장 중요한 이유는 데이터
액세스 로직을 담은 묘드를 성격이 다른 코드에서 분리해놓기 위해서다. 또한 분리된
DAO는 전략 패턴을 적용해 구현 방법을 변경해서 사용할 수 있게 만들기 위해서이기
도 하다. DAO를 사용하는 쪽에서는 DAO가 내부에서 어떤 데이터 액세스 기술을 사
용하는지 신경 쓰지 않아도 된다. User와 같은 자바빈으로 만들어진， 특정 기술에 독립
적인 단순한오브젝트를주고받으면서 데이터 액세스 기능을시용하기만하면 된다. 그
런 면에서 DAO는 인터페이스를 λF용해 구체적인 클래스 정보와 구현 방법을 감추고，
DI를 통해 제공되도록 만드는 것이 바람직하다.
그런데 DAO의 사용 기술과 구현 코드는 전략 패턴과 DI를 통해서 DAO를 사용하
는 클라이언트에게 감출 수 있지만， 메소드 선언에 나타나는 예외정보가 문제가 될 수
있다. UserDao의 인터페이스를 분리해서 기술에 독립적인 인터페이스로 만들려면 리스
트
4-19와같이 정의해야한다.

리스트 4-19 기술에 독립적인 이상적인 DAO 인터페이스

public interface UserDao (
public void add(User user); --률 이렇게 선언하는 것이 과언 가능힐끼?

하지만 리스트 4-19의 메소드 선언은 사용할 수 없다. DAO에서 사용히는 데이터
액세스 기술의 API가 예외를 던지기 때문이다. 만약 JDBC API를 사용하는 UserDao
구현 클래스의 add() 메소드라면 SQLException을 던질 것이다. 인터페이스의 메소드
선언에는 없는 예외를 구현 클래스 메소드의 throws
에 넣을 수는 없다. 따라서 인터페
이스 메소드도 디음과 같이 선언돼야 한다.

public void add(User user) throws SQLException;

이렇게 정의한 인터페이스는 JDBC가 아닌 데이터 액세스 기술로 DAO 구현을 전


환하면 사용할 수 없다. 데이터 액세스 기술의 API는 자신만의 독자적인 예외를 던지기
때문에 다음과 같이 인터페이스 메소드를 바꿔주변 모르겠지만， SQLException을 던지

도록 선언한 인터페이스 메소드는 시용할 수 없다.

public void add(User user) throws PersistentException; 11 JPA
public void add(User user) throws HibernateException; 11 Hibernate
public void add(User user) throws JdoException; 11 JDO

결국 인터페이스로 메소드의 구현은 추상화했지만 구현 기술마다 던지는 예외가 다
르기 때문에 메소드의 선언이 달라진다는 문제가 발생한다. DAO 인터페이스를 기술에
완전히 독립적으로 만들려면 예외가 일치하지 않는 문제도 해결해야 한다.

가장 단순한 해결 방법은 모든 예외를 다 받아주는 throws Exception으로 선언하는
것이다.

public void add(User user) throws Exception;

간단하긴 하지만 무책임한 선언이다.

다행히도 JDBC
보다는 늦게 등장한 JDO , Hibernate , JPA 등의 기술은
SQLException 같은 체크 예외 대신 런타임 예외를 사용한다. 따라서 throws
에 선언을
해주지 않아도 된다. 남은 것은 SQLException을 던지는 JDBC API를 직접 사용하는
DAO뿐인데， 이 경우에는 DAO 메소드 내에서 런타임 예외로 포장해서 던져줄 수 있
다. JDBC를 이용한 DAO에서 모든 SQLException을 런타임 예외로 포장해주기만 한다
면 DAO
의 메소드는 처음 의도했던 대로 다음과 같이 선언해도 된다.

public void add(User user);

이제 DAO에서 사용하는 기술에 완전히 독립적인 인터페이스 선언이 가능해졌다.

하지만 이것만으로 충분할까?

대부분의 데이터 액세스 예외는 애플리케이션에서는 복구 불가능하거나 할 필요가
없는 것이다. 그렇다고 모든 예외를 다 무시해야 하는 건 아니다. 중복 키 에러처럼 비
즈니스 로직에서 의미 있게 처리할 수 있는 예외도 있다. 애플리케이션에서는 사용하지
않더라도 시스템 레벨에서 데이터 액세스 예외를 의미 있게 분류할 필요도 있다. 문제
는 데이터 액세스 기술이 달라지면 같은 상햄서도 다른 종류의 예외가 던져진다는 점
이다. 중복 키 에러가 발생했을 때 JDBC로 만든 DAO에서는 SQLException이， JPA에

서는 PersistenceException
이， 하이버네이트에서는 HibernateException
이 던져진다.

4장-예외 305


따라서 DAO를 사용하는 클라이언트 입장에서는 DAO의 사용 기술에 따라서 예외 처
리 방법이 달라져야한다. 결국클라이언트가
DAO의 기술에 의존적이 될 수밖에 없다.

단지 인터페이스로 추상화하고 일부 기술에서 발생하는 체크 예외를 런타임 예외로
전환하는 것만으론 불충분하다.

데이터 액서|스 예외 추상화와 DataAccessException 계층구조
그래서 스프링은 자바의 다양한 데이터 액세스 기술을 사용할 때 발생하는 예외들을 추
상화해서 DataAccessException 계층구조 안에 정리해놓았다.
앞에서 살펴본 것처럼 스프링의 JdbcTemplate은 SQLException
의 에러 묘드를 DB
별로 매핑해서 그에 해당하는 의미 있는 DataAccessException
의 서브클래스 중 하
나로 전환해서 던져준다. 그렇다고 DataAccessException 클래스들이 단지 JDBC
의
SQLException을 전환하는 용도로만 쓰이는 건 아니다.

DataAccessException은 자바의 주요 데이터 액세스 기술에서 발생할 수 있는 대부
분의 예외를 추상화하고 있다. 데이터 액세스 기술에 상관없이 공통적인 예외도 있지만
일부 기술에서만 발생하는 예외도 있다. JPA , 하이버네이트처럼 ORM에서는 발생하지
만 JDBC에는 없는 예외가 있다. 스프링의 DataAccessException은 이런 일부 기술에

서만 공통적으로 나타나는 예외를 포함해서 데이터 액세스 기술에서 발생 가능한 대부

분의 예외를 계층구조로 분류해놓았다.

예를 들어 JDBC, JDO, JPA, 하이벼네이트에 상관없이 데이터 액세스 기술을 부정
확하게 사용했을 때는 InvalidDataAccessResourceUsageException 예외가 던져진다. 이
를 다시 구체적으로 세분화하면 JDBC에서 발생할 수 있는 BadSqlGrammarException
이나， 하이버네이트에서 발생하는 HibernateQueryException 또는 잘못된 타입을 사
용하려고 했을 때 발생하는 TypeMismatchDataAccessException 등으로 구분된다.
InvalidDataAccessResourceUsageException 예외는 거의 대부분 프로그램을 잘못
작성해서 발생하는 오류다. 스프링이 기술의 종류에 상관없이 이런 성격의 예외를
InvalidDataAccessResourceUsageException 타입의 예외로 던져주므로 시스템 레벨의
예외처리 작업을통해 개발자에게 빠르게 통보해주도록만들수 있다.

또는 JDO, JPA , 하이버네이트처럼 오브젝트/엔티티 단위로 정보를 업데이트하는
경우에는 낙관적인 락킹。이imistic locking
이 발생할 수 있다. 이 닥관적인 락킹은 같은 정보

를 두 명 이상의 사용자가 동시에 조회하고 순차적으로 업데이트를 할 때， 뒤늦게 업데

이트한 것이 먼저 업데이트한 것을 덮어쓰지 않도록 막아주는 데 쓸 수 있는 편리한 기


능이다. 이런 예외들은 사용자에게 적절한 안내 메시지를 보여주고， 다시 시도할 수 있
도록 해줘야 한다. 하지만 역시 JDO, JPA, 하이버네이트마다 다른 종류의 닥관적인 락
킹 예외를 발생시킨다. 그런데 스프링의 예외 전환 방법을 적용하면 기술에 상관없이
DataAccessException의 서브클래스인 ObjectOptimisticLockingFailureException으
로통일시킬수있다.

ORM 기술이 아니지만 JDBC 등을 이용해 직접 낙관적인 락킹 기능을 구현
했다고 해보자. 이때는 그림 4-2
처럼 ObjectOptimisticLockingFailureException
의 슈퍼클래
스
인 OptimisticLockingFailureException
을 상속해서
JdbcOptimisticLockingFailureException
을 정의해 사용할 수도 있다. 기술
에 상관없이 낙관적인 락킹이 발생했을 때 일관된 방식으로 예외처리를 해주려면
OptimisticLockingFailureException을 잡도록 만들면 된다. 어떤 데이터 액세스 기술
을 사용했는지에 상관없이 닥관적인 락킹을 처리히는 묘드를 만들어낼 수 있다.


OptimisticLockingFailureExceptι。nOb j ectOpt imi 5 t icLockingE" a i 1 ureExcept ion JdbCOptimiaticLockingFailureException
Hibe r na t eOpt imi 5 t i cLoc ki ng F a i 1 u reExcept i on JdoOpt imi 5 t icLocking Fa i 1 ureExcept ion
그림 4-2 Jdbc를 이용한 닥관적인 락킹 예외 클래스의 적용

DataAccessException 계층구조에는 템플릿 메소드나 DAO 메소드에서 직접 활용
할 수 있는 예외도 정의되어 있다. JdbcTemplate의 queryForObject() 메소드는 한 개
의 로우만 돌려주는 쿼리에 사용하도록 되어 있다. 쿼리 실행 결과가 하나 이상의 로
우를 가져오면， 템플릿 메소드의 사용 방법에 문제가 있거나 SQL을 잘못 작성한 것
이다. 이런 경우에 JDBC
에서는 예외가 발생하지 않는다. 하지만 JdbcTemplate
에
서 볼 때는 기대한 결과가 나오지 않은 예외상황이다. 이런 경우에 사용할 수 있도
록 DataAccessException 계층구조에는 IncorrectResultSizeDataAccessException
이 정의되어 있다. queryForObject()
에서는 좀 더 자세한 정보를 담은 서브클래스인
EmptyResultDataAccessException을 발생시 킨다.

4장-예외 307


그림 4-3은 스프링 DataAccessException 계층구조의 일부다. 스프링의 데이터 액
세스 전략이나 DataAccessE
xception
의 예외 시용법은 11
장에서 더 자세히 살펴보겠다.

~ e

AuntimeException
eException

liHil‘ NestedAuntim
Iii QAData Ac cessException e CustomErrorCodeE >cception
~ .Ci" Non TransientDataAccessException e CIBiíilnupFail
ureDataAc
cess
E
xc
e띠
on

liiI (J DatalntegrityVlolatlonException e DupllcateKeyException
‘~
-e OataAetriev히
Fa
l1
ureE)(ception

(i) IncorrectAesultSetColumnCountExc8ption
!i. e IncorrectAesultSlzeOata Þccess Exception e EmptyAesultData Ac cessExce ptlon e LobAetrievalFailureE xcepti on

!i. e ObjectAetrievalFallureExc eption e HibernateObjectAetrievalFailureE xceptlon
(J JdoObjectAetrievalFai1ureException e JpaObjectAetrievalFallureE xc eption

e DataSou rceLookupFailureExc8ption
ii e InvalidOa어Ac
cess
Ap
iUsage
E
xception

(j JdoUsageException
cil S，
I이Tl
IFeature Notim pl ementedE )( ceptJ on

~ e InvalidOata AccessAesourceUsageExceptlon e 8adSQIGrammarExceptlon
(j CciOperationNotSuppor1edException e HibemateOueryException

~ . e IncorrectUpdateSemanticsOataAccessE)(ception
cil JdbcUpdale뼈8디edlncorrectNumberO머ows
Exc
eption e InvalldAesuttSetAccessE)(ception

-e InvalldResu ttSetAccessException e AecordTypeNotSuppor1edException e TypeMlsmatchOata Ac cessException

흩 (j NonTranslentOataAccessAesourceExceptlon
1iiI. e Oata Ac cessResourceFallureException
• (J CannotCreateRecordExceptlon
(j CannotGetCciConnectionException
!.~ (j CannotGeUdbcConnectionE)(ception

•

a JdoResourceFailureException
(i PermisslonDenledDataAcc:essExc:eption
Ii e A UncategorizedDataAccessException
ci Aec:overableOataAccessExceptlon
Ii e'" TransientDataAccessExceptlon
6iI. e ConcurrencyFailureE)(ception
~ . e OPtimisticloc“ngFailureException
Ii/ cil ObJectOptlml해clocldngFa
llureExceptlon e HibernateOptimisti
c:
locldngFallureExce이on

‘ GÞ JdoOptimisticLocldngFailureException e JpaOptimisticlocldngFallureE)(ception

그링 4-3 DataAccessException 계층구조(일부)

JdbcTempate과 같이 스프링의 데이터 액세스 지원 기술을 이용해 DAO를 만들면 사
용 기술에 독립적인 일관성 있는 예외를 던질 수 있다. 결국 인터페이스 사용， 런타임
예외 전환과 함께 DataAccessException 예외 추상화를 적용하면 데이터 액세스 기술과
구현 방법에 독립적인 이상적인 DAO를 만들 수가 있다.

4.2.4 기술에 독립적인 UserDao 만들기
인터페이스적용
지금까지 만들어서 써왔던 UserDao 클래스를 이제 인터페이스와 구현으로 분리해보자.
인터페이스와구현클래스의 이름을정하는방법은여러 가지가있다. 인터페이스를구


분하기 위해 인터페이스 이름 앞에는 I
라는 접두어를 붙이는 방법도 있고， 인터페이
스
이름은 가장 단순하게 하고 구현 클래스는 각각의 특정을 따르는 이름을 붙이는 경우도
있다. 여기서는후자의 방법을시용해보자. 시용자 처리 DAO의 이름은
UserDao라하
고， JDBC를 이용해 구현한 클래스의 이름을 UserDaoJdbc
라고 하자. 나중에 lPA나 하
이버네이트로 구현한다면 그때는 UserDaoJpa, UserDaoHibernate라고 이름을 붙일 수
있다.

UserDao 인터페이스에는 기존 UserDao 클래스에서 DAO
의 기능을 사용하려는
클라이언트들이 필요한 것만 추출해내면 된다. 리스트 4-20은 인터페이스로 만든
UserDao
다.

리스트 4-20U똥rD∞ 인터페이스

public interface UserDao (
void add(User user);
User get(String id);
List(U ser> getAll();
void deleteAll();
int getCount();


public 접근자를 가진 메소드이긴 하지만 UserDao의 setDataSource() 메소드는 인
터페이스에 추가하면 안 된다는 사실에 주의하자. setDataSource() 메소드는 UserDao
의 구현 방법에 따라 변경될 수 있는 메소드이고 UserDao를 사용히는 클라이언트가 알
고 있을 필요도 없다. 따라서 setDataSource()
는 포함시키지 않는다.

이제 기존의 UserDao 클래스는 다음과 같이 이름을 UserDaoJdbc
로 변경하고
UserDao 인터페이스를 구현하도록 implements로 선언해줘야 한다.
public class UserDaoJdbc implements UserDao {

또 한 가지 변경할 사항은 스프링 설정파일의 userDao 빈 클래스 이름이다. userDao
빈 클래스를 리스트 4-21
과 같이 바꿔준다.

리스트 4-낀 민 쿨래스 변경

<bean id="userDao" c
매gboo
k
이Jdbc"

디lass="sprin1밍
이야
.
daoα).UserDao
’"
<properπty name="dataSource" ref=“ dataSource" />
</bean>

4장-예외 309


클래스 이름 외에는 변경할 게 없다. 보통 빈의 이름은 클래스 이름이 아니라，
dataSource 빈이 그랬던 것처럼 클래스의 구현 인터페이스 이름을 따르는 경우가 일반
적이다. 그래야 니중에 구현 클래스를 바꿔도 혼란이 없기 때문이다.

테스트보완

이제 남은 것은 기존 UserDao 클래스의 태스트 묘드다. 디음과 같은 UserDao 인스턴스
변수 선언도 UserDaoJdbc로 변경해야 할까?

public class UserDaoTest {
@Autowired
private UserDao dao; 11 UserDaoldbc로 변경해야 하나?

굳이 그럴 필요는 없다. @Autowired는 스프링의 컨텍스트 내에서 정의된 빈 중에서

인스턴스 변수에 주입 가능한 타입의 빈을 찾아준다. UserDao는 UserDaoJdbc가 구현한
인터페이스이므로 UserDaoTest
의 dao 변수에 UserDaoJdbc 클래스로 정의된 빈을 넣는
데 아무런 문제가 없다. UserDaoJdbc 오브젝트는 UserDao 타입이기 때문이다.

경우에 따라서 의도적으로 UserDaoJdbc dao라고 선언할 수도 있다. 중요한 건 테스
트의 관심이다. 그구현 기술에 상관없이 DAO의 기능이 동작히는데만관심이 있다면，
UserDao 인터페이스로 받아서 태스트하는 편이 낫다. 나중에 다른 데이터 액세스 기술
로 DAO 빈을 변경한다고 하더라도 이 태스트는 여전히 유효하다. 반면에 특정 기술을
λ}용한 UserDao의 구현 내용에 관심을 가지고 태스트하려면 태스트에서 @Autowired로
DI 받을 때 UserDaoJdbc
나 UserDaoHibernate 같이 특정 타입을 시용해야 한다.

일단 UserDao 태스트는 DAO의 기능을 검증하는 것이 목적이지 JDBC를 이용한 구
현에 관심이 있는 게 아니다. 그러니 UserDao라는 변수 타입을 그대로 두고 스프링 빈
을 인터페이스로 가져오도록 만드는 편이 낫다.

그림 4-4는 UserDao의 인터페이스와 구현을 분리함으로써 데이터 액세스의 구체적
인 기술과 UserDao의 클라이언트 사이에 DI가 적용된 모습을 보여준다. 아직 UserDao
를 사용하는 애플리케이션 코드를 만들지는 않았지만 일단 테스트를 하나의 클라이언

트라고생끽빼도좋다.


UserDaoTest

UserDa。


~------------------------'------------------------I

U...rDaoJdbc UserDaoJpa UserDaoHiberate
setDataSource ()

그림 4-4 UserDao 인터페이스와 구현의 분리

이제 UserDaoTest
에 중복된 키를 가진 정보를 등록했을 때 어떤 예외가 발생하는지를
확인하기 위해 테스트를 하나 추가해보자. 이것은 UserDao의 로직을 테스트하기 위해
서라기보다는 스프링이 데이터 액세스 예외를 다루는 기능을 직접 확인해보기 위한 것
이니 일종의 학습 테스트다.

일반적으로 학습 태스트는 애플리케이션 코드에 대한 태스트와 분리해서 작성하는
게 좋지만 여기서는 간단히 UserDaoTest
에 넣어보겠다. 리스트 4-22와 같은 메소드를
UserDaoTest
에 추가해보자.

리스트 4-22 DataA.c용ssException에 대한 테스트


@Test(expected=DataAccessException.class)
public void duplciateKey() {
dao.deleteAll();

dao .add(user1);

dao .add(user1); -률
강제로 같은 사용자훌 두 번 등록한디
여기서 예외가 발생해야 한다

아이디가 같은 사용자를 두 번 add() 메소드로 등록하면 USER 테이블의 기본키 중
복 때문에 예외가 발생할 것이다. 이때 스프링의 DataAccessException 예외 중의 하나
가 던져져야 한다. 예외가 발생하면 성공이고 아니면 실패하게 만들어야 하므로 예외를
검증해주는 @Test(expected= .. )를 이용한다. 메소드가 끝날 때까지 예외가 발생하지
않으면 태스트는 실패하게 된다.

태스트를 실행해보면 성공이다. 성공한 것으로 보아 DataAccessException 타입의
예외가 던져졌음이 분명한데 DataAccessException
의 서브클래스일 수도 있으므로 구

체적으로 어떤 예외인지 확인해볼 필요가 있다. 이런 경우에 어떤 예외가 발생했는지
확인해보려면 태스트를 실패하게 만들면 된다.
4장여|
외 311


이번엔 expected=DataAccessException.class 부분을 빼고 태스트를 실행해보자.
예외가 발생하면 테스트는 실패하지만， 에러 메시지를 통해 어떤 예외 클래스가 던져졌
는지를 확인할 수 있다. expected 부분을 빼고 돌려보면 다음과 같은 예외가 발생했음
을알수있다.

org.springframework.dao.DuplicateKeyException: PreparedStatementCallback; SQL

[insert into users(id , name , password) values(ι7，
7)]; Duplicate entry ’ gyumee' for

key 1; nested exception is com.mysql .jdbc.exceptions.jdbc4.MySQLlntegrityConstrain

tViolationException: Duplicate entry ’ gyumee ’ for key 1

그림 4-3을 참고해보면 DuplicateKeyException은 DataAccessException의 서브
클래스로 DatalntegrityViolationException
의 한 종류임을 알 수 있다. 이 태스트의
expected 항목을 DuplicateKeyException으로 바꾸고 실행해보자. 테스트는 역시 성공
할 것이다. 좀 더 정확한 예외 발생을 확인하는 테스트가 됐다.

DataAccessException 활용 시 주의사항
이렇게 스프링을 활용하면 DB 종류나 데이터 액세스 기술에 상관없이 키 값이 중복
이 되는 상황에서는 동일한 예외가 발생하리라고 기대할 것이다. 하지만 안타깝게도
DuplicateKeyException은 아직까지는 JDBC를 이용하는 경우에만 발생한다. 데이터

액세스 기술을 하이버네이트나 JPA를 사용했을 때도 동일한 예외가 발생할 것으로 기
대하지만 실제로 다른 예외가 던져진다. 그 이유는 SQLException에 담긴 DB의 에러 코
드를 바로 해석히는 JDBC의 경우와 달리 JPA나 하이버네이트，
JDO 등에서는 각 기술
이 재정의한 예외를 가져와 스프링이 최종적으로 DataAccessException으로 변환하는

데， DB
의 에러 코드와 달리 이런 예외들은 세분화되어 있지 않기 때문이다.

예를 들어 하이벼네이트는 중복 커가 발생하는 경우에 하이벼네이트의
ConstraintViolationException을 발생시킨다. 스프령은 이를 해석해서 좀 더 포
괄적인 예외인 DatalntegrityViolationException으로 변환할 수밖에 없다. 물론
DuplicateKeyException도 DatalntegrityViolationException의 한 종류다. 따라
서 expected=DatalntegrityViolationException으로 해준다면 하이벼네이트로 만든
DAO로 바문다고 하더라도 통일한 예외를 기대할 수는 있다. 하지만 제약조건을 위반
하는 다른 상휩l서도 동일한 예외가 발생하기 때문에 DuplicateKeyException을 이용
하는 경우에 비해서는 이용가치가 떨어진다.

DataAccessException
이 기술에 상관없이 어느 정도 추상화된 공통 예외로 변환해주

긴 하지만 근본적인 한계 때문에 완벽하다고 기대할 수는 없다. 따라서 사용에 주의를


기울여야 한다. DataAccessException을 잡아서 처리하는 코드를 만들려고 한다면 미리
학습 태스트를 만들어서 실제로 전환되는 예외의 종류를 확인해둘 필요가 있다.

만약 DAO
에서 사용하는 기술의 종류와 상관없이 동일한 예외를 얻고 싶다면
DuplicatedUserldException처럼 직접 예의를 정의해두고， 각 DAO의 add() 메소드에
서 좀 더 상세한 예외 전환을 해줄 필요가 있다. 하이버네이트 예외의 경우라도 중첩된
예외로 SQLException
이 전달되기 때문에 이를 다시 스프링의 JDBC 예외 전환 클래스
의 도움을받아서 처리할수있다.

학습 태스트를 하나 더 만들어서 SQLException을 직접 해석해 DataAccessException
으로 변환하는 묘드의 사용법을 살펴보자.

스프링은 SQLException을 DataAccessException으로 전환하는 다양한 방법
을 제공한다. 가장 보편적이고 효과적인 방법은 DB 에러 코드를 이용하는 것이다.
SQLException을 코드에서 직접 전환하고 싶다면 SQLExceptionTranslator 인터페이스
를 구현한 클래스 중에서 SQLErrorCodeSQLExceptionTranslator를 사용하면 된다.

이 SQLErrorCodeSQLExceptionTranslator는 에러 묘드 변환에 펼요한 DB의 종류를
알아내기 위해 현재 연결된 DataSource를 필요로 한다. UserDaoTest
에 리스트 4-23
처
럼 DataSource 변수를 추가해서 DataSource 타입의 빈을 받아두도록 한다.

리스트 4-23 Da떠Source 빈올 주입받도록 만든 UserDaoTest


public class UserDaoTest {
@Autowired UserDao dao;
öAutowired DataSource dataSource;

리스트 4-24
는 이 DataSource
를 사용해 SQLException
에서 직접
DuplicateKeyException으로 전환하는 기능을 확인해보는 학습 태스트다.

리스트 4-24 SQLException 전환 기능의 학습 테스트

@Test

public void sqlExceptionTranslate() {
dao .deleteAll();

try {
dao.add(userl);
dao.add(userl);

catch(DuplicateKeyException ex) {

4장-예외 313


SQLException sqlEx = (SQLException)ex.QetRootCause();
SQLExceptionTranslator set =~ 코드흩 이용한
밍도x∞αion의전환

new SQLErrorCodeSQLExceptionTranslator(this.dataSource);

「용 에러 메시^I 만둘 때 人용õf는 정보이멀 nu
l료 넣어도 된다

assertThat(set .translate(null , null , sqlEx) ,
is(DuplicateKeyException.class));

먼저 JdbcTemplate을 시용하는 UserDao를 이용해 강제로 DuplicateKeyException을
발생시킨다. 이렇게 가져온 DuplicateKeyE
x
ception은 중첩된 예외로 JDBC 뻐I에서
처음 발생한 SQLException을 내부에 갖고 있다. getRootCause() 메소드를 이용하면 중
첩되어 있는 SQLException을 가져올 수 있다.

이제 검증해볼 사항은 스프링의 예외 전환 API
를 직접 적용해서
DuplicateKeyE
xce
ption
이 만들어지는가이다. 주입받은 dataSource를 이용해
SQLErrorCodeSQLE
xc
eptionTranslator
의 오브젝트를 만든다. 그리고 SQLException
을 따라미터로 넣어서 translate() 메소드를 호출해주면 SQLE
x
ception
을
DataAccessException 타입의 예외로 변환해준다. 변환된 DataAccessException 타입
의 예외가 정확히 DuplicateKeyException 타입인지를 확인하면 된다. assertThat()의
is() 메소드에 클래스를 넣으면 오브젝트의 equals () 비교 대신 주어진 클래스의 인스
턴스인지 검사해준다. 이 태스트가 성공한다면 코드에 의한 예외 전환이 잘 됐음을 확
인할수있다.

태스트는 물론 성공한다. DB
에 상관없이 항상 DuplicateKeyException 예외로 전환
되는지 궁금하다면 DB를 바꿔서 해보는 것도 재있을 것이다.

JDBC 외의 기술을 사용할 때도 DuplicateKeyE
x
ception
을 발생시키려면
SQLException을 가져와서 직접 예외 전환을 하는 방법을 생각해볼 수도 있다. 또
는 JDBC를 이용하지만 JdbcTemplate과 같이 자동으로 예외를 전환해주는 스프
링의 기능을 사용할 수 없는 경우라도 SQLE
xce
ption을 그대로 두거나 의미 없는
RuntimeE
xc
eption으로 뭉뚱그려서 던지는 대신 스프링의 DataAccessException 계층
의 예외로 전환하게 할 수 있다.


[ 4.3 정리

4장에서는 엔터프라이즈 애플리케이션에서 사용할 수 있는 바람직한 예외처리 방법은
무엇인지를 살며봤다. 또한 JDBC 예외의 단점이 무엇인지 살펴보고， 스프링이 제공하
는 효과적인 데이터 액세스 기술의 예외처리 전략과 기능에 대해서도 알아봤다. 이 장
에서 살펴본 주요 내용은 다음과 같다.

• 예외를 집아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발히는 것은 위험
하다.
• 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야
한다.
• 좀 더 의미 있는 예외로 변경하거나 불필요한 catch/throws를 피하기 위해 런타임 예외로
포장하는 두 가지 방법의 예외 전환이 있다.
• 복구할 수 없는 예외는 가능한 한 빨리 런타임 예외로 전환하는 것이 바람직하다.
• 애플리케이션의 로직을담기 위한예외는체크예외로만든다.
• JDBC의 SQLException은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야 한다.
• SQLException의 에러 묘드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환될 필요가
있다.
• 스프링은 DataAccessException을 통해 DB
에 독립적으로 적용 가능한 추상화된 런타임 예
외계층을제공한다.
• DAO를 데이터 액세스 기술에서 독립시키려변 인터페이스 도입과 런타임 예외 전환， 기술
에 독립적인 추상화된 예외로 전환이 필요하다.
4장-여|외 315


X바에는 표준 스펙 상용 제품， 오푼소스를 통틀어서 새 방법과 형식은 다르지

| 만 기능과 목적이 유사한 기술이 존재한다. 심지어는 같은 자바의 표준 기술 중
에서도 플랫폼과 컨텍스트에 차이가 있거나 발전한 역사가 다르기 때문에 목적이 유사
한여러 기술이 공존하기도한다. 환경과상햄 따라서 기술이 바뀌고， 그에 따라다른
API를 사용하고 다른 스타일의 접근 방법을 따라야 한다는 건 매우 피곤한 일이다.

5장에서는 지금까지 만든 DAO
에 트랜잭션을 적용해보면서 스프링이 어떻게 성격
이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지
원하는지를 살펴볼 것이다.

[ ~땅자 레벨 관리 기능 추가 C젠
I

지금까지 만들었던 UserDao는 User 오브젝트에 담겨 있는 사용자 정보를 등록， 조회，

수정， 삭제하는 일명 CRUD라고 불리는 가장 기초적인 작업만 가능하다. 사용자 정보

를 DB
에 넣고 빼는 것을 제외하면 어떤 비즈니스 로직도 갖고 있지 않다.

이제 여기에 간단한 비즈니스 로직을 추가해보자. 지금까지 만들었던 UserDao를 다
수의 회원이 가입할 수 있는 인터넷 서비스의 사용자 관리 모률에 적용한다고 생
ζ벼}보
자. 사용자 관리 기능에는 단지 정보를 넣고 검색히는 것 외에도 정기적으로 사용자의
활동내역을 참고해서 레벨을 조정해주는 기능이 필요하다.

인터넷 서비스의 사용자 관리 기능에서 구현해야 할 비즈니스 로직은 다음과 같다.

5징-서비스추상화 317


• 사용자의 레벨은 BA5IC , 5ILVER, GOLD 세 가지 중 하나다.
• 사용자가 처음 가입하면 BA5IC 레벨이 되며 이후 활동에 따라서 한 단계씩 업그레이드될
수있다.
• 가입 후 50회 이상 로그인을 하면 BA5IC에서 5ILVER 레벨이 된다.
• 5ILVER 레벨이면서 30번 이상 추천을 받으면 GOLD 레벨이 된다.
• 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일팔적으로 진행된다. 변경 작업 전에는
조건을 충족하더라도 레벨의 변경이 일어나지 않는다.
사용자 관리의 기본 로직은 정해진 조건에 따라 시용자의 레벨을 주기적으로 변경한
다는간단한내용이다.

5.1.1 필드 추가
Level 이늄
먼저 User 클래스에 사용자의 레벨을 저장할 필드를 추가하자. DB의 User 테이블에는
어떤 타입으로 넣을 것인지， 또 이에 매핑되는 자바의 User 클래스에는 어떤 타입으로
넣을지생각해보자.
DB
에 varchar 타입으로 선언하고 "BASI C'’. "SILVER". "GOLD"
라고 문자를 넣는 방
법도 있겠지만， 이렇게 일정한종류의 정보를문자열로 넣는 것은 별로좋아보이지 않
는다. 대신 각 레벨을 코드화해서 숫자로 넣는 건 어떨까? 나쁘지 않다. 범위가 작은 숫
자로 관리하면 DB 용량도 많이 차지하지 않고 가벼워서 좋다.
그럼 자바의 User에 추가할 프로퍼티 타입도 숫자로 하면 될까? 이건 별로 좋지 않
다. 의미 없는 숫자를 프로퍼티에 사용하면 타입이 안전하지 않아서 위험할 수 있기 때
문이다.
만약 리스트 5-1과 같이 상수 값을 정해놓고 int 타입으로 레벨을 시용한다고 해
보자.

리스트 5-1 정수형 상수 강으로 정의한 사용자 레밸

class User {
private static final int BA5IC = 1;
private static final int 5ILVER =2;
private static final int GOLD =3;

int leveL


public void setLevel(int level ) (
this .level = level;

BASIC , SILVER, GOLD처럼 의미 있는 상수도 정의해놨으니 리스트 5-2처럼 깔끔하게
코드를 작성할 수 있긴 하다. DB에 저장될 때는 getLevel() 이 돌려주는 숫자 값을 사
용하면된다.

리스트 5-2 사용자 레벨 상수 값올 이용한 코드

if (userl .getLevel() == User .BASIC) (
userl .setLevel(User .S ILVER);

문제는 level
의 타입이 int
이기 때문에 디음처럼 다른 종류의 정보를 넣는 실수를
해도 컴파일러가 체크해주지 못한다는 점이다. 우연히 getSum() 메소드가 1, 2, 3과 같
은 값을 돌려주면 기능은 문제없이 돌아가는 것처럼 보이겠지만 사실은 레벨이 엉뚱하
게바뀌는심각한버그가만들어진다.

userl.setLevel(other.QetSum());

또， 아래와 같이 범위를 벗어나는 값을 넣을 위험도 있다.

userl.setLevel(lÐÐÐ);

그래서 숫자 타입을 직접 사용하는 것보다는 자바 5 이%에서 제공하는 01늄enum을
이용히는 게 안전하고 편리하다. 시용자 레벨로 사용할 이늄을 리스트 5-3과 같이 정의
한다.

리스트 5-3 사용자 레밸용 이늄


package springbook .user .domain;

public enum Level (
BASIC (l) , SILVER(2) , GOLD(3);
--을 세 개의 이늄오브젝트정의
private final int value;
Level(int value) {
--을 DB에
저장할값올넣어줄썽성자롤만들어둔다

5징-서비스추상화 319


this.value = value;

public int intValue() (--을 값율 가져오는 메소드
return value;

강으로부터 Level 티입 오브젝트훌

public static Level valueOf(int value) (--용 가져오도록 만든 스태틱 메소드

switch(value) (

case 1: return BASIC;

case 2: return SILVER;

case 3: return GOLD;

default: throw new AssertionError( ‘ Unknown value: • + value);

이렇게 만들어진 Level 이늄은 내부에는 DB
에 저장할 int 타입의 값을 갖고 있
지만， 겉으로는 Level 타입의 오브젝트이기 때문에 안전하게 사용할 수 있다
user1
setLevel( 1000)
과 같은 코드는 컴파일러가 타입이 일치하지 않는다는 에러를 내면서
걸러줄것이다.

User
필드추가
이렇게 만든 Level 타입의 변수를 리스트 5--4와 같이 User 클래스에 추가하자. 사용자
레벨 관리 로직에서 언급된 로그인 횟수와 추천수도 추가하자. 이 두 가지는 단순한 int
타입으로 만들어도 좋다. 각각 접근자와 수정자 메소드도 추가해두자.

리스트 당-4 User에 추가된 필드

public class User (

Level level;
int login;
int recommend;

public Level getLevel() (
return level;

public void setLevel(Level level) {


this.level = level;

// login , recommend getter/setter 생략

이제 DB의 USER 태이블에도 표 5-] 에 나와 있는 필드를 추가한다.
표 5-1 USER 테이불 추가 필드

| 팔드영 i 타입 | 설정 |

Level tinyint Not Null

Login ínt Not Null

Recommend ínt Not Null

UserDaoTest 테스트 수정
UserDaoJdbc와 테스트에도 필드를 추가해야 한다. UserDaoJdbc는 태스트까지 갖추고
있는 안정된 코드다. 기존 코드에 새로운 기능을 추가하려면 태스트를 먼저 만드는 것
이안전하다.
먼저 태스트 픽스처로 만든 userl. user2. user3에 리스트 5-5와 같이 새로 추가된
세 펼드의 값을 넣는다. 태스트에서 유용하게 쓰려면 각각 다른 값을 넣는 것이 좋다.

리스트 • 5 수정된 테스트 픽스처


public class UserDaoTest (

OOefore

public void setUp() ( 추가된 필드를 위한 초기값
this .user1 =new User("gyumee", "박성철‘， "springno1", Leve[ÖÄSïCT;Ø);
this .user2 =new User("leegw799", .이길원·’ "springno2", Level.SILVER, 55, 19);
this.user3 = new User('bumjin", "박범진"， "springno3", Level.GOLD, 199, 4Ð);

이에 맞게 User 클래스 생성자의 파라미터도 추가해준다. User의 필드를 추가해놓았
다면 IDE에서 지원히는 필드를 이용한 생성자 자동추가 기능을 사용해서 리스트 5-6
과 같은 새로운 생성자를 만들 수 있다.

5당-서비스 추S화 321


리스트 5-6 추가된 필드를 파라미터로 포홀하는 생성자

class User (

public User(String id , String name , String password , Level level ,

int login , int recommend) (
this.id =id;
this.name =name;
this.password = password;
this.level =level;
this.login =login;
this.recommend =recommend;

다음은 UserDaoTest 태스트에서 두 개의 User 오브젝트 필드 값이 모두 같은지 비교
하는 checkSameUser() 메소드를 수정한다. 리스트 5-7과 같이 새로운 필드를 비교하
는 코드를 추가한다. 검증용 필드를 추가해서 기존에 만들었던 DAO 테스트 기능을 보
완히는 것이다. 이를 빼먹으면 새로 추가된 펼드의 DB 쓰기와 읽기가 바르게 되는지 검
증되지않는다.

리스트 5-7 새로운 필드를 포함하는 User 필드 값 검증 메소드

private void checkSameUser(User user1 , User user2) (
assertThat(user1.getld() , is(user2.getld()));
assertThat(user1.getName() , is(user2.getName()));
assertThat(user1.getPassword() , is(user2.getPassword()));
assertThat(userl .getLevel() , is(user2.getLevel()));
assertThat(userl.getLogin() , is(user2.getLogin()));
assertThat(userl.getRecommend() , is(user2.getRecommend()));

기존의 addAndGet( ) 테스트에서는 checkSameUser() 메소드를 사용하지 않고 테
스트 메소드에서 직접 asser
tT
hat()
을 사용했다. 이제 필드도 늘어났고， 앞으로 추
가되거나 변경돼도 User 오브젝트를 비교하는 로직을 일정하게 유지할 수 있도록
checkSameUser()를 이용해 리스트 5
-8처럼 수정한다.


리스트 5-8 checkSameUser( ) 메소드를 사용하도록 만든 addAndGet( ) 메소드

@Test public void addAndGet() (

User usergetl =dao.get(userl.getld());
checkSameUser(userget1 , user1);

User userget2 =dao.get(user2.getld());
checkSameUser(userget2 , user2);

태스트는 이제 준비됐다. 테스트 대상인 UserDaoJdbc는 아직 수정하지 않았으니 지
금 태스트를 돌려보면 실패할 것이 분명하다. 그래도 눈으로 확인해보고 싶다면 태스트
를 돌려봐도 좋다. 혹시라도 테스트가 성공한다면 태스트를 잘못 수정한 것이다.

UserDaoJdbc 수정
이제 미리 준비된 태스트가 성공하도록 UserDaoJdbc 클래스를 수정할 차례다. 등록
을 위한 INSERT 문장이 들어 있는 add() 메소드의 SQL과 각종 조회 작업에 사용되
는 User 오브젝트 매핑용 콜백인 userMapper
에 추가된 펼드를 넣는다. 리스트 5-9는
UserDaoJdbc 클래스에서 수정된 메소드와 필드를 보여주고 있다.

리스트 웅-9 추가된 필드를 위한 UserD∞Jdbc의 수정 코드


public class UserDaoJdbc implements UserDao (

private RowMapper<User> userMapper =
new RowMapper<User>() (

public User mapRow(ResultSet rs , int rowNum) throws SQLException (
User user =new User();
user .setId(rs. getString(" id"));
user.setName(rs.getString("name'‘ ));
user .setPassword(rs.getString("password"));
user.setLevel(Level.valueOf(rs.getlnt( ‘ level")));
user .setLogin(rs.getlnt( "loign"));
user.setRecommend(rs.getlnt("recommend"));
return user;

public void add(User user) {

5징-서비스 추S힘 323


this . jdbcTemplate.update(
"insert into users(id, name , password , level , login , recommend) " +
"values(?,?,?,?,?,?)“, user.getld() , user.getName() ,
user.getPassword() , user.getLevel().intValue() ,
user.getLogin() , user.getRecommend());

여기서 눈여겨볼 것은 Level 타입의 level 필드를 시용히는 부분이다. Level 이늄
은 오브젝트이므로 DB
에 저장될 수 있는 SQL 타입이 아니다. 따라서 DB에 저장 가
능한 정수형 값으로 변환해줘야 한다. 각 Level 이늄의 DB 저장용 값을 얻기 위해서는
Level
에 미리 만들어둔 intValue() 메소드를 사용한다. add() 메소드에서 이 메소드를
사용했다.

반대로 조회를 했을 경우， ResultSet에서는 DB의 타입인 int로 level 정보를 가
져온다. 이 값을 User의 setLevel() 메소드에 전달하면 타입이 일치하지 않는다는 에
러가 발생할 것이다. 이때는 Level
의 스태틱 메소드인 valueOf()
를 이용해 lnt 타입
의 값을 Level 타입의 이늄 오브젝트로 만들어서 setLevel() 메소드에 넣어줘야 한다.
userMapper
에 이 방식을 적용했다.

자， 이제 테스트를 돌려보자. 앗! 테스트가 실패한다. 무슨 문제일까? 발생한 예외를
살펴보니 아래와 같은 메시지가 보인다.

org .springframework.jdbc.BadSQlGrammarException: Prepared5tatementCallback; bad

5QL grammar [select * from users where id = ?]; nested exception is java.sql .

5QLException: Column 'loign' not found.

DB 서버가 다운된 것도， 커넥션 리소스에 이상이 있는 것도 아니다. 메시지를 살펴
보면 발생한 예외는 스프령 DataAccessException
의 하나인 BadSqlGrammarException
임을 알 수 있다. 이름에서 알 수 있듯이 SQL 문법이 틀혔다는 뭇이다. 수정한 내용 중
에서 SQL
에 영향을 주는 부분은 펼드 이름을 추가한 곳이다. 어딘가 펼드 이름을 잘못
쓴 것이다. 중첩된 예외를 보면 loign 컬럼을 찾을 수 없다는 메시지가 보인다.login을
loign이라고 잘못 쓴 것이 분명하다.

매핑 코드를 담은 userMapper에 추가한 내용 중에 펼드 이름을 잘못 쓴 것이 있다.
눈썰미 있는 독자라면 리스트 5-9의 수정된 UserDaoJdbc 코드를 보면서 이 오타를 발
견했을 것이다. 출판 과정에서 교정을 잘못 봐서 오타가 들어갔다고 생각했을지 모르
겠지만 사실은 의도적으로 잘못된 펼드 이름을 넣은 것이다.


JDBC가 사용하는 SQL은 컴파일 과정에서는 자동으로 검증이 되지 않는 단순 문

자열에 불과하다. 따라서 SQL 문장이 완성돼서 DB
에 전달되기 전까지는 문법 오류나

오타조차 발견하기 힘들다는 게 문제다. 미리미리 DB까지 연통되는 태스트를 잘 만들

어뒀기 때문에 SQL 문장에 사용될 펼드 이름의 오타를 아주 빠르게 잡아낼 수 있었다.

그런데， 지주 실행해볼 수 있도록 만들어진 테스트가 없는 채로 사용자 정보에 새로운

펼드가 추가됐다면 어됐을까? 수정된 묘드를 빌드하고 서버에 올려서 누군가 사용자

의 정보를 읽고 쓰는 기능을 시용하기 전까지는 이런 오타조차 발견하기 힘들 것이다.

한참 후에 수동 태스트를 통해 에러 메시지를 보고 그제서야 겨우 오타를 확인할 것이

다. 그때까지 진행한 빌드와 서버 배치 서버 재시작 수동 태스트 등에 소모한 시간은

낭비에 가깝다. 혹시 애플리케이션이 이미 운영 중인 상태에서 기능을 추가하고 제대

로 수동 테스트조차 거치지 못한 채로 서버에 배포됐다면 시용자들이 무시무시한 에러

메시지를 만나게 되는 끔찍한 상햄l 처했을지도 모른다. 그래서 빠르게 실행 기능한

포괄적인 테스트를 만들어두면 이렇게 기능의 추가나 수정이 일어날 때 그 위력을 발

휘한다.

자， 이제 간단히 userMapper
에 나오는 멸드 이름을 바르게 login으로 수정하고 태스

트를 다시 실행해보자. 테스트 결과는 성공이다. 추가된 필드가 DB에 저장되고 조회되

는 기능에 아무 문제가 없다는 확신하에 다음 작업으로 넘어가자.

5.1.2 사용자수정 기능추가
사용자 관리 비즈니스 로직에 따르면 사용자 정보는 여러 번 수정될 수 있다. 상식적으
로 생각빼봐도 기본키인 i
d를 제외한 나머지 필드는 수정될 기능성이 있다. 성능을 극
대화하기 위해， 수정되는 필드의 종류에 따라서 각각 여러 개의 수정용 DAO 메소드를
만들어야 할 때도 있다. 하지만 아직은 사용자 정보가 단순하고 펼드도 몇 개 되지 않으
며 사용자 정보가 지주 변경되는 것도 아니므로 간단히 접근하자. 수정할 정보가 담긴
User 오브젝트를 전달하면 id를 참고해서 시용자를 찾아 펼드 정보를 UPDATE 문을 이용
해 모두 변경해주는 메소드를 하나 만들겠다.

수정기능테스트추가
만들어야할코드의 기능을생각해볼 겸 리스트
5-10과같은태스트를 먼저 작성한다.

g앙-서비스 추상화 325


리스트 5-10 사용자 정보 수정 메소드 테스트

@Test
public void update () (
dao.deleteAll();

dao.add(userl);

userl.setName("
오민규");

userl .setPassword("springno6‘ );

userl .setLevel(Level.GOLD); 바 믹스처에 들oi 있는 정보룰 변경해서
userl .setLogin(1000); 수정 메소드를 호출효κt
userl .setRecommend(999);

dao.update(userl);

User userlupdate =dao.get(userl .getld());
checkSameUser(userl , userlupdate );

먼저 픽스처 오브젝트 하나를 등록한다. 그리고 id를 제외한 필드의 내용을 바문 뒤
update( )를 호출한다. 이제 해당 id
의 사용자 정보가 변경됐어야 한다. 다시 id로 조회
해서 가져옹 User 오브젝트와 수정한 픽스처 오브젝트를 비교한다.

그런데 user1
이라는 텍스트 픽스처는 인스턴스 변수로 만들어놓은 것인데， 이를 직
접 변경해도 될까? 상관없다. 어차띠 태스트 메소드가 실행될 때마다 UserDaoTest 오브
젝트는 새로 만들어지고. setUp() 메소드도 다시 불려서 초기화될 태니 내용을 변경해
도상관없다.

UserDao와 UserDaoJdbc 수정
여기까지 만들고 나면 dao 변수의 타입인 UserDao 인터페이스에 update( ) 메소드가 없
다는 컴파일 에러가 날 것이다. IDE의 자동수정 기능을 이용해 UserDao 인터페이스에
리스트
5-11과같이 update( ) 메소드를추가한다.

리스트 5-11 update() 메소드 추가

public interface UserDao (
public void update(User userl);


贊
IDE의 챔수껑 기농과 태스트 코드 작성

대부분의 자바 IDE에는 컴파일 에러에 대한 자동수정 기능이 있다. 이클립스에는 빠른고칩
(Quick Rx)이라는 기능이 있어서 검파일 에러가 발생하면 끽바+..1.) 키를 눌러서 IDE가 제요h하
는 자동수정 내용 중 하나훌 선택할 수 있다. 존재하지 않는 클래스훌 사용한 코드가 있다면 클
래스 생성을 제요벼{주고. 역시 존재하지 않는 메소드나 파라미터가 있다면 메소드나 파라미터
톨 자동으로 추가해주는 기능을 제공해준다.

테스트롤 먼저 만들면， 아직 준비되지 않은 클래스나 메소드훌 테스트 코드 내에서 먼저 사용
하는 경우가 있다. 이 경우 IDE의 자바 코드 에디터에서 에러가 표시되면 자동고침 기능올 이용
해 클래스나 메소드롤 생성하도록 만들면 매우 편리하다. 코딩 양울 줄여주고 메소드 이륨이나
클래스 이룸의 오타훌 막아줘서 매우 빠르게 코드톨 작성할 수 있다.

반대로 클래스나 메소드톨 먼저 만들고 테스트훌 작성하는 경우라면 IDE의 자동완성 기능을
활용하면된다.

UserDao 인터페이스에 update( )를 추가하고 나면 이번엔 UserDaoJdbc
에서 메소드
를 구현하지 않았다고 에러가 날 것이다. 이때는 대부분의 IDE에서 지원하는， 구현되
지 않은 메소드를 자동 추가히는 기능을 사용하면 면리하다.

UserDaoJdbc
의 update() 메소드는 add()
와 비슷한 방식으로 만들면 된다. 리스트
5-12처럼 JdbcTemplate의 update() 기능을 사용해서 UPDATE 문과 바인딩할 파라미터
를전달해주면된다.

리스트 5-12 사용자 정보 수정용 u여at허 ) 메소드


public void update(User user) {

this.jdbcTemplate .update(
"update users set name = κ password = χ level = 7, login = ζ " +
"recommend = 7 where id = 7 user. getName() , user. getPassword() ,
user.getLevel().intValue() , user.getLogin() , user.getRecommend() ,
user. getId());

이제 태스트를돌려서 결과를확인해보자.

수정테스트보완
태스트가 성공하는 것을 봤으니 이쯤에서 만족하고 다른 작업으로 넘어가도 좋을 것 같
다. 하지만 꼼꼼한 개발자라면 이 태스트에 뭔가 불만을 가지고 의심스럽게 코드를 다
시 살펴봐야 할 것이다. JDBC 개발에서 리소스 반환과 같은 기본 작업을 제외하면 가

5징-서비스 추S화 327


장 많은 실수가 일어나는 곳은 바로 SQL 문장이다. 필드 이름이나 SQL 키워드를 잘못

넣은 거라면 태스트를돌려보면 에러가나니 쉽게 확인할수 있다. 하지만 리스트
5-10
과 같은 태스트로는 검증하지 못하는 오류가 있을 수 있다. 바로 UPDATE 문징에서 WHERE
절을 빼먹는 경우다. UPDATE는 WHERE가 없어도 아무런 경고 없이 정상적으로 동작하는
것처럼 보인다. update() 테스트에서 바뀐 로우의 내용만확인해보면 정상적으로동작
한 것으로 보인다. 하지만 현재 update( ) 태스트는 수정할 로우의 내용이 바뀐 것만 확
인할 뿐이지， 수정하지 않아야 할 로우의 내용이 그대로 남아 있는지는 확인해주지 못
한다는문제가있다.

이 문제를 해결할 방법을 생각해보자.

첫 번째 방법은 JdbcTemplate
의 update( )가 돌려주는 리턴 값을 확인하는 것이다.
JdbcTemplate의 update()는 UPDATE나 DELETE 같이 테이블의 내용에 영향을 주는 SQL
을 실행하면 영향받은 로우의 개수를 돌려준다. 지금까지는 이 정보를 무시해왔는데 이
쯤에서 UserDao의 add(). deleteAll (). update() 메소드의 리턴 타입을 int로 바꾸고
이 정보를 리턴하게 만들 수 있다. update() 테스트라면 이 값이 I인지 확인히는 코드
를 하나 더 추가해주면 된다. 비록 에러가 발생하지 않고 원히는 시용자의 정보는 변경
됐음을 확인했더라도 영향받은 로우의 개수가 l 이상이라면 update( ) 메소드의 SQL에
문제가 있다는 사실을 알 수 있다.

두 번째 방법은 테스트를 보강해서 원히는 사용자 외의 정보는 변경되지 않았음을
직접 확인하는 것이다. 사용자를 두 명 등록해놓고 그중 하나만 수정한 뒤에 수정된 사
용자와 수정하지 않은 시용자의 정보를 모두 확인하면 된다.

여기서는 두 번째 방법을 적용해보자.

확실하게 태스트하려면 UserDao update() 메소드의 SQL 문장에서 WHERE 부분을
빼보면 된다. 그래도 기존 update( ) 테스트는 성공할 것이다. 테스트에 결함이 있다는
증거다. 이 상태에서 태스트를 수정해서 태스트가 실패하도록 만들어야 한다. 이쯤에서
꼼꼼한 태스트를 만들지 않았을 때의 아찔한 결괴를 한 번쯤 떠올려보고 넘어가도 좋겠
다. 태스트를 만들면 작성한 코드에 확신을 가질 수 있고 미음이 편해지는 건 사실이지
만， 귀찮다고 대충 작성한 테스트는 오히려 찾기 힘든 버그와 사고의 원인이 될 수도 있
으니조심하자.

리스트 5-13은 두 번째 방법으로 태스트를 보완한 것이다.


리스트 5-13 보완된 U여at허 ) 테스트

@Test
public void update() (
dao .deleteAll();

dao .add(userl); // 수정할 사용자
dao.add(user2); // 수정하지 않을 사용자

userl .setName("
오민규");
userl .setPassword( 닝pringno6");
userl.setLevel(Level.GOLD);
userl.setLogin(1000);
userl .setRecommend(999);

dao .update(userl);

User userlupdate = dao .get(userl .getld());
checkSameUser(userl , userlupdate);
User user2same =dao.get(user2.getld());
checkSameUser(user2 , user2same);


update( ) 메소드의 SQL에서 WHERE를 빼먹었다면 이 태스트는 실패로 끝날 것이다.
이제 태스트가 성공하도록 SQL을 원래대로 만들어주면 된다.
사용자 정보를 수정히는 기능을 추가했으니 이제 본격적인 시용자 관리 비즈니스 로
직을구현할차례다.

5.1.3 UserService.upgradeLevels()
레벨 관리 기능을 구현하기는 어렵지 않다. 테스트를 거친 UserDao도 준비되어 있으니
데이터 액세스 기능은 문제없다. UserDao의 getAll() 메소드로 사용자를 다 가져와서
사용자별로 레벨 업그레이드 작업을 진행하면서 UserDao의 update( )를 호출해 DB에
결과를넣어주면된다.

사용자 관리 로직은 어디다 두는 것이 좋을까? UserDaoJdbc는 적당하지 않다. DAO
는 데이터를 어떻게 가져오고 조작할지를 다루는 곳이지 비즈니스 로직을 두는 곳이 아
니다. 사용자 관리 비즈니스 로직을 담을 클래스를 하나 추가하자. 비즈니스 로직 서비
스를 제공한다는 의미에서 클래스 이름은 UserService로 한다. UserService는 UserDao

5잠-서비스 추승화 329


인터페이스 타입으로 userDao 빈을 DI 받아 사용하게 만든다. 대문자로 시작하는
UserDao는 인터페이스 이름이고， 소문자로 시작하는 userDao는 빈 오브젝트 이름이니
잘구분하기바란다.

UserService는 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 해야 한다. 데이
터 액세스 로직이 바뀌었다고 비즈니스 로직 코드를 수정하는 일이 있어서는 안 된다.
따라서 DAO의 인터페이스를 사용하고 DI를 적용해야 한다.DI를 적용하려면 당연히
UserService도 스프링의 빈으로 등록돼야 한다.

UserService를 위한 테스트 클래스도 하나 추가하자. 태스트 클래스의 이름은
UserServiceTest로 한다. UserService의 클래스 레벨 의존관계를 정리해보면 그림
5-1
과같다.

UserServiceTest U••rS.rvice


---->


써

r -” … ’

l ’

l ’

UaerOaoJdbc U.erOaoJpa

그힐 5-1 U않rService의 의존관계

UserService 클래스와 빈 등록
UserService 클래스를 만들고 사용할 UserDao 오브젝트를 저장해둘 인스턴스 변수를
선언한다. 리스트 5-14와 같이 UserDao 오브젝트의 DI가 가능하도록 수정자 메소드도
추가한다.

리스트 도14User용rvl∞ 클래스

package springbook.user.service;

public class UserService (
UserDao userDao;

public void setUserDao(UserDao userDao) {
this .userDao =userDao;


그리고 스프링 설정파일에 userService 아이디로 빈을 추가한다. 리스트 5
-15와 같
이 userDao 빈을 DI 받도록 프로퍼티를 추가해준다
.

리스트 5-15 userServi∞ 빈 실정

(bean id="userService" class="springbook.user.service .UserService">
(property name="userDao" ref="u~erDao
" />

</bean> ~

(bean id='userDao" cla
ss=
갱
p
ringbook
.
dao.UserDaoJdbc ’'>
(property name="dataSource " ref="dataSource" />

(/bean>

UserServiceTest 테스트 클래스
다음은 UserServiceTest 클래스를 추가하고 태스트 대상인 UserService 빈을 제공받
을 수 있도록 @Autowired가 붙은 인스턴스 변수로 선언해준다. UserService는 컨테
이너가 관리하는 스프링 빈이므로 스프링 태스트 컨텍스트를 통해 주입받을 수 있다.
UserServiceTest 테스트 클래스는 리스트 5-16과 같이 만들어질 것이
다.

리스트 5-16 UserServiceTest 클래스


package springbook.user .service;

@R unWith(SpringJUnit4ClassRunner.class)
OContextConfiguration(locations="/test-applicationContext .xml" )
public class UserServiceTest (

öAutowired
UserService userService;

그런데 아직은 @Test 테스트가 없으니 좀 이상하다. JUnit 태스트로 실행해보면 태
스트 메소드가 하나도 없다고 에러가 날 것이다. 간단히 userService 빈이 생성돼서
userService 변수에 주입되는지만 확인하는 리스트 5-17의 태스트 메소드를 추가해
보자.

리스트 5-17 userService 빈의 주입올 확인하는 테스트

@Test
public void bean() {

5징-서비스 추상화 331


assertThat(this.userService , is(notNullValue())) ;

테스트 메소드가 추기됐으니 JUnit으로 테스트를 수행할 수 있다. 태스트가 성공하
면 UserService 빈이 잘 등록됐음을 알 수 있다. 이후에 userService 오브젝트를 추가
하면 bean() 테스트는 별 의미가 없으니 삭제해도 좋다.

upgradeLevels( ) 메소드
이제 로직을 추가할 준비는 끝났다. 이번엔 시용자 레벨 관리 기능을 먼저 만들고 테스
트를만들어보자.
앞에서 살펴본 로직을 잘 보고 그대로 코드로 구현해보면 리스트 5-18과 같은 메소
드로만들어낼수있다.

리스트 5-18 사용자 레밸 업그레이드 메소드

public void upgradeLevels() (
List<User) users = userDao.getAll();
for(User user users) (
Boolean changed =null;-웅‘ 레옐의 변화가 있는지톨 확인히는 율래그
if (user.getLevel() == Level .BASIC && user.getLogin() >= 50) (
user .setLevel(Level.SILVER); BA'3lC 레벨 업그레이드 ξ엉
changed =true;

else if (user.getLevel () == Level.SILVER && user.getRecαrrnend 0 >= 30) (

user.setLevel(Level .GOLD); SlLVER 레앨 업그레이드 작업
chånged = true;~ 례벨 변경 을래그 설정

else if (user.getLevel() == Level .GOLD) { changed =false; }
else { changed =false; } •

} 일맴치채핸는조전건이뼈없으면면 변볍경 없앓응 01 일뺑어에빠뼈뼈나따때tJ:찌재|

a
∞때띠뻐뻐레뺀|벨뿔은 번뽕뺑뺑경켈행
않뿔는다

f (changed) { us잊
뻐
때랴아(l
디);

erDa
o
.
upda
te
ωuser
}

“l
~ 레벨의 변경이 있는 경우에만 U여a때) 호훌

먼저 모든 사용자 정보를 DAO에서 가져온 후에 한 명씩 레벨 변경 작업을 수행한
다. 현재 사용자의 레벨이 변경됐는지를 확인할 수 있도록 플래그를 하나 선언한다.
BASIC 레벨이면서 로그인 조건을 만족하면 User 오브젝트의 레벨을 SILVER로 변경하


고 레벨 변경 플래그인 changed를 true로 설정한다. 마찬가지로 SILVER의 업그레이드
조건도 검사하고 조건을 충족하면 레벨을 변경한다. GOLD
일 때는 로직에 따라 레벨 변
경이 일어나지 않는다. 어떤 조건도 충족하지 못했을 때도 마찬가지로 레벨 변경은 없
다. changed 플래그를 확인해서 레벨 변경이 있는 경우에만 UserDao의 update()를 이
용해 수정 내용을 DB
에 반영한다.

본격적인 비즈니스 로직이 들어가니 조건문도 많이 나오고 코드가 조금 복잡해 보인
다. 이 정도 코드라면 한 번 살펴보는 것만으로 오류가 있는지 쉽게 찾아낼 자신이 있는
개발자도 있겠지만， 정말 뛰어난 개발자라면 아무리 간단해 보여도 실수할 수 있음을
알고 있기 때문에 태스트를 만들어서 직접 동작하는 모습을 확인해보려고 할 것이다.

ψgradeLevels( ) 테스트
태스트 방법을 생각해보자. 적어도 가능한 모든 조건을 하나씩은 확인해봐야 한다. 사
용자 레벨은 BASIC, SILVER, GOLD 세 가지가 있고， 변경이 일어나지 않는 GOLD를 제외
한 나머지 두 가지는 업그레이드가 되는 경우와 아닌 경우가 있을 수 있으므로 최소한
다섯 가지 경우를 살펴봐야 한다. 다섯 종류의 사용자 정보를 등록해두고 업그레이드를
진행한 후에 예상한 대로 결과가 나오는지 확인해보자.
테스트 픽스처의 개수가 UserDaoTest
에서보다 많아졌으니 이번에는 각각 변수로 등
록하는 리스트 5-19와 같이 리스트를 사용해보자.

리스트 5-19 리스트로 만든 테스트 픽스처


class UserServiceTest (

List<User> users; // 테스트 픽스처

OOefore

-배열을 리스트로 만들어주는 편리
한 메소드

public void setup() ( r배열을
가변인자로넣어주연 더욱펀리하다

users = Arrays.asList(
new User("bumjin" , "박범진’기 "p1", Level.BASI(, 49, 0),
new User("joytouch" , "강명성"， "p2“, Level.BASIC, 50, 0),

new User(
갯rwins"， "신승한
"p3"， Level.SILVER, 60, 29).
new User("madnite1" , "이상호기 "p4", Level.SILVER, 60, 30),
new User( "green", .오민큐
"p5"， Level.GOLD, 100, 100)

5징-서비스 추상회 333


BASIC과 SILVER 레벨의 사용지는 각각 두 개씩 등록했다. 로직을 보면 로그인 횟수

|여
In와 추천 횟수recommend가 각각 기준 값인 50. 30 이상이 되면 SILVER와 GOLD로 엽그
레이드된다. 이럴 땐 태스트에 사용할 데이터를 경계가 되는 값의 전후로 선택하는 것
이 좋다. 첫 번째 테스트 사용자는 SILVER 업그레이드 경계인 50에서 하나 모자란 49를，
두 번째 태스트 사용자는 업그레이드가 되는 가장 작은 login 값인 50으로 설정했다.

리스트 5-20은 준비된 픽스처를 사용해 만든 테스트다.

리스트 5-20 사용자 레벨 업그레이드 테스트

@Test

public void upgradeLevels() (
userDao.deleteAll();
for(User user users) userDao.add(user);

userService .upgradeLevels();

checkLevel(users.get(0) , Level.BASIC);
checkLevel(users.get(1) , Level.SILVER);
checkLevel(users .get(2) , Level.SILVER); ~ 각 앵자별로 업그레이드 후의

checkLevel(users.get(3) , Level.GOLD); 1 예상레벨을
검증한다

checkLevel(users.get(4) , Level.GOLD);

private void checkLevel(User user , Level expectedLevel) (

DB에서 사용자 정보훌 가져와

User userUpdate =userDao.get(user .getld()); 레웰율 확인하는 코드가 중복되

assertThat(userUpdate.getLevel() , is(expectedLevel)); 므로 헬머 메소드로 분리했다

먼저 준비한 다섯 가지 종류의 사용자 정보를 저장한 뒤에 upgradeLevels() 메소드
를 실행한다. 업그레이드 작업이 끝나면 시용자 정보를 하나씩 가져와 레벨의 변경 여
부를확인하면된다.

이제 태스트를 돌려보자. 물론 성공이다. 사용자 레벨 변경 기능은 이제 완벽하게 만
들어졌다.

5.1.4 UserService.add()
시용자 관리 비즈니스 로직에서 대부분은 구현했지만 아직 하나가 남았다. 처음 가입하
는 사용자는 기본적으로 BASIC 레벨이어야 한다는 부분이다
.


이 로직은 어디에 담는 것이 좋을까?

일단 UserDaoJdbc
의 add() 메소드는 적합하지 않아 보인다. UserDaoJdbc는 주어진
User 오브젝트를 DB
에 정보를 넣고 읽는 방법에만 관심을 가져야지， 비즈니스적인 의
미를 지닌 정보를 설정하는 책임을 지는 것은 바람직하지 않다.

그렇다면 User 클래스에서 。배 level 필드를 Leve
l.
BASIC으로 초기화하는 것은 어
떨까? 그리 나쁘지 않은 생각인 것 같다. 하지만 처음 가입할 때를 제외하면 무의미한
정보인데 단지 이 로직을 담기 위해 클래스에서 직접 초기화하는 것은 좀 문제가 있어
보인다.

그렇다면 사용자 관리에 대한 비즈니스 로직을 담고 있는 UserService에 이 로직을
넣으면 어떨까? UserDao의 add() 메소드는 사용자 정보를 담은 User 오브젝트를 받아
서 DB에 넣어주는 데 충실한 역할을 한다면 UserService에도 add()를 만들어두고 사
용자가 등록될 때 적용할 만한 비즈니스 로직을 담당하게 하면 될 것이다.

이번에는 태스트부터 만들어보자. 검증할 기능은 UserService
의 add()
를 호출하면
레벨이 BASIC으로 설정되는 것이다. 그런데 UserService의 add()
에 전달되는 User 오
브젝트에 level 펼드에 값이 미리 설정되어 있는 경우에는 어떻게 해야 할까? 이건 정
하기 나름이다. 여기서는 add()
를 호출할 때 level
의 값이 비어 있으면 로직을 따라서
BASIC을 부여해주고， 만약 특별한 이유가 있어서 미리 설정된 레벨을 가진 User 오브젝
트인 경우에는 그대로 두기로 하자.

태스트 케이스는 두 종류를 만들면 된다. 레벨이 미리 정해진 경우와 레벨이 비어 있
는 두 가지 경우에 각각 add() 메소드를 호출하고 결과를 확인하도록 만들자. User 오
브젝트의 레벨이 변경됐는지 확인하기 위해 사용할 수 있는 두 가지 방법이 있다.

간단한 방법은 UserService의 add() 메소드를 호출할 때 파라미터로 넘긴 User 오
브젝트에 level 펼드를 확인해보는 것이고 다른 방법은 UserDao의 get() 메소드를 이
용해서 DB에 저장된 User 정보를 가져와 확인하는 것이다. 두 가지 다 해도 좋고 후자
만 해도 괜찮을 것 같다. UserService는 UserDao를 통해 DB
에 시용자 정보를 저장하기
때문에 이를 확인해보는 게 가장 확실한 방법이다. UserService가 UserDao를 제대로 사
용하는지도 함께 검증할 수 있고， 디폴트 레벨 설정 후에 UserDao를 호출히는지도 검증
되기 때문이다.

이제 add() 메소드에 대한 테스트를 만들어보자. 리스트 5-21
은 완성된 태스트 코
드다.

닮L 서비스 추상화 335


리스트 5-.낀 add() 메소드의 테스트

@Test
public void add() {

userDao .deleteAll(); GOLD 레엘이 이미 지정된 user리연
레웰올 초기화하지 않이야 한다

User 빼ithLevel = 때LI 러|벨

users.get(4);

User userWithoutLevel =users.get(0); 레벨이 비어 있는 시용자 로직에 따라 등록
userWithoutLevel .setLevel(null); 중에 g잉C 레엘도 설정돼야 효κt

userService .add(userWithLevel);
userService.add(userWithoutLevel);

User userWithLevelRead =userDao .get(userWithLevel.getld());
User userWithoutLevelRead =userDao .get(userWithoutLevel.getld());

DB에 저장된 결과훌 가져와 확인효[↑

assertThat(userWithLevelRead .getLevel() , is(userWithLevel.getLevel()));
assertThat(userWithoutLevelRead .getLevel() , is(Level .BASIC));

이미 레벨이 GOLD로 설정된 사용자와 레벨이 null
인 사용자 오브젝트 두 개를 준비
한다. 준비한 두 개의 사용자 오브젝트를 UserService의 add() 메소드를 통해 초기화
한 뒤에 DB에 저장되도록 만든다. 확인을 위해 DB에서 사용자 정보를 읽어온다. 레벨
이 이미 설정됐던 것은 그대로 유지되어 있어야 하고 레벨이 없던 것은 디폴트인 BASIC
으로 설정됐는지 확인해준다.

테스트는 준비됐으니 이제 태스트가 성공하도록 묘드를 만들어보자. add() 메소드는
리스트 5-22와 같이 간단히 만들 수 있다.

리스트 5-22 사용자 신규 둥록 로직율 담은 add() 메소드

public void add(User user) {
if (user.getLevel() == null) user .setLevel(Level .BASIC);
userDao .add(user);

태스트를 돌려보면 성공이다. 다만 태스트가 조금 복잡한 것이 흠이다. 간단한 비즈
니스 로직을 담은 묘드를 테스트하기 위해 DAO와 DB까지 모두 동원되는 점이 조금
불편하다. 이런 테스트는 깔끔하고 간단히 만드는 방법이 있는데， 뒤에서 다시 다뤄보
겠다.


5.1.5 코드 개선
이제 비즈니스 로직의 구현을 모두 마쳤다. 태스트도 만들어서 꼼꼼하게 점검했으니 할
만큼했다고생각하고넘어가고싶지만 깔끔한묘드를추구하는스프링 사용자답게 만

들어진 코드를 다시 한번 검토해보자.

작성된 코드를 살펴볼 때는 다음과 같은 질문을 해볼 필요가 있다.

• 코드에 중복된 부분은 없는가?
• 코드가 무엇을 하는 것인지 이해하기 불편하지 않은개
• 코드가 자신이 있어야 할 자리에 있는가?
• 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고， 그 변회에 쉽게 대응할 수 있게 작성되
어있는가?
upgradeLevels( ) 메소드 코드의 문제점
이런 질문을 하며 UserService의 upgradeLevels() 메소드를 살펴보면 몇 가지 문제점

이보인다.

일단 for 루프 속에 들어 있는 if/elseif/else 블록들이 읽기 불편하다. 레벨의 변
화 단계와 업그레이드 조건， 조건이 충족됐을 때 해야 할 작업이 한데 섞여 있어서 로직
을 이해하기가 쉽지 않다. 플래그를 두고 이를 변경하고 마지막에 이를 확인해서 업데

이트를 진행히는 방법도 그리 깔팝해 보이지 않는다.
코드가 깔끔해 보이지 않는 이유는 이렇게 성격이 다른 여러 가지 로직이 한데 섞여

있기 때문이다.
if 블록 하나를 중심으로 살펴보자.

@ @

if (user.getLevel() == Level.BASIC && user .getLogin() >= 50) (
user .setLevel(Level.SILVER); ~
changed = true; @

if (changed) ( userDao.update(user); } @

@은 현재 레벨이 무엇인지 파악히는 로직이다.
@는 업그레이드 조건을 담은 로직

이다.
@에는 다음 단계의 레벨이 무엇이며 업그레이드를 위한 작업은 어떤 것인지가

함께 담겨 있다.@는 그 자체로는 의미가 없고 단지 멀리 떨어져 있는 @의 작업이 펼

5징-서비스 추상화 337



요한지를 알려주기 위해 임시 플래그를 설정해주는 것이다. 관련이 있어 보이지만 사실
은 성격이 조금씩 다른 것들이 섞여 있거나 분리돼서 나타나는 구조다.

게다가 이런 if 조건 블록이 레벨 개수만큼 반복된다. 만약 새로운 레벨이 추가된다
면 Level 이늄도 수정해야 하고 upgradeLevels()
의 레벨 업그레이드 로직을 담은 코
드에 if 조건식과 블록을 추가해줘야 한다. 업그레이드 조건이 복잡해지거나 업그레이
드 작업에서 하는 일이 단지 level 필드를 변경하는 수준 이상이라면 upgradeLevels()
메소드는 점점 길어지고 복챔지며， 갈수록 이해하고 관리하기가 힘들어진다. 지저분
해지는 코드 탓에 찾기 힘든 버그가 숨어들어 갈 가능성이 높아질 것이다.

현재 레벨과 업그레이드 조건을 동시에 비교히는 부분도 문제가 될 수 있다. BASIC
이
면서 로그인 횟수가 50이 되지 않는 경우는 마지막 else 블록으로 이동한다. 새로운 레
벨이 추가돼도 역시 기존의 if 조건들에 맞지 않을 테니 else 블록으로 이동할 것이다.
성격이 다른 두 가지 경우가 모두 한 곳에서 처리되는 것은 뭔가 이^ð하다. 제대로 만
들려면 조건을 두 단계에 걸쳐서 비교해야 한다. 첫 단계에서는 레벨을 확인하고 각 레
벨별로 다시 조건을 판단하는 조건식을 넣어야 한다. 이렇게 만들면 지금보다 깔끔하게
예외적인 상황을 분리해서 처리할 수 있겠지만 코드는 훨씬 더 복잡해질 것이다.

아직은 별로 복잡해 보이지 않고， 주어진 비즈니스 로직을 잘 처리하는 코드인 듯 보
이지만 사실 곰곰이 따져보면 상당히 변회에 취약하고 다루기 힘든 코드임을 알 수 있
다. 문제점이 뭔지 따져보고 설명하는 것조차 힘들다.

upgradeLevels( ) 리팩토링
이제 코드를 리팩토링해보자.
가장 먼저 추상적인 레벨에서 로직을 작성해보자. 기존의 upgradeLevels() 메소드
는 자주 변경될 가능성이 있는 구체적인 내용이 추상적인 로직의 흐름과 함께 섞여 있
다. 레벨을 업그레이드하는 작업의 기본 흐름만 리스트 5-23과 같이 먼저 만들어보자.
구체적인 구현에서 외부에 노출할 인터페이스를 분리히는 것과 마찬가지 작업이라고
생각하면된다.

리스트 5-23 기본 작업 흐롬만 남겨둔 U며radeLevels( )

public void upgradeLevels() (
List<User) users = userDao.getAll();
for(User user users) {
if (canUpgradeLevel(user)) (
upgradeLevel(user);


이 묘드는 이렇게 읽을 수 있다. 모든 사용자 정보를 가져와 한 명씩 업그레이드가
가능한지 확인하고， 가능하면 업그레이드를 한다. 참 간단하지 않은가? 구체적인 내용
은 모르겠지만 upgradeLevels() 메소드가 어떤 작업을 하는지는 쉽게 이해할 수 있다.

이제 하나씩 구체적인 내용을담은메소드를만들면 된다.

먼저 업그레이드가 가능한지를 알려주는 메
소
드인 리
스트 5 -24
의
canUpgradeLevel() 메소드를 살펴보자. 주어진 user
에 대해 업그레이드가 가능하면
true, 가능하지 않으면 false를 리턴하면 된다. 상태에 따라서 업그레이드 조건만 비교
하면 되므로， 역할과 책임이 명료해진다.

리스트 5-24 업그레이드 가능 확인 메소드

private boolean canUpgradeLevel(User user) (
Level currentLevel = user .getLevel () ;
switch(currentLevel) (

case BA5IC: return (user.getLogin() >=58);
레
벨별로구문해서

case 5ILVER: return (user.getRecommend() >= 38);

조건을
판단한다

case GOLD: return false;

default : throw new IllegalArgumentException( “ Unknown Level : " +
currentLevel); ~ 현재 로직에서 다룰 수 없는 레벨이 주어지연 예외를 일생시킨다 새로운

혜밸이 추가되고 로직을 수정하지 않으면 에러기 나서 확인할 수 있다‘


업그레이드가 가능한지 확인하는 방법은 User 오브젝트에서 레벨을 가져와서，
switch 문으로 레벨을 구분하고 각 레벨에 대한 업그레이드 조건을 만족하는지를 확인
해주면 된다. GOLD 같은 경우는 항상 업그레이드가 불가능하니 false로， 그 외에는 주어
진 사용자 정보를 기준으로 조건을 넣으면 된다. 로직에서 처리할 수 없는 레벨인 경우
에 예외를 던져준다. 새로운 레벨이 추가됐지만 업그레이드 로직을 추가하지 않았다면
예외가발생할테니 쉽게확인할수있다.

다음은 업그레이드 조건을 만족했을 경우 구체적으로 무엇을 할 것인가를 담고 있는
upgradeLevel() 메소드를 만들어보자. 레벨 업그레이드를 위한 작업은 사용자의 레벨
을 다음 단계로 바꿔주는 것과 변경사항을 DB
에 업데이트해주는 것이다. 물론 니중에

5징-서비스 추상화 339


업그레이드 안내 메일을 보낸다거나 로그를 남기거나 관리자에게 통보를 해주거나， 통
계를 내는 작업이 추가될 수도 있다. 업그레이드 작업용 메소드를 따로 분리해두면 나
중에작업 내용이추가되더라도어느
곳을수정해야할지가명확해진다는장점이 있다.

일단 리스트 5-25와 같이 메소드를 만들어보자.

리스트 5-25 레밸 업그레이드 작업 메소드

private void upgradeLevel(User user ) (
if (user.getLevel() == Level .BASIC) user.setLevel(Level.SILVER);
else if (user.getLevel() == Level.SILVER) user.setLevel(Level.GOLD);
userDao .update(user);

이 메소드는 사용자 오브젝트의 레벨정보를 다음 단계로 변경하고， 변경된 오브젝
트를 DB
에 업데이트히는 두 가지 작업을 수행한다. 이제 테스트를 돌려보자. 태스트가
성공한다면 리팩토링한 사용자 레벨 변경 기능이 바르게 동작함을 확인할 수 있다.

그런데 리스트 5-25
의 upgradeLevel() 메소드 코드는 마음에 안 든다. 다음 단계가
무엇인가송}는로직과그때 사용자오브젝트의 level 필드를변경해준다는로직이 함께
있는데다， 너무 노골적으로 드러나 있다. 게다가 예외상햄 대한 처리가 없다. 만약 업
그레이드 조건을 잘못 파악해서 더 이상 디음 단계가 없는 GOLD 레벨인 사용자를 업그
레이드하려고 이 메소드를 호출한다면 아무것도 처리하지 않고 그냥 DAO의 업데이트
메소드만 실행될 것이다. 레벨이 늘어나면 if 문이 점점 길어질 것이고， 레벨 변경 시
사용자 오브젝트에서 level 펼드 외의 값도 같이 변경해야 한다면 if 조건 뒤에 붙는 내
용도 점점 길어질 것이다.

이것도더분리해보자.

먼저 레벨의 순서와 디음 단계 레벨이 무엇인지를 결정하는 일은 Level에게 맡기자.
레벨의 순서를 굳이 UserService에 담아둘 이유가 없다. Level을 리스트 5-26과 같이
수정한다.

리스트 5-26 업그레이드 순서톨 담고 있도록 수정한 Level

public enum Level (
GOLD(3 , null) , SILVER(ι GOLD) , BASIC(l , SILVER);
L•-이늄 선언에 DB에 저장할 값과 힘께 다옴 단계의 레빌 정보도 추가효센

private final int value;

private final Level next;-•-다옴 딘계의 레벨 정보톨 스스로 갖고 있도록
Lev
히 타입의 re씨 연수를 추기한다


Level(int value , Level next) (
this .value = value;
this.next =next;

public int intValue() (
return value;

public Level nextLevel() (
return this.next;

public static Level valueOf(int value) (

switch(value) (

case 1: return BASIC;

case 2: return SILVER;

case 3: return GOLD;

default: throw new AssertionError("Unknown value: " + value);


Level 이늄에 next라는 다음 단계 레벨 정보를 담을 수 있도록 필드를 추가한다. 생
성자 파라미터를 추가해서 다음 단계 레벨 정보를 지정할 수 있게 해준다. Level 이늄
을 정의할 때 DB
에 저장될 값과 다음 레벨이 무엇인지를 함께 넣어줄 수 있다. 그리고
다음 레벨이 무엇인지를 알고 싶다면 nextLevel( ) 메소드를 호출해주면 된다. 이렇게
만들어두면 레벨의 업그레이드 순서는 Level 이늄 안에서 관리할 수 있다. 다음 단계의
레벨이 무엇인지를 일일이 if 조건식을 만들어서 비즈니스 로직에 담아둘 필요가 없다.

이번엔 시용자 정보가 바뀌는 부분을 UserService 메소드에서 User로 옮겨보자.
User의 내부 정보가 변경되는 것은 UserService보다는 User가 스스로 다루는 게 적절
하다. User는 사용자 정보를 담고 있는 단순한 자바빈이긴 하지만 User도 엄연히 자바
오브젝트이고 내부 정보를 다루는 기능이 있을 수 있다. UserService가 일일이 레벨 업
그레이드 시에 User의 어떤 펼드를 수정한다는 로직을 갖고 있기보다는， User에게 레벨
업그레이드를 해야 하니 정보를 변경하라고 요청히는 편이 낫다.

User 클래스에 리스트 5-27의 메소드를 추가하자.

g앙-서비스 추상화 341


리스트 5-Z1 User의 레벨 업그레이드 작업용 메소드

/ public void upgradeLevel() { /

/

Level nextLevel = this.level.nextLevel ();
i f (nextLevel == null) {
throw new Illega15tateException(this.level + "은 업그레이드가 불가능합니다");

else {
this.level = nextLevel;

먼저 Level
의 nextLevel() 기능을 이용해 현재 레벨의 다음 단계가 무엇인지 확인

한다. Level
의 순셔와 다음 단계 정보는 모두 Level 이늄에서 관리하기 때문에， User

는 Level 타입의 level 필드에게 다음 레벨이 무엇인지 알려달라고 요청해서 현재 레

벨을 변경해주면 된다. 단， 더 이상 업그레이드가 불가능한 경우가 있다. UserService

의 canUpgradeLevel() 메소드에서 업그레이드 가능 여부를 미리 판단해주기는 하지만，

User 오브젝트를 UserService만 사용하는 건 아니므로 스스로 예외상햄l 대한 검증

기능을 갖고 있는 편이 안전하다.

Level 이늄은 다음 레벨이 없는 경우에는 nextLevel()
에서 null을 리턴한다. 따라
서 이 경우에는 User
의 레벨 업그레이드 작업이 진행돼서는 안 되므로 예외를 던져야
한다. 애플리케이션의 로직을 바르게 작성한다면 이런 경우는 아예 일어나지 않겠지만
User 오브젝트를 잘못 시용하는 코드가 있다면 확인해줄 수 있으니 유용하다.

User
에 업그레이드 작업을 담당하는 독립적인 메소드를 두고 사용할 경우， 엽그
레이드 시 기타 정보도 변경이 필요해지면 그 장점이 무엇인지 알 수 있을 것이다. 가
장 최근에 레벨을 변경한 일자를 User 오브젝트에 남겨두고 싶을 수도 있다. 이때는
lastUpgraded 필드를 추가하고 아래와 같은 코드를 upgradeLevel()
에 넣어주기만 하
면된다.

this.lastUpgraded = new Date();

이 덕분에 UserService는 User 오브젝트에게 알아서 업그레이드에 펼요한 작업을
수행하라고 요청만 해주면 되기 때문에， upgradeLevel () 메소드는 리스트 5-28처럼
간결해진다.

342


리스트 5-28 간결해진 U며radeLevel( )

private void upgradeLevel(User user) {
user.upgradeLevel();
userDao.update(user);

이제 if 문장이 많이 들어 있던 이전 코드보다 간결하고 작업 내용이 명확하게 드러
나는 코드가 됐다. 각 오브젝트가 해야 할 책임도 깔끔하게 분리가 됐다.
이제 태스트를 돌려보자. 성공이다. 제법 많이 리팩토링했지만 기능에는 문제가 없
다는 사실을 다시 확인할 수 있다.

지금 개선한 묘드를 살펴보면 각 오브젝트와 메소드가 각각 자기 몫의 책임을 맡아
일을 히는 구조로 만들졌음을 알 수 있을 것이다. UserService, User, Level이 내부 정
보를 다루는 자신의 책임에 충실한 기능을 갖고 있으면서 필요가 생기연 이런 작업을
수행해달라고 서로 요청히는 구조다. 각자 자기 책임에 충실한 작업만 하고 있으니 코
드를 이해하기도 쉽다. 또 변경이 펼요할 때 어디를 수정해야 할지도 쉽게 알 수 있다.
잘못된 요청이나 작업을 시도했을 때 이를 확인하고 예외를 던져줄 준비도 다 되어 있
다. 각각을 독립적으로 테스트하도록 ~들면 테스트 코드도 단순해진다.

객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신 데이터를
갖고 있는 다른 오브젝트에게 작업을 해달라고 요청한다. 오브젝트에게 데이터를 요구
하지 말고 작업을 요청하라는 것이 객체지향 프로그래밍의 가장 기본이 되는 원리이기
도 하다. 처음 구현했던 UserService
의 upgradeLevels() 메소드는 User 오브젝트에서
데이터를 가져와서 그것을 가지고 User 오브젝트나 Level 이늄이 해야 할 작업을 대신
수행하고 직접 User 오브젝트의 데이터를 변경해버린다. 이보다는 UserService는 User
에게 “레벨 업그레이드 작업을 해달라”고 요청하고， 또 User는 Level
에게 “다음 레벨이
무엇인지 알려달라”고 요청하는 방식으로 동작하게 하는 것이 바람직하다.

객체지향이 어쩌고 저쩌고 하는 설명이 불펀하다면 단순히 ‘이렇게 만들면 코드를
더 이해하기 쉽고 변회에 대응하기가 면하구나’라고 생각해도 좋다.

만약 “BRONZE 레벨을 BASIC과 SILVER 사이에 추가하고 그 다음 례벨로 업그레이드하
는 조건은 로그인 횟수 80
번이다. 그리고 가장 최근의 레벨 변경 날짜를 저장해두고， 레
벨 변경 시 콘솔에 로그를 남기도록 하라”는 수정 요청이 들어왔을 때， 각 요청사항은
어디를 손보면 되는지를 쉽게 알 수 있다. 변경 후에도 코드는 여전히 깔끔하고 코드를
이해하는 데도 어려움이 없을 것이다.

5장-서비스 추S화 343



물론 지금까지 진행한 UserService의 리팩토링과 그 결과로 만들어진 코드가 정답이
라거나 완벽한 것은 아니다. 애플리케이션의 특성과 구조， 발전방향 등에 따라 더 세련
된 설계도 가능하다. 좀 더 객체지향적인 특정이 두드러지게 구조를 바꿀 수도 있다. 현
재 UserService의 코드는 5
ÀJ-에서 설명하려는 스프링의 기능을 적용하기 적절한 구조
로 만들어둔 것뿐이다. 항상 코드를 더 깔끔하고 유연하면서 변회에 대응하기 쉽고 태
스트하기 좋게 만들려고 노력해야 함을 기억하고 디음으로 넘어가자.

User 테스트
방금 User
에 간단하지만 로직을 담은 메소드를 추가했다. 이것도 태스트하는 게 좋을
까? 이 정도는 태스트 없이 넘어갈 수도 있겠지만 앞으로 계속 새로운 기능과 로직이
추가될 가능성이 있으니 태스트를 만들어두면 도움이 될 것이다. 리스트 5-29는 User
에 추가한 upgradeLevel() 메소드에 대한 테스트다.

리스트 5-29U똥r 테스트

package springbook.user.service;

public class UserTest (
User user;

OOefore
public void setUp() (
user = new User();

@Test()

public void upgradeLevel() (
Level[] levels = Level.values();
for(Level level levels) (

if (level .nextLevel() == null) continue;

user.setLevel(level);

user.upgradeLevel();

assertThat(user.getLevel() , is(level.nextLevel()));

@Test(expected=IllegalStateException.class)

public void cannotUpgradeLevel() (
Level[] levels = Level.values();
for(Level level levels) {


if (level.nextLevel() != null) continue;
user .setLevel(level);
user .upgradeLevel();

User 클래스에 대한 태스트는 굳이 스프링의 태스트 컨텍스트를 사용하지 않아도 된
다. User 오브젝트는 스프링이 IoC로 관리해주는 오브젝트가 아니기 때문이다. 컨테
이너가 생성한 오브젝트를 @Autowired로 가져오는 대신 생성자를 호출해서 태스트할
User 오브젝트를 만들면 된다.

upgradeLevel() 테스트는 Level 이늄에 정의된 모든 레벨을 가져와서 User에 설정
해두고 User
의 upgradeLeve1()을 실행해서 다음 레벨로 바뀌는지를 확인히는 것이다.
단， 다음 단계가 null
인 경우는 제외한다. 디음 단계로 업그레이드가 가능한 정상적인
상태만 확인하면 되기 때문이다. 굳이 이렇게까지 테스트해야 할까 싶기도 하지만， 이
렇게 테스트를 만들어두면 나중에 upgradeLevel() 메소드에 좀 더 복잡한 기능이 추가
됐을 때도 이 태스트를 확장해 사용할 수 있다.

다음은 더 이상 업그레이드할 레벨이 없는 경우에 upgradeLevel()
을 호출하
면 예외가 발생히는지를 확인히는 태
스트다. nextLevel ( )이 null~ 경우에 강제로
upgradeLevel()
을 호출해본다. 이때 @Test(expected=)
에 설정한 예외가 발생하면 테
스트가 성공이다. 만약 그대로 진행돼서 메소드가 정상적으로 종료되면 JUnit에 의해
태스트가 실패로 간주될 것이다.

UserServiceTest 개선
UserService 태스트도 혹시 손볼 데가 없을지 살펴보자. 기존 테스트에서는
checkLevel() 메소드를호출할때 일일이 다음단계의 레벨이 무엇인지 넣어췄다. 이것
도 사실 중복이다. Level
이 갖고 있어야 할 다음 레벨이 무엇인가 하는 정보를 테스트에
직접 넣어둘 이유가 없다. 레벨이 추가되거나 변경되면 테스트도 따라서 수정해야 하니
번거롭다. 차라리 리스트 5-30처럼 만드는 편이 간결하다.


5장-서비스 추S탤I 345


리스트 5-30 개선한 U며r싫eLevels() 테스트

@Test

public void upgradeLevels () {
userDao.deleteAll();
for(User user users) userDao.add(user);

userService .upgradeLevels();

checkLevelUpgraded(users.get(8) , false);
checkLevelUpgraded(users.get(1) , true);
checkLevelUpgraded(users.get(2) , false);
checkLevelUpgraded(users.get(3) , true);
checkLevelUpgraded(users.get(4) , false);

어떤 레벨로 바뀔 것인가가 아니라， 다음 혜벨로
업그레이드될 것인가 아닌가룰 지정효삐

+

private void checkLevelUpgraded(User user, boolean upgraded) (
User userUpdate = userDao.get(user.getld()); 댐 레
엘
01 무엇인지는 L뼈에게
if (upgraded) ( 물어보연 된다 i

assertThat(userUpdate.getLevel(), is(user.getLevel().nextLevel()));

4 업그레이드7
1 일어났는지 뺀

else (
assertThat(userUpdate.getLevel() , is(user.getLevel()));

4 업그레이드가 일어나지 않았는지 확인

기존의 upgradeLevels() 테스트 코드는 테스트 로직이 분명하게 드러나지 않는 것
이 단점이었다. checkLevel ()을 호출하면서 파라미터로 Level 이늄을 하나 전달히는
데， 테스트 코드만 봐서는 그것이 업그레이드된 경우를 태스트하려는 것인지 쉽게 파
악이 안 된다. 픽스처 내용과 함께 살펴보면 태스트의 의도를 이해히는 게 불가능하지
는 않지만 아무래도 번거롭다. 그에 반해 개선한 upgradeLevels () 테스트는 각 사용자
에 대해 업그레이드를 확인하려는 것인지 아닌지가 좀 더 이해하기 쉽게 true, false
로 나타나 있어서 보기 좋다. 또 업그레이드됐을 때 어떤 레벨인지는 Level 이늄의
nextLevel()
을 호출해보면 된다.

다음은 코드에 나타난 중복을 제거해보자. 업그레이드 조건인 로그인 횟수와 추천
횟수가 애플리케이션 코드와 태스트 코드에 중복돼서 나타난다.

case BASIC: return (user.getLogin() >= 58 ); // UserService

~중복
new User("joytouch", "강명성 ‘ p2" , Leve
1.
BASIc~~e， Ø) // UserServiceTest


태스트와 애플리케이션 코드에 나타난 이런 숫자의 중복도 제거해줘야 할까? 당연하
다. 한 가지 변경 이유가 발생했을 때 여러 군데를 고치게 만든다면 중복이기 때문이다.
테스트에는 어느 정도 애플리케
이
션 로직이 반복돼서 나타날 수밖에 없긴 하지만 그래
도 이런 상수 값을 중복하는 건 바람직하지 못하다. 기준이 되는 최소 로그인 횟수가 변
경될 때도 한 번만 수정할 수 있도록 만들자. 가장 좋은 방법은 정수형 상수로 변경하는
것이다.

먼저 UserService의 코드를 리스트 5-3
1과 같이 수정한다.

리스트 5-31 상수의 도입

public static final int MIN_LOGCOUNT_FOR_SILVER =59;
public static final int MIN_RECCOMEND_FOR_GOLD =39;

private boolean canUpgradeLevel(User user) (
Level currentLevel =user .getLevel();
switch(currentLevel) (

case BASIC : return (user.getLogin() >= MIN_LOGCOUNT_FOR_SILVER) ;
case SILVER: return (user.getRecommend() >= MIN_RECCOMEND_FOR_GOLD) ;
case GOLD: return false;
default: throw new IllegalArgumentException( “ Unknown Level: " +

currentLevel );


그리고 태스트도 리스트 5-32처럼 U
serServi
ce에 정의해둔 상수를 사용하도록 만
들자.

리스트 5-32 상수릎 사용하도록 만든 테스트

import static springbook.user.service.UserService.MIN_LOGCOUNT_FOR_SILVER;
import static springbook.user.service.UserService.MIN_RECCOMEND_FOR_GOLD;

OOefore
public void setUp() ( 테스트에서는 가능한 한 경계 값을 사용하는 것이 좋다

users =Arrays.asList( •
new User( "bumjin" , “
박범
진 ‘’p1 ", Level .BASIC, MIN_LOGCOUNT_FOR-SILVER-1 , 0) ,
new User ( " j oytouch" , "강명
성 “p2" , Level.BAS1 C, MIN_LOGCOUNT_FOR_SILVER , 0) ,
new User
(
갱rW
l
ns
‘기 ”신승한‘， "p3" , Level.SILVER, 60 , MINßECCOMEND]OR_GOLD-l),
new User(’‘madnitel" , "이상호
"04"， Level.SILVER , 60, MINßECCOMEND_FOR-GOLD),

얄L 서비스추S힘 347


new User( "green" , "오민규" "p5" , Leve l.GOLD , 100, Integer .lWCVALUE)

숫자로만 되어 있는 경우에는 비즈니스 로직을 상세히 코멘트로 달아놓거나 설계문
서를 참조하기 전에는 이해하기 힘들었던 부분이 이제는 무슨 의도로 어떤 값을 넣었는
지 이해하기 쉬워졌다. 그리고 코드와 태스트 사이에서도 중복을 제거했기 때문에 업그
레이드 조건 값이 바뀌는 경우 UserService
의 상수 값만 변경해주면 된다.

좀 더 욕심을 내자면 레벨을 업그레이드하는 정책을 유연하게 변경할 수 있도록 개
선히는 것도 생각해볼 수 있다. 연말 이벤트나 새로운 서비스 홍보기간 중에는 레벨 업
그레이드 정책을 다르게 적용할 필요가 있을 수도 있다. 그럴 때마다 중요한 사용자 관
리 로직을 담은 UserService의 코드를 직접 수정했다가 이벤트 기간이 끝나면 다시 이
전 코드로 수정한다는 것은 상당히 번거롭고 위험한 방법이다.

이런 경우 사용자 업그레이드 정책을 UserService에서 분리하는 방법을 고려해볼 수
있다. 분리된 업그레이드 정책을 담은 오브젝트는 DI를 통해 UserService에 주입한다.
스프링 설정을 통해서 평상시 정책을 구현한 클래스를 UserService에서 시용하게 하다
가， 이벤트 때는 새로운 업그레이드 정책을 담은 클래스를 따로 만들어서 DI 해주변 된
다. 이벤트가 끝나면 기존 업그레이드 정책 클래스로 다시 변경해준다.

리스트 5-33과 같은 업그레이드 정책을 담은 인터페이스를 만들어두고 UserService
는 DI로 제공받은 정책 구현 클래스를 이 인터페이스를 통해 사용할 수 있다.

리스트 5-33 업그레이드 정책 인터페이스

public interface UserLevelUpgradePolicy {
boolean canUpgradeLevel(User user);
void upgradeLevel(User user);

UserService
에 DI를 통해 UserLevelUpgradePolicy를 적용해보는 것은 간단한 작업

이니 DI 적용 실습 차원에서 직접 만들어보기 바란다.


Iæ 트랜잭션 서m추상화 i펠I

이제 시용자 레벨 관리 기능에 대한 구현을 마쳤고 태스트를 통해 검증도 끝났다. 이쯤
에서 마무리하고 다음 기능으로 넘어가고 싶은데 갑자기 이런 질문이 나왔다.

“정기 사용자 레벨 관리 작업을 수행하는 도중에 네트워크가 끊기거나 서버에 장애
가 생겨서 작업을 완료할 수 없다면 그때까지 변경된 λF용자의 레벨은 그대로 둘까요?
아니면 모두 초기 상태로 되돌려 놓아야 할까요?"

이 시스템을 사용할 고객과 개발팀의 열띤 토론 끝에 사용자 레벨 조정 작업은 중간
에 문제가 발생해서 작업이 중단된다면 그때까지 진행된 변경 작업도 모두 취소시키도
록 결정했다. 일부 사용자는 레벨이 조정됐는데 일부는 안 됐다면 사용자의 반발이 심
할 것으로 예상되기 때문이다. 민감한 일부 사용자가 차별받는다고 오해하게 만드는 것
보다는 차라리 시스탬 장애가 있어서 레벨 변경 작업을 못했다고 공지하고 다음 날 다
시 시도하는 편이 나을 것이다.

5.2.1 모 아니면 도
그렇다면， 지금까지 만든 사용자 레벨 업그레이드 코드는 어떻게 동작할지 궁금해진다.
모든 사용자에 대해 업그레이드 작업을 진행하다가 중간에 예외가 발생해서 작엽이 중
단된다면 어떻게 될까? 이미 변경된 시용자의 레벨은 작업 이전 상태로 돌아갈까? 아니
면 바뀐 채로 남아 있을까?
태스트를 만들어서 확인해보자. 그런데 이번 태스트는 간단하지 않다. 예외적인 상
황을 작업 중간에 강제로 발생시켜야 하기 때문이다. 테스트 시나리오를 생각해보자.
일단 5
명의 사용자 정보를 DB
에 넣는다. 그리고 업그레이드 작업을 수행하다가 중간
에서 예외가 발생되게 만든다. 시스템 예외상황을 만들면 더 좋겠지만 l
초도 안 걸리는
짧은 업그레이드 작업 중간에 DB 서벼를 다운시키거나 네트워크를끊는등의 강제적인
장애상황을 연출하는 건 불가능하다. 게다가 테스트의 기본은 자동화된 테스트여야 하
니 사람이 간섭히는 것은 좋은 생각이 아니다. 이보다는 싼H가 발생했을 때 일어나는
현상 중의 하나인 예외가 던져지는 상황을 의도적으로 만드는 게 나을 것이다.

테스트용 UserService 대역
어떻게 작업 중간에 예외를 강제로 만들 수 있을까? 가장 쉬운 방법은 예외를 강제로
발생시키도록 애플리케이션 코드를 수정히는 것이다. 하지만 태스트를 위해 코드를 함

g앙-서비스 추S힘 349


부로 건드리는 것은 좋은 생각이 아니다. 그래서 이런 경우엔 테스트용으로 특별히 만
든 UserService의 대역을 사용하는 방법이 좋다. UserService를 대신해서 태스트의 목
적에 맞게 동작하는 클래스를 만들어 사용하자는 것이다.

태스트용 UserService 확장 클래스는 어떻게 만들 수 있을까? UserService의 코드
를 복사해서 새로운 클래스를 만들고 일부를 수정하면 되겠지만， 코드 중복도 발생하고
시용하기도 번거로워 보인다. 간단히 UserService를 상속해서 테스트에 펼요한 기능을
추가하도록 일부 메소드를 오버라이딩히는 방법이 나을 것 같다.

현재 5
개의 테스트용 사용자 정보 중에서 두 번째와 네 번째가 업그레이드 대상이다.
그렇다면 네 번째 사용자를 처리하는중에 예외를 발생시키고 그 전에 처리한두 번째
사용자의 정보가 취소됐는지， 아니면 그대로 남았는지를 확인하자.

먼저 태스트용으로 UserService를 상속한 클래스를 하나 만든다. 태스트에서만 사
용할 클래스라면 번거롭게 파일을 따로 만들지 말고 테스트 클래스 내부에 스태틱 클래
스로 만드는 것이 간편하다. 테스트용 UserService의 서브클래스는 UserService 기능
의 일부를 오버라이딩해서 특정 시점에서 강제로 예외가 발생하도록 만들 것이다. 그런
데 UserService의 메소드 대부분은 현재 private 접근제한이 걸려 있어서 오벼라이딩
이 불가능하다. 테스트 코드는 테스트 대상 클래스의 내부의 구현 내용을 고려해서 밀
접하게 접근해야 하는데 private처럼 제약이 강한 접근제한자를 사용하면 불편하다.
테스트를 위해 애플리케이션 코드를 직접 수정히는 일은 가능한 한 피히는 것이 좋지만
이번은 예외로 해야 할 것 같다.

테스트용 UserService 서브클래스에서 오버라이딩하려는 것은 upgradeLevel() 메
소드다. 이 메소드에 전달되는 User 오브젝트를 확인해서 네 번째 User 오브젝트가 전
달됐을 경우에 강제로 예외를 발생시커려고 한다. 예외가 발생하면 upgradeLevels()
의
작업이중단될것이다.

먼저 UserService의 upgradeLevel() 메소드 접근권한을 다음과 같이 protected로
수정해서 상속을 통해 오벼라이딩이 가능하게 하자.

protected void upgradeLevel(User user) { ... }

이제 UserService를 상속해서 upgradeLevel() 메소드를 오버라이딩한 UserService
대역을 맡을 클래스를 UserServiceTest 안에 리스트 5-34와 같이 추가한다.


리스트 5-34 UserService의 테스트용 대역 클래스

static class TestUserService extends UserService (
private String id;

private TestUserService(String id) (
this.id = id; ~ 예외툴발생시킬
U영오브젝트의잉를지정할수있게만든다

protected void upgradeLevel (User user ) (
-을 lJsefSeNice의 머|소드톨 오버리이드한다
if (user.getld().equals(this.id)) throw new TestUserServiceException();
super.upgradeLevel(user); ~← 지정된 잉의 뼈r 뾰젝트가 발견되언 예외률 던져서

ξ엠올 강제로 중딘시킨다

오버라이드된 UP9radeLevel() 메소드는 UserService 메소드의 기능을 그대로 수행
하지만 미리 지정된 id를 가진 사용자가 발견되면 강제로 예외를 던지도록 만들었다.

다른 예외가 발생했을 경우와 구분하기 위해 태스트 목적을 띤 예외를 리스트 5-35
와 같이 정의해둔다. TestUserService와 마찬가지로 최상위 클래스로 정의하는 대신
태스트 클래스 내에 스태틱 멤버 클래스로 만들어도 된다.

리스트 5-35 테스트용 예외


static class TestUserServiceException extends RuntimeException {

강제 예외 발생을 통한 테스트
이제 테스트를 만들어보자. 테스트의 목적은 시용자 레벨 업그레이드를 시도하다가 중
간에 예외가 발생했을 경우 그 전에 업그레이드했던 사용자도 다시 원래 상태로 돌아
갔는지를 확인하는 것이다.
리스트 5-36의 테스트 코드를 살펴보자.

리스트 5-36 예외 빌생 시 작업 취소 여부 테스트

@Test 예외를 발생시킬 네 번째 사용자의 d를 넣어서
테스트용 냉erSeαice 대역 오브젝트를 생성효κt

public void upgradeAIIOrNothing() { ~
UserService testUserService = new TestUserService(users .ge't(3) .getId());
testUserService
.
setUserDao(this
.
userDao);
-을 userO∞훌 수동 미 해준다

5징-서비스 추S화 351


userDao.deleteAll();
for(User user users) userDao.add(user);

try
τ
(
estUserService
.
upgradeLevels(); TestUserSeNice는 업그레이드 작업 중에 예외

가 발생해야 한다 정상 종료라언 문제가 있으니
fai l("TestUserServiceException expected"); 실때
}

Test냉;er않Nrce가 던져추는 예외훌 잡아서 계속

catch(TestUserServiceException e) ( • 진행되도록 한다. 그 외의 예외라연 테스트 실때
}

예외가 발생하기 전에 례엘 변
경이 있었던checkLevelUpgraded(users.get(l) , false);~
사용자의 레일이 처음 S빽로 바뀌었나 확인

먼저 태스트용으로 만들어둔 TestUserService
의 오브젝트를 만든다. 생성자 파
라미터로는 예외를 발생시킬 사용자의 id를 넣어준다. 스프링 컨텍스트로부터 가져
온 userDao를 테스트용 TestUserService
에 수동으로 DI 해준다. TestUserService는
upgradeAIIOrNothing() 테스트 메소드에서만 특별한 목적으로 시용되는 것이니， 번거
롭게 스프링 빈으로 등록할 필요는 없다. 테스트 메소드에서 직접 TestUserService의
오브젝트를 만들고， 동작하는 데 필요한 DAO만 스프링이 만들어준 UserDao 오브젝트
를 DI 해주면 된다. 컨테이너에 종속적이지 않은 평범한 자바 코드로 만들어지는 스프
링 DI 스타일의 장점이 바로 이런 것이다. UserDao를
DI 해주고 나면 testUserService
오브젝트는 스프링 설정에 의해 정의된 userService 빈과 통일하게 UserDao를 사용해
데이터 액세스기능을이용할수있다.

태스트 대상 오브젝트 준비가 끝났으니 5
개의 사용자 정보를 등록해준다. 그
리고 testUserService
의 업그레이드 메소드를 실행한다. 테스트용으로 개조한
upgradeLevels()에서는 DB에서 5개의 User를 가져와 차례로 업그레이드를 하다가 지
정해둔 4번째 사용자 오브젝트 차례가 되면 TestUserServiceException을 발생시킬 것
이다. 혹시라도 테스트 묘드를 잘못 작성해서 예외 발생 없이 upgradeLevels() 메소드
가 정상적으로 종료되면 fai 1 () 메소드 때문에 테스트가 실패할 것이다. fail()
은 태
스트가 의도한 대로 동작하는지를 확인하기 위해 넣은 것이다.

TestUserServiceException을 잡은 후에는 checkLevelUpgraded() 메소드를 이용해
두 번째 사용자 레벨이 변경됐는지 확인한다. 우리가 기대하는 건 네 번째 사용자를 처
리하다가 예외가 발생해서 작업이 중단됐으니 이미 레벨을 수정했던 두 번째 사용자도
원래 상태로 돌아가는 것이다.

이제 테스트를 돌려보자.


다음과 같은 메시지를 출력하며 태스트가 실패한다.

java .lang .AssertionError:
Expected: is <BASIC)
got: <SILVER)

두 번째 사용자의 레벨이 BASIC
에서 SILVER로 바뀐 것이 네 번째 λF용자 처리 중 예

외가 발생했지만 그대로 유지되고 있는 것이다.

테스트실패의원인

DB와 JDBC 프로그래밍에 대한 기본적인 지식이 있다면 왜 이런 결과가 나왔는지 쉽

게 알 수 있다. 바로 트랜잭션 문제다. 모든 사용자의 레벨을 업그레이드하는 작업인

upgradeLevels() 메소드가하나의 트랜잭션 안에서 동작하지 않았기 때문이다. 트랜잭

션이란 더 이상 나눌 수 없는 단위 작업을 말한다. 작업을 쪼개서 작은 단위로 만들 수

없다는 것은 트랜잭션의 핵심 속성인 원자성을 의미한다.

모든 사용자에 대한 레벨 업그레이드 작업은 새로 추가된 기술 요구사항대로 전체가

다 성공하든지 아니면 전체가 다 실패하든지 해야 한다. 레벨 업그레이드 작업은 그 작

업을 쪼개서 부분적으로는 성공하기도 하고 여러 번에 걸쳐서 진행할 수 있는 작업이

아니어야 한다. 더 이상은 쪼개질 수 없는 물질이라는 의미로 이름을 붙인 원자와 마찬

가지로， 이 작업도 더 이상 쪼개서 이뤄질 수 없는 원자와 같은 성질을 띤다. 따라서 중

간에 예외가 발생해서 작업을 완료할 수 없다면 아예 작업이 시작되지 않은 것처럼 초

기 상태로 돌려뇌야 한다. 이것이 바로 트랜잭션이다.

upgradeLevels() 메소드의 작업은 이 하나의 작업 단위인 트랜잭션이 적용되지 않

았기 때문에 새로 추가된 기술 요건을 만족하지 못하고 이를 검증하기 위해 만든 태스

트가실패하는것이다.

5.2.2 트랜잭션 경계설정
DB는 그 자체로 완벽한 트랜잭션을 지원한다.SQL을 이용해 다중 로우의 수정이나 삭
제를 위한 요청을 했을 때 일부 로우만 삭제되고 나머지는 안 된다거나， 일부 펼드는 수

정했는데 나머지 펼드는 수정이 안 되고 실패로 꿀나는 경우는 없다. 하나의 SQL 명령

을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있다.

하지만 여러 개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야 히는 경우

도 있다. 트랜잭션을 설명할 때 자주 언급되는 계좌이체라든가 이 장에서 만든 여러 사

g앙-서비스 추상화 353


용자에 대한 레벨 수정 작업 등이 그렇다. 은행 시스댐의 계좌이체 작업은 반드시 하나
의 트랜잭션으로 묶여서 일어나야 한다. 이제를 할 때는 출금계좌의 잔고는 이제금액만
큼 줄어들고， 입금계좌에는 이체금액만큼 증가돼야 한다. 이때 이체 프로그램은 DB
에
두 번 요청을 보낸다. 적어도 DB 출금계좌의 잔고를 수정히는 것과 입금계좌 레묘드의
잔고를 수정하는 두 개의 SQL이 필요하다.

문제는 첫 번째 SQL을 성공적으로 실행했지만 두 번째 SQL이 성공하기 전에 장애
가 생겨서 작업이 중단되는 경우다. 이때 두 가지 작업이 하나의 트랜잭션이 되려면， 두
번째 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우에는 앞에서 처리
한 SQL 작업도 취소시켜야 한다. 이런 취소 작업을 트랜잭션 롤백t떠
nsaclton r이
lback이라고
한다. 반대로 여러 개의 SQL을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행
작업이 다 성공적으로 마무리됐다고 DB
에 알려줘서 작업을 확정시켜야 한다. 이것을

트랜잭션 커잇transactíon commít이라고 한다.

JDBC 트랜잭션의 트랜잭션 경계설정
모든 트랜잭션은 시작하는 지점과 끝나는 지점이 있다. 시작히는 방법은 한 가지이지만
꿀나는 방법은 두 가지다. 모든 작업을 무효화하는 롤백과 모든 작업을 다 확정하는 커
빗이다. 애플리케이션 내에서 트랜잭션이 시작되고 끝나는 위치를 트랜잭션의 경계라
고 부른다. 복잡한 로직의 흐름 사이에서 정확하게 트랜잭션 경계를 설정하는 일은 매
우중요한작업이다.
리스트 5-37은 JDBC를 이용해 트랜잭션을 적용하는 가장 간단한 예제다. 트랜잭션
처리 부분에 초점을 맞춰 간략하게 만든 코드라 Connection , PreparedStatement를 처
리히는 일부분은 생략되어 있다.

리스트 5-37 트랜잭션을 사용한 JDBC 코드

Connection c =dataSource.getConnection(); A

æ
키넥션

c.setAutoCommit(false);~ 트랜잭션 시작 트랜잭션
try (
r-PreparedStatement stl 트랜잭션이 존
c.prepareStatement("update users ... ‘); 재하는범위 즉
트랜잭션이 시
stl.executeUpdate();
PreparedStatement st2 =
하나의 트랜잭
바션으로묶인단
위
ξ엠
ξf하는곳과물
나는곳을지정
하는것을트랜
잭선 경계설정
c. prepareStatement( "delete users ... "); 이라고한다
st2.executeUpdate();


c. commi t();-용 트랜잭션 키멋
catch(Exception e) (

c
.
rollback();~ 트랜잭션 률백
c. close() ;
*

JDBC의 트랜잭션은 하나의 Connection을 가져와 사용하다가 닫는 사이에서 일어난
다. 트랜잭션의 시작과 종료는 Connection 오브젝트를 통해 이뤄지기 때문이다. JDBC
에서 트랜잭션을 시작하려면 자동커빗 옵션을 false로 만들어주변 된다. JDBC의 기본
설정은 DB 작업을 수행한 직후에 자동으로 커빗이 되도록 되어 있다. 작업마다 커맛해
서 트랜잭션을 끝내버리므로 여러 개의 DB 작업을 모아서 트랜잭션을 만드는 기능이
꺼져 있는 것이다. JDBC에서는 이 기능을 false로 설정해주변 새로운 트랜잭션이 시
작되게 만들 수 있다. 트랜잭션이 한 번 시작되면 commit() 또는 rollback( ) 메소드가
호출될 때까지의 작업이 하나의 트랜잭션으로 묶인다. commi t() 또는 rollback( )이 호
출되면 그에 따라 작업 결과가 DB
에 반영되거나 취소되고 트랜잭션이 종료된다. 일반
적으로 작엽 중에 예외가 발생하면 트랜잭션을 롤백한다. 예외가 발생했다는 건， 트랜
잭션을 구성하는 데이터 액세스 작업을 마무리할 수 없는 상황이거나 DB
에 결괴를 반
영하면 안 되는 이유가 생겼기 때문이다.

이렇게 setAutoCommit(false)
로 트랜잭션의 시작을 선언하고 commit() 또는
rollback( )으로 트랜잭션을 종료히는 작업을 트랜잭션의 경계설정transaction demarcation
이

라고 한다. 트랜잭션의 경계는 하나의 Connection
이 만들어지고 닫히는 범위 안에 존재
한다는 점도 기억해두자. 이렇게 하나의 DB 커넥션 안에서 만들어지는 트랜잭션을 로
컬 트랜잭션|∞al transaction이 라고도 한다.

UserService와 UserDao의 트랜잭션 문제
그렇다면 이제 왜 UserService의 upgradeLevels()
에는트랜잭션이 적용되지 않았는지
생각해보자. 이유는 단순하다. 지금까지 만든 코드 어디에도 트랜잭션을 시작하고， 커
맛하고， 롤백하는 트랜잭션 경계설정 코드가 존재하지 않는다. JDBC
의 트랜잭션 경계
설정 메소드는 모두 Connection 오브젝트를 사용하게 되어 있는데. JdbcTemplate을 사
용하기 시작한 이후로부터 이 Connection 오브젝트는 구경도 못해봤다.
JdbcTemplate은 직접 만들어봤던 JdbcContext와 작업 흐름이 거의 동일하다. 하

5장-서비스추S화 355



나의 템플릿 메소드 안에서 DataSource
의 getConnection( ) 메소드를 호출해서
Connection 오브젝트를 가져오고， 작업을 마치면 Connection을 확실하게 닫아주고 랩
플릿 메소드를 빠져나옹다. 결국 뱀플릿 메소드 호출 한 번에 한 개의 DB 커넥션이 만
들어지고 닫히는 일까지 일어나는 것이다. 일반적으로 트랜잭션은 커넥션보다도 존재
범위가 짧다. 따라서 템플릿 메소드가 호출될 때마다 트랜잭션이 새로 만들어지고 메소
드를 빠져나오기 전에 종료된다. 결국 JdbcTemplate의 메소드를 사용히는 UserDao는
각 메소드마다 하나씩의 독립적인 트랜잭션으로 실행될 수밖에 없다.

앞에서 만든 upgradeAIIOrNothing() 테스트 메소드에는 5
개의 시용자 오브젝트
를 가져와 순차적으로 업그레이드 가능성을 확인하다가 2번째 시용에서 레벨을 변경
해서 UserDao
의 update() 메소드를 호출한다. JdbcTemplate을 사용하는 UserDao의
update( ) 메소드는 자동으로 UPDATE 작업의 트랜잭션을 종료시킬 것이고， 수정 결과는
영구적으로 DB
에 반영된다. 따라서 그 후에 예외가 발생하든 서버가 다운되든 상관없
이 그 두 번째 사용자의 레벨 업데이트 결과는 DB
에 남아 있는 것이다. 트랜잭션 작업
은 내구성을 보장받기 때문에 일단 커빗되고 나면 DB 서버가 다운되더라도 그 결과는
DB에그대로남는다.

그림 5-2는 UserService와 UserDao를 통해 트랜잭션이 일어나는 과정을 나타낸 것
이다. upgradeLevels()에서 세 번에 걸쳐 UserDao의 update()를 호출했다고 해보자.
UserDao는 JdbcTemplate을 통해 매번 새로운 DB 커넥션과 트랜잭션을 만들어 시용한
다. 첫 번째 update( )를 호출할 때 작업이 성공했다면 그 결괴는 이미 트랜잭션이 종료
되면서 커빗됐기 때문에 두 번째 update( )를 호출하는 시점에서 오류가 발생해서 작업
이 중단된다고 해도 첫 번째 커빗한 트랜잭션의 결과는 DB
에 그대로 남는다.

UserService UserDa。
Connection
(JdbcTemplate) + Transaction

upgnHÚLlWels() (
userDao.updateO
userDao
.u때at터) update() Connection
userDao.updateO + Transaction

Connection

+ Transaction
그림 5-2 UserService와 UserDa。의 트랜잭션 처리 과정

데이터 액세스 코드를 DAO로 만들어서 분리해놓았을 경우에는 이처럼 DAO 메소드
를 호출할 때마다 하나의 새로운 트랜잭션이 만들어지는 구조가 될 수밖에 없다. DAO


메소드 내에서 JDBC API를 직접 사용하든 JdbcTemplate을 이용하든 마찬가지다.
DAO 메소드에서 DB 커넥션을 매번 만들기 때문에 어쩔 수 없이 나타나는 결과다. 결
국 DAO를 시용하면 비즈니스 로직을 담고 있는 UserService 내에서 진행되는 여러 가
지 작업을 하나의 트랜잭션으로 묶는 일이 불가능해진다.

그렇다면 upgradeLevels()
와 같이 여러 번 DB
에 업데이트를 해야 히는 작업을 하나
의 트랜잭션으로 만들려면 어떻게 해야 할까? 어떤 일련의 작업이 하나의 트랜잭션으
로 묶이려면 그 작업이 진행되는 동안 DB 커넥션도 하나만 사용돼야 한다. 앞에서 설
명한 것처럼 트랜잭션은 Connection 오브젝트 안에서 만들어지기 때문이다. 하지만 현
재는 UserService에서 DB 커넥션을 다룰 수 있는 방법이 없다.

비즈니스 로직 내의 트랜잭션 경계설정
이 문제를 해결하기 위해 DAO 메소드 안으로 upgradeLevels() 메소드의 내용을 옮기
는 방법을 생각해볼 수 있다. DAO 안에서 리스트 5-37과 같이 JDBC API를 직접 이
용한다면 하나의 DB 커넥션과트랜잭션을만들어놓고 여러 명의 사용자에 대한정보를
업데이트할 수 있다. 하지만 이 방식은 비즈니스 로직과 데이터 로직을 한데 묶어버리
는 한심한 결과를 초래한다. 지금까지 성격과 책임이 다른 코드를 분리하고， 느슨하게
연결해서 확장성을 좋게 하려고 많은 수고를 해왔는데 여기서 트랜잭션 문제를 해결한
답시고 JDBC API와 User의 업그레이드 정책을 담은 코드를 뒤죽박죽으로 만드는 건
도저히용납할수없다.
UserService와 UserDao를 그대로 둔 채로 트랜잭션을 적용하려면 결국 트랜잭션
의 경계설정 작업을 UserService 쪽으로 가져와야 한다. 프로그램의 흐름을 볼 때
upgradeLevels() 메소드의 시작과 함께 트랜잭션이 시작하고 메소드를 빠져나올 때 트
랜잭션이 종료돼야 하기 때문이다. UserDao가 가진 SQL이나 JDBC API를 이용한 데
이터 액세스 코드는 최대한 그대로 남겨둔 채로 UserService에는 트랜잭션 시작과 종
료를 담당하는 최소한의 코드만 가져오게 만들면 어느 정도 책임이 다른 코드를 분리해
둔 채로 트랜잭션 문제를 해결할 수 있다.
트랜잭션 경계를 upgradeLevels() 메소드 안에 두려면 DB 커넥션도 이 메소드 안
에서 만들고， 종료시킬 펼요가 있다. 결국 upgradeLevels() 메소드 안에 트랜잭의 경계
설정을 리스트 5-38과 같은 구조로 만들어야 한다.

얄L 서비스 추ε탤f 357


리스트 5-38u∞radeLevels의 트랜잭션 경계설정 구조

public void upgradeLevels() throws Exception {

(1) DB Connection 생성
(2) 트랜잭션 시작
try (

(3) DAO 메소드 호훌
(4) 트랜잭션 커맛
catch(Exception e) {

(5) 트랜잭션 톨백
throw e;

finally (

(6) DB Connection 종료
트랜잭션을 사용하는 전형적인 JDBC 코드의 구조다. 그런데 여기서 생성된
Connection 오브젝트를 가지고 데이터 액세스 작엽을 진행하는 코드는 UserDao
의
update( ) 메소드 안에 있어야 한다. 트랜잭션 때문에 DB 커넥션과 트랜잭션 관련 코
드는 어쩔 수 없이 UserService로 가져왔지만 순수한 데이터 액세스 로직은 UserDao
에 둬야 하기 때문이다. UserDao의 update() 메소드는 반드시 upgradeLevels() 메소드
에서 만든 Connection을 사용해야 한다. 그래야만 같은 트랜잭션 안에서 동작하기 때
문이다. 기존의 JdbcTemplate처럼 매번 새로운 Connection 오브젝트를 만들어버리면，
upgradeLevels() 안에서 시작한 트랜잭션과는 무관한 별개의 트랜잭션이 만들어지므
로주의해야한다.

UserService에서 만든 Connection 오브젝트를 UserDao에서 사용하려면 DAO 메소
드를 호출할 때마다 Connection 오브젝트를 파라미터로 전달해줘야 한다. 결국 DAO
메소드들은 리스트 5-39와 같이 변경돼야 할 것이다.

리스트 5-39 Con
nect때1 오브젝트를 파라미터로 전달받는 UserD∞ 메소드

public interface UserDao (
public void add(Connection c, User user);
public User get(Connection c, String id);

public void update(Connection c, User userl);


트랜잭션을 담고 있는 Connection을 공유하려면 더 해줄 일이 있다. UserService의
upgradeLevels()
는 UserDao
의 update()
를 직접 호출하지 않는다. UserDao를 시용하는
것은 사용자별로 업그레이드 작업을 진행하는 upgradeLevel() 메소드다. 결국 리스트
5-40과 같이 UserService의 메소드 사이에도 같은 Connection 오브젝트를 사용하도록
파라미터로 전달해줘야만 한다.

리스트 5-40 Connection율 공유하도록 수정한 UserService 메소드

Connection c =

때

띠

class UserService {
public void upgradeLevels() throws Exception {
\트랜잭션{ \try -----
upgradeLevel(cuser);,
麗앓摩號펀
User user) {c，
하없

」

때

뼈

빼

。「
」


m rn “emmω
Il

v

”

”m
O
Mo m ·m”” ‘r u ” .

v , ,


이렇게 Connection 오브젝트를 전달해서 사용하면 UserService의 upgradeLevels()
안에서 시작한 트랜잭션에 UserDao
의 메소드들도 참여하게 할 수 있다
.
upgradeLevels() 메소드 안에서 트랜잭션의 경계설정 작업이 일어나야 하고， 그 트랜
잭션을 갖고 있는 DB 커넥션을 이용하도록 해야만 별도의 클래스에 만들어둔 DAO
내의 코드도 트랜잭션이 적용될 테니 결국 이 방법을 사용할 수밖에 없다.

얄L 서비스 추S회 359


UserService 트랜잭션 경계설정의 문제점

UserService와 UserDao를 이런 식으로 수정하면 트랜잭션 문제는 해결할 수 있겠지만，

그 대신 여러 가지 새로운 문제가 발생한다.

첫째는 DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 JdbcTemplate
을 더 이상 활용할 수 없다는 점이다. 결국 JDBC API를 직접 사용하는 초기 방식
으로 돌아가야 한다. try/catch/finally 블록은 이제 UserService 내에 존재하고，
UserService의 묘드는 JDBC 작업 묘드의 전형적인 문제점을 그대로 가질 수밖에 없다.

두 번째 문제점은 DAO의 메소드와 비즈니스 로직을 담고 있는 UserService의 메

소드에 Connection 파라미터가 추가돼야 한다는 점이다. upgradeLevels()
에서 시용

하는 메소드의 어딘가에서 DAO를 필요로 한다면 그 사이의 모든 메소드에 걸쳐서

Connection 오브젝트가 계속 전달돼야 한다. UserService는 스프링 빈으로 선언해서

싱글톤으로 되어 있으니 UserService
의 인스턴스 변수에 이 Connection을 저장해뒀다

가 다른 메소드에서 사용하게 할 수도 없다. 멀티스레드 환경에서는 공유하는 인스턴

스 변수에 스레드별로 생성하는 정보를 저장하다기는 서로 덮어쓰는 일이 발생하기 때

문이다. 결국 트랜잭션이 필요한 작업에 참여하는 UserService의 메소드는 Connection

따라미터로 지저분해질 것이다.

세 번째 문제는 Connection 파라미터가 UserDao 인터페이스 메소드에 추가되면

UserDao는 더 이상 데이터 액세스 기술에 독립적일 수가 없다는 점이다. JPA나 하이버

네이트로 UserDao의 구현 방식을 변경하려고 하면 Connection 대신 EntityManager나

Session 오브젝트를 UserDao 메소드가 전달받도록 해야 한다. 결국 UserDao 인터페이

스는 바뀔 것이고， 그에 따라 UserService 코드도 함께 수정돼야 한다. 기껏 인터페이

스를 사용해 DAO를 분리하고 DI를 적용했던 수고가 물거품이 되고 말 것이다.

마지막으로 DAO 메소드에 Connection 파라미터를 받게 하면 테스트 코드에도 영
향을 미친다. 지금까지 DB 커넥션은 전혀 신경 쓰지 않고 테스트에서 UserDao를 사용
할 수 있었는데， 이제는 테스트 묘드에서 직접 Connection 오브젝트를 일일이 만들어서
DAO 메소드를 호출하도록 모두 변경해야 한다.

5.2.3 트랜잭션동기화
비즈니스 로직을 담고 있는 UserService 메소드 안에서 트랜잭션의 경계를 설정해 관
리하려면 지금까지 만들었던 깔끔하게 정리된 코드를 포기해야 할까? 아니면， 트랜잭

션 기능을 포기해야 할까?


물론 둘 다 아니다. 스프링은 이 딜레마를 해결할 수 있는 멋진 방법을 제공해준다.

Connection 파라미터 제거
먼저 Connection을 파라미터로 직접 전달히는 문제를 해결해보자. upgradeLevels()
메소드가 트랜잭션 경계설정을 해야 한다는 사실은 피할 수 없다. 따라서 그 안에서

Connection을 생성하고 트랜잭션 시작과 종료를 관리하게 한다. 대신 여기서 생성된
Connection 오브젝트를 계속 메소드의 파라미터로 전달하다가 DAO를 호출할 때 시용
하게 하는 건 피하고 싶다. 이를 위해 스프링이 제안히는 방법은 독립적인 트랜잭션 동기
화lransaction synchron때lon 방식이다. 트랜잭션 동기화란 UserService에서 트랜잭션을 시
작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고， 이후에 호출되
는 DAO의 메소드에서는 저장된 Connection을 가져다가 사용하게 하는 것이다. 정확
히는 DAO가 사용히는 JdbcTemplate이 트랜잭션 동기화 방식을 이용하도록 하는 것이

다. 그리고 트랜잭션이 모두 종료되면 그때는 동기화를 마치면 된다.
그림 5-3은 트랜잭션 동기화 방식을 시용한 경우의 작업 흐름을 보여준다.

(1) (12)

upgradeLevelsO (
dao.update();
dao.updateO;
dao.update();.

updateO


그림 5-3 트랜잭션 동기화톨 사용한 경우의 작업 흐룸

(1) UserService는 Connection을 생성하고 (2) 이를 트랜잭션 동기화 저장소에 저장
해두고 Connection
의 setAutoCommit(false)
를 호출해 트랜잭션을 시작시킨 후에 본
격적으로 DAO의 기능을 이용하기 시작한다. (3) 첫 번째 update ( ) 메소드가 호출되
고. update() 메소드 내부에서 이용히는 JdbcTemplate 메소드에서는 가장 먼저 (4) 트
랜잭션 동기화 저장소에 현재 시작된 트랜잭션을 가진 Connection 오브젝트가 존재하
는지 확인한다. (2) upgradeLeve15 () 메소드 시작 부분에서 저장해둔 Connection을 발
견하고 이를 가져온다. 가져온 (5) Connection을 이용해 PreparedStatement를 만들
어 수정 SQL을 실행한다. 트랜잭션 동기화 저장소에서 DB 커넥션을 가져왔을 때는
JdbcTemplate은 Connection을 닫지 않은 채로 작업을 마친다. 이렇게 해서 트랜잭션
5징-서비스 추상회 361


안에서 첫 번째 DB 작업을 마쳤다. 여전히 Connection은 열려 있고 트랜잭션은 진행
중인 채로 트랜잭션 동기화 저장소에 저장되어 있다.

(6) 두 번째 update( )가 호출되면 이때도 마찬가지로 (7) 트랜잭션 동기화 저장소에
서 Connection을 가져와 (8) 시용한다. (9) 마지막 update()
도 (1 0) 같은 트랜잭션을 가
진 Connection을 가져와 (11) 시용한다.
트랜잭션 내의 모든 작업이 정상적으로 끝났으면 UserService는 이제 (12)
Connection
의 commitO을 호출해서 트랜잭션을 완료시킨다. 마지막으로 (1 3) 트랜잭션
저장소가 더 이상 Connection 오브젝트를 저장해두지 않도록 이를 제거한다. 어느 작
업 중에라도 예외상황어 발생하면 UserService는 즉시 Connection
의 rollback( )을 호
출하고 트랜잭션을 종료할 수 있다. 물론 이때도 트랜잭션 저장소에 저장된 동기화된
Connection 오브젝트는 제거해줘야 한다.

트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저
장하고 관리하기 때문에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌
이날염려는없다.

이렇게 트랜잭션 동기화 기법을 사용하면 파라미터를 통해 일일이 Connection 오
브젝트를 전달할 필요가 없어진다. 트랜잭션의 경계설정이 필요한 upgradeLevels()
에서만 Connection을 다루게 하고， 여기서 생성된 Connection과 트랜잭션을 DAO의
JdbcTemplate이 사용할 수 있도록 별도의 저장소에 통기화하는 방법을 적용하기만 하
면 된다. 더 이상 로직을 담은 메소드에 Connection 타입의 파라미터가 전달될 필요도
없고. UserDao의 인터페이스에도 일일이 JDBC 인터페이스인 Connection을 사용한다
고노출할펼요가없다.

트랜잭션동기화적용
문제는 멀티스레드 환경에서도 안전한 트랜잭션 동기화 방법을 구현하는 일이 기술적
으로 간단하지 않다는 점인데 다행히도 스프링은 JdbcTemplate과 더불어 이런 트랜잭
션 동기화 기능을 지원히는 간단한 유틸리티 메소드를 제공하고 있다.
리스트 5-41
은 트랜잭션 동기화 방법을 적용한 UserService 클래스의 코드다.

리스트 5-41 트랜잭션 동기화 방식을 적용한 UserServi∞

private DataSource dataSource;
public void setDataSource(DataSource dataSource) {I ~~tior을 생성할 때 앵할

DataSou
n∞률 0 받도록 효따

this.dataSource =dataSource;


‘ 트랜잭션 동기화 관리자를 이용해public void upgradeLevels() throws Exception ( ~ 동기화쟁을초기회한다

TransactionSynchronizationManager.initSynchronization( );

DB 커넥션을 생성하고 트랜잭Connection c =DataSourceUtils.getConnection(dataSource);
션을 시ξ딴κt 이후의 DAO 작
c.setAutoCommit(false); 업은 모두 여기서 시작한 트랜

DB 커넥션 생성과 동기화훌
잭션안에서
진행된다
try ( 함께 해주는 유틸리티 메소드
List<User> users = userDao.getAll();
for (User user users) {
if (canUpgradeLevel(user )) (
upgradeLevel (user );

C.commit () ; _ 정상적으로 ξ엉을 마치
연 트랜잭션 커잇
} catch (Exception e) (

c. rollback () ; 예외가발생하언 롤백한다
throw e;
l 스프링 유틸리티 메소드를 이용해

} finally ( ~ 머 커넥션을 인전하게 닫는다
DataSourceUtils.releaseConnection(c, dataSource );
TransactionSynchronizationManager .unbindResource (this.dataSource);

동기회작업종료및정리


UserService에서 DB 커넥션을 직접 다룰 때 DataSource가 필요하므로 DataSource
빈에 대한 DI 설정을 해둬야 한다.

스프링이 제공하는 트랜잭션 동기화 관리 클래스는 TransactionSynchronizationManager
다. 이 클래스를 이용해 먼저 트랜잭션 동기화 작업을 초기화하도록 요청한다. 그리고
DataSourceUtils
에서 제공히는 getConnection() 메소드를 통해 DB 커넥션을 생성한
다. DataSource에서 Connection을 직접 가져오지 않고， 스프링이 제공하는 유틸리티 메
소드를 쓰는 이유는 이 DataSourceUtils
의 getConnection( ) 메소드는 Connection 오
브젝트를 생성해줄 뿐만 아니라 트랜잭션 동기회에 사용하도록 저장소에 바인딩해주기
때문이다. 동기화 준비가 됐으면 트랜잭션을 시작하고 DAO의 메소드를 사용하는 트랜
잭션 내의 작업을 진행한다. 트랜잭션 동기화가 되어 있는 채로 JdbcTemplate을 사용하
면 JdbcTemplate
의 작업에서 동기화시킨 DB 커넥션을 사용하게 된다. 결국 UserDao를
통해 진행되는 모든 JDBC 작업은 upgradeLevels() 메소드에서 만든 Connection 오브
젝트를 시용하고 같은 트랜잭션에 참여하게 된다. 작업을 정상적으로 마치면 트랜잭션
을 커멋해준다. 그리고 스프링 유틸리티 메소드의 도움을 받아 커넥션을 닫고 트랜잭션

5징-서비스 추상화 363


동기화를 마치도록 요청하면 된다. 만약 예외가 발생하면 트랜잭션을 롤백해준다. 이때
도 DB 커넥션을 닫는 것과 동기화 작업 중단은 동일하게 진행해야 한다.

JDBC의 트랜잭션 경계설정 메소드를 사용해 트랜잭션을 이용히는 전형적인 코드에
간단한 트랜잭션 동기화 작업만 붙여줌으로써， 지저분한 Connection 파라미터의 문제
를깔끔히해결했다.

트랜잭션테스트보완
이제 트랜잭션이 적용됐는지 테스트를 해보자. 앞에서 만든 UserServiceTest
의
upgradeAIIOrNothing() 태스트 메소드에 리스트 5-42와 같이 dataSource 빈을 가져
와 주입해주는 묘드를 추가해야 한다. 태스트용으로 확장해서 만든 TestUserService는
UserService
의 서브클래스이므로 UserService와 마찬가지로 트랜잭션 동기화에 필요
한 DataSource를 DI 해줘야 하기 때문이다.

리스트 5-42 동기화가 적용된 Ul옹rServ
ice어| 따라 수정된 테스트

OAutowired DataSource dataSource;

@Test

public void upgradeAllOrNothing() throws Exception (
UserService testUserService =new TestUserService(users .get(3) .getld());
testUserService.setUserDao(this.userDao);
testUserService.setDataSource(this.dataSource);

upgradeAIIOrNothing() 테스트를 다시 실행해보자. 이번엔 테스트가 성공할 것이
다. 새로운 기술적인 요구사햄l 맞게 사용자 레벨 업그레이드 작업에 트랜잭션이 적용
됐다! 이제 모든 사용자의 레벨 업그레이드 작업을 완료하지 못하고 작업이 중단되면 이
미 변경된 사용자의 레벨도 모두 원래 상태로 돌아갈 것이다.

나머지 태스트도 문제없이 동작하게 하려면 UserService의 dataSource 프로퍼티 설
정을 리스트 5-43과 같이 설정파일에 추가해줘야 한다. TestUserService를 직접 구성
하는 upgradeAIIOrNothing() 태스트외는 달리. upgradeLevels() 테스트는 스프링 컨
테이너가 초기화한 userService를 시용해야 하기 때문이다.


리스트 5-43 da떠Sou
rce 프로퍼티를 추가한 userService 빈 설정

<bean id=“userService" class="sprin매gboα00lk .user. serviκce.UserService
“

1밍
이야)끼


<property name="userDao" ref="userDao" /)
<property name=념ataSource" ref="dataSource'’ /)
</bean)

JdbcTemplate과 트랜잭션 동기화
한 가지 궁금한 것이 있다. JdbcTemplate
의 동작방식이다. 지금까지 JdbcTemplate은
update( )나 query() 같은 JDBC 작업의 뱀플릿 메소드를 호출하면 직접 Connection
을 생성하고 종료히는 일을 모두 담당한다고 설명했다. 태스트에서 특별한 준비 없이
DAO
의 메소드를 직접 사용했을 때도 제대로 동작히는 것을 보면 스스로 Connection
을생성해서 사용한다는사실을알수 있다.
JdbcTemplate은 영리하게 동작하도록 설계되어 있다. 만약 미리 생성돼서 트랜잭
션 동기화 저장소에 등록된 DB 커넥션이나 트랜잭션이 없는 경우에는 JdbcTemplate
이 직접 DB 커넥션을 만들고 트랜잭션을 시작해서 JDBC 작업을 진행한다. 반면에
upgradeLevels() 메소드에서처럼 트랜잭션 동기화를 시작해놓았다면 그때부터 실행되
는 JdbcTemplate의 메소드에서는 직접 DB 커넥션을 만드는 대신 트랜잭션 동기화 저
장소에 들어 있는 DB 커넥션을 가져와서 사용한다. 이를 통해 이미 시작된 트랙잭션에
참여하는것이다.
따라서 DAO를 시용할 때 트랜잭션이 굳이 펼요 없다면 바로 호출해서 사용해도 되
고，
DAO 외부에서 트랜잭션을 만들고 이를 관리할 필요가 있다면 미리 DB 커넥션을
생성한 다음 트랜잭션 동기화를 해주고 사용하면 된다. 트랜잭션 동기화를 해주고 나
면 DAO에서 시용하는 JdbcTemplate은 자동으로 트랜잭션 안에서 동작할 것이다. 따라
서 트랜잭션 적용 여부에 맞춰 UserDao 코드를 수정할 펼요가 없다. JDBC 코드의 try/
catch/finally 작업 흐름 지원， SQLException
의 예외 변환과 함께 JdbcTemplate
이 제
공해주는 세 가지 유용한 기능 중 하나다.
비즈니스 로직 레벨의 트랜잭션을 적용했지만 JdbcTemplate을 포기할 필요도 없고，
지저분한 Connection 파라미터를 계속 물고 다니지 않아도 된다. UserDao는 여전히 데
이터 액세스 기술에 종속되지 않는 깔끔한 인터페이스 메소드를 유지하고 있다. 그리고
태스트에서 DAO를 직접 호출해서 사용하는 것도 아무런 문제가 되지 않는다.
트랜잭션 개념 도입에 따른 거의 대부분의 문제가 해결된 듯하다. 하지만 만족하긴
이르다. 스프링에서는 지금부터가 트랜잭션 적용에 대한 본격적인 고민의 시작이다.

5징-서비스 추상화 365



5.2.4 트랜잭션 서비스 추상화
지금까지 만들어온 U
serService와 UserDao. UserDaoJdbc는 JDBC API를 사용하고 트
랜잭션을 적용했으면서도， 책임과 성격에 따라 데이터 액세스 부분과 비즈니스 로직을
잘분리， 유지할수 있게 만든뛰어난코드다. JDBC를사용하면서 이보다더 깔끔한코

드를 만들기는 힘들 것이다.

기술과 환경에 종속되는 트랜잭션 경계설정 코드

그런데 새로운 문제가 발생했다. 이 사용자 관리 모률을 구매해서 사용하기로 한 G 사

에서 들어옹 새로운 요구 때문이다. 지금까지 만든 코드로도 업체별 DB 연결 방법은 자

유롭게 바꿔서 사용할수 있다.DB 연결 방법이 바뀌어도
UserDao나
UserService 코드

는 수정하지 않아도 된다. DataSource 인터페이스와 DI를 적용한 덕분이다.

하지만 트랜잭션 처리 묘드를 담은 UserService에서 문제가 발생했다.G 사는 여러

개의 DB를 사용하고 있다. 그래서 하나의 트랜잭션 안에서 여러 개의 DB
에 데이터를

넣는 작업을 해야 할 필요가 발생했다. 한 개 이상의 DB로의 작업을 하나의 트랜잭션

으로 만드는 건 JDBC
의 Connection을 이용한 트랜잭션 방식인 로컬 트랜잭션으로는

불가능하다. 왜냐하면 로컬 트랜잭션은 하나의 DB Connection
에 종속되기 때문이다.

따라서 각 DB와 독립적으로 만들어지는 Connection을 통해서가 아니라， 별도의 트랜

잭션 관리자를 통해 트랜잭션을 관리히는 글로벌 트랜잭션global tran앓ction 방식을 사용해

야 한다. 글로벌 트랜잭션을 적용해야 트랜잭션 매니저를 통해 여러 개의 DB가 참여하

는 작업을 하나의 트랜잭션으로 만들 수 있다. 또 JMS와 같은 트랜잭션 기능을 지원하

는 서비스도 트랜잭션에 참여시킬 수 있다.
자바는 JDBC 외에 이런 글로벌 트랜잭션을 지원히는 트랜잭션 매니저를 지원하기
위한 API인 JTAJava Transaction API를 제공하고 있다.

그림 5-4는 JTA를 이용해 여러 개의 DB 또는 메시징 서벼에 대한 트랜잭션을 관리

하는 방법을 보여준다. 애플리케이션에서는 기존의 방법대로 DB는 JDBC, 메시정 서

버라면 JMS 같은 API를 사용해서 펼요한 작업을 수행한다. 단， 트랜잭션은 JDBC나

JMS API를 시용해서 직접 제어하지 않고 JTA를 통해 트랜잭션 매니저가 관리하도록

위임한다. 트랜잭션 매니저는 DB와 메시징 서벼를 제어하고 관리하는 각각의 리소스

매니저와
XA 프로토콜을통해 연결된다. 이를통해 트랜잭션 매니저가실제 DB와메

시정 서버의 트랜잭션을 종합적으로 제어할 수 있게 되는 것이다. 이렇게 JTA를 이용

해 트랜잭션 매니저를활용하면 여러 개의 DB나메시정 서버에 대한작업을하나의 트


트랜잭션 매니저
트랜잭션 서비스
XA
트랜잭션 매니저
트랜잭션 서비스
XA
랜잭션으로 통합히는 분산 트랜잭션 또는 글로벌 트랜잭션이 가능해진다. 분산 트랜잭
션에 관한 내용은 11
징에서 자세히 설명할 것이다. 일단은 하나 이상의 DB가 참여히는
트랜잭션을 만들려면 JTA를 사용해야 한다는 사실만 기억해두자.

JMS

XA


그림 5-4JTA톨 통한 글로벌/분산 트랜잭션 관리

아무튼 G 사의 요청은 서버가 제공하는 트랜잭션 매니저와 트랜잭션 서비스를 사용할
테니 JDBC API가 아닌 JTA를 사용해 트랜잭션을 관리하게 해달라는 것이다.
JTA를 이용한 트랜잭션 처리 코드의 전형적인 구조는 리스트 5-44와 같다.

리스트 5-44
JTA률 이용한 트랜잭션 코드 구조

InitialContext ctx =new InitialContext();
UserTransaction tx = (UserTransaction)ctx.lookup(USER_TX_JNDI_NAME);

JNDI률 이용해 서버의 U똥
rTran뚱ICtíon 오브젝트톨 가져온다.

tx .begin();

Connection c = dataSource.getConnection();
--을 JNDI로가져온
da떠없Jr∞를사용해야효되

try (
// 데이터 액세스 코드
tx .commi t();

} catch (Exception e) (
tX .rollback();
throw e;

} finally (

c. close() ;
JTA를 이용한 방법으로 바뀌긴 했지만 트랜잭션 경계설정을 위한 구조는 JDBC를
사용했을 때와 비슷하다. Connection
의 메소드 대신에 UserTransaction
의 메소드를 사
용한다는 점을 제외하면 트랜잭션 처리 방법은 별로 달라진 게 없다. 코드의 구조도 비
슷하다. 문제는 JDBC 로컬 트랜잭션을 JTA를 이용하는 글로벌 트랜잭션으로 바꾸려
면 UserService의 코드를 수정해야 한다는 점이다. 로컬 트랜잭션을 사용하면 충분한

5징-서비스 추S화 367


고객을 위해서는 JDBC를 이용한 트랜잭션 관리 코드를 G 사처럼 다중 DB를 위한 글
로벌 트랜잭션을 필요로 하는 곳을 위해서는 JTA를 이용한 트랜잭션 관리 묘드를 적용
해야 한다는 문제가 생긴다. UserService는 자신의 로직이 바뀌지 않았음에도 기술환
경에 따라서 코드가 바뀌는 코드가 돼버리고 말았다.

두 가지 종류의 트랜잭션 묘드를 가지고 고민을 하는 중에 또 다른 고객관리 모률
구매 고객인 Y 사에서 연락이 왔다. 자신들이 하이벼네이트를 이용해 UserDao를 직
접 구현했다고 알려왔다. UserService와 UserDao는 DI를 통해 연결되어 있기 때문에，
UserService를 수정하지 않고도 UserDao의 데이터 액세스 기술은 얼마든지 변경이 가
능하다는 점을 영리하게 활용한 것이다.

그런데 문제는 하이버네이트를 이용한 트랜잭션 관리 코드는 JDBC나 JTA의 코드
와는 또 다르다는 것이다. 하이버네이트는 Connection을 직접 시용하지 않고 Session
이라는 것을 사용하고， 독자적인 트랜잭션 관리 API를 시용한다. 그렇다면 이번엔
UserService를 하이버네이트의 Session과 Transaction 오브젝트를 사용히는 트랜잭션
경계설정 코드로 변경할 수밖에 없게 됐다.

트랜잭션 API의 의존관계 문제와 해결책
이런 문제를 어떻게 해결할 것인가? UserDao가 DAO 패턴을 사용해 구현 데이터 액세
스 기술을 유연하게 바꿔서 시용할 수 있게 했지만 UserService에서 트랜잭션의 경계
설정을 해야 할 필요가 생기면서 다시 특정 데이터 액세스 기술에 종속되는 구조가 되
고말았다.
UserService에 트랜잭션 경계설정 묘드를 도입한 후에 클래스의 의존관계는 그림
5-5와 같이 돼버렸다.

UserService

c . comrnit ();
c. rollback () ;
JDBC 트랜잭션 API
와‘ l , {
「

JdbcTemplate과 동기화 l ’ ’

” “

…

」

,,

하는 API로 인해 JDBC I

DAI
l

때의존하게된다 UserOaoJdbc UserOaoHibernate

그림 5-5 트랜잭션 도입으로 인한 새로운 의존관계
원래 UserService는 UserDao 인터페이스에만 의존하는 구조였다. 그래서 DAO 클래


스의 구현 기술이 JDBC에서 하이버네이트나 여타 기술로 바뀌더라도 UserService
코드는 영향을 받지 않았다. 전형적인 OCP 원칙을 지키는 코드였다. 문제는 JDBC
에 종속적인 Connection을 이용한 트랜잭션 코드가 UserService에 등장하면서부터
UserService는 UserDaoJdbc
에 간접적으로 의존하는 묘드가 돼버렸다는 점이다. 기껏

UserDao 인터페이스를 사이에 두고， 데이터 액세스 기술의 다양한 예외도 모두 추상화
하고，
DI를 적용해서 구현 클래스에 대한 의존도를 완벽하게 제거했는데 트랜잭션 때문
에 그동안의 수고가 허사가 되고 밀댔다.

UserService
의 묘드가 특정 트랙잭션 방법에 의존적이지 않고 독립적일 수 있게
만들려면 어떻게 해야 할까? UserService의 메소드 안에서 트랜잭션 경계설정 묘드
를 제거할 수는 없다. 하지만 특정 기술에 의존적인 Connection, UserTransaction,
Session/Transaction API 등에 종속되지 않게 할수 있는 방법은 있다.

다행히도 트랜잭션의 경계설정을 담당하는 묘드는 일정한 패턴을 갖는 유사한 구조

다. 이렇게 여러 기술의 사용방법에 공통점이 있다면추상화를생각해볼수 있다. 추상

화란 하위 시스뱀의 공통점 뽑아내서 분리시키는 것을 말한다. 그렇게 하면 하위 시스

템이 어떤 것인지 알지 못해도 또는 하위 시스뱀이 바뀌더라도 일관된 방법으로 접근

할수가있다.

DB
에서 제공히는
DB
클라이언트라이브러리와
API는서로전혀 호환이 되지 않는
독자적인 방식으로 만들어져 있다. 하지만 모두 SQL을 이용하는 방식이라는 공통점이
있다. 이 공통점을 뽑아내 추상화한 것이 JDBC다. JDBC라는 추상화 기술이 있기 때
문에 자바의 DB 프로그램 개발자는 DB
의 종류에 상관없이 일관된 방법으로 데이터 액
세스 코드를 작성할 수가 있다.

그렇다면 트랜잭션 처리 코드에도 추상화를 도입해볼 수 있지 않을까? JDBC, JTA,
하이버네이트， JPA, JDO, 심지어는 JMS도 트랜잭션 개념을 갖고 있으니 모두 그 트
랜잭션 경계설정 방법에서 공통점이 있을 것이다. 이 공통적인 특징을 모아서 추상화된
트랜잭션 관리 계층을 만들 수 있다. 그리고 애플리케이션 코드에서는 트랜잭션 추상

계층이 제공히는 API를 이용해 트랜잭션을 이용하게 만들어준다면 특정 기술에 종속되

지 않는 트랜잭션 경계설정 묘드를 만들 수 있을 것이다.

스프링의 트랜잭선 서비스 추4i간확

스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화 기술을 제공하고 있다. 이를

이용하면 애플리케이션에서 직접 각 기술의 트랜잭션 API를 이용하지 않고도， 일관된

g앙-서비스 추S회 369


방식으로 트랜잭션을 제어하는 트랜잭션 경계설
정 작업이 가능해진다. 그림 5-6은 스
프링이 제공하는 트랜잭션 추상화 계층구조를 보여준다.


애율리
케이션계총

추상화계흥

,. -----------------------r-----------------------,


그림 5-tì 스프링의 트랜잭션 추상화 계흥

스프링이 제공히는 트랜잭션 추상화 방법을 UserService에 적용해보면 리스트 5-45와
같은 코드로 만들 수 있다.

리스트 5-45 스프링의 트랜잭션 추상화 API룰 적용한 U며radeLevels( )

public void upgradeLevels( ) (
JDBC
트랜잭션추싱

PlatformTransactionManager transactionManager = r-융 오브젝트 생성
new DataSourceTransactionManager(data$ource);

트랜잭션시작

TransactionStatus status =
transactionManager .getTransaction(new DefaultTransactionDefinition ()) ;
try{
τist
<User
) users = userDao.getAll();
for (User user users ) {
if (canUpgradeLevel(user)) (
upgradeLevel(user); 트랜잭션 안에서 진행되는 직업

transactionManager
.
commit
(s
tatu
s)
;
--융 트랜잭션 커잇

} catch (RuntimeException e) {

transactionMan
a
ger.rollba
c
k
(
statu
s)
;
--을 트랜잭션 커멋

throw e;


스프령이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스
는 PlatformTransactionManager
다. JDBC
의 로컬 트랜잭션을 이용한다
변 PlatformTransactionManager
를 구현한 DataSourceTransactionManager
를 사용하면 된다. 사용할 DB
의 DataSource
를 생성자 파라미터로 넣으면서
DataSourceTransactionManager
의 오브젝트를 만든다.

JDBC를 이용하는 경우에는 먼저 Connection을 생성하고 나서 트랜잭션을 시
작했다. 하지만 PlatformTransactionManager
에서는 트랜잭션을 가져오는 요청인
getTransaction() 메소드를 호출하기만 하면 된다. 필요에 따라 트랜잭션 매니저
가 DB 커넥션을 가져오는 작업도 같이 수행해주기 때문이다. 여기서 트랜잭션을 가
져온다는 것은 일단 트랜잭션을 시작한다는 의미라고 생각하자. 파라미터로 넘기는
Defa띠
tTransactionDefinition 오브젝트는 트랜잭션에 대한 속성을 담고 있다. 트랜
잭션 속성에 대해서는 뒤에서 다시 살펴보겠다.

이렇게 시작된 트랜잭션은 TransactionStatus 타입의 변수에 저장된다.
TransactionStatus는 트랜잭션에 대한 조작이 필요할 때 PlatformTransactionManager
메소드의 파라미터로 전달해주면 된다.

트랜잭션이 시작됐으니 이제 JdbcTemplate을 사용하는 DAO를 이용하는 작업을 진
행한다. 스프링의 트랜잭션 추상화 기술은 앞에서 적용해봤던 트랜잭션 동기화를 사용
한다. PlatformTransactionManager로 시작한 트랜잭션은 트랜잭션 동기화 저장소에
저장된다. PlatformTransactionManager를 구현한 DataSourceTransactionManager 오
브젝트는 JdbcTemplate에서 사용될 수 있는 방식으로 트랜잭션을 관리해준다. 따라서
PlatformTransactionManager를 통해 시작한 트랜잭션은 UserDao의 JdbcTemplate 안
에서사용된다.

트랜잭션 작업을 모두 수행한 후에는 트랜잭션을 만들 때 돌려받은
TransactionStatus 오브젝트를 파라미터로 해서 PlatformTransactionManager
의
commit() 메소드를 호출하면 된다. 예외가 발생하면 rollback() 메소드를 부른다.

트랜잭션 추상회를 적용을 마쳤으니 이제 UserServiceTest 테스트를 다시 돌려보
자. 트랜잭션이 정상적으로 커멋되는 경우를 검증하는 upgradeLevels() 테스트와 트랜
잭션이 롤백되는 경우에 대한 테스트인 upgradeAllOrNothing() 태스트 모두 성공적으
로끝날것이다.

!rct_ 서비스추상화 371


트랜잭션 기술 설정의 분리
트랜잭션 추상화 API를 적용한 UserService 코드를 JTA를 이용하는 글로벌 트랜잭션
으로 변경하려면 어떻게 해야 할까? 방법은 간단하다. PlatformTransactionManager
구현 클래스를 DataSourceTransactionManager에서 JTATransactionManager로 바꿔
주기만 하면 된다. JTATransactionManager는 주요 자바 서버에서 제공히는 JTA 정
보를 JNDl를 통해 자동으로 인식히는 기능을 갖고 있다. 따라서 별다른 설정 없이
JTATransactionManager를 사용하기만 해도 서버의 트랜잭션 매니저
/서비스와 연동해
서동작한다.
JTA로 바꾸려면 upgradeLevels() 메소드의 첫 줄을 다음과 같이 수정해주면 된다.

PlatformTransactionManager txManager = new lTATrasactionManager();

만약 히이벼네이트로 UserDao를 구현했다면 HibernateTransactionManager를. JPA를
적용했다면 JPATransactionManager를 시용하면 된다. 모두 PlatformTransactionManager
인터페이스를 구현한 것이니 트랜잭션 경계설정을 위한 getTransaction(). commi t ().
rollback( ) 메소드를 사용한 코드는 전혀 손댈 필요가 없다.

하지만 어떤 트랜잭션 매니저 구현 클래스를 사용할지 UserService 코드가 알고 있
는 것은 Dl 원칙에 위배된다. 자신이 시용할 구체적인 클래스를 스스로 결정하고 생성
하지 말고 컨테이너를 통해 외부에서 제공받게 히는 스프링 Dl의 방식으로 바꾸자.

그렇다면 DataSourceTransactionManager는 스프링 빈으로 등록하고 UserService
가 Dl 방식으로 시용하게 해야 한다. 어떤 클래스든 스프링의 빈으로 등록할 때 먼
저 검토해야 할 것은 싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은
가 하는 점이다. 상태를 갖고 있고， 멀티스레드 환경에서 안전하지 않은 클래스를 빈
으로 무작정 등록하면 심각한 문제가 발생하기 때문이다. 스프링이 제공히는 모든
PlatformTransactionManager
의 구현 클래스는 싱글톤으로 사용이 기능하다. 따라서
안심하고 스프링의 싱글톤 빈으로 등록해도 좋다.

UserService에는 PlatformTransactionManager 인터페이스 타입의 인스턴스 변
수를 선언하고， 수정자 메소드를 추가해서 Dl가 가능하게 해준다. 일반적으로는 인
터페이스 이름과 변수 이름 수정자 메소드 이름을 모두 같은 것으로 통일하지만
PlatformTransactionManager의 경우는 관례적으로 transactionManager라는 이름을
사용한다. 스프링이 PlatformTransactionManager라는 긴 이름을 붙인 이유는 JTA의
TransactionManager 인터페이스와 혼동되지 않도록 하기 위해서일 뿐 다른 의미가 있
는건아니다.


UserService
에 추가했
던 DataSource 변수와 수정자 메
소드는 제거
해도 된다. UserService
는 이제 PlatformTransactionManager
만 있으면
Connection 생성과 트랜잭션 경계설정 기능을 모두 이용할 수 있기 때문이
다. DataSource는 PlatformTransactionManager 타입의 빈에서 펼요할 뿐이다.
PlatformTransactionManager 타입 오브젝트를 생성하는 코드도 제거해준다. 이제 트
랜잭션 관련 기능이 필요하면 DI 받은 인스턴스 변수를 이용하면 된다.

리스트 5
-46은 PlatformTransactionManager를 빈으로 독립하고 DI 받아서 시용하
도록 수정한 UserService 클래스다.

리스트 5-46 트랜잭션 매니저률 빈으로 분리시킨 U똥rSe
rvi∞

public class UserService (

private PlatformTransactionManager transactionManager;

r-므로떠티 이뚱 관례를 따라 transactío뼈때g라고
만드는것이면리하다

public void setTransactionManager(PlatformTransactionManager
transactionManager) (
this.transactionManager =transactionManager;

public void upgradeLevels( ) (
미 받은 트랜잭션 매니저톨 공유해서 사용한다

TransactionStatus status τi

r-멀티스레드 환경에서도 안전하다

this .transactionManager .getTransaction(new
DefaultTransactionDefinition());

try (
List(User) users =userDao.getAll();
for (User user users ) {

if (canUpgradeLevel(user)) (
upgradeLevel(user);

this.transactionManager .commit (status );

} catch (RuntimeException e) (
this.transactionManager .rollback(status);
throw e;


다음은 UserService
에 DI 될 transactionManager 빈을 설정파일에 등록

~-서비스 추상화 373


하자. JDBC 기반의 단일 DB
를 사용하는 트랜잭션을 사용하려면 다음과 같이
DataSourceTransactionManager 클래스를 사용하면 된다. 스프링 설정파일을 리스트
5-47처럼 수정한다.

리스트 5-47 트랜잭션 매니저 빈올 둥록한 설정파일

<bean id="userService" class="springbook .user .service.UserService“>
<property name="userDao" ref="userDao‘ />
(property name="transactionManager" ref="transactionManager" 1>

</bean>

<bean id="transactionManager"
class="org.springframework.idbc.datasource.DataSourceTransactionManager">
<property name="dataSource" ref="dataSource" 1>
</bean>

DataSourceTransactionManager는 dataSource 빈으로부터 Connection을 가져와 트
랜잭션 처리를 해야 하기 때문에 dataSource 프로퍼티를 갖는다. userService 빈도 기
존의 dataSource 프로퍼티를 없애고 새롭게 추가한 transactionManager 빈을 DI 받도
록프로퍼티를설정한다.

태스트도 조금 손봐야 한다. 컨테이너가 만들어주는 UserService 빈을 가져와서 태
스트히는 경우는 상관없지만， 트랜잭션 예외상황을 태스트하기 위해 수동 DI를 히는
upgradeAIIOrNothing() 메소드는 수정이 필요하다. 리스트 5-48과 같이 스프링 컨태
이너로부터 transactionManager 빈을 @Autowired로 주입받게 하고 이를 직접 DI 해줘
야한다.

리스트 5-48 트랜잭션 매니저룰 수동 미 하도록 수정한 테스트

public class UserServiceTest (

öAutowired

PlatformTransactionManager transactionManager;

@Test
public void upgradeAllOrNothing() throws Exception (
UserService testUserService = new TestUserService(users.get(3).getld());

testUserService .setUserDao(userDao);
testUserService.setTransactionManager(transactionManager);

userSeα
lCe 빈의 프로퍼티 설정과 동일한 수동 미


이제 PlatformTransactionManager
의 적용이 모두 끝났으니 UserServiceTest 테스
트를 돌려보자. 보기 좋은 녹색 막대를 그리며 모든 테스트가 성공할 것이다.

이제 UserService는 트랜잭션 기술에서 완전히 독립적인 코드가 됐다. 트랜잭션을
JTA를 이용하는 것으로 싶다면 설정파일의 transactionManager 빈의 설정만 다음과
같이 고치면된다.

<bean id="transactionManager"
class="org .springframework.transaction . jta. JtaTransactionManager" />

JtaTransactionManager는 애플리케이션 서버의 트랜잭션 서비스를 이용하기 때문

에 직접 DataSource와 연동할 필요는 없다. 대신 JTA를 시용하는 경우는 DataSource도

서버가 제공해주는 것을 사용해야 한다.
OAO를 하이버네이트나 1PA. 100 등을 사용하도록 수정했다면 그에 맞게
transactionManager
의 클래스만 변경해주면 된다
UserService
의 코드는 조금도 수정

할필요가없다.

I~1 서비스 추상화와 단일 책임 원칙 꽉I

이제 스프링의 트랜잭션 서비스 추상화 기법을 이용해 다양한 트랜잭션 기술을 일관된
방식으로 제어할 수 있게 됐다. 덕분에 0, N 사와 더불어 G, Y 사에게도 사용자 모률
을 문제없이 납품할 수 있었다. 당연히 사용자 관리의 핵심 묘드 소스는 공개하지 않아
도 된다. 설정을 고치는 것만으로도 OB 연결 기술， 데이터 액세스 기술， 트랜잭션 기술
을 자유롭게 바꿔서 시용할 수 있기 때문이다.

수직， 수평 계층구조와 의존관계

이렇게 기술과 서비스에 대한추상화 기법을 이용하면 특정 기술환경에 종속되지 않는
포터블한 코드를 만들 수 있다
UserDao와 UserService는 각각 담당히는 묘드의 기능
적인 관심에 따라 분리되고， 서로 불필요한 영향을 주지 않으면서 독자적으로 확장이
가능하도록 만든 것이다. 같은 애플리케이션 로직을 담은 코드지만 내용에 따라 분리했

다. 같은계층에서 수평적인분리라고볼수있다.

트랜잭션의 추상회는 이외는 좀 다르다. 애플리케이션의 비즈니스 로직과 그 하위에

서 동작하는 로우레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드를 분

리한것이다.

앉L 서비스 추상화 375


UserDa。
애훌리케이션 계충

、v
DataSource 서비스 주상화 계중

Transa이뚫확1----카


기슐 서비스 계충

그림 5-7 계흥과 책임의 분리

그림 5-7은 지금까지 만들어진 사용자 관리 모률의 의존관계를 나타낸다. UserService
와 UserDao는 애플리케이션의 로직을 담고 있는 애플리케이션 계층이다. UserDao는
데이터
를 어떻게 가져오고 등록할 것인가에 대한 데이터 액세스 로직을 담고 있다.
UserService는 순수하게 시용자 관리의 업무의 비즈니스 로직을 담고 있다. UserDao와
UserService는 인터페이스와 DI를 통해 연결됨으로써 결합도가 낮아졌다. 결합도가 낮
다는 건 데이터 액세스 로직이 바뀌거나， 심지어 데이터 액세스 기술이 바뀐다고 할지
라도 UserService의 코드에는 영향을 주지 않는다는 뭇이다. 서로 독립적으로 확장될
수있다.

또 UserDao는 DB 연결을 생성하는 방법에 대해 독립적이다. DataSource 인터페이
스와 DI를 통해 추상화된 방식으로 로우레벨의 DB 연결 기술을 시용하기 때문이다.
애플리케이션 안에서 동작히는 DB 풀링 라이브러리를 시용하든， JDBC
의 원시적인
DriverManager를 사용하든， WAS가 JNDI를 통해 제공히는 데이터 소스 서비스를 이
용히든 상관없이 UserDao의 코드는 조금도 변하지 않는다. 즉 UserDao와 DB 연결 기술
도 결합도가 낮다는 뭇이다.

마찬가지로 UserService
와 트랜잭션 기술과도 스프링이 제공하는
PlatformTransactionManager 인터페이스를 통한 추상화 계충을 사이에 두고 사용하
게 했기 때문에， 구체적인 트랜잭션 기술에 독립적인 묘드가 됐다. 설령 서벼가 바뀌고
로우레벨의 트랜잭션 기술이 변경된다고 할지라도 UserService는 영향을 받지 않는다.
UserDao와 DB 연결 기술 UserService와 트랜잭션 기술의 결합도가 낮은 분리는 애플
리케이션 묘드를 로우레벨의 기술 서비스와 환경에서 독립시켜준다.

애플리케이션 로직의 종류에 따른 수평적인 구분이든， 로직과 기술이라는 수직적인
구분이든 모두 결합도가 낮으며 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조
를 만들 수 있는 데는 스프링의 DI가 중요한 역할을 하고 있다
DI의 가치는 이렇게 관
심， 책임， 성격이 다른 코드를 깔끔하게 분리히는 데 있다.


단일책임원칙
이런 적절한 분리가 가져오는 특정은 객체지향 설계의 원칙 중의 하나인 단일 책임 원칙
Single Responsibilily Principle으로 설명할 수 있다. 단일 책임 원칙은 하나의 모율은 한 가지

책임을 가져야 한다는 의미다. 하나의 모률이 바뀌는 이유는 한 가지여야 한다고 설명
할수도있다.

UserService
에 JDBC Connection
의 메소드를 직접 샤용하는 트랜잭션 코드가 들
어 있었을 때를 생각해보자. UserService는 어떻게 사용자 레벨을 관리할 것인가와 어
떻게 트랜잭션을 관리할 것인가라는 두 가지 책임을 갖고 있었다. 두 가지 책임을 갖
고 있다는 건 UserService 묘드가 수정되는 이유가 두 가지라는 뭇이다. 사용자의 레
벨 업그레이드 정책과 같은 사용자 관리 로직이 바뀐다면 당연히 UserService 코드를
수정해야 한다. 그런데 사용자 관리 업무는 바뀌지 않았지만 서버환경이 바뀌어서 트랜
잭션 기술을 JDBC에서 JTA로 변경해야 한다면 어떨까? 이때도 UserService의 코드
를 수정해야 한다. 직접 노출한 Connection 오브젝트의 트랜잭션 메소드 대신， JTA의
UserTransaction 오브젝트를 이용하게 하려면 UserService를 수정할 수밖에 없다. 결
국 UserService는 단일 책임 원칙을 지키지 못히는 것이다. 변경의 이유가 두 가지가 되
기 때문이다.

하지만 이렇게 트랜잭션 서비스의 추상화 방식을 도입하고， 이를 DI를 통해 외부
에서 제어하도록 만들고 나서는 어떻게 됐을까? 이제는 UserService가 바뀔 이유는
한 가지뿐이다. 시용자 관리 로직이 바뀌거나 추가되지 않는 한 UserService의 코드
에는 손댈 이유가 없다. 설령 트랜잭션 기술이 바뀌고， 사용할 서버환경이 바뀌고， 또
는 UserDao의 데이터를 가져오는 테이블이 바뀌고 UserDao의 구현 기술이 JDBC에서
JPA로 바뀌더라도 UserService 코드는 단 한 줄도 수정할 이유가 없다. 따라서 단일 책
임 원칙을 충실하게 지키고 있다고 말할 수 있다. UserDao도 마찬가지다.

단일책임원칙의장점
이렇게 단일 책임 원칙을 지키는 코드가 되면 어떤 장점이 있을까? 단일 책임 원칙을
잘 지키고 있다면， 어떤 변경이 필요할 때 수정 대
^cf이 명확해진다. 기술이 바뀌면 기술
계층과의 연동을 담당히는 기술 추상화 계층의 설정만 바꿔주면 된다. 데이터를 가져오
는 테이블의 이름이 바뀌었다면 데이터 액세스 로직을 담고 있는 UserDao를 변경하면
된다. 비즈니스 로직도 마찬가지다.
지금은 User라는 아주 단순한 하나의 모률만 갖고 있으니 별로 대단한 장점이 아닌

닭!t_ 서비스 추상화 377


듯이 보일지도 모르겠다
.DAO가 각각 수백 개가 되고 서비스 클래스도 그만큼 많다고
생각해보자. 서비스 하나가 여러 개의 DAO를 사용하는 경우가 많아질 것이다. 의존관
계가 매우 복잡해진다. 그런데 DAO를 하나 수정할 경우 그에 의존하고 있는 서비스 클
래스도 같이 수정해야 히는 구조라면 어떤 일이 벌어질까? UserDao를 수백 군데에서 사
용하고 있다면? 수백 개의 클래스를 다 같이 수정해줘야 한다. 이 때문에 수많은 태스트
도함께수정해야할수도있다.

기술적인 수정사항도 마찬가지다. 애플리케이션 계층의 묘드가 특정 기술에 종속돼
서 기술이 바뀔 때마다 코드의 수정이 필요하다면 어떨지 상상해보자. 그나마 트랜잭
션 동기화 기법을 사용해 서비스 클래스의 코드를 간략히 했다고 하더라도. JDBC에서
JTA로 트랜잭션 기술이 변경되면， 아마 그에 따라 (서비스 클래스 수)
x
(트랜잭션을 사
용하는 메소드 수)만큼의 엄청난 코드를 수정해야 할 것이다. 그런 경우와 XML 설정을
몇 줄 수정하는 것으로 트랜잭션 기술을 한 번에 전환하는 방식을 비교해보자. 그 차이
는상상도할수 없을만큼크다. 단지 수정하는작업량만의 문제가아니다. 많은코드를
수정하는 작업에선 그만큼 실수가 일어날 획률이 높다. 치명적인 버그가 도입될 가능성
도 있다. 개발중이 아니라운영 중인묘드에 이런수정이 필요하다면， 아마도 엄청난부
담을 안고 시작하거나 아니면 겁나서 도저히 못 하겠다고 저항해야 할지도 모르겠다.

그래서 적절하게 책임과 관심이 다른 코드를 분리하고， 서로 영향을 주지 않도
록 다양한 추상화 기법을 도입하고， 애플라케이션 로직과 기술/환경을 분리하는 등
의 작업은 갈수록 복잡해지는 엔터프라이즈 애플리케이션에는 반드시 필요하다. 이
를 위한 핵심적인 도구가 바로 스프링이 제공하는 DI다. 스프링의 DI가 없었다면 인
터페이스를 도입해서 나름 추상화를 했더라도 적지 않은 코드 사이의 결합이 남아
있게 된다. PlatformTransactionManager 인터페이스가 제공하는 트랜잭션 메소드
를 적용했지만 리스트 5-45
에서처럼 new DataSourceTransactionManager()
라는 구
체적인 의존 클래스 정보가 드러나는 코드가 존재할 때를 생각해보자. 이런 식이라
변 인터페이스로 추상화를 안 했을 때보다는 훨씬 적긴 하겠지만 로우레벨 기술의 변
화가 있을 때마다 비즈니스 로직을 담은 코드의 수정이 발생한다. 결국 DI를 통해
PlatformTransactionManager
의 생성과 의존관계 설정을 스프링에 맡긴 덕에 완벽하게
트랜잭션 기술에서 지유로운 UserService를 가질 수 있게 된 것이다.

객체지향 설계와 프로그래밍의 원칙은 서로 긴밀하게 관련이 었다. 단일 책임 원칙
을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI로 연결해야 하며， 그 결
과로 단일 책임 원칙뿐 아니라 개방 패쇄 원칙도 잘 지키고， 모률 간에 결합도가 낮아서
서로의 변경이 영향을 주지 않고， 같은 이유로 변경이 단일 책임에 집중되는 응집도 높


은 묘드가 나오니까 말이다. 그뿐인가? 이런 과정에서 전략 패턴
， 어랩터 패턴， 브리지
패턴， 미디에이터 패턴 등 많은 디자인 패턴이 자연스럽게 적용되기도 한다. 객체지향
설계 원칙을 잘 지켜서 만든 코드는 태스트하기도 펀하다. 스프링이 지원히는 DI와 싱
글톤 레지스트리 덕분에 더욱 편리하게 자동화된 태스트를 만들 수 있다.

개발지들이 일일이 설계 원칙이니 디자인 패턴이니， 각종 소프트웨어 원리를 따져
가면서 만들기는 사실 쉽지 않다. 하나씩 그 개념을 확실히 이해하고 다양한 응용 방법
을 익히는 것도 상당한 부담이다. 책 몇 권 읽고 몇 달 노력한다고 쉽게 마스터할 수 있
는 일도 아니다. 좋은 코드를 설계하고 만들려면 꾸준한 노력이 필요하다. 그저 기능이
동작한다고 해서 코드에 쉽게 만족하지 말고 계속 다듬고 개선하려는 자세도 펼요하다.
패턴이나 설계 원칙을 공부하는 이유는 폼나는 용어를 외우고 기계적인 지식을 습득하
면 저절로 깔끔하고 유연한 코드가 나오기 때문이 아니다. 좋은 코드를 만들기 위한 개
발자 스스로의 노력과 고민이 있을 때 도움을 주기 때문이다. 멋진 이름을 달고 있는 패
턴이나 원칙은 사실은 많은 선배 개발자가 좋은 코드를 만들려고 고민했던 시간을 통해
만들어진 유산일 뿐이다.DI도 마찬가지다.

지금까지 코드를 개선하고 발전시켜옹 과정을 생각해보면 단 한 번도 DI
가 빠진 적
이 없었다.DAO와 DataSource를 분리할 때도 DI를 이용했고 효과적인 단위 태스트를
만드는 과정에도 DI를 적용했다. 그뿐인가! 뱀플릿/콜백 패턴도 역시 DI를 응용했다.
스프링 컨테이너 대신에 마이크로 DI 방식을 사용하긴 했지만 말이다. 비즈니스 로직을
데이터 로직과 별도로 만들어서 연결하는 데도 DI를 적용했고 비즈니스 로직에 필요한
트랜잭션 기술을 추상화해서 분리하는 데도 역시 DI가 사용됐다.

이렇게 스프링의 의존관계 주입 기술인 DI는 모든 스프링 기술의 기반이 되는 핵심
엔진이자 원리이며， 스프링이 지지하고 지원하는， 좋은 설계와 코드를 만드는 모든 과
정에서 사용되는 가장 중요한 도구다. 스프링을 DI 프레임워크라고 부르는 이유는 외부
설정정보를 통한 런타임 오브젝트 DI라는 단순한 기능을 제공하기 때문이 아니다. 오히
려 스프링이 DI
에 담긴 원칙과 이를 응용하는 프로그래밍 모댈을 자바 엔터프라이즈 기
술의 많은 문제를 해결히는 데 적극적으로 활용하고 있기 때문이다. 또， 스프링과 마찬
가지로 스프링을 사용하는 개발자가 만드는 애플리케이션 코드 또한 이런 DI를 활용해
서 깔끔하고 유연한 코드와 설계를 만들어낼 수 있도록 지원하고 지지해주기 때문이다.

객체지향 기술이나 패턴을 익히고 적용히는 일이 어렵고 지루하게 느껴진다면， 스프
링에서 DI가 어떻게 적용되고 있는지를 살펴보면서 이를 따라해보는 것도 좋은 방법이
다. 그러면서 좋은 묘드의 특정이 무엇이고 가치가 있는지 살펴보는 것이다. 변경사유
가 생겼을 때 코드의 어디를 어떻게 수정해야 하는지 주의 깊게 살펴보자.DI의 원리를

5장-서비스 추상화 379


잘 활용해서 스프링을 열심히 사용하다 보면 어느 날 자신이 만든 코드에 객체지향 원
칙과 디자인 패턴의 장점이 잘 녹아 있다는 사실을 발견하게 될 것이다. 그것이 스프링
을 사용함으로써 얻을 수 있는 가장 큰 장점이다.

[ ~] 메일 서비스 추상화 펠 I

고객으로부터 시용자 레벨 관리에 관한 새로운 요청사항어 들어왔다. 레벨이 업그레이
드되는 사용자에게는 안내 메일을 발송해달라는 것이다. 안내 메일을 발송하기 위해 해
야 할 일이 두 가지가 있다. 먼저 사용자의 이메일 정보를 관리해야 한다. User에 email
필드를 추가하면 된다. 그리고 업그레이드 작업을 담은 UserService의 upgradeLevel()
메소드에 메일 발송 기능을 추7다}는 것이다.

5.4.1 JavaMail을 이용한 메일 발송 기능
사용자 정보에 이메일을 추가하는 일은 레벨을 추가했을 때와 동일하게 진행하면 된다.
DB
의 User 테이블에 email 펼드를 추가하고 User 클래스에 email 프로퍼티를 추
가한다. 그에 따라 UserDao의 userMapper와 insert() , update()
에 email 펼드 처리
코드를 추가해준다. 수정된 코드가 정확히 동작하는지 확인하기 위해 테스트 코드도
수정한다. User 생성자가 email을 받을 수 있게 하고， 테스트 데이터를 맞게 준비한 뒤
에 등록과 수정， 조회에서 email 값이 잘 처리되는지 확인할 수 있도록 UserDaoTest를
수정한다.
email 필드를 추가히는 작업과 태스트가 모두 성공적으로 끝나면 이제 다음 단계로
넘어가자.

JavaMail 메일 발송
자바에서 메일을 발송할 때는 표준 기술인 JavaMail을 시용하면 된다. j avax. mail 때
커지에서 제공하는 자바의 이메일 클래스를 사용한다. JavaMail을 이용해 업그레이드
시 메일 발송 기능을 추가해보자.
먼저 리스트 5-49와 같이 업그레이드 작업을 담은 메소드인 upgradeLeve1()에서
메일 발송 메소드를 호출한다. upgradeLeve1 () 안에 JavaMail 묘드를 직접 넣지 않는
편이 낫다는 건 굳이 설명하지 않아도 될 것이다.

380


리스트 5-49 레밸 업그레이드 작업 메소드 수정

protected void upgradeLevel(User user) (
user .upgradeLevel();
userDao .update(user);
sendUpgradeEMail(user);

다음은 리스트 5-50과 같。
1 lavaMail API를 사용히는 메소드를 추가한다.
리스트 5응o JavaMail올 이용한 메일 발송 메소드

private void sendUpgradeEMail(User user) (
Properties props = new Properties();
props.put("mail.smtp.host" , "mail .ksug.org");
Session 5 = Session.getlnstance(props , null);

MimeMessage message = new MimeMessage(s);

try (
message .setFrom(new InternetAddress("useradmin@ksug .org"));
message.addRecipient(Message.RecipientType .TO ,

new InternetAddress(user .getEmail()));
message .setSubject("Upgrade 안내“);
message.setText("사용자님의 등급이 " + user.getLevel() .name() +

”로 업그레이드되었습니다");

Transport .send(message);
} catch (AddressException e) (
throw new RuntimeException(e);
} catch (MessagingException e) (
throw new RuntimeException(e);
} catch (UnsupportedEncodingException e) (
throw new RuntimeException(e);


lavaMail을 이용해 메일을 발송히는 가장 전형적인 코드다. 단순한 예제이므로 한글
엔코딩 부분은 생략했다. 이렇게 해서 업그레이드되는 사용자에게 안내 메일을 발송하
는 기능이 추기됐다. SMTP 프로토콜을 지원히는 메일 전송 서버가 준비되어 있다면，
이 코드는 정상적으로 동작할 것이고 안내 메일이 발송될 것이다.

5질-서비스 추S회 381


5.4.2 JavaMail이 포함된 코드의 테스트
그런데 메일 서벼가 준비되어 있지 않다면 어떻게 될 것인가? 물론 운영 중에야 메일
서버가 준비되어 있을 테
니 별문제는 없다고 하지만 개발 중이라면 어떨까? 현재 묘드
는 업그레이드 사용자인지 확인되면 upgradeLevel () 메소드를 호출한다. 결국 메일 발
송용 메소드인 sendUpgradeEMail()도 호출될 것이다. 그렇다면， 시용자 레벨 업그레이

드의 기능을 태스트하려고 만든 태스트를 실행해도 이 메일 전송 메소드가 호출된다.
문제는 태스트를 실행했는데 만약 메일 서버가 준비되어 있지 않았다면 디음과 같은 예
외가 발생하면서 테스트가 실패한다는 점이다.

iava.lang.RuntimeException: javax.mail.MessagingException: Could not connect to
SMTP host : mai l .ksug.org, port: 25;

태스트 실패의 원인은 분명하다. 메일을 발송하려는데 메일 서벼가 현재 연결 가능

하도록 준비되어 있지 않기 때문이다. 태스트가 수행될 때 메일이 전송될 수 있으니 실

제로 사용할 메일 서버를 제대로 준비해두고 태스트를 실행할 수 있다. 서버가 잘 준비

되어 있다면 아무런 문제 없이 테스트는 성공할 것이다. 그리고 메일도 실제로 발송될

것이다.

그런데， 과연 태스트를 하면서 매번 메일이 발송되는 것이 바람직한가? 대개는 바람직

하지 못하다. 메일 발송이란 매우 부하가 큰 작업이다. 그것도 실제 운영 중인 메일 서버

를통해 태스트를 실행할때마다메일을보내면 메일 서버에 상당한부담을줄수 있다.

게다가 메일이 실제로 발송돼버린다는 문제도 있다. 태스트용 사용자 정보의 메일

주소는 존재하지 않는 엉터리 메일 주소로 하거나 태스트용으로 미리 준비한 특별한

메일 주소로만 사용하게 히는 방법이 있다. 하지만 그래도 태스트를 돌릴 때마다 메일

서버에 부담을 주는 것은 어쩔 수 없다. 그렇다면 실제 DB 대신에 태스트 DB를 사용하

듯이 테스트 때는 메일 서버 설정을 다르게 해서 테스트용으로 따로 준비된 메일 서버

를 이용하는 방법은 어떨까? 운영 중인 메일 서버에 부하를 주지 않는다는 면에서는 분

명히나은방법이다.

메일 발송 기능은 사용자 레벨 업그레이드 작업의 보조적인 기능에 불과하다. 물론

콕 필요하고 정상적으로 동작하는지 확인하는 일이 중요하긴 하지만， 업그레이드 정책

에 따라 업그레이드가 실제로 일어나는지， 그것이 DB
에 잘 반영되는지를 확인하는 일

만큼 중요하지는 않다. 게다가 메일 발송 테스트란 엄밀히 말해서 불가능하다. 메일이

정말 잘 도착했는지를 확인하지 못한다면 그것이 무슨 메일 발송 테스트라고 할 수 있

을까? 기껏해야메일 발송용서버에 별문제 없이 전달됐음을확인할뿐이다.


물론 이렇게 생각할 수 있다. 메일 서버는 충분히 테스트된 시스램이다. SMTP로
메일 전송 요청을 받으면 별문제 없이 메일이 잘 전송됐다고 믿어도 충분하다. 따라서
lavaMail을 통해 메일 서버까지만 메일이 잘 전달됐으면， 결국 사용자에게도 메일이 잘
보내졌을 것이라고 생각할 수 있다. 굳이 의심스럽다면 메일 서버가 잘 동작히는지 몇
번만 실제 주소로 메일을 보내보고 직접 메일 수신을 통해 확인하면 된다. 따라서 메일
태스트를 한다고 매번 메일 수신 여부까지 일일이 확인할 펼요는 없고， 태스트 기능한
메일 서버까지만 잘 전송되는지 확인하면 된다. 그리고 태스트용 메일 서버는 메일 전
송 요청은 받지만 실제로 메일이 발송되지 않도록 설정해주면 된다.

그림 5-8은 실제 메일 서버를 사용하지 않고 테스트 메일 서버를 이용해 테스트하는
방법을 보여준다. 점선 안이 테스트가 동작하는 범위다. 태스트 메일 서버는 외부로 메
일을 발송하지 않고， 단지 lavaMail과 연동해서 메일 전송 요청을 받는 것까지만 담당
한다. 결국 이 테스트용으로 준비한 메일 서벼는 업그레이드 작업 시 테스트에서 메일
전송 관련 예외가 발생하지 않고 태스트를 마치게 해주는 역할을 맡을 뿐이다.

)‘ !니 매일 서버 |다

“

테스트용 매일 서버 1:


~--------------------------------------------------------------’
그림 5-8 테스트 메일 서버를 이용한 테스트 구조

SMTP라는 표준 메일 발송 프로토콜로 메일 서버에 요청이 전달되기만 하면 메일이 발
송될 것이라고 믿고， 실제 메일 서버가 아닌 테스트용으로 따로 준비한 메일 서버를 사
용해 태스트를 수행해도 좋다면 그 똑같은 원리를 UserService와 lavaMail 사이에도

적용할수있지않을까?

lavaMail은 자바의 표준 기술이고 이미 수많은 시스랩에 사용돼서 검증된 안정적인
모률이다. 따라서 lavaMail API를 통해 요청이 들어간다는 보장만 있다면 굳이 테스트
할 때마다 lavaMail을 직접 구동시킬 필요가 없다. 게다가 lavaMail
이 동작하면 외부의
메일 서버와 네트워크로 연통하고 전송하는 부하가 큰 작업이 일어나기 때문에 이를 생

략할 수 있다면 더할 나위 없이 좋을 것이다.

>< i 키 JavaMail |다

l

테스트용 JavaMail I

그림 5-9 테스트용 JavaMail을 이용한 테스트 구조

옆~-서비스 추상화 383


그림 5-9는 태스트용 JavaMail을 이용하는 방법을 나타낸다. 운영 시에는 JavaMail을
직접 이용해서 동작하도록 해야겠지만 개발 중이거나 태스트를 수행할 때는 JavaMail
을 대신할 수 있는， 그러나 JavaMail을 시용할 때와 통일한 인터페이스를 갖는 코드가
동작하도록 만들어도 될 것이다. 이렇게 할 수 있다면 굳이 매번 검증이 필요 없는 불필
요한 메일 전송 요청을 보내지 않아도 되고， 테스트도 매우 빠르고 안전하게 수행될 수
있다.

5.4.3 테스트를 위한 서비스 추상화
문제는 거의 해결된 듯하다. 실제 메일 전송을 수행하는 JavaMail 대신에 태스트에서
사용할， JavaMail과 같은 인터페이스를 갖는 오브젝트를 만들어서 사용하면 문제는 모
두 해결된다. 마치 DataSource 인터페이스를 이용해 DB 연결을 가져오게 해서 태스트
중에는 실제 운영 중인 DB 서버 대신에 테스트용으로 개발자 PC
에 설치한 가벼운 DB
를 시용할 수 있도록 바꿔치기한 것과 마찬가지다.

JavaMail을 이용한 테스트의 문제점
그런데 한 가지 심각한 문제가 있다. JavaMail
의 API는 이 방법을 적용할 수 없다는 점
이다. JavaMail의 핵심 API에는 DataSource처럼 인터페이스로 만들어져서 구현을 바
꿀수있는게없다.
메일 발송을 위해 가장 먼저 생성해야하는 javax.mail.Session 클래스의 사용방법
을살펴보자.

Session 5 =Session.getlnstance(props , null);

JavaMail에서는 Session 오브젝트를 만들어야만 메일 메시지를 생성할 수 있고， 메

일을 전송할 수 있다. 그런데 이 Session은 인터페이스가 아니고 클래스다. 게다가 생

성자가 모두 private으로 되어 있어서 직접 생성도 불기능하다. 스태틱 팩토리 메소드

를 이용해 오브젝트를 만드는 방법밖에 없다. 게다가 Session 클래스는 더 이상 상속이

불가능한 final 클래스다. 도무지 구현을 바꿔치기할 만한 인터페이스의 존재가 보이

지 않는다. 메일 메시지를 작성히는 MailMessage도 전송 기능을 맡고 있는 Transport

도마찬가지다.

결국 JavaMail의 구현을 테스트용으로 바꿔치기하는 건 불기능하다고 볼 수밖에 없

다. JavaMail은 확장이나 지원이 불가능하도록 만들어진 가장 악명 높은 표준 API 중


의 하나로 알려져 있다. 그렇다면 두 번째 방법으로 생각한 lavaMail 대신 테스트용
lavaMail로 대체해서 사용하는 것은 포기해야 할까?

물론 아니다.1avaMail처럼 테스트하기 힘든 구조인 API를 태스트하기 좋게 만드는
방법이 있다. 트랜잭션을 적용하면서 살펴봤던 서비스 추상화를 적용하면 된다. 스프링
은 lavaMail을 사용해 만든 묘드는 손쉽게 태스트하기 힘들다는 문제를 해결하기 위해
서 lavaMail
에 대한 추상화 기능을 제공하고 있다. 리스트 5-51
은 스프링이 제공하는
메일 서비스 추상화의 핵심 인터페이스다.

메일발송기능추상화

리스트 5-51 JavaMail의 서비스 추상화 인터페이스

pàckage org.springframework.mail;

public interface MailSender {
void send(SimpleMailMessage simpleMessage) throws MailException;
void send(SimpleMailMessage[) simpleMessages) throws MailException;


이 인터페이스는 SimpleMailMessage라는 인터페이스를 구현한 클래스에 담긴 메일
메시지를 전송히는 메소드로만 구성되어 있다. 기본적으로는 lavaMail을 사용해 메일
발송 기능을 제공하는 JavaMailSenderlmpl 클래스를 이용하면 된다. 리스트 5-52는
스프링이 제공하는 JavaMailSender 구현 클래스를 사용해서 만든 메일 발송용 코드다.

리스트 5-52 스프링의 MailSender훌 이용한 메일 발송 메소드

private void sendUpgradeEMail(User user) {
JavaMailSenderlmpl mailSender = new JavaMailSenderlmpl();_ ~il~r 구현 클래스의

오브젝트훌생성한다

mailSender.setHost("mail.server.com");

SimpleMailMessage mailMessage = new SimpleMailMessage();
mailMessage.setTo(user.getEmail());
mailMessage.setFrom( 띠
seradmin@ksug.org');
mailMessage.setSubject("Upgrade 안내 ");
mailMessage
.
setText("
사용자님의 등급이 " + user.getLevel().name());

MailMessage 인터페이스의 구현 클래스 오브젝트훌
mailSender .send(mailMessage); 만줄어 메일 내용을 작성한다

~-서비스 추상화 385


스프링이 제공하는 JavaMailSender 인터페이스와 관련 클래스 등으로 수정하고 나
니 일단 지저분한 try/catch 블록이 사라진 것이 가장 먼저 눈에 띈다. 스프령의 예외
처리 원칙에 따라^i JavaMail을처리하는중에 발생한각종예외를
MailExceptionoj
라
는 런타임 예외로 포장해서 던져주기 때문에 귀찮은 try/catch 블록을 만들지 않아도
된다.

*후]~휠라이브러리

∞m.spnngsoorce.
]av없.activatio마-1.1.
0.jar

∞m.spring없Jrce.javax.
mai
l-l.4.0.jar

org.sprt때framewαk.α:>ntext.suppo끼-3.0.7.RELEASE.jar

MailMessage 타입의 SimpleMailMessage 오브젝트를 만들어서 메시지를 넣은 뒤에
JavaMailSender 타입 오브젝트의 send() 메소드에 전달해주면 된다. 메시지는 간단한
텍스트가 전부이므로 MailMessage 인터페이스를 구현한 SimpleMailMessage를 사용했
고， 메일 전송 오브젝트는 JavaMailSender 인터페이스를 구현한 JavaMailSenderlmpl
의 오브젝트를 만들어 사용했다. JavaMailSenderlmpl은 내부적으로 JavaMail API를
이용해 메일을전송해준다.

복잡하고 지저분해 보이는 JavaMail API를 사용했던 경우에 비해 코드가 간결해졌
다. 하지만 아직은 JavaMail API를 사용하지 않는 태스트용 오브젝트로 대체할 수는
없다. JavaMail API를 사용하는 JavaMailSenderlmpl 클래스의 오브젝트를 코드에서
직접 시용하기 때문이다.

그렇다면， 이제 스프링의 DI를 적용할 차례다. sendUpgradeEMail() 메소드에는
JavaMailSenderlmpl 클래스가 구현한 MailSender 인터페이스만 남기고， 구체적인 메
일 전송 구현을 담은 클래스의 정보는 코드에서 모두 제거한다. 메일 발송 호스트를 설
정하는 코드도 제거해야 한다. 다음은 리스트 5-53과 같이 UserService에 MailSender
인터페이스 타입의 변수를 만들고 수정자 메소드를 추가해 DI
가 기능하도록 만든다.

리스트 5냉3 메일 전송 기능올 가진 오브젝트를 미 받도록 수정한 UserService

public class UserService (

private MailSender mailSender;

public void setMailSender(lailSender mailSender) {

this.mailSender =mailSender;


private void sendUpgradeEMail (User user) (
SimpleMailMessage mailMessage = new SimpleMailMessage();
mailMes sage.setTo (user .getEmai l ());
mailMessage.setFrom("useradmin@ksug.org");
mailMessage.setSubject("Upgrade 안내");
mailMessage.setText(
"사용자님의 등급이 " + user.getLeve l ().name());

this.mailSender.send(mailMe55age);

다음은 리스트 5
-54와 같이 설정파일 안에 JavaMailSenderlmpl 클래스로 빈을 만
들고 UserService
에 01 해준다. 스프링 빈으로 등록되는 MailSender의 구현 클래스들
은 싱글톤으로 시용 가능해야 한다.

리스트 • 54 메일 발송 오브젝트의 빈 등록

<bean id="userService" class=닝
pringbook.user
.
serv
ice
.
U
se
rService"
>
<property name="userDao" ref="userDao" />
<property name="transactionManager" ref="transactionManager" />
(property name="mailSender" ref="mailSender'’ 1>

</bean>

(be
않하n 찌하="개
민맨der" c
55="깨rg.5
gfr매빼
work.m뻐
avamnra
i
l.J퍼뻐얘뻐
민n1띠
뼈따

a
id
en
o
arme
nai
l.껴i 배하빼뼈뻐랴 avaMailSe때derImnp1" 〈 때따 n(mailS) m(때) " (la) =(매) a(따) se(때) r.c(앤) m(따) " 1> (뼈) (p)

φpro p erty a(앞) e="ho5t(뎌) value(따) "m(얘) il.(rin) rve(펴) o(뼈) (띠) (1) (없) (띠) (l)

</bean>


테스트용 메일 발송 오브젝트
mailSender 빈의 host 프로퍼티
에는 메
일 서버를 지정해준다. 이제 태스트를 실행하면
JavaMail API를 직접 사용했을 때와 동일하게 지정된 메일 서버로 메일이 발송된다.
우리가 원히는 건 JavaMail을 사용하지 않고， 메일 발송 기능이 포함된 코드를 태스트
하는 것
이다. 이를 위해 메
일 전송 기능을 추상화해서 인터페이스를 적용하고 DI를 통
해 빈으로 분리해놨으니 모든 준비가 끝났다.
스프링이 제공한 메
일 전송 기능에 대한 인터페이스가 있으니 이를 구현해서 테스트
용 메일 전송 클래스를 만들어보자. 구현해야 할 인터페이스는 MailSender다. 테스트가

5징-서비스 추S회 387


수행될 때는 JavaMail을 사용해서 메일을 전송할 필요가 없다. 리스트 5-55
처럼 그냥
아무것도 하지 않는， Mai lSender 구현 빈 클래스를 만들어보자.

리스트 웅동5 아무런 기능이 없는 MailSender 구현 클래스

package springbook.user.service;

public class DummyMailSender implements MailSender (
public void send(SimpleMailMessage mailMessage) throws MailException (

public void send(SimpleMailMessage[] mailMessage) throws MailException {

DummyMailSender는 MailSender 인터페이스를 구현했을 뿐， 하는 일이 없다. 다
음은 태스트 설정따일의 mailSender 빈 클래스를 다음과 같이 JavaMail을 시용하는
JavaMailSenderlmpl 대신 DummyMailSender로 변경한다.

(bean id="mailSender" class="springbook .user. service .DummyMailSender" />

스프링의 DI를 이용해서 테스트가 구동될 때 UserService가 사용할 오브젝트를 변
경해줬기 때문에 UserService 코드 자체에는 아무런 수정이 필요하지 않다.

이제 태스트를 수행해보자. UserService에 새로운 DI용 프로퍼티가 추가됐으
니 수동 DI 방식을 사용한 upgradeAIIOrNothing() 메소드에도 리스트 5-56과 같이
mailSender도 추가해주는 것을 잊지 말자.

리스트 5• 56 테스트용 U똥rServi∞를 위한 메일 전송 오브젝트의 수동 미

public class UserServiceTest (

itAutowired
MailSender mailSender;
@Test

public void upgradeAIIOrNothing() throws Exception (
testUserService.setMailSender(mailSender);


UserServiceTest 테스트는 모두 성공으로 끝난다. 태스트용 메일 전송 클래스인
DummyMailSender를 이용히는 한 메
일이 메
일 서버로 발송될 일은 없다. 메일 발송 기
능 자체는 MailSender에 대한 별도의 학습 태스트 또는 메일 서버 설정 점검용 테스트
를 만들어서 확인해보면 된다. 메
일 전송 메소드가 호출됐는지 간단히 확인해보려면
DummyMailSender
의 메소드에 간단히 콘솔에 발송정보를 출력하도록 만들고 한 번쯤 콘
솔에 찍힌 내용을 학인해보는 방법을 사용할 수도 있다.

테스트와서비스추상화
그림 5-\0은 스프링이 제공하는 MailSender 인터페이스를 핵심으로 하는 메일 전송 서
비스 추상화의 구조다. 일반적으로 서비스 추상화라고 하면 트랜잭션과 같이 기능은 유
사하나 사용 방법이 다른 로우레벨의 다양한 기술에 대해 추상 인터페이스와 일관성 있
는 접근 방법을 제공해주는 것을 밀빨다. 반면에 l
av
aMail
의 경우처럼 태스트를 어렵게
만드는 건전하지 않은 방식으로 설계된 API를 사용할 때도 유용하게 쓰일 수 있다.

! rl

Use r Service 애을리케이션
계층

추상화계충

±


비서

뼈

펴

-

A

J avaMail


그림 5-10 스프링의 메일 전송 서비스 추상화 구조

꾀

| JavaMailService뼈

-

」

챔

스프링이 직접 제공하는 MailSender를 구현한 추상화 클래스는 JavaMailServicelmpl
하나뿐이다. 다양한 트랜잭션 기술에 대해 추상화 클래스를 제공하는 것과는 분명 대비
된다. 그럼에도 불구하고 이 추상화된 메일 전송 기능을 사용해 애플리케이션을 작성함
으로써 얻을 수 있는 장점은 크다.

lavaMail이 아닌 다른 메시정 서벼의 API를 이용해 메일을 전송해야 하는 경우가
생겨도， 해당 기술의 API를 이용히는 MailSender 구현 클래스를 만들어서 미 해주변
된다. 또는 메일을 바로 전송하지 않고 작업 큐에 담아뒀다가 정해진 시간에 메일을 발
송하는 기능을 만드는 일도 어렵지 않다. 이때도 MailSender로 추상화된 메일 전송 추

얄L 서비스 추상화 389


상화 계층이 도움이 된다. Ma i 1 Sender 인터페이스를 구현한， 메일 발송 큐의 구현을 하
나 만들어두고 다시 DI를 통해 JavaMailServicelmpl 같은 실제 메일 발송용 오브젝트
를 연결해서 사용할 수 있다. 그 외에도 추상화 계층을 이용할 수 있는 수많은 응용 방
법이있다.

어떤 경우에도 UserService와 같은 애플리케이션 계층의 코드는 아래 계층에서는
어떤 일이 일어나는지 상관없이 메일 발송을 요청한다는 기본 기능에 충실하게 작성하
면 된다. 메일 서버가 바뀌고 메일 발송 방식이 바뀌는 등의 변화가 있어도 메일을 발송
한다는 비즈니스 로직이 바뀌지 않는 한 UserService는 수정할 필요가 없다.

사실 지금 만든 코드에는 한 가지 부촉한 점이 있다. 바로 메일 발송 작업에 트랜잭
션 개념이 빠져 있다는 사실이다. 레벨 업그레이드 작업 중간에 예외가 발생해서 DB
에
반영했던 레벨 업그레이드는 모두 롤백됐다고 하자. 하지만 메일은 사용자별로 업그레
이드처리를할때 이미 발송해버렸다. 그것은어떻게 취소할것인가?

따라서 메일 발송 기능에도 트랜잭션 개념을 적용해야 한다. 물론 UserService는 스
프령의 기초 개념을 설명하기 위해 예제로 만든 것이니 너무 복잡해지지 않도록 이 정
도로 넘어가겠다. 하지만실전이라면용납할수 없다.

이런 문제를 해결하려면 두 가지 방법을 사용할 수 있다. 한 가지 방법은 메일을 업
그레이드할 사용자를 발견했을 때마다 발송하지 않고 발송 대상을 별도의 목록에 저장
해두는 것이다. 그리고 업그레이드 작업이 모두 성공적으로 끝났을 때 한 번에 메일을
전송하면 된다. 이 방식의 단점은 메일 저장용 리스트 등을 파라미터로 계속 갖고 다녀
야 한다는 점이다. 다른 방법은 MailSender를 확장해서 메일 전송에 트랜잭션 개녕을
적용하는 것이다. MailSender를 구현한 트랜잭션 기능이 있는 메일 전송용 클래스를 만
든다. 이 오브젝트에 업그레이드 작업 이전에 새로운 메일 전송 작업 시작을 알려주고，
그때부터는 mailSender.send() 메소드를 호출해도 실제로 메일을 발송하지 않고 저장
해둔다. 그리고 업그레이드 작업이 끝나면 트랜잭션 기능을 가진 MailSender
에 지금까
지 저장된 메일을 모두 발송하고， 예외가 발생하면 모두 취소하게 할 수 있다. 두 가지
방법에 쓴 전략이 비슷하긴 하다. 하지만 전자가 사용자 관리 비즈니스 로직과 메일 발
송에 트랜잭션 개념을 적용하는 기술적인 부분이 한데 섞이게 한다면. MailSender
의 구
현 클래스를 이용하는 방법은 서로 다른 종류의 작업을 분리해 처리한다는 면에서 장점
이있다.

서비스 추상화란 이렇게 원활한 테스트만을 위해서도 충분히 가치가 있다. 기술이나
환경이 바뀔 가능성이 있음에도. JavaMail처럼 확장이 불가능하게 설계해놓은 API를


사용해야 하는 경우라면 추상화 계층의 도입을 적극 고려해볼 필요가 있다. 특별히 외
부의 리소스와 연동하는 대부분 작업은 추상화의 대상이 될 수 있다.

5.4.4 테스트 대역
DummyMailSender
에 대해 좀 더 생각해보자. DummyMailSender 클래스는 아무것도 히는
일이 없다. Ma i 1 Sender 인터페이스를 구현해놨을 뿐 메소드는 비어 있다. 하는 일이 없
으면 가치도 없어야 할 텐데 사실 이 클래스의 가치는 매우 크다. 이 클래스를 이용해
lavaMail로 메일을 직접 발송히는 클래스를 대치하지 않았다면 태스트는 매우 불편해
지고 자주 실행하기 힘들었을 것이다.

스프링의 XML 설정파일을 태스트용으로 따로 만든 이유는 무엇인가? 개발자 환경

에서 손쉽게 이용할 수 있는 테스트용 DB를 사용하도록 만들기 위해서다. 그렇지 않고

운영 중인 DB 서벼를 WAS
의 풀링 서비스를 통해 이용하게 만들었다면 테스트를 자

주 실행할 엄두도 못냈을지 모른다. 이처럼 테스트 환경에서 유용하게 사용히는 기법

이 있다. 대부분 테스트할 대상이 의존하고 있는 오브젝트를 DI를 통해 바꿔치기하는

것이다.

의존 오브젝트의 변경을 통한 테스트 방법

그림 5-11
은 UserDaoTest
를 통해 태스트가 진행될 때의 상황을 나타낸다. 원래

UserDao는 운영 시스템에서 사용히는 DB와 연결돼서 동작한다. 대용량의 DB 연결 기

능에 최적화된 WAS에서 동작히는 DB 풀링 서비스를 사용하고， 이에 최적화된 복잡한

DataSource
의 구현 클래스를 이용하도록 되어 있다. 하지만 테스트에서는 운영 DB
의

연결도， WAS
의 DB 풀링 서비스의 사용도 번거로운 짐이 될 뿐이다. UserDaoTest
의

관심은 UserDao가 어떻게 동작하는지에 있지 그 뒤에 존재하는 DB 커넥션 풀이나 DB

자체에 있지 않기 때문이다. 하지만 UserDao가 제 기능을 수행하려면 반드시 DB를 사

용해야 하기에 무시할 수는 없다. 그래서 이를 대신할 수 있도록 태스트환경에서도 잘

동작하고， 준비 과정도 간단한 DataSource를 사용하고， DB도 개발자 PC에 설치해서

사용해도 무방한 가벼운 버전을 이용하게 한 것이다.

5앙-서비스 추S힘 391


J---1(0mplex빼Souκe 버 W잉 DB Pool 됨월

SimpleDataSource

그림 5-11 UserDa。
테스트 구조

다음은 UserService의 테스트를 살펴보자. 그림 5-12는 UserService의 테스트 중에
메일 전송 기능을 이용하는 구조를 나타낸 것이다. 실제로 。
1
UserService가 운영 시스
템에서 사용될 때는 당연히 JavaMailSenderlmpl과 JavaMail을 통해 메일 서버로 이어
지는 구성이 필요하다. 하지만 테스트 때는 일일이 이 구조를 유지하고 있으면 오히려
손해다. UserServiceTest의 관심시는 UserService에서 구현해놓은 사용자 정보를 가
공히는 비즈니스 로직이지， 메일이 어떻게 전송이 될 것인지가 아니기 때문이다.

_ ~ JavaMailSenderlmpl

DummyMailSender

그림 5-12 UserService 테스트 구조

그렇다고 메일 전송 기능을 아예 뺑 수도 없다. 테스트 때는 UserService에 있는 메일
발송용 메소드를 제거했다가 테스트가 끝나면 다시 추가하는 것은 현실적으로 불가능
하다. 태스트 대상이 되는 코드를 수정하지 않고 메일 발송 작업 때문에 UserService
자체에 대한 태스트에 지장을 주지 않기 위해 도입한 것이 결국 DummyMailSender
다. 이
름 그대로 아무런 기능도 없지만 UserService가 반드시 이용해야 하는 의존 오브젝트
의 역할을 해주면서 원활하게 테스트 중에 UserService의 코드가 실행되게 해준다.

이 두 가지 경우에서 확인할 수 있듯이 태스트 대상이 되는 오브젝트가 또 다른 오
브젝트에 의존하는 일은 매우 흔하다. UserService는 이미 DI를 통해 주입받는 오브젝
트만 세 가지다. 이렇게 하나의 오브젝트가 사용하는 오브젝트를 DI에서 의존 오브젝트
라고 불러왔다. 의존한다는 말은 종속되거나 기능을 사용한다는 의미다. 작은 기능이라
도 다른 오브젝트의 기능을 사용하면， 사용하는 오브젝트의 기능이 바뀌었을 때 자신이
영향을 받을 수 있기 때문에 의존하고 있다고 밀하는 것이다. 의존 오브젝트를 협력 오
브젝트collaboralor라고도 한다. 함께 협력해서 일을 처리하는 대상이기 때문이다.

아무튼 이렇게 태스트 대상인 오브젝트가 의존 오브젝트를 갖고 있기 때문에 발생하


는 여러 가지 태스트상의 문제점이 있다. 대표적으로. UserDao나 UserService의 태스
트 예에서 봤듯이 간단한 오브젝트의 코드를 테스트하는 데 너무 거창한 작업이 뒤따르
는 경우다. 이럴 땐 UserDao의 경우처럼 테스트를 위해 간단한 환경으로 만들어주던가，
아니면 UserService의 메일 발송 기능의 경우처럼 아예 아무러 일도 하지 않는 빈 오브
젝트로 대치해주는 것이 해결책이다. 스프링의 Dl는 이럴 때 큰 위력을 발휘한다.

트랜잭션과 메일의 추상화 과정에서도 살펴봤듯이 실전에서 사용할 오브젝트를 교
체하지 않더라도， 단지 태스트만을 위해서도 Dl는 유용하다. 그것은 DataSource의 경
우에서도 마찬가지였다. 운영 중인 시스랩에서는 특정 DataSource 외에는 절대로 다른
것을 사용하지 않는다고 100% 확신하더라도. DAO에서 특정 DataSource 구현 클래스
를 new로 직접 만들어서 λF용하지 않는 편이 낫다고 했다. 운영 중에는 절대 바뀌지 않
더라도 테스트 때는 바꿀 수밖에 없기 때문이다. 그래서 DataSource라는 인터페이스를
시용하고， 어떤 클래스의 오브젝트를 사용할지 외부에서 주입해주도록 스프링의 Dl를
적용해야한다.

테스트 대역의 종류와 특징
이렇게 태스트용으로 시용되는 특별한 오브젝트들이 있다. 대부분 테스트 대상인 오브
젝트의 의존 오브젝트가 되는 것들이다. UserDao의 DataSource이거나. UserService의
MailSender 인터페이스를 구현한 것들이다. 이렇게 테스트 환경을 만들어주기 위해， 태
스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게， 지주 태스트를 실
행할 수 있도록 사용하는 이런 오브젝트를 통틀어서 테스트 대역test double이라고 부른다.
대표적인 태스트 대역은 테스트 스럽
test stub이다. 태스트 스럽은 태스트 대상 오브젝
트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕
는 것을 말한다. 일반적으로 테스트 스럽은 메소드를 통해 전달하는 파라미터와 달리，
테스트 코드 내부에서 간접적으로 사용된다. 따라서 Dl 등을 통해 미리 의존 오브젝트
를 태스트 스럽으로 변경해야 한다. DummyMailSender는 가장 단순하고 심플한 태스트
스럽의 예다.
많은 경우 태스트 스럽이 결과를 돌려줘야 할 때도 있다. MailSender처럼 호출만 하
면 그만인 것도 있지만， 리턴 값이 있는 메소드를 이용히는 경우에는 결과가 펼요하다.
이럴 땐 스럽에 미리 태스트 중에 필요한 정보를 리턴해주도록 만들 수 있다. 또는 어떤
스럽은 메소드를 호출하면 강제로 예외를 발생시키게 해서 테스트 대상 오브젝트가 예
외상햄l서 어떻게 반응하지를 테스트할 때 적용할 수도 있다.

얄~ 서비스 추S화 393


태스트가 원활하게 돌아가도록 의존 오브젝트로서 간접적인 도움을 준다는 개
념과 달리， 어떤 태스트 대역은 태스트 과정에 매우 적극적으로 참여할 수 있다.
DummyMailSender는 upgradeLevels() 메소드가 동작히는 동안에 사용이 되도 그만이
고， 안 되도 그만이다. 필요하면 호출될 수는 있지만 테스트 중에 호출되지 않아도 그만
이다.

태스트는 보통 어떤 시스템에 입력을 주었을 때 기대하는 출력이 나오는지를 검증한
다. 단위 태스트에서는 보통 입력 값을 테스트 대상 오브젝트의 메소드의 따라미터로
전딜하고， 메소드의 리턴 값을 출력 값으로 보고 검증한다. 그런데 스럽을 이용하면 간
접적인 입력 값을 지정해줄수도 있다. 마찬가지로 어떤 스럽은간접적인 출력 값을받
게 할 수 있다. DummyMailSender는 태스트 오브젝트에 돌려주는 것은 없지만 태스트 오
브젝트인 UserService로부터 전달받는 것은 있다.

테스트 대상 오브젝트의 메소드가 돌려주는 결과뿐 아니라 테스트 오브젝트가 간접
적으로 의존 오브젝트에 넘기는 값과 그 행위 자체에 대해서도 검증하고 싶다면 어떻게
해야 할7lt? 이 경우에는 단순하게 메소드의 리턴 값을 assertThat()으로 검증히는 것
으로는불기능하다.

이런 경우에는 태스트 대상의 간접적인 출력 결과를 검증하고， 태스트 대상 오브젝
트와 의존 오브젝트 사이에서 일어나는 일을 검증할 수 있도로 특별히 설계된 목 오브젝
트mock obiect를 사용해야 한다. 목 오브젝트는 스럽처럼 태스트 오브젝트가 정상적으로
실행되도록 도와주면서， 태스트 오브젝트와 자신의 사이에서 일어나는 커뮤니케이션
내용을 저장해뒀다가 테스트 결괴를 검증히는 데 활용할 수 있게 해준다.

직접 택스트 구간 간접 태스트 구간

.-----------. . -----------.

테스트
의존/협력 오E젝트
(혹오브잭트)

”

’


------------------------------------------------’

(5) 간정 구간 훌혁 확민
그림 5-13 목 오브젝트툴 이용한 테스트 동작방식
그림 5-13은 목 오브젝트를 이용한 테스트의 구조다. 여기서 (5)번을 제외하면 스럽이
라고 봐도 된다. 테스트는 테스트의 대%에 되는 오브젝트에 직접 입력 값을 제공하고，
태스트 오브젝트가 돌려주는 출력 값， 즉 리턴 값을 가지고 결과를 확인한다. 테스트 대
상이 받게 될 입력 값을 제어하면서 그 결과가 어떻게 달라지는지 확인하기도 한다. 문


제는 테스트 대상 오브젝트는 태스트로부터만 입력을 받는 것이 아니라는 점이다. 테스
트가 수행되는 동안 실행되는 코드는 테스트 대상이 의존하고 있는 다른 의존 오브젝트
와도 커뮤니케이션하기도 한다. 테스트 대상은 의존 오브젝트에게 값을 출력하기도 하
고 값을 입력받기도 한다. 출력은 무시한다고 칠 수 있지만， 간접적으로 태스트 대상이
받아야 할 입력 값은 필요하다. 이를 위해 별도로 준비해둔 스럽 오브젝트가 메소드 호
출 시 특정 값을 리턴하도록 만들어두면 된다.

때론 태스트 대상 오브젝트가 의존 오브젝트에게 출력한 값에 관심이 있을 경우가
있다. 또는 의존 오브젝트를 얼마나 사용했는가 히는 커뮤니케이션 행위 자체에 관심
이 있을 수가 있다. 문제는 이 정보는 테스트에서는 직접 알 수가 없다는 점이다. 이때
는 테스트 대상과 의존 오브젝트 사이에 주고받는 정보를 보존해두는 기능을 가진 태스
트용 의존 오브젝트인 목 오브젝트를 만들어서 사용해야 한다. 태스트 대상 오브젝트의
메소드 호출이 끝나고 나면 테스트는 목 오브젝트에게 태스트 대상과 목 오브젝트 사이
에서 일어났던 일에 대해 확인을 요청해서， 그것을 태스트 검증 자료로 삼을 수 있다.

목 오브젝트를 이용한 테스트
목 오브젝트는 이렇게 말로 설명하면 굉장히 복잡해 보이는데 사실은 단순한 개념이다.
UserServiceTest
에 이 개념을 적용해보자.
기본적으로 테스트를 위한 스프링 설정에는 UserService가 사용할 mailSender 프
로퍼티를 아무것도 하지 않는 DummyMailSender로 만들어뒀다. 때론 이 방법이면 충분
하다. 예를 들어 트랜잭션 기능을 태스트하려고 만든 upgradeAIIOrNothing()
의 경우
는 태스트가 수행되는 동안에 메일이 전송됐는지 여부는 관심의 대상이 아니다. 따라서
DummyMailSender가 잘 어울린다.
반면에 정상적인 사용자 레벨 업그레이드 결과를 확인하는 upgradeLevels() 테스트
에서는 메일 전송 자체에 대해서도 검증할 펼요가 있다. 조건을 만족하는 사용자의 레
벨을 수정했다면， 메일도 발송했어야 하기 때문이다.
만약 JavaMail을 직접 사용하는 방식으로 놔뒀다면 메일 발송 태스트는 업그레이드
대상 주소에 넣은 메일 주소로 실제 메일이 들어왔는지 직접 확인하거나， 아니면 아주
복잡한 방법을 사용해 메일 서버의 로그를 뒤져서 메일 발송 로그가 그 시점에 납았는
지를 확인해야 할 것이다. 하지만 우리는 스프링의 JavaMail 서비스 추상화를 적용했기
때문에， 방금 살펴본 목 오브젝트를 만들어서 메일 발송 여부를 확인할 수 있다.
DummyMailSender 대신에 새로운 MailSender를 대체할 클래스를 하나 만들자. 물론

5징-서비스 추상화 395


메일을 발송하는 기능은 없다. UserService
의 쿄드가 정상적으로 수행되도록 돕는 역
할이 우선이다. 대신 테스트 대상이 넘겨주는 출력 값을 보관해두는 기능을 추가했다.
UserServiceTest 안에서만 한정적으로 사용될 것이므로 굳이 별도의 파일에 만들지 않
고， 리스트 5-57과 같이 UserServiceTest
의 스태틱 맹버 클래스로 정의하겠다.

리스트 5-5l 목 오브젝트로 만든 메일 전송 확인용 클래스

static class MockMailSender implements MailSender {
rprivate List(String) requests =new ArrayList(String)();

UserService.

로부터 전송 요정
public List(String) getRequests () { 율 받은 메일 주소훌 저ε}해
return requests; 두고이률읽을수있게한다

public void send(SimpleMailMessage mailMessage) throws MailException {

requests
.
add(mailMessage
.
getTo()[이);-용 전송요정올 받은이메일주소훌 저첼H둔다 간단하게

첫 번째 수신자 메일 주소인 저장했다

public void send(SimpleMailMessage[) mailMessage) throws MailException {

MockMailSender 클래스도 DummyMailSender 못지않게 단순하다. 실제로 메일을 발송
히는 기능이 없기 때문이다. 대신 이 클래스는 태스트 대상인 UserServce가 send() 메
소드를 통해 자신을 불러서 메일 전송 요청을 보냈을 때 관련 정보를 저장해두는 기능이
있다. 전달받은 SimpleMailMessage 오브젝트에서 첫 번째 수신자 메일 주소를 꺼내온
다. 어차피 한 번에 한 명씩 보내기 때문에 하나뿐일 것이다. 그리고 수신자 메일 주소를
미리 준비해둔 리스트에 저장해둔다. 리스트이므로 순서대로 중복 호출까지 포함해서
다 저장해둘 것이다. 그리고 이를 테스트에서 읽어갈 수 있도록 간단한 접근자 메소드를
만들어둔다. 태스트 대상 오브젝트가 목 오브젝트에게 전달히는 출력정보를 저장해두는
것이다.

이제 MockMailSender를 이용해 리스트 5-58과 같이 테스트 upgradeLevels() 태스
트 코드를 수정해서 목 오브젝트를 통해 메일 발송 여부를 검증하도록 만들 수 있다.

리스트 • 58 메일 발송 대상을 확인하는 테스트

@Test
tIO irtiesContext _ 컨텍스트의 대 설정올 변경하는 테스트라는 것을 알려준다


public void upgradeLevels() throws Exception (
userDao .deleteAll();
for(User user users) userDao.add(user);

1 메일 발소 결과를 테스트할

MockMailSer빠 mockMailSender =new MockMailSender(); 1-.수 있도훌 목 뾰젝트를 만

userService.setMailSender(mockMailSender); 들어 userService의 의존 오
브젝트로주입해준다

userServ띠ice
.
upgradeLevels();

checkLevelUpgraded(users.get(0) , false);

나

”

여」 그

업

페m
따

결

멜딴

미씨미]

앓

택뼈백

廠

뾰

따뼈띠얘

M

checkLevelUpgraded(users .get(l) , true);
checkLevelUpgraded(users.get(2) , false);
checkLevelUpgraded(users.get(3), true);
checkLevelUpgraded(users.get(4) , false);

}

「

멘

List<String> request =mockMailSender.getRequests();
l 목 오브젝트에 저장된 메일

assertThat(request.size() , is(2)); • 수신자
목록을 쩌와 업그레

assertThat(request.get(0) , is(users.get(1).getEmail())); 1 01드 대상과 일치S반지 뿔
assertThat(request.get(1) , is(users.get(3).getEmail())); 1 1 한다


태스트 대상인 UserService
의 메소드를 호출하기에 앞서 스프링 설정을 통해 DI
된 DummyMailSender를 대신해서 사용할 메일 전송 검증용 목 오브젝트를 준비한다.
MockMailSender
의 오브젝트를 만들고 UserService 오브젝트의 수정자를 이용해 수동
DI 해준다. 이제 userService 오브젝트는 DummyMailSender 대신에 MockMailSender를
사용할 수 있는 준비가 됐다
. 생성된 MockMailSender 오브젝트는 뒤에서 검증정보를 얻
을 때 사용할 것이므로 변수에 저장해둬야 한다. 준비가 끝났으면 태스트 대상의 메소
드를 호출하고 먼저 업그레이드 결과에 대한 검증 과정을 거친다.

다음은 MockMailSender 오브젝트로부터 UserService 사이에서 일어난 일에 대한 결
과를 검증할 차례다. userService
에 DI 해줬던 목 오브젝트로부터 getRequests()
를 호
출해서 메일 주소가 저장된 리스트를 가져온다. Moc kMa i 1Sender의 send() 메소드가 호
출됐다면， 그때마다 수신인 정보에 들어 있던 메일 주소가 리스트로 추가됐을 것이다.
리스트에 담긴 결과를 검증해보자. 태스트 조건에 따르면 업그레이드 대상은 두 번째와
네 번째 사용자 두 명이다. 검증 방법은 다음과 같다. 먼저 리스트의 크기를 확인하고，
리스트의 첫 번째 메일 주소와두 번째 사용자의 메일 주소를 비교한다. 그리고 두 번째
메일 주소와 네 번째 사용자의 메일 주소가 같은지 검증한다.

5장-서비스 추상화 397


테스트를 수행하고 결과를 확인해보면 모두 성공일 것이다. 이제 레벨 업그레이드가
일어날 때 DB
의 내용이 변경되는 것은 물론이고 메일도 정상적으로 발송된다는 사실
도 확인할 수 있다. 메일 발송 자체에 대해 좀 더 확신이 필요하다면 순수하게 메일 발
송 기능만 학습 테스트로 만들어서 태스트해봐도 좋다. 또는 통합 태스트를 통해 실제
메일이 발송되도록 테스트해볼 수도 있다. 하지만 단순히 UserService의 기능에 초점
을 두고 테스트하는 것이라면 이렇게 목 오브젝트를 시용해 검증하는 것으로 충분하다.

목 오브젝트를 이용한 테스트라는 게 작성하기는 간단하면서도 기능은 상당히 막강
하다는 사실을 알 수 있을 것이다. 보통의 태스트 방법으로는 검증하기가 매우 까다로
운 테스트 대상 오브젝트의 내부에서 일어나는 일이나 다른 오브젝트 사이에서 주고받
는 정보까지 검증히는 일이 손쉽기 때문이다.

태스트가 수행될 수 있도록 의존 오브젝트에 간접적으로 입력 값을 제공해주는 스럽
오브젝트와 간접적인 출력 값까지 화인이 가능한 목 오브젝트， 이 두 가지는 태스트 대
역의 가장 대표적인 방법이며 효과적인 태스트 코드를 작성하는 데 빠질 수 없는 중요
한 도구다. 태스트 대역을 λF용한 태스트 기법에 대해서는 앞으로 계속해서 설명해나갈
것이다.

I~~ 정리

5조벼l서는 비즈니스 로직을 담은 UserService 클래스를 만들고 트랜잭션을 적용하면서
스프링의 서비스추상화에 대해 살펴보았다. 여기서 다룬주요한내용은다음과같다.

• 비즈니스 로직을 담은 묘드는 데이터 액세스 로직을 담은 코드와 깔끔하게 분리되는 것이
바람직하다. 비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메소드로
정리돼야한다.
• 이를 위해서는 DAO의 기술 변화에 서비스 계층의 묘드가 영향을 받지 않도록 인터페이스
와 DI를 잘 활용해서 결합도를 낮춰줘야 한다.
• DAO를 사용히는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 펼요하다.
• 트랜잭션의 시작과 종료를 지정하는 일을 트랜잭션 경계설정이라고 한다. 트랜잭션 경계설
정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다.
• 시작된 트랜잭션 정보를 담은 오브젝트를 따라미터로 DAO에 전달하는 방법은 매우 비효
율적이기 때문에 스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 편리하다.
398


• 자바에서 사용되는 트랜잭션 API의 종류와 방법은 다양하다 환경과 서버에 따라서 트랜잭
션 방법이 변경되변 경계설정 코드도 함께 변경돼야 한다.
• 트랜잭션 방법에 따라 비즈니스 로직을 담은 묘드가 함께 변경되면 단일 책임 원칙에 위배
되며，
DAO가 사용하는 특정 기술에 대해 강한 결합을 만들어낸다.
• 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하
는 트랜잭션 서비스 추상화를 이용하면 된다.
• 서비스 추상회는 로우레벨의 트랜잭션 기술과 API의 변회에 상관없이 일관된 API를 가진
추상화 계층을 도입한다.
• 서비스 추상화는 테스트하기 어려운 lavaMail 같은 기술에도 적용할 수 있다. 테스트를 편
리하게 작성하도록 도외주는 것만으로도 서비스 추상화는 가치가 었다.
• 태스트 대상이 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트를 테스트 대역이
라고한다.
• 태스트 대역은 테스트 대상 오브젝트가 원활하게 동작할 수 있도록 도우면서 태스트를 위해
간접적인 정보를 제공해주기도 한다.
• 태스트 대역 중에서 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 것을
목오브젝트라고한다.
5장-서비스 추S쩍 399


6
웰F 폐~OP

• • •

. ... _.

----,ai· ~ j

-. .

낯흡?뷰→
.. . -
--
-:.-’.. k-
'--" ; ·-. (-)


A~P틴oC/DI 서비스 램화와 더불어 프링의 3
대 기반기술의 따다 AOP

는 스프링의 기술 중에서 가장 이해하기 힘든 난해한 용어와 개념을 가진 기술로
악명이 높다. AOP를 바르게 이용하려면 OOP를 대체하려고 하는 것처럼 보이는 AOP
라는 이름 뒤에 감춰진， 그 필연적인 등장배경과 스프링이 그것을 도입한 이유， 그 적

용을 통해 얻을 수 있는 장점이 무엇인지에 대한 충분한 이해가 펼요하다. 그래야지만

AOP의 가치를 이해하고 효과적으로 사용할 방법을 찾을 수 있다. 또한 까다로운 AOP

학습에 충분한 노력을 투자할 동기도 부여받을 수 있다.

스프링에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이
다. 서비스 추상화를 통해 많은 근본적인 문제를 해결했던 트랜잭션 경계설정 기능을
AOP를 이용해 더욱 세련되고 깔끔한 방식으로 바꿔보자. 그리고 그 과정에서 스프링
이 AOP를 도입해야 했던 이유도 알아보자.

[ 닫1 뀔랜뺀」결뜯맏분렌 j젠I

지금까지 서비스 추상화 기법을 적용해 트랜잭션 기술에 독립적으로 만들어줬고， 메일
발송 기술과 환경에도 종속적이지 않은 깔끔한 코드로 다듬어온 User
Service
이지만，
코드를 볼 때마다 여전히 찜점한 구석이 있는 것은 어쩔 수 없다. 트랜잭션 경계설정을
위해 넣은 코드 때문이다.

스프링이 제공하는 깔끔한 트랜잭션 인터페이스를 썼음에도 비즈니스 로직이 주인
이어야 할 메소드 안에 이름도 길고 무시무시하게 생긴 트랜잭션 코드가 더 많은 자리

6장
AOP 401


를 차지하고 있는 모습이 못마땅하다. 하지만 논리적으로 따져봐도 트랜잭션의 경계는
분명 비즈니스 로직의 전후에 설정돼야 하는 것이 분명하니 UserService의 메소드에
두는것을거부할명분이 없다.

6.1.1 메소드분리
그렇다고 여기서 깔끔한 코드에 대한 열정을 포기할 이유는 없다.
리스트
6-1
에 나온트랜잭션이 적용된 코드를다시 한번살펴보자.

리스트 &-1 트랜잭션 경계설정과 비즈니스 로직이 공존하는 메소드

public void upgradeLevels() throws Exception (
TransactionStatus status =this.transactionManager

...: -----‘

getTransaction(new DefaultTransactionDefinition());
try (

List(User> users = userDao.getAll(); 트랜잭션경계설정;
for (User user users) {

if (canUpgradeLevel(user)) (

비즈니스
로직

upgradeLevel(user);

this.transactionManager.commit(status);
} catch (Exception e) {

this.tr뎌뼈다띠디띠빼매빼

an
sac
t
i
onn1애l

throw e;

얼핏 보면 트랜잭션 경계설정 묘드와 비즈니스로 로직 코드가 복잡하게 얽혀 있는
듯이 보이지만， 자세히 살펴보면 뚜렷하게 두 가지 종류의 묘드가 구분되어 있음을 알
수 있다. 비즈니스 로직 코드를 씨에 두고 트랜잭션 시작과 종료를 담당하는 묘드가
앞뒤에위치하고있다.

또， 이 묘드의 특징은 트랜잭션 경계설정의 코드와 비즈니스 로직 묘드 간에 서로 주
고받는 정보가 없다는 점이다. 비즈니스 로직 코드에서 직접 DB를 사용하지 않기 때문
에 트랜잭션 준비 과정에서 만들어진 DB 커넥션 정보 등을 직접 참조할 펼요가 없기 때
문이다. 이 메소드에서 시작된 트랜잭션 정보는 트랜잭션 동기화 방법을 통해 DAO가


알아서 활용한다. 따라서 이 두가지 묘드는 성격이 다를뿐아니
라서로주고받는 것도
없는， 완벽하게 독립적인 코드다. 다만 이 비즈니스 로직을 담당하는 코드가 트랜잭션
의 시작과 종료 작업 사이
에서 수행돼야 한다는 사항만 지켜지면 된다. 그렇다면 이 성
격이 다른 묘드를 두 개의 메소드로 분리할 수 있지 않을까?

리스트 6-2와 같이 비즈니스 로직을 담당하는 코드를 메소드로 추출해서 독립시켜
보자.

리스트 6-2 비즈니스 로직과 트랜잭션 경계설정의 분리

public void upgradeLevels() throws Exception {
TransactionStatus status = this.transactionManager
getTransaction(new DefaultTransactionDefinition());
try {
upgradeLevelsInternal();
this.transactionManager .commit(status);
} catch (Except ion e) {
this.transactionManager.rollback(status);
throw e;

private void upgradeLevelslnternal() (
List<U ser> users =userDao .getAll() ;
for (User user users) {
if (canUpgradeLevel(user)) (

분리된 비즈니스 로직 코드 트랜잭션을
upgradeLevel(user) ; 적용하기전과동일하다


코드를 분리하고 나니 보기가 한결 깔끔해졌다. 적어도 순수하게 사용자 레벨 업
그

레이드를 담당하는 비즈니스 로직 코드만 독립적인 메소드에 담겨 있으니 이해하기도

편하고， 수정하기에도부담이 없다. 실수로트랜잭션 코드를 건드릴 염려도 없어졌다.

코드의 구조를 개선하는 리팩토링을 했으니 태스트를 돌려보는 것을 잊지 말자.

6.1.2 미를 이용한 클래스의 분리
비즈니스 로직을 담당하는 코드는 깔끔하게 분리돼서 보기 좋긴 하다. 그렇지만 여전
히 트랜잭션을 담당하는 기술적인 코드가 버젓이 UserServi ce 안에 자리 잡고 있다.

6징:... AOP 403


어차피 서로 직접적으로 정보를 주고받는 것이 없다면 아예 트랜잭션 코드가 존재하
지 않는 것처럼 사라지게 할 수는 없을까? 물론 코드에 마법을 걸 수도 없는 노릇이고
꼭 필요한 기능을 담당히는 묘드라고 그냥 안 보이게 할 방법은 없다. 하지만 적어도
UserService에서는 보이지 않게 할 수 있지 않을까? 간단하게 트랜잭션 코드를 클래스
밖으로뽑아내면된다.

DI 적용을 이용한 트랜잭션 분리
지금 UserService는 UserServiceTest가 클라이언트가 되어서 사용하고 있다. 실전에
서는 아마 다른 클래스나 모률에서 이 UserService를 호출해 사용할 것이다. 그런데
UserService는 현재 클래스로 되어 있으니 다른 코드에서 사용한다면 UserService 클
래스를 직접 참조하게 된다. 그렇다면 트랜잭션 코드를 어떻게든 해서 UserService 밖
으로 빼버리면 UserSerivce 클래스를 직접 시용하는 클라이언트 코드에서는 트랜잭션
기능이 빠진 UserService를 사용하게 될 것이다. 구체적인 구현 클래스를 직접 참조하
는 경우의 전형적인 단점이다.
직접 사용하는 것이 문제가 된다면 간접적으로 사용하면 된다.DI의 기본 아이디어
는 실제 사용할 오브젝트의 클래스 정체는 감춘 채 인터페이스를 통해 간접으로 접근하
는 것이다. 그 덕분에 구현 클래스는 얼마든지 외부에서 변경할 수 있다. 바로 이런 개
념을 가진 DI가 지금 펼요하다.
현재 구조는 그림 6-) 처럼 UserSerivce 클래스와 그 사용 클라이언트 간의 관계가
강한 결합도로 고정되어 있다. 이 사이를 비집고 다른 무엇인가를 추가하기는 힘들다.

I

Client

(UserServiceTest)

」키

| UserService

‘

그림 6-1 UserService 클래스와 클라이언트의 직접 연결을 통한 강한 결합

그래서 다음과 같이 UserService를 인터페이스로 만들고 기존 코드는 UserService 인
터페이스의 구현 클래스를 만들어넣도록 한다. 그러면 클라이언트와 결합이 약해지고，
직접 구현 클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능해진다. 그림 6-2는
인터페이스를 이용해 클라이언트와 UserService 구현 클래스의 직접 결합을 믹。}주고
유연한확장이 가능하게 만든 것이다. 이미 여러 차례 반복했던 익숙한작업이다.


Client

-------.;>

(UserServiceTest)

<<interface>>
UserServicelmpl

그림 6-2 UserService 인터페이스 도입을 통해 약한 결합을 강는 유연한 구조

그런데 보통 이렇게 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고
런타임 시에 DI를 통해 적용히는 방법을 쓰는 이유는， 일반적으로 구현 클래스를 바꿔
가면서 사용하기 위해서다. 테스트 때는 필요에 따라 테스트 구현 클래스를， 정식 운영
중에는 정규 구현 클래스를 DI 해주는 방법처럼 한 번에 한 가지 클래스를 선택해서 적
용하도록되어 있다.

하지만 꼭 그래야 한다는 제약은 없다. 한 번에 두 개의 UserService 인터페이스 구
현 클래스를 통시에 이용한다면 어떨까? 지금 해결하려고 하는 문제는 UserService에
는 순수하게 비즈니스 로직을 담고 있는 코드만 놔두고 트랜잭션 경계설정을 담당히는
묘드를 외부로 빼내려는 것이다. 하지만 클라이언트가 UserService
의 기능을 제대로
이용하려면 트랜잭션이 적용돼야 한다.

그래서 그림 6-3과 같은 구조를 생각해볼 수 있다. UserService를 구현한 또 다
른 구현 클래스를 만든다. 이 클래스는 사용자 관리 로직을 담고 있는 구현 클래스인
UserServicelmpl
을 대신하기 위해 만든 게 아니다. 단지 트랜잭션의 경계설정이라는
책임을 맡고 있을 뿐이다. 그리고 스스로는 비즈니스 로직을 담고 있지 않기 때문에 또
다른 비즈니스 로직을 담고 있는 UserService
의 구현 클래스에 실제적 인 로직 처 리 작
업은 위임하는 것이다. 그 위임을 위한 호출 작업 이전과 이후에 적절한 트랜잭션 경계
를 설정해주면， 클라이언트 입장에서 볼 때는 결국 트랜잭션이 적용된 비즈니스 로직의
구현이라는 기대히는 동작이 일어날 것이다.

Client

-------.;>

(UserServiceTest)

“ interface>>
r------------L ------------,

’ •
UserServicelmpl UserServiceTx

-,

그림 6-3 트랜잭션 경계설정을 위한 UserSe
rviceTx의 도입

6갚 AOP 405


이 방법을 이용해 트랜잭션 경계설정 코드를 분리해낸 결과를 살펴보자.

UserService 인터페이스 도입
먼저 기존의 UserService 클래스를 UserServicelmpl
로 이름을 변경한다. 그리고 클
라이언트가 사용할 로직을 담은 핵심 메소드만 UserService 인터페이스로 만든 후
UserServicelmpl
이 구현하도록 만든다.
클라이언트에 노출할 메소드를 담은 인터페이스는 리스트 6-3과 같다. 현재 구현한
사용자 관리 로직의 메소드는 add( )와 upgradeLevels() 두 개뿐이다.

리스트 6-3 UserService 인터페이스

public interface UserService (
void add(User user);
void upgradeLevels();

UserService 인터페이스의 구현 클래스인 UserServicelmpl은 기존 UserService 클
래스의 내용을 대부분 그대로 유지하면 된다. 단， 트랜잭션과 관련된 코드는 독립시키기
로 했으니 모두 제거해도 좋다. 따라서 PlatformTransactionManager 인스턴스 변수와
수정자 메소드， 또 upgradeLevels()
에 남겨뒀던 트랜잭션 관련 묘드도 모두 제거한다.
앞에서 upgradeLevelslnternal()
로 분리했던 코드는 다시 원래대로 upgradeLevels()
에 넣는다. 이렇게 정리한 UserServicelmpl 묘드는 리스트 6-4와 같다.

리스트 6-4 트랜잭션 코드톨 제거한 U않rService 구현 클래스

package springbook .user .service;

public class UserServiceImpl implements UserService (
UserDao userDao;
MailSender mailSender;

public void upgradeLevels() {
List<User> users =userDao.getAll();
for (User user users) {

if (canUpgradeLevel(user)) {
upgradeLevel(user);


이렇게 수정하고 보니 메일 발송 기능을 추가했던 것을 제외하면 트랜잭션을 고려하
지 않고 단순하게 로직만을 구현했던 처음 모습으로 돌아왔다. 코드 어디에도 기술이나
서버환경， 심지어는 스프링에 관련된 코드도 보이지 않는다. 이 자체로만 보면 UserDao
라는 인터페이스를 이용하고， User라는 도메인 정보를 가진 비즈니스 로직에만 충실한
깔끔한코드다.

분리된트랜잭션기능
이제 비즈니스 트랜잭션 처리를 담은 UserServiceTx를 만들어보자. UserServiceTx는
기본적으로 UserService를 구현하게 만든다. 그리고 같은 인터페이스를 구현한 다른
오브젝트에게 고스란히 작업을 위임하게 만들면 된다. 적어도 비지니스 로직에 대해서
는 UserServiceTx가 아무런 관여도 하지 않는다. 단순하게 위임하는 코드로 만들면 리
스트 6-5와 같은 코드가 나올 것이다.

리스트 6-5 위임 기능을 가진 UserSe
rvi∞，Tx 클래스

package springbook.user.service;

public class UserServiceTx implements UserService (
UserService userService;

냉e얻농rvice률 구현한 다른

public void setUserService(UserService userService) ( I 오브젝트를 01 받는다
this .userService = userService;


public void add(User user) (
userService.add(user);

01 받은 UserService 오브젝트에
모든
기능올위임한다

public void upgradeLevels() (
userService.upgradeLevels();

UserServiceTx는 UserService 인터페이스를 구현했으니， 클라이언트에 대해
UserService 타입 오브젝트의 하나로서 행세할 수 있다. UserServiceTx는 사용자 관리
라는 비즈니스 로직을 전혀 갖지 않고 고스란히 다른 UserService 구현 오브젝트에 기
능을 위임한다. 이를 위해 UserService 오브젝트를 DI 받을 수 있도록 만든다.

6징:... AOP 407


이렇게 준비된 UserServiceTx에 트랜잭션의 경계설정이라는 부가적인 작업을 부여
해보자. UserService에 스프링의 트랜잭션 경계설정 API를 도입한 것과 동일하다. 그
구체적인 기술은 알지 못하지만 transact
ionManager라는 이름의 빈으로 등록된 트랜잭
션 매니저를 DI로 받아뒀다가 트랜잭션 안에서 동작하도록 만들어줘야 하는 메소드 호
출의 전과 후에 필요한 트랜잭션 경계설정 API를 사용해주면 된다.

리스트 6-6은 트랜잭션을 적용하도록 만든 코드다.

리스트 융용 트랜잭션이 적용된 U똥rServ
iceTx

public class UserServiceTx implements UserService {
UserService userService;
PlatformTransactionManager transactionManager;

public void setTransactionManager(
PlatformTransactionManager transactionManager) {
this.transactionManager =transactionManager;

public void setUserService(UserService userService) {
this.userService = userService;

public void add(User user) {
this. userService.add( user);

public void upgradeLevels() {
TransactionStatus status =this.transactionManager
.getTransaction(new DefaultTransactionDefinition()) ;
try {

u
serServiκce.
u
pgra
d
e
L
e
v
e
l
s();

this.transactionManager.commit(status);

} catch (RuntimeException e) {
this .transactionManager.rollback(status);
throw e;


upgradeLevels()는 UserService에서 트랜잭션 처리 메소드와 비즈니스 로직 메소
드를 분리했을 때 트랜잭션을 담당한 메소드와 거의 한 메소드가 됐다. 추상화된 트랜
잭션 구현 오브젝트를 01 받을 수 있도록 PlatformTransactionManager 타입의 프로퍼
티도추가됐다.

트랜잭션 적용을 위한 미 설정
이제 남은 것은 설정파일을 수정하는 부분이다. 클라이언트가 UserService라는 인터페
이스를 통해 사용자 관리 로직을 이용하려고 할 때 먼저 트랜잭션을 담당하는 오브젝트
가 사용돼서 트랜잭션에 관련된 작업을 진행해주고， 실제 사용자 관리 로직을 담은 오
브젝트가 이후에 호출돼서 비즈니스 로직에 관련된 작업을 수행하도록 만든다.
스프링의 DI 설정에 의해 결국 만들어질 빈 오브젝트와 그 의존관계는 그림 6-4와
같이구성돼야한다.

Client


UserServiceTx UserServicelmpl

(UserServiceTest)

그림 6-4 트랜잭션 기능의 오브젝트가 적용된 의존관계

기존에 userSerivce 빈이 의존하고 있던 tranactionManager는 UserServiceTx의 빈
이. userDao와 mailSender는 UserServicelmpl 빈이 각각 의존하도록 프로퍼티 정보를
분리한다.

리스트 6-7은 이렇게 수정한 스프링 설정파일의 내용이다.

리스트 &-7 트랜잭션 오브젝트가 추가된 실정파일


<bean id="userService" class="springbook.user.service.UserServiceTx">
<property name="transactionManager" ref="transactionManager" />
<property name=“ userService" ref=“ userServicelmpl" />

</bean> ~

<bean i
d=
띠’
미1" UserServicelmpl">띠늬딘”η'userServiκcelmpψp
class=갱
pringbook.user.service
.


<property name="userDao" ref="userDao" />

<property n1녕헤me="깨r

매a

〈

ν/bean>


이제 클라이언트는 UserServiceTx 빈을 호출해서 사용하도록 만들어야 한다. 따
라서 userService라는 대표적인 빈 아이디는 UserServiceTx 클래스로 정의된 빈에

6징:_ AOP 409


게 부여해준다. userService 빈은 UserServicelmpl 클래스로 정의되는， 아이디가
userServicelmpl 인 빈을 DI 하게 만든다.

트랜잭션 분리에 따른 테스트 수정

기본적인 분리 작업이 끝났으니 이제 태스트를 돌려봐야 히는데， 그 전에 태스트 묘드

에 손볼 곳이 제법 있다. UserService라는 클래스를 직접 사용히는 테스트 구조에， 각
종 의존 오브젝트를 테스트용 DI 기법을 이용해 바꿔치기해서 사용하곤 했으니， 기존의
UserService 클래스가 인터페이스와 두 개의 클래스로 분리된 만큼 테스트에서도 적합
한 타입과 빈을 사용하도록 변경해야 할 것이다.

먼저 스프링의 태스트용 컨텍스트에서 가져올 빈들을 생각해보자. 기존에는
UserService 클래스 타입의 빈을 @Autowired로 가져다가 사용했다. UserService는
이제 인터페이스로 바뀌었다. 인터페이스라고 하더라도 @Autowired로 가져오는 데는

아무런 문제가 없다. 하지만 @Autowired는 기본적으로 타입이 일치하는 빈을 찾아주
기 때문에 다른 문제가 발생한다. 수정한 스프링의 설정파일에는 UserService라는 인
터페이스 타입을 가진 두 개의 빈이 존재하기 때문이다. 같은 타입의 빈이 두 개라면
@Autowired를 적용한 경우 어떤 빈을 가져올까? @Autowired는 기본적으로 타입을 이용
해 빈을 찾지만 만약 타입으로 하나의 빈을 결정할 수 없는 경우에는 펼드 이름을 이용

해빈을찾는다.
따라서 UserServiceTest
에서 다음과 같은 userService 변수를 설정해두면 아이디
가 userService
인 빈이 주입될 것이다.

@Autowired UserService userService;

UserService는 인터페이스로 변경했으므로 테스트 코드는 이제 구체적인 클래스 정
보는 알지 못한 채로 컨테이너가 제공해주는 대표적인 UserService 구현 오브젝트를
사용하게 된다. UserDao를 인터페이스로 바꿨을 때와 마찬가지라고 생각하면 된다.

그런데 UserServiceTest는 하나의 빈을 더 가져외.01= 한다. 바로 UserServicelmpl
클래스로 정의된 빈이다. 일반적인 UserService 기능의 테스트에서는 UserService 인
터페이스를 통해 결과를 확인하는 것으로 충분하다. 그런데 앞 %에서 만든 MailSender
목 오브젝트를 이용한 태스트에서는 태스트에서 직접 MailSender를 DI 해줘야 할 펼
요가 있었다. MailSender를 DI 해줄 대상을 구체적으로 알고 있어야 하기 때문에
UserServicelmpl 클래스의 오브젝트를 가져올 펼요가 있다.


개발자가 자신이 작성한 묘드를 검증하기 위한 테스트인만큼 내부 구조를 속속들
이 알고 있는 채로 테스트를 만드는 것에는 문제가 없다. 단순히 UserService
의 기능
을 태스트할 때는 구체적인 클래스 정보를 굳이 태스트에 노출하지 않는 편이 낫겠지
만， 이렇게 목 오브젝트를 이용해 수동 DI를 적용하는 태스트라면 어떤 클래스의 오브
젝트인지 분명하게 알 필요가 있다. 따라서 다음과 같이 UserServicelmpl 클래스 타
입의 변수를 선언하고 @Autowired를 지정해서 해당 클래스로 만들어진 빈을 주입받도
록 한다. 그래야만 MockMailSender를 설정해주기 위한 수정자 메소드에 접근할 수 있
기 때문이다.

@Autowired UserServicelmpl userServicelmpl;

다음은 upgradeLevels() 테스트 메소드다. 한 가지만 수정해주면 된다. MailSender
의 목 오브젝트를 설정해주는 건 이제 UserService 인터페이스를 통해선 불가능하기
때문에 리스트 6-8과 같이 별도로 가져온 userServicelmpl 빈에 해줘야 한다.

리스트 6-8 목 오브젝트 설정이 필요한 테스트 코드 수정

@Test
public void upgradeLevels() throws Exception (

MockMailSender mockMailSender = new MockMailSender();
userServicelmpl.setMailSender(mockMailSender);


add() 테스트 메소드는 손댈 것이 없다. 변경하기 전과 동일하게 동작함이 보장되므
로 테스트는 그대로 둬도 좋다.

upgradeAllOrNothing() 테스트는 수정할 부분이 있다. 이 태스트는 사실 사용자 관
리 로직을 태스트하려는 목적이 아니라， 트랜잭션 기술이 바르게 적용됐는지를 확인하
기 위해 만든 일종의 학습 태스트다. 그래서 직접 테스트용 확장 클래스도 만들고 수동
DI도 적용하고 한 만큼， 바뀐 구조를 모두 반영해주는 작업이 펼요하다.

기존에는 바로 Tes tUserService 오브젝트를 만들어서 필요한 의존 오브젝트를
넣어주고서 테스트를 진행했다. 이제는 TestUserService
가 트랜잭션 기능은 빠진
UserServicelmpl을 상속하도록 해야 한다. 트랜잭션 롤백의 확인을 위해 강제로 예외
를 발생시킬 위치가 UserServicelmpl
에 있기 때문이다. 그렇다고 이 오브젝트를 가지
고 태스트해버리면， 이제는 트랜잭션이 빠져버렸으니 트랜잭션 태스트가 정상적으로
될 리가없다.

6징:..-AOP 411


그래서 리스트 6-9와 같이 TestUserService 오브젝트를 UserServiceTx 오브젝트
에 수동 DI시킨 후에 트랜잭션 기능까지 포함된 UserServiceTx의 메소드를 호출하면서
태스트를 수행하도록 해야 한다. 태스트 준비 묘드가 좀 길어지긴 했지만 원래 하나의
오브젝트만 만들던 것을 두 개로 나눴을 뿐이지 내용이 달라지진 않았다.

리스트 6-9 분리된 테스트 기능이 포함되도록 수정한 U며rade，셰
IO
rNαhing()

@Test

public void upgradeAIIOrNothing() throws Exception {
TestUserService testUserService =new TestUserService(users.get(3).getld());
testUserService.setUserDao(userDao);
testUserService.setMailSender(mailSender);

UserServiceTx txUserService =new UserServiceTx();

txUserService.setTransactionManager(transaction삐
anager);

txUserService.setUserService(testUserService);

트랜잭션 기능을 분리한
냉erServiceTx는 예외 발
생용으로수정할 필요가
없으니그대로
사용한다

userDao .deleteAll () ;
for (User user users ) userDao .add(user );

try {

트랜잭션 기능을 문리한 오브젝트톨 통해 예외 발생용txUserService.upgradeLevels();
--톨
TestUser않W∞가 호출되게 해야 한다

fai 1 ("TestUserServiceException expected");

트
랜잭션 테스트용으로 특별히 정의한 TestUserService 클래스는 이제
UserServicelmpl 클래스를 상속하도록 바꿔주변 된다.

static class TestUserService extends UserServicelmpl {

태스트 코드의 수정도 모두 끝났다. 한 번에 태스트가 성공적으로 끝나기를 바라면
서 기다리던 태스트를 수행해보자. 수정 작업 중에 오타만 없었다면 모두 깔끔하게 성
공할 것이다. 트랜잭션이 정상적으로 적용된 경우 예외가 발생해서 롤백된 경우 모두
분리하기 전과 마찬가지로 문제없이 동작할 것이다.

트랜잭션 경계설정 코드 분리의 장점
트랜잭션 경계설정 묘드의 분리와 DI를 통한 연결은 지금까지 해왔던 작업 중에서 가장
복잡하고， 큰 개선 작업이었다. 이런 수고를 한 결과로 얻을 수 있는 장점은 무엇인가?


첫째， 이제 비즈니스 로직을 담당하고 있는 UserServicelmpl
의 묘드를 작성할 때는
트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다. 트랜잭션의 적용이
필요한지도 신경 쓰지 않아도 된다. 스프링의 JDBC나 JTA 같은 로우레벨의 트랜잭션
API는 물론이고 스프링의 트랜잭션 추상화 API조차 필요 없다. 트랜잭션은 DI를 이용
해 UserServiceTx와 같은 트랜잭션 기능을 가진 오브젝트가 먼저 실행되도록 만들기만
하면 된다. 따라서 언제든지 트랜잭션을 도입할 수 있다. 트랜잭션 같은 기술적인 내용
때문에 잘 만들어놓은 비즈니스 로직 코드에 괜히 손을 대서 엉망으로 만드는 불상사도
일어나지 않을 것이다. 스프링이나 트랜잭션 같은 로우레벨의 기술적인 지식은 부족한
개발자라고 할지라도， 비즈니스 로직을 잘 이해하고 자바 언어의 기초에 충실하면 복잡
한 비즈니스로 로직을 담은 UserService 클래스를 개발할 수 있다.

두 번째 장점은 비즈니스 로직에 대한 태스트를 손쉽게 만들어낼 수 있다는 것이다.
이에 대해서는 다음 절에서 좀 더 자세히 알아보자.

: ~ 고립된 단위 테스트 j델 I

가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 태스트하는 것이다.

작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문
이다. 반대로 태스트에서 오류가 발견됐을 때 그 테스트가 진행되는 동안 실행된 코드
의 양이 많다면 그 원인을 찾기가 매우 힘들어질 수 있다. 또한 태스트 단위가 적L아야
태스트의 의도나 내용이 분명해지고， 만들기도 쉬워진다. 테스트할 대상이 크고 복잡하
면 테스트를 만들기도 그만큼 어렵고， 만들었다 해도 충분하지 못할 수 있다.

클래스 하나가 동작하도록 태스트를 만드는 것과 클래스 수십 개가 얽히고 설혀서
동작하도록만드는것중에서 어떤 것이 논리적인오류를찾기 쉬울지는분명하다. 테
스트 대상의 단위가 커지면 충분한 태스트를 만들기도 쉽지 않다. 논리적인 오류가 발
생해서 결과가 바르게 나오지 않았을 때 그 원인을 찾기도 어려워진다. 어쩌면 테스트
가 실패한 묘드를 살펴보는 것만으로는 충분하지 못해서 디버거를 사용해 한 줄씩 실
행해보면서 어느 부분에 오류가 있는지 일일이 확인해봐야 할 수도 있다. 차라리 처음
부터 작은 단위로 태스트하면서 진행해왔다면 나중에 덩치가 커져도 어렵지 않게 오
류를 찾아낼 수 있다. 작은 단위의 테스트로 검증한 부분은 제외하고 접근할 수 있기
때문이다.

6징:... AOP 413


따라서 태스트는 작은 단위로 하면 좋다. 하지만 작은 단위로 태스트하고 싶어도 그
럴 수 없는 경우가 많다. 태스트 대상이 다른 오브젝트와 환경에 의존하고 있다면 작은
단위의 태스트가주는장점을얻기 힘들다.

6.2.1 복즙펀} 의존관계 속의 테스트
UserService의 경우를 생각해보자. UserService는 엔터프라이즈 시스템의 복잡한
모률과는 비교할 수 없을 만큼 간단한 기능만을 갖고 있다. 그럼에도 UserService
의 구현 클래스들이 동작하려면 세 가지 타입의 의존 오브젝트가 필요하다. UserDao
타입의 오브젝트를 통해 DB와 데이터를 주고받아야 하고， MailSender를 구현
한 오브젝트를 이용해 메일을 발송해야 한다. 마지막으로 트랜잭션 처리를 위해
PlatformTransactionManager와 커뮤니케이션이 필요하다.
그림 6-5는 UserService를 분리하기 전의 테스트가 동작하는 모습이다.

머댁
JavaMailSenderlmpl
테스트 대상의 의존 대상
그림 6-5 테스트 대상의 의존구조

UserServiceTest가 태스트하고자 하는 대상인 UserService는 시용자 정보를 관리하는
비즈니스 로직의 구현 코드다. 따라서 UserService의 묘드가 바르게 작성되어 있으면
성공하고， 아니라면 실패하면 된다. 따라서 테스트의 단위는 UserService 클래스여야
한다.

하지만 UserService는 UserDao, TransactionManager, MailSender라는 세 가지 의
존관계를 갖고 있다. 따라서 그 세 가지 의존관계를 갖는 오브젝트들이 태스트가 진행
되는 동안에 같이 실행된다. 더 큰 문제는 그 세 가지 의존 오브젝트도 자신의 코드만
실행하고 마는 게 아니라는 점이다. JDBC를 이용해 UserDao를 구현한 UserDaoJdbc
는
DataSource의 구현 클래스와 DB 드라이버， 그리고 DB 서버까지의 네트워크 통신과
DB 서버 자체 그리고 그 안에 정의된 테이블에 모두 의존하고 있다. 트랜잭션 매니저
는 그나마 DataSource 방식이라 데이터 소스 구현에만 의존하고 있다. JTA
였다면 JTA


구현 오브젝트와 WAS 서버의 트랜잭션 서비스에까지 의존하고 있을 것이다. 메일도

앞에서 살펴본 것처럼 메일 서버의 셋업 상태에까지 모두 의존하고 있다.

따라서 UserService를 태스트하는 것처럼 보이지만 사실은 그 뒤에 존재하는 훨씬

더 많은오브젝트와환경， 서비스， 서버， 심지어 네트워크까지 함께 테스트하는셈이 된

다. 그 어느 것이라도 바르게 셋업되어 있지 않거나， 코드에 문제가 있다면 그 때문에

UserService에 대한 테스트가 실패해버리기 때문이다. 그래서 UserService라는 태스

트 대상이 테스트 단위인 것처럼 보이지만 사실은 그 뒤의 의존관계를 따라 등장하는

오브젝트와 서비스， 환경 등이 모두 합쳐져 태스트 대상이 되는 것이다.

따라서 이런 경우의 태스트는준비하기 힘들고， 환경이 조금이라도달라지면통일한

테스트 결과를 내지 못할 수도 있으며， 수행 속도는 느리고 그에 따라 태스트를 작성하

고 실행하는 빈도가 점차로 떨어질 것이 분명하다. UserService는 문제가 없는데도 누

군가 UserDao의 코드를 잘못 수정해서， 그 오류 때문에 UserService의 태스트가 실패

한다면 그 원인을 찾느라고 불펼요한 시간을 낭비해야 할 수도 있다.

DB가 함께 동작해야 하는 테스트는 작성하기 힘든 경우도 많다. 예를 들어 UserDao

에서 사용히는 SQL이 여러 개의 테이블을 조인하고， 복잡한 조건을 갖고 있고， 통계 계

산을 해서 가져오는 경우를 생각해보자. 이 DAO의 메소드가 수행돼서 테스트에 필요

한 정보를 UserService가 사용하게 하려면 DAO를 위해 복잡한 태스트 데이터를 준비

해야 한다. 그런데 막상 UserService는 가져온 목록을 가지고 간단한 계산을 하는 게

전부라면? 배보다 배꼽이 더 큰 작업이 될지도 모른다.

6.2.2 테스트 대상 오브젝트 고랍시키기
그래서 태스트의 대상이 환경이나， 외부 서벼， 다른 클래스의 묘드에 종속되고 영향
을 받지 않도록 고립시킬 필요가 있다. 태스트를 의존 대상으로부터 분리해서 고립시
키는 방법은 MailSender
에 적용해봤던 대로 태스트를 위한 대역을 사용하는 것이다.
MailSender에는 이미 DummyMailSender라는 테스트 스럽을 적용했다. 또 테스트 대역이
태스트 검증에도 참여할 수 있도록， 특별히 만든 MockMailSender라는 목 오브젝트도 사
용해봤다.

테스트를 위한 UserServicelmpl 고립
같은 방법을 UserDao에도 적용할 수 있다. 하지만 PlatformTransactionManager에는 이
런 수고를 할 필요가 없다. 트랜잭션 코드를 독립시켰기 때문에 사용자 관리 로직을 담은
UserServicelmpl은 PlatformTransactionManager에 더 이상 의존하지 않기 때문이다.

g장:_ AOP 415


이렇게 고립된 태스트가 가능하도록 UserService를 재구성해보면 그림 6-6과 같은
구조가 될 것이다. 이제 UserServicelmpl
에 대한 태스트가 진행될 때 사전에 테스트를
위해 준비된 동작만 하도록 만든 두 개의 목 오브젝트에만 의존하는 완벽하게 고립된
태스트 대상으로 만들 수 있다.


UserDaoJdbc

MockUserDa。


DSTransactionManager

UserServiceTest

DataSource / DBDriver

MockMailsender

JavaMailSener/JavaMail

고립된 테스트 대상 DB Server / Mail Server
UserServiceTx 1------------------~
그림 6-6 고립시킨 UserServicelmpl
에 대한 테스트 구조

UserDao는 단지 태스트 대상의 코드가 정상적으로 수행되도록 도와주기만 히는 스럽
이 아니라， 부가적인 검증 기능까지 가진 목 오브젝트로 만들었다. 그 이유는 고립된
환경에서 동작하는 upgradeLevels()
의 테스트 결과를 검증할 방법이 펼요하기 때문
이다.

UserServicelmpl
의 upgradeLevels() 메소드는 리턴 값이 없는 void
형이
다. 따라서 메소드를 실행하고 그 결과를 받아서 검증하는 것은 아예 불가능하다.
upgradeLevels()는 DAO를 통해 펼요한 정보를 가져와， 일정한 작업을 수행하고 그 결
과를 다시 DAO를 통해 DB
에 반영한다. 따라서 그 코드의 동작이 바르게 됐는지 확인
하려면 결과가 남아 있는 DB를 직접 확인할 수밖에 없다. 따라서 기존 태스트 코드에서
는 UserService의 메소드를 실행시킨 후에 UserDao를 이용해 DB에 들어간 결과를 가
져와 검증하는 방법을 사용했다.

그런데 의존 오브젝트나 외부 서비스에 의존하지 않는 고립된 테스트 방식으로 만든
UserServicelmpl은 아무리 그 기능이 수행돼도 그 결과가 DB 등을 통해서 남지 않으
니， 기존의 방법으로는 작업 결과를 검증하기 힘들다. upgradeLeve15 ( )처럼 결과가 리
턴되지 않는 경우는 더더욱 그렇다.

그래서 이럴 땐 테스트 대상인 UserServicelmpl과 그 협력 오브젝트인 UserDao에게
어떤 요청을 했는지를 확인하는 작업이 펼요하다. 태스트 중에 DB
에 결과가 반영되지
는 않았지만. UserDao의 update( ) 메소드를 호출하는 것을 확인할 수 있다면， 결국 DB
에 그 결과가 반영될 것이라고 결론을 내릴 수 있기 때문이다. UserDao와 같은 역할을


하면서 UserServicelmpl
과의 사이에서 주고받은 정보를 저장해뒀다가， 태스트의 검증
에 사용할 수 있게 하는 목 오브젝트를 만들 필요가 있다.

고립된단위테스트활용
고립된 단위 테스트 방법을 UserServiceTest
의 upgradeLevels() 태스트에 적용해보자.
리스트 6-10에 나온 기존 태스트 코드의 구성을 자세히 살펴보자.

리스트 6-10 u∞radeLevels( ) 테스트

@Test
public void upgradeLevels() throws Exception (
ruserDao.deleteAll(); ‘

O
B
테스트데이
터
준비

for(User user users) userDao.add(user);

MockMailSender mockMailSender = new MockMailSender(); I 메일 빌송 여부 확인올
userServicelmpl .setMailSender(mockMailSender); 위해 목 오브젝트 01

이 테스트는 다섯 단계의 작업으로 구성된다.

1. 테스트 실행 중에 UserDao를 통해 가져올 태스트용 정보를 DB
에 넣는다. UserDao
는 결국 DB를 이용해 정보를 가져오기 때문에 최후의 의존 대상인 DB
에 직접 정
보를넣어줘야한다.
6징:.. AOP 417


이 이

떼

‘리이

때 때

댔
椰


userService .upgradeLevels(); -용 테스트 대상 실행

뼈 세띠

u r*1 ·t

”9며 m써

/

” 9 ”” n

l

+l

떼 ‘떼

。도
”ul

!’
」
nr
ar
u’
L
mw
’』

”

이

세띠셰이때

‘/ …9
R떼

뻐

뼈

.,

ι
p/
떼
Jl
ι마 ，리

긴 키 띠

써이 때

써이

빠郞

때 때 때 때 때

m써 여

‘빠 떼

•
。도
11
,
」’」

따 따 따 따 샤없

tμ

nr u Q U

/

이 대

+L
r+1

l
u ” M nd

/

List<String> reQuest = mockMailSender.getReQuests();
assertThat(reQuest.size() , is(2));

목오브젝트흘 이용한

assertThat(reQuest .get(0) , is(users.get(l).getEmail())); I 결과확인
assertThat(reQuest.get(l) , is(users.get(3).getEmail()));

private void checkLevelUpgraded(User user , boolean upgraded) (
User userUpdate = userDao.get(user.getld());

쩌면

된

XC

저


2. 메일 발송 여부를 확인하기 위해 MailSender 목 오브젝트를 DI 해준다.
3. 실제 테스트 대상인 userService의 메소드를 실행한다.
4. 결과가 DB에 반영됐는지 확인하기 위해서 UserDao를 이용해 DB에서 데이터를
가져와 결과를 확인한다.
5. 목 오브젝트를 통해 UserService에 의한 메일 발송이 있었는지를 확인하면 된다.
태스트 작업을 분류해보면 처음 두 가지는 UserService의 upgradeLevels() 메소드
가 실행되는 동안에 시용하는 의존 오브젝트가 테스트의 목적에 맞게 동작하도록 준비
히는 과정이다. 첫 번째 작업은 의존관계를 따라 마지막에 등장하는 DB를 준비하는 것
인 반면에， 두 번째는 테스트를 의존 오브젝트와 서버 등에서 고립시키도록 태스트만을
위한 목 오브젝트를 준비한다는 점이 다르다.

네 번째와 다섯 번째는 테스트 대상 묘드를 실행한 후에 결과를 확인히는 작업이다.
네 번째는 의존관계를 따라 결국 최종 결과가 반영된 DB의 내용을 확인히는 방법인 반
면， 다섯 번째는 메일 서버까지 갈 펼요 없이 목 오브젝트를 통해 upgradeLevels() 메
소드가실행되는중에 메일 발송요청이 나간적이 있는지만확인하도록되어 있다.

UserDao 목 오브젝트
이제 실제 UserDao와 DB까지 직접 의존하고 있는 첫 번째와 네 번째의 테스트 방식도
목 오브젝트를 만들어서 적용해보겠다. 목 오브젝트는 기본적으로 스럽과 같은 방식으
로 테스트 대상을 통해 사용될 때 필요한 기능을 지원해줘야 한다. upgradeLevels() 메
소드가 실행되는 중에 UserDao와 어떤 정보를 주고받는지 입출력 내역을 먼저 확인할
펼요가있다.
리스트 6--11 에서 볼 수 있듯이. UserServicelmpl
의 코드를 살며보면
upgradeLevels() 메소드와 그 사용 메소드에서 UserDao를 사용하는 경우는 두 가지다.

리스트 &-11 사용자 례밸 업그레이드 작업 중에 Ul꽃m∞률 사용하는 코드

public void upgradeLevels() (
List<U ser> users = userDao.getAll(); --을 업그레이드후보
사용자
목록을가져온다
for (User user users) {

if (canUpgradeLevel(user)) (
upgradeLevel(user);


protected void upgradeLevel(User user) {
user.upgradeLevel ();

userDao.update(user);
--을 수정된 사용자 정보를 DB에 반영한다‘

sendUpgradeEMail(user);

userDao.getAll()
은 레벨 업그레이드 후보가 될 사용자의 목록을 받아옹다. 이 메소
드 기능을 지원하기 위해서 테스트용 UserDao에는 DB에서 읽어온 것처럼 미리 준비된
사용자 목록을 제공해줘야 한다. userDao
.
update(user)
의 호출은 리턴 값이 없다. 따
라서 태스트용 UserDao가 특별히 미리 준비해둘 것은 없다. 태스트가 진행되도록 하기
위해서라면 아무런 내용도 없는 빈 메소드로 만들어도 된다.

하지만 update( ) 메소드의 사용은 upgradeLevels()
의 핵심 로직인 ‘전체 사용자 중
에서 업그레이드 대상자는 레벨을 변경해준다’에서 ‘변경’에 해당하는 부분을 검증할 수
있는 중요한 기능이기
도 하다. 업그레이드를 통해 레벨이 변경된 사용자는 DB
에 반영
되도록 userDao의 update()
에 전달돼야 하기 때문이다.

그래서 getAll()
에 대해서는스럽
으로서. update()
에 대해서는목오브젝트로서 동
작하는
UserDao 타입의 태스트 대역이 필요하다. 이 클래스의 이름을
MockUserDao라고
하자.

MockUserDao의 코드는 리스트 6-12와 같이 만들 수 있다. UserServiceTest 전용일
테니 역시 스태틱 내부 클래스로 만들면 편리하다. 물론 따로 클래스 파일을 두고 만들
어도상관은없다.

리스트 6-12 U똥rD∞ 오브젝트


static class MockUserDao implements UserDao {

private List(User> users;~ 레벨 업그레이드 후보 User 오브젝트 목록

private List(User> updated = new ArrayList( );

L•-업그레이드 대상 오브젝트를 저첼H둘 목록

private MockUserDao(List(User> users) {
this .users = users;

public List(User> getUpdated() {
return this.updated;

6갚 AOP 419


public List<User) getAll () ( I

1 스텀 기능제공

return this .users;

public void update(User user) (
updated .add(user); 목 오브젝트 기능 제공

public void add(User user) ( throw new UnsupportedOperationException(); }
public void deleteAll() ( throw new UnsupportedOperationException(); }
public User get(String id) ( throw new UnsupportedOperationException(); }
public int getCount() ( throw new UnsupportedOperationException(); }

테스트에 사용되지 않는 메소드

MockUserDao는 UserDao 구현 클래
스를 대신해야 하니 당연히 UserDao 인터페
이스를 구현해야 한다. 인터페이
스를 구현하려면 인터페이스 내의 모든 메소드
를 만들어줘야 한다는 부담이 었다. upgradeLevels() 테스트 중에 사용할 것은
getAll()
과 update()
뿐인데도 말이다. 사용하지 않을 메소드도 구현해줘야 한다
면 UnsupportedOperationException을 던지도록 만드는 편이 좋다. 그냥 빈 채로 두
거나 null
을 리턴하게 해도 문제는 없다. 하지만 실수로 사용될 위험이 있으므로
UnsupportedOperationException을 던지게 해서 지원하지 않는 기능이라는 예외가 발
생하도록 만드는 게 좋다.

MockUserDao에는 두 개의 User 타입 리스트를 정의해둔다. 하나는 생성지를 통해
전달받은 사용자 목록을 저장해뒀다가. getAll() 메소드가 호출되면 DB에서 가져온
것처럼 돌려주는 용도다. 목 오브젝트를 사용하지 않을 때는 일일이 DB
에 저장했다
가 다시 가져외야 했지만. MockUserDao는 미리 준비된 테스트용 리스트를 메모리에 갖
고 있다가 돌려주기만 하면 된다. 다른 하나는 update( ) 메소드를 실행하면서 넘겨준
업그레이드 대상 User 오브젝트를 저장해뒀다가 검증을 위해 돌려주기 위한 것이다.
upgradeLevels() 메소드가 실행되는 동안 업그레이드 대상으로 선정된 사용자가 어떤
것인지 확인하는 데 쓰인다.

이제 upgradeLevels() 테스트가 MockUserDao를 사용하도록 리스트 6-13과 같이 수
정해보자.


리스트 6-13 M∞kUserDao를 사용해서 만든 고립된 테스트

@Test
public void upgradeLevels() throws Except ion {

고립된 테스트에서는 테스트

UserServicelmpl userServicelmpl = new UserServicelmpl();
--용 대상 오브젝트률 직접 생성
하면된다

MockUserDao mockUserDao = new MockUserDao(this.users); I 목 오브젝트로 인든 UserDa。를
userServiceImpl.setUserDao(mockUserDao); 직접 미 해준다

MockMailSender mockMai lSender = new MockMailSender();

userServicelmpl.setMailSender(mockMailSender);

userServicelmpl.upgradeLevels();

MockUserDa。로부터 업데이트

List이ser) updated = mockUserDao.getUpdated(); --을 결과를 가져온다
assertThat(updated.size() , is(2));
checkUserAndLevel(updated.get(9) , ' joytouch' , Level.SILVER); 1업데이트 횟수와 정보를

1 확인효따

checkUserAndLevel(updated.get(l) , 'madnitel' , Level.GOLD) ;

Li st<String) request = mockMailSender.getRequests();
assertThat(request.size() , is(2));
assertThat(request.get(0) , is(users.get(l).getEmail()));
assertThat(request.get(l) , is(users.get(3).getEmail()));

잉외 kèvel을 확인하는 간딘한 헬떠 메소드

+

private void checkUserAndLevel(User updated , String expectedId, Level
expectedLevel) (
assertThat(updated.getId() , is(expectedId));
assertThat(updated.getLevel() , is(expectedLevel));


태스트 대역 오브젝트를 이용해 완전히 고립된 테스트로 만들기 전의 테스트의 대상
은 스프링 컨테이너에서 @Autowired를 통해 가져온 UserService 타입의 빈이었다. 컨
테이너에서 가져온 UserService 오브젝트는 DI를 통해서 많은 의존 오브젝트와 서비
스， 외부 환경에 의존하고 있었다. 이제는 완전히 고립돼서 태스트만을 위해 독립적으
로 동작하는 테스트 대상을 사용할 것이기 때문에 스프링 컨테이너에서 빈을 가져올 필
요가없다.

먼저 태스트하고 싶은 로직을 담은 클래스인 UserServicelmpl
의 오브젝트를 직접
생성한다. UserServiceTest 내의 다른 태스트들이 아직 스프링으로부터 가져옹 빈을
가지고 테스트하기 때문에 태스트 클래스의 설정은 그대로 뒀지만 upgradeLevels() 테

6징:... AOP 421


스트만 있었다면 스프링의 태스트 컨텍스트를 이용하기 위해 도입한 @RunWith 등은 제
거할수있다.

사용자 정보를 모두 삭제하고 테스트용 시용자 정보를 DB
에 등록하는 등의 번거로
운 준비 작업은 필요 없다. 준비해둔 MockUserDao 오브젝트를 사용하도록 수동 DI 해주
기만 하면 된다. 이미 고립된 테스트가 가능하도록 준비된 MockMailSender도 수정자 메
소드를 이용해 DI 해준다.

고립된 태스트를 위한 준비가 끝났으면 태스트 대상인 UserServicelmpl 오브젝트의
메소드를 실행시킨다. MockDaoUser가 의존 오브젝트로 DI 되어 있으므로 미리 준비해
둔 사용자 목록을 받을 것이고， 로직에 따라 업그레이드 대상을 선정해서 레벨 변경 후
MockDaoUser의 update() 메소드를 호출하게 된다.

이제 검증에 들어갈 차례다. 과연 UserServicelmpl은 UserDao의 update()를 이용
해 몇 명의 샤용자 정보를 DB
에 수정하려고 했는지， 그 사용자들이 누구인지， 어떤 레
벨로 변경됐는지를 확인하면 된다. MockUserDao 오브젝트로부터 update( )가 호출될 때
전달받은 사용자 목록을 가져온다. 먼저 확인할 사항은 레벨 업그레이
9t 두 명에게만
일어났는지이다. 기존에는 DB에서 모든 시용자의 정보를 다시 가져와 일일이 확인해
야 했지만 이제는 그럴 필요가 없다. update() 메소드를 호출해서 변경을 시도한 것만
확인하면 되기 때문이다. MockUserDao에는 update( ) 메소드가 호출될 때마다 저장해둔
시용자 목록이 있을 것이다. 준비했던 테스트 데이터에 따르면 업그레이드 대상자는 두
명이다. 따라서 목록의 수는 2여야 한다. 전체 개수를 확인했으면 순서에 따라서 업그

레이드된 사용자의 아이디와 바뀐 레벨을 확인해보면 된다.

테스트수행성능의향상

이제 UserServiceTest
의 upgradeLevels() 태스트를 실행해보자. 태스트 결과는 물론
성공이다.
워닥 간단한 태스트인지라 전체 수행시간의 차이를 못 느끼겠지만. upgradeLeve15 ()
의 태스트 수행시간은 이전보다 분명히 빨라졌다. add()와 upgradeAIIOrNothing()은

여전히 DB까지 연동하는 의존 대상이 모두 포함된 테스트다.DB를 이용하는 태스트와

목 오브젝트만을 이용하는 태스트의 수행시간을 비교해보자.

예제를 작성한 PC에서 태스트를 실행해보고， 실행시간을 JUnit으로부터 확인해보니
add() 태스트는 0.703
초. upgradeAllOrNothing() 테스트는 0.250초가 걸렸다. 반면에
고립된 태스트로 만든 upgradeLevels() 테스트는 0.000초가 나왔다. 설마 0초일 리는


없고， JUnit의 태스트 시간 측정을 위한 최소 단위가 0.001
초인데 그보다 더 짧은 시간

에 테스트가 모두 실행됐다는 뭇이다.

어떻게 l
밀리초도 되지 않는 짧은 시간에 나름 복잡한 비즈니스 로직을 가진 테스트

가 실행될 수 있었을까? 그것은 UserServicelmpl와 태스트를 도와주는 두 개의 목 오

브젝트의 외에는 사용자 관리 로직을 검증하는 데 직접적으로 필요하지 않은 의존 오브

젝트와 서비스를 모두 제거한 덕분이다. 정말 얼마가 걸렸는지 확인할 길이 없지만， 최

대로 잡아서 0.001
초가 걸렸다고 쳐도 평균하면 DB를 사용한 여타 테스트와 비교해서

수행시간이 500배의 차이가 난다. 지금은 태스트를 모두 수행해도 2초도 안 되는 간단

한 태스트이니 별 차이 없어 보이지만， 만약 DB에서 복잡한 방법으로 대량의 데이터를

조합해 가져오는 SQL을 가진 DAO를 사용하고， 진행 과정에서 수많은 DB 업데이트나

등록이 일어나는 태스트라면 태스트 수행시간은 훨씬 큰 차이를 보일 것이다. 전체 애

플리케이션이 복잡해지면서 테스트 숫자도 늘어나고 태스트를 수행하는 시간은 점점

길어질 것이다. 그런 상황이 된다면 500배라는 차이가 주는 결과는 크다.

고립된 테스트를 하면 태스트가 다른 의존 대상에 영향을 받을 경우를 대비해 복잡

하게 준비할 펼요가 없을 뿐만 아니 라， 테스트 수행 성능도 크게 향상된다. 태스트가 빨

리 돌아가면 부담 없이 자주 태스트를 돌려볼 수 있다. 혹시 UserService의 묘드를 수

정하면서 다른 기능에 영향을 주지는 않는지 확인하고 싶다면 관련 있는 다른 태스트도

같이 실행해볼 멸요가 있다. 모든 테스트가 고립 테스트라면 1000개의 태스트를 돌려

도 l
초도안걸릴 것이다.

고립된 테스트를 만들려면 목 오브젝트 작성과 같은 약간의 수고가 더 펼요할지 모

르겠지만， 그보상은충분히 기대할만하다.

6.2.3 단위 테스트와 통합 테스트
단위 태스트의 단위는 정하기 나름이다. 사용자 관리 기능 전체를 하나의 단위로 볼 수
도 있고 하나의 클래스나 하나의 메소드를 단위로 볼 수도 있다. 중요한 것은 하나의 단
위에 초점을 맞춘 태스트라는 점이다. 어쨌든 단위 테스트라는 용어를 사용할 때는 그
의미를 명확히 할 펼요가 있다. 이 책에서는 앞으로 upgradeLevels() 테스트처럼 ‘태스
트 대상 클래스를 목 오브젝트 등의 태스트 대역을 이용해 의존 오브젝트나 외부의 리
소스를 사용하지 않도록 고립시켜서 태스트하는 것’을 단위 테스트라고 부르겠다. 반면
에 두 개 이상의， 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나，
또는 외부의 DB나 파일， 서비스 등의 리소스가 참여하는 태스트는 통합 테스트라고 부

tm_ AOP 423


르겠다. 통합 테스트란 두 개 이상의 단위가 결합해서 동작하면서 테스트가 수행되는
것이라고 보면 된다. 스프링의 테스트 컨텍스트 프레임워크를 이용해서 컨텍스트에서
생성되고 DI된 오브젝트를 태스트하는 것도 통합 태스트다.

그렇다면 단위 태스트와 통합 태스트 중에서 어떤 방법을 쓸지는 어떻게 결정할 것
인가? 몇 가지 가이드라인을살펴보자.

• 항상 단위 테스트를 먼저 고려한다
• 하나의 클래스나 성격과 목적이 같은 긴밀한 클래스 몇 개를 모아서 외부와의 의존관계를
모두 차단하고 필요에 따라 스럽이나 목 오브젝트 등의 테스트 대역을 이용하도록 태스트를
만든다. 단위 태스트는 태스트 작성도 간단하고 실행 속도도 빠르며 테스트 대상 외의 묘드
나 환경으로부터 태스트 결과에 영향을 받지도 않기 때문에 가장 빠른 시간에 효과적인 태
스트를 작성하기에 유리하다.
• 외부 리소스를 사용해야만 가능한 태스트는 통합 테스트로 만든다.
• 단위 태스트로 만들기가 어려운 코드도 있다. 대표적인 게 DAO다. DAO는 그 자체로 로직
을 담고 있기보다는 DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 한다. SQL을
JDBC를 통해 실행하는 코드만으로는 고립된 태스트를 작성하기가 힘들다. 작성한다고 해
도 가치가 없는 경우가 대부분이다. 따라서 DAO는 DB까지 연동하는 태스트로 만드는 편
이 효과적이다. DB를 사용하는 테스트는 DB에 테스트 데이터를 준비하고. DB에 직접 확
인을 하는 등의 부가적인 작업이 필요하다.
• DAO 태스트는 DB라는 외부 리소스를 사용하기 때문에 통합 태스트로 분류된다. 하지만
코드에서 보자연 하나의 기능 단위를 테스트히는 것이기도 하다. DAO를 태스트를 통해 충

분히 검증해두변. DAO를 이용하는 코드는 DAO 역할을 스럽이나 목 오브젝트로 대체해서

태스트할 수 있다. 이후에 실제 DAO와 연동했을 때도 바르게 통작하리라고 확신할 수 있
다. 물론 각각의 단위 태스트가 성공했더라도 여러 개의 단위를 연결해서 태스트하면 오류
가 발생할 수도 있다. 하지만 충분한 단위 태스트를 거친다면 통합 테스트에서 오류가 발생
할 확률도 줄어들고 발생한다고 하더라도 쉽게 처리할 수 있다.

• 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다. 다만， 단
위 태스트를 충분히 거쳤다면 통합 테스트의 부담은 상대적으로 줄어든다.
• 단위 테스트를 만들기가 너무 복잡하다고 판단되는 표드는 처음부터 통합 테스트를 고려해
본다. 이때도 통합 테스트에 참여하는 코드 중에서 가능한 한 많은 부분을 미리 단위 태스트
로 검증해두는 게 유리하다.
• 스프링 태스트 컨텍스트 프레임워크를 이용하는 태스트는 통합 태스트다. 가능하면 스프링의
지원 없이 직접 코드 레벨의 DI를 사용하면서 단위 테스트를 하는 게 좋겠지만 스프링의 설정
자체도 태스트 대싱}이고， 스프링을 이용해 좀 더 추상적인 레벨에서 테스트해야할 경우도 종
종 있다. 이럴 땐 스프링 태스트 컨텍스트 프레임워크를 이용해 통합 테스트를 작성한다.

여기서 밀F하는 단위 태스트와 통합 테스트 모두 개발자가 스스로 자신이 만든 묘드를

테스트하기 위해 만드는 개발자 테스트다. 전문 태스터나 고객에 의해 진행되는 기능 태

스트는 다른 관점에서 생각해야 한다. 태스트는 코드가 작성되고 빠르게 진행되는 편이

좋다. 태스트를 먼저 만들어두는 TDD는 코드를 만들자마자 바로 테스트가 가능하다는

장점이 있다. 테스트를 코드를 작성한 후에 만드는 경우에도 기능한 한 빨리 작성하도록

해야 한다. 묘드를 만들고 나서 오랜 시간이 지난 뒤에 작성하는 테스트는 테스트 대상

코드에 대한 이해가 떨어지기 때문에 불완전해지기 쉽고 작성하기도 번거롭다.

코드를 작성하면서 테스트는 어떻게 만들 수 있을끼를 생각해보는 것은 좋은 습관이

다. 태스트하기 편하게 만들어진 코드는 깔끔하고 좋은 묘드가 될 가능성이 높다. 만약

DI도 사용하지 않고， 비즈니스 로직과 로우레벨의 기술과， 외부 환경과 성격이 다른 데

이터 액세스 기능들이 한데 모여 강하게 결합되어 있는 코드였다면， 과연 이런 테스트

를 만들 수나 있었을까? 나중에 U
I까지 연동해서 한 번에 태스트하려고 했을 때 쏟아지

는 수많은 예외 메시지와 알 수 없는 결과를 가지고 코드와 밤새 씨름해야 겨우 테스트

가 가능할 것이 분명하다.

스프링이 지지하고 권장히는 깔끔하고 유연한 코드를 만들다보면 테스트도 그만큼

만들기 쉬워지고， 태스트는 다시 코드의 품질을 높여주고， 리팩토링과 개선에 대한 용

기를 주기도 할 것이다. 반대로 좋은 코드를 만들려는 노력을 게을리하면 테스트 작성

이 불편해지고， 태스트를 잘 만들지 않게 될 가능성이 높아진다. 태스트가 없으니 과감

하게 리팩토링할 엄두를 내지 못할 것이고 코드의 품질은 점점 떨어지고 유연성과 확장

성을잃어갈지모른다.

6.2.4 목 프레임워크
단위 테스트를 만들기 위해서는 스럽이나 목 오브젝트의 시용이 필수적이다. 의존관계
가 없는 단순한 클래스나 세부 로직을 검증하기 위해 메소드 단위로 테스트할 때가 아
니
라면， 대부분 의존 오브젝트를 필요로 하는 묘드를 테스트하게 되기 때문이다.
단위 테스트가 많은 장점이 있고 가장 우선시해야 할 태스트 방법인 건 사실이지
만 작성이 번거롭다는 점이 문제다. 특히 목 오브젝트를 만드는 일이 가장 큰 짐이다.
MockUserDao를 만들 때 이야기했듯이 태스트에서는 사용하지 않는 인터페이스도 모두
일일이 구현해줘야 한다. 검증 기능이 있는 목 오브젝트로 만들려면， 메소드의 호출 내
용을 저장했다가 이를 다시 불러오는 것도 매번 귀찮은 일이 아닐 수 없다. 특히 태스트
메소드별로 다른 검증 기능이 펼요하다면， 같은 의존 인터
페
이스를 구현한 여러 개의
목 클래스를 선언해줘야 한다.

6장
AOP 425


다행히도， 이런 번거로운 목 오브젝트를 편리하게 작성하도록 도외주는 다양한 목
오브젝트 지원 프레임워크가 있다.

Mockito 프레입워크
그중에서도 Mockito라는 프레임워크는 사용하기도 편리하고 코드도 직관적이라 최근
많은 인기를 꿀고 있다. 직접 만든 목 오브젝트를 시용했던 태스트를 이 Mockito를 이
용하도록바꿔보자.
Mockito와 같은 목 프레임워크의 특징은 목 클래스를 일일이 준비해둘 펼요가 없다
는 점이다. 간단한 메소드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트
용 목 오브젝트를 만들 수 있다.
UserDao 인터페이스를 구현한 테스트용 목 오브젝트는 다음과 같이 Mockito의 스태
틱 메소드를 한 변 호출해주면 만들어진다. mock() 메소드는 org.mockito.Matchers 클
래스에 정의된 스태틱 메소드다. 스태틱 임포트를 시용해 로컬 메소드처럼 호출하게 하
면편리하다.

UserDao mockUserDao = mock(UserDao .class);

이렇게 만들어진 목 오브젝트는 아직 아무런 기능이 없다. 여기에 먼저 getAll( ) 메
소드가 불려올 때 사용자 목록을 리턴하도록 스럽 기능을 추가해줘야 한다. 다음의 묘
드면충분하다.

when(mockUserDao.getAll()) .thenReturn(this .users);

mockUserDao.getAll()
이 호출됐을 때
(when
l. users 리스트를 리턴해주래thenReturn
)는
선언이다. 이렇게 정의한후에는
mockUserDao의 getAll() 메소드가호출되면 users 리
스트가 지동으로 리턴될 것이다.

다음은 update() 호출이 있었는지를 검증히는 부분이다. Mockito를 통해 만들어진
목 오브젝트는 메소드의 호출과 관련된 모든 내용을 자동으로 저장해두고， 이를 간단한
메소드로 검증할 수 있게 해준다.

테스트를 진행하는 동안 mockUserDao의 update( ) 메소드가 두 번 호출됐는지 확인
하고 싶다면， 다음과 같이 검증 묘드를 넣어주면 된다.

verify(mockUserDao, times(2)) .update(any(User.class));


User 타입의 오브젝트를 파라미터로 받으며 update( ) 메소드가 두 번 호출됐는지
(times(2)) 확인하래veri fy
)는 것이다.

UserDao 인터페이스를 구현한 클래스를 만들 필요도 없고 리턴 값을 생성자를 통
해 넣어줬다가 메소드 호출 시 리턴하도록 코드를 만들 필요도 없다. 특정 메소드의 호
출이 있었는지， 어떤 값을 가지고 호출했는지를 일일이 기록해뒀다가 반환하는 기능을
만들지 않아도 된다. 편리하게 작성된 메소드 몇 개로 목 오브젝트를 사용할 수 있게

해준다.
Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용하면 된다. 두 번째와 네 번째
는 각각 필요할 경우에만 사용할 수 있다.

• 인터페이스를 이용해 목 오브젝트를 만든다.
• 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다. 메소드가 호출되면 예외를 강제로 던
지게만들수도있다.
• 테스트 대상 오브젝트에 DI 해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
• 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지， 어떤 값을
가지고 몇 번 호출됐는지를 검증한다.
특별한 기능을 가진 목 오브젝트를 만들어야 하는 경우가 아니라면 거의 대부분의

단위 태스트에서 펼요한 목 오브젝트는 Mockito를 사용하는 것으로 충분하다. 리스트

6-14는 Mockito를 이용해 만든 태스트 코드다.

리스트 6-14M∞kit。률 적용한 테스트 코드


@Test
public void mockUpgradeLevels() throws Exception {
UserServicelmpl userServicelmpl = new UserServicelmpl();

UserDao mockUserDao = mock(UserDao.class); 다이내믹한 목 오브젝트 생성과 메소드의

when(mockUserDao.getAll()) .thenReturn(this .users); I 리턴 값 설정， 그리고 미까지 세 줄이연 충
userServicelmpl.setUserDao(mockUserDao); 분하다

MailSender mockMailSender = mock(MailSender .class); I 리턴 값이 없는 메소드를 기진 목 오브
userServicelmpl.setMailSender(mockMailSender); 젝트는 더욱 죠받!하게 만들 수 있다

userServicelmpl.upgradeLevels();

6앙:_ AOP 427


verify(mockUserDao , times(2)).update(any(User.class));

verify(mockUserDao, times(2)).update(any(User.class)); Il 목 오브젝트가 제공하는 검증 기능
Verify띠띠〔디싸씨따안떠삐이)
ujψpdate
얀
을 통해서 어떤 메메;살셜가 몇 번 호훌

앤
씨(r
αk
U
rD
o
매떠
빈(Lωusers.ge

moc
<lJse
ao
Lμ.
띠샌
t(1) )ι

asserπrtT까h1녕빼라때(l따(l뼈」
.M'-I

뼈mt

a
ωu


verify(mockUserDao).update(users.get(3));
assertThat(users.get(3) .getLevel() , is(Level .GOLD));

ArgumentCaptor<SimpleMailMessage> mailMessageArg = 따라미터훌 정밀히게 검사하기

위해껍처할수도있다

ArgumentCaptor.forClass(SimpleMailMessage .class); "-Â
verify(mockMailSender , times(2)).send(mailMessageArg.capture());
List<S impleMailMessage> mailMessages = mailMessageArg .getAllValues();
assertThat(mailMessages.get(0).getTo()[
이 , is(users.get(l) .getEmail()));
assertThat(mailMessages.get(l).getTo()[
이 , is(users .get(3).getEmail()));

UserDao의 목 오브젝트를 생성하고 getAll()
이 호출됐을 때의 리턴 값을 설정해준
뒤에 태스트 대상에 01 해준다. UserDao 인터페이스를 구현해서 목 클래스를 따로 정의
할 필요도 없이 매우 간단한 코드 몇 줄로 목 오브젝트의 준비가 묻난다. MailSender도
따로 목 클래스를 정의할 필요가 없다. Mockito를 이용해 간단히 목 오브젝트를 생성해
서 01 해주면 된다. 목 오브젝트의 준비는 끝났고，
01를 마친 userSericelmpl 오브젝
트는 이제 고립된 테스트가 가능해졌다.

userServicelmpl 메소드가 실행되는 동안 01 해준 목 오브젝트의 메소드가 호출되
면 자동으로 호출 기록이 남겨진다. getAll()
처럼 미리 설정해둔 리턴 값이 있는 경우
에는 그 값을 그대로 리턴해주기도 한다.

다음은 목 오브젝트의 메소드가 어떻게 호출됐는지를 검증할 차례다. times()
는 메
소드 호출 횟수를 검증해준다. any()
를 사용하면 파라미터의 내용은 무시하고 호출 횟
수만 확인할 수 있다. 호출 횟수 검사가 끝나면 목 오브젝트가 호출됐을 때의 파라미터
를 하나씩 점검한다. 이 태스트에서 확인하고 싶은 사항은 UserDao
의 update( ) 메소
드가두 번 호출됐고， 그때의 파라미터는
getAll()
에서 넘겨준
User 목록의 두 번째와
네 번째여야 한다는 것이다. verify(mockUserDao).update(users.get(l))
은 users .
get(l)
을 따라미터로 update()
가 호출된 적이 있는지를 확인해준다. update()
가 아예
호출된 적이 없거나파라미터가
users.get(l)
이 아니었다면 태스트는 실패한다.

각각 오브젝트는 확인했지만 레벨의 변회는 파라미터의 직접 비교로는 직접 확인이
되지 않는다. 따라서 getAll()
을 통해 전달했던 User 목록의 내용을 가지고 레벨이 변
경됐는지를 직접 확인해야 한다.


Mai
l
Send
er의 경우는 ArgumentCaptor라는 것을 사용해서 실제 MailSender 목 오브
젝트에 전달된 파라미터를 가져와 내용을 검증하는 방법을 사용했다. 파라미터를 직접
비교하기보다는 파라미터의 내부 정보를 확인해야 하는 경우에 유용하다.

Mockito는 지금까지 나온 목 오브젝트 방식을 지원히는 프레임워크 중에서 가장 사
용하기 편리한 기능을 갖고 있다. 처음엔 조금 어렵게 느껴질지 모르겠지만， 목 프레임
워크만의 독특한 사용 방법에 익숙해지면， 빠른 속도로 단위 태스트를 만드는 데 강력
한도구가될것이다.

이 책에서는 더 이상 Mockito와 같은 툴의 사용 방법은 다루지는 않을 것이다. 하지
만 스프링을 사용한다면 단위 테스트를 만들어야 할 태고， 단위 태스트를 만든다면 목
오브젝트는 지주 펼요하다. 따라서 Mockito와 같은 목 오브젝트 지원 프레임워크 하나
쯤은 익숙하게 사용할 수 있도록 학습해두자.

IE 다이내믹 프렇|오f 괜원l fH i섣I

6.3.1 프록시와 프록시 패턴， 데코레이터 꽤턴
트랜잭션 경계설정 코드를 비즈니스 로직 코드에서 분리해낼 때 적용했던 기법을 다시
검토해보자.
단순히 확장성을 고려해서 한 가지 기능을 분리한다면 전형적인 전략 패턴을 사용하
면 된다. 트랜잭션 기능에는 추상화 작업을 통해 이미 전략 패턴이 적용되어 있다. 하지
만 전략 패턴으로는 트랜잭션 기능의 구현 내용을 분리해냈을 뿐이다. 트랜잭션을 적용
한다는 사실은 코드에 그대로 남아 있다. 그림 6-7은 트랜잭션과 같은 부가적인 기능을
위임을 통해 외부로 분리했을 때의 결과를 보여준다. 구체적인 구현 코드는 제거했을지
라도위임을통해 기능을시용하는코드는 핵심 코드와함께 남아있다.

핵심기능 코드 핵심기능 코드

E수 --:õ>f 부가기능 인터페이스

부가기능 구현 코드 부가기능 위잉 코드 | 부가기능 구현 코드
그립 6-7 전략 때턴 적용올 통한 부가기능 구현의 분리

트랜잭션이라는 기능은 사용자 관리 비즈니스 로직과는 성격이 다르기 때문에 아예 그
적용 사실 자체를 밖으로 분리할 수 있다. 그림 6-8과 같이 부가기능 전부를 핵심 코드

6징:... AOP 429



가 담긴 클래스에서 독립시킬 수 있다. 이 방법을 이용해 U
serSe
r
v
i
ceTx를 만들었고，
UserSer
vicelmp
l에는 트랜잭션 관련 코드가 하나도 남지 않게 됐다.

--l

핵심기능 코드 부가기능

ll

」

핵심기능

다

l’’

-


,

|
j

그림 6-8 부가기능과 핵심기능의 분리

걱

「

이렇게 분리된 부가기능을 담은 클래스는 중요한 특징이 있다. 부가기능 외의 나머지
모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 한다. 핵심기능은 부가기능을
가진 클래스의 존재 자체를 모른다. 따라서 부가기능이 핵심기능을 사용히는 구조가 되

는것이다.

문제는 이렇게 구성했더라도 클라이언트가 핵심기능을 가진 클래스를 직접 시용해
버리면 부가기능이 적용될 기회가 없다는 점이다. 그래서 부가기능은 마치 자신이 핵심
기능을 가진 클래스인 것처럼 꾸며서， 클라이언트가 자신을 거쳐서 핵심기능을 사용하
도록 만들어야 한다. 그러기 위해서는 클라이언트는 인터페이스를 통해서만 핵심기능

을 사용하게 하고， 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에
끼어틀어야 한다. 그러면 클라이언트는 인터페이스만 보고 사용을 하기 때문에 자신은
핵심기능을 가진 클래스를 사용할 것이라고 기대하지만， 사실은 그림 6-9처럼 부가기

능을 통해 핵심기능을 이용하게 되는 것이다.

클라이언트 핵심기능 인터페이스 핵심기능 인터페이스
부가기능 핵심기능}/ [
그림 6-9 핵심기능 인터페이스의 적용

부가기능 코드에서는 핵심기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인
기능을 적용해줄 수 있다. 비즈니스 로직 코드에 트랜잭션 기능을 부여해주는 것이 바
로 그런 대표적인 경우다.

이렇게 마치 자신이 클라이언트가 시용하려고 히는 실제 대상인 것처럼 위장해서 클
라이언트의 요청을 받F아주는 것을 대리자， 대리인과 같은 역할을 한다고 해서 프록시
proxy라고 부른다. 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리히는 실제 오
브젝트를 타깃target 또는 실체real su이ect라고 부른다. 그림 6-1
0은 클라이언트가 프록시

를 통해 타깃을 시용하는 구조를 보여주고 있다.

부가기능 구현 코드

|.l


I|l

l
1I

--L
F l

l’

’

j

꺼

ll

I

J

클라이언트 프록시

r---?

타깃

cu

펴

깃타

쐐렐애

프록시의 특정은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할
수 있는 위치에 있다는 것이다.

프록시는 사용 목적에 따라 두 가지로 구분할 수 있다. 첫째는 클라이언트가 타깃에
접근하는 방법을 제어하기 위해서다. 두 번째는 타깃에 부가적인 기능을 부여해주기 위
해서다. 두 가지 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일
하지만， 목적에 따라서 디자인 패턴에서는 다른 패턴으로 구분한다.

데코레이터패턴
데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이
내
믹하게 부여해주기 위해
프록시를 사용하는 패턴을 밀한다. 다이내믹하게 기능을 부가한다는 의미는 컴파일 시
점， 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해
져 있지 않다는 뭇이다. 이 패턴의 이름이 데코레이
터
라고 불리는 이유는 마치 제품이
나 케익 등을 여러 겹으로 포장하고 그 위에 장식을 붙이는 것처럼 실제 내용물은 동일
하지만 부가적인 효과를 부여해줄 수 있기 때문이다. 따라서 데코레이터 패턴에서는 프
록시가 목 한 개로 제한되지 않는다. 프록시가 직접 타깃을 사용하도록 고정시킬 필요
도 없다. 이를 위해 데코레이터 패턴에서는 같은 인터페이스를 구현한 타켓과 여러 개
의 프록시를 시용할 수 있다. 프록시가 여러 개인 만큼 순서를 정해서 단계적으로 위임
하는 구조로 만들면 된다.
예를 들어 소스코드를 출력하는 기능을 가진 핵심기능이 있다고 생각해보자. 이 클
래스에 데코레이터 개념을 부여해서 타깃과 같은 인터페이스를 구현하는 프록시를 만
들수 있다. 예를들어 소스코드에 라인넘벼를붙여준다거나 문법에 따라색을 변경해
주거나， 특정 폭으로 소스를 잘라주거나， 페이지를 표시해주는 등의 부가적인 기능을
각각 프록시로 만들어두고 그림 6-11
과 같이 런타임 시에 이를 적절한 순서로 조합해
서사용하면된다.

클라이언트

데코레이터
그림 6-11 데코레이터 패턴 적용 예


6장:... AOP 431


프록시로서 동작하는 각 데코레이터는 위임히는 대상에도 인터페이스로 접근하기 때문
에 자신이 최종 타깃으로 위임하는지， 아니면 다음 단계의 데코레이터 프록시로 위임하
는지 알지 못한다. 그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성
자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만
들어야한다.

자바 IO 패키지의 InputStream과 OutputStream 구현 클래스는 데묘레이터 패턴이
시용된 대표적인 예다. 다음 코드는 InputStream이라는 인터페이스를 구현한 타깃인
FilelnputStream에 버퍼 읽기 기능을 제공해주는 BufferedlnputStream이라는 데코레
이터를적용한예다.

InputStream is = new BufferedlnputStream(new FilelnputStream("a.txt"));

UserService 인터페이스를 구현한 타깃인 UserServicelmpl
에 트랜잭션 부가기능을
제공해주는 UserServiceTx를 추가한 것도 데묘레이터 패턴을 적용한 것이라고 볼 수
있다. 이 경우는 수정자 메소드를 이용해 데코레이터인 UserServiceTx
에 위임할 타깃
인 UserServicelmpl을 주입해줬다.

인터페이스를 통한 데코레이터 정의와 런타임 시의 다이내믹한 구성 방법은 스프링
의 DI를 이용하면 아주 편리하다. 데코레이터 빈의 프로퍼티로 같은 인터페이스를 구현
한 다른 데코레이터 또는 타깃 빈을 설정하면 된다.

스프링 설정을 다시 살펴보자. UserServiceTx 클래스로 선언된 userService 빈은
데코레이터다. UserServiceTx는 UserService 타입의 오브젝트를 DI 받아서 기능은 위
임하지만， 그 과정에서 트랜잭션 경계설정 기능을 부여해준다. 리스트 6-I5
에 나타
난 대로 현재는 UserServicelmpl 클래스로 선언된 타깃 빈이 DI를 통해 데코레이터 인
userService 빈에 주입되도록 설정되어 있다. 다이내믹한 부가기능의 부여라는 데코레
이터 패턴의 전형적인 적용 예다.

리스트 EH5 데코레이터 때턴율 위한 미 설정

<!--더|코레이터 -->

<bean id="userService" class="springbook.user.service .UserServiceTx">
<property name="transactionManager" ref="transactionManager" />
<property name="userService'’ ref="userServicelmpl" />

</bean> --


미톨 통한 다이내믹한 구성
<!--타깃 -->

Ãé

<bean id="userServicelmpl" class="springbook.user .service.UserServicelmpl">


<property name="userDao" ref="userDao" />
<property name="mailSender" ref="mailSender" />
</bean>

데코레이터 패턴은 인터페이스를 통해 위임히는 방식이기 때문에 어느 데코레이터에
서 타깃으로 연결될지 묘드 레벨에선 미리 알 수 없다. 구성하기에 따라서 여러 개의 데
코레이터를 적용할 수도 있다. UserServiceTx도 UserSerivce라는 인터페이스를 통해
다음 오브젝트로 위임하도록 되어 있지 UserServicelmpl
이라는 특정 클래스로 위임하
도록 되어 있지 않다. 펼요하다면 언제든지 트랜잭션 외에도 다른 기능을 부여해주는 데
코레이터를 만들어서 UserServiceTx와 UserServicelmpl 사이에 추가해줄 수도 있다.

데묘레이터 패턴은 타깃의 코드를 손대지 않고， 클라이언트가 호출히는 방법도 변경
하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

프록시패턴
일반적으로 사용하는 프록시라는 용어와 디자인 패턴에서 말히는 프록시 패턴은 구분
할 필요가 있다. 전자는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를
두는 방법을 총칭한다면， 후자는 프록시를 샤용하는 방법 중에서 타깃에 대한 접근 방
법을제어하려는목적을가진 경우를가리킨다.
프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언
트가 타깃에 접근하는 방식을 변경해준다. 타깃 오브젝트를 생성하기가 복잡하거나 당
장 필요하지 않은 경우에는 목 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다.
그런데 타깃 오브젝트에 대한레퍼런스가미리 필요할수 있다. 이럴 때 프록시 패턴을
적용하면 된다. 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데， 실제 타깃 오
브젝트는 만드는 대신 프록시를 넘겨주는 것이다. 그리고 프록시의 메소드를 통해 타
깃을 사용하려고 시도하면， 그때 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주
는 식이다. 만약 레퍼런스는 갖고 있지만 묻까지 사용하지 않거나， 많은 작업이 진행된
후에 사용되는 경우라면， 이렇게 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이
많다.
또는 원격 오브젝트를 이용하는 경우에도 프록시를 사용하면 편리하다. RMI나
EJB, 또는 각종 리모팅 기술을 이용해 다른 서벼에 존재하는 오브젝트를 사용해야 한
다면， 원격 오브젝트에 대한 프록시를 만들어두고， 클라이언트는 마치 로컬에 존재하는
오브젝트를 쓰는 것처럼 프록시를 시용하게 할 수 있다. 프록시는 클라이언트의 요청을

6징:... AOP 433



받으면 네트워크를 통해 원격의 오브젝트를 실행하고 결과를 받아서 클라이언트에게
돌려준다. 클라이언트로 하여금 원격 오브젝트에 대한 접근 방법을 제공해주는 프록시

패턴의예라고볼수있다.
또는 특별한 상햄서 타깃에 대한 접근권한을 제어하기 위해 프록시 패턴을 시용할
수 있다. 만약 수정 가능한 오브젝트가 있는데， 특정 레이어로 넘어가서는 읽기전용으

로만 동작하게 강제해야 한다고 하자. 이럴 때는 오브젝트의 프록시를 만들어서 사용할
수 있다. 프록시의 특정 메소드를 시용하려고 하면 접근이 불가능하다고 예외를 발생시
키면 된다. Collections
의 unmodifiableCollection()
을 통해 만들어지는 오브젝트가
전형적인 접근권한 제어용 프록시라고 볼 수 있다. 파라미터로 전달된 Collection 오브
젝트의 프록시를 만들어서. add () t..f remove () 같이 정보를 수정히는 메소드를 호출할
경우 UnsupportedOperationException 예외가 발생하게 해준다.

이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근히는 방법을 제
어해주는 프록시를 이용하는 것이다. 구조적으로 보자면 프록시와 데코레이터는 유사
하다. 다만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는
경우가 많다. 생성을 지연하는 프록시라면 구체적인 생성 방법을 알。야 하기 때문에
타깃 클래스에 대한 직접적인 정보를 알아야 한다. 물론 프록시 패턴이라고 하더라도
인터페이스를 통해 위임하도록 만들 수도 있다. 인터페이스를 통해 다음 호출 대상으
로 접근하게 하면 그 사이에 다른 프록시나 데코레이터가 계속 추가될 수 있기 때문이
다. 그림 6-12는접근제어를위한프록시를두는프록시 패턴과컬러， 페이정 기능을추
가하기 위한프록시를두는데코레이터 패턴을함께 적용한예다. 두가지 모두프록시의
기본 원리대로 타깃과 같은 인터페이스를 구현해두고 위임하는 방식으로 만들어져 있다.

클라이언트


프록시 패턴 데코레이터 패턴 타깃
그림 6-12 프록시 패턴과 데코레이터 때턴의 혼용

앞으로는 타깃과 통일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면서
기능의 부가 또는 접근 제어를 담당히는 오브젝트를 모두 프록시라고 부르겠다. 하지만
그때마다 사용의 목적이 기능의 부가인지， 접근 제어인지를 구분해보면 각각 어떤 목적
으로 프록시가 사용됐는지 그에 따라 어떤 패턴이 적용됐는지 알 수 있을 것이다.


6.3.2 다이내믹프록시
프록시는 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제
어할 수 있는 유용한 방법이다. 그럼에도 불구하고 많은 개발자는 타깃 코드를 직접 고
치고 말지 번거롭게 프록시를 만들지는 않겠다고 생각한다. 왜냐하면 프록시를 만드는
일이 상당히 번거롭게 느껴지기 때문이다. 매번 새로운 클래스를 정의해야 하고， 인터
페이스의 구현해야 할 메소드는 많으면 모든 메소드를 일일히 구현해서 위임하는 코드
를 넣어야 하기 때문이다. 단위 태스트를 위해 목이나 스럽을 일일이 클래스로 정의하
고 인터페이스의 모의 메소드를 구현하는 일이 불편했던 것과 마찬가지다.
그렇다면 목 오브젝트를 만드는 불편함을 목 프레임워크를 사용해 편리하게 바꿨던
것처럼 프록시도 일일이 모든 인터페이스를 구현해서 클래스를 새로 정의하지 않고도
편리하게 만들어서 사용할 방법은 없을까?
물론 있다. 자바에는 java.lang.reflect 패키지 안에 프록시를손쉽게 만들수 있도
록 지원해주는 클래스들이 있다. 기본적인 아이디어는 목 프레임워크와 비슷하다. 일일
이 프록시 클래스를 정의하지 않고도 몇 가지 API를 이용해 프록시처럼 동작하는 오브
젝트를 다이내믹하게 생성히는 것이다.

프록시의 구성과 프록시 작성의 문제점
프록시는 다음의 두 가지 기능으로 구성된다.

• 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임한다.
• 지정된 요청에 대해서는 부가기능을 수행한다.
트랜잭션 부가기능을 위해 만든 UserTx는 기능 부가를 위한 프록시다. 리스트 6-16
의 UserTx 코드에서 이 두 가지 기능을 구분해보자.

리스트 6-16 UserSe
rvi∞，Tx 프록시의 기능 구분


public class UserServiceTx implements UserService (
UserService userService; -•-타깃 오브젝트

public void add(User user) (
this .userService .add(user); I 메소드구현과위임

public void upgradeLevels() {-융 메소드 구현

6징:.. AOP 435


TransactionStatus status = this.transactionManager
.getTransaction(new DefaultTransactionDefinition()); I부가기능 수행
try {

userService.upgradeLevels();--융 위임

this.transactionManager.commit(status);

} catch (RuntimeException e) {
부가기능수행
this.transactionManager.rollback(status);
throw e;

UserServiceTx 코드는 UserService 인터페이스를 구현하고 타깃으로 요청을 위임하
는 트랜잭션 부가기능을 수행하는 묘드로 구분할 수 있다. 이렇게 프록시의 역할은 위임
과 부가작업이라는 두 가지로 구분할 수 있다. 그렇다면 프록시를 만들기가 번거로운 이
유는 무엇일까? 역시 두 가지 이유를 찾이볼 수 있다.

• 첫째는 타깃의 인터페이스를 구현하고 위임하는 묘드를 작성하기가 번거롭다는 점이다. 부
가기능이 필요 없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
복잡하진 않지만 인터페이스의 메소드가 많아지고 다양해지면 상당히 부담스러운 작업이
될 것이다. 또， 타깃 인터페이스의 메소드가 추가되거나 변경될 때마다 함께 수정해줘야 한
다는부담도있다.
• 두 번째 문제점은 부가기능 코드가 중복될 7벼성이 많다는 점이다. 트랜잭션은 DB를 사
용하는 대부분의 로직에 적용될 펼요가 있다. 아직까지 add() 메소드에는 트랜잭션 부가기
능을 적용하지 않았지만， 사용자를 추가하는 과정에서 다른 작업이 함께 진행돼야 한다면
add() 메소드에도 트랜잭션 경계설정 부가기능이 적용돼야 한다. 메소드가 많아지고 트랜
잭션 적용의 비율이 높아지면 트랜잭션 기능을 제공하는 유사한 코드가 여러 메소드에 중복
돼서나타날것이다.
사용자 관리 로직 외에도 다OJ=한 비즈니스 로직을 담은 클래스가 만들어질 것이다.
그때마다 메소드에 트랜잭션 기능을 부여하는 코드가 중복돼야 할지 모른다. 트랜잭션
외의 프록시를 활용할 만한 부가기능， 접근제어 기능은 일반적인 성격을 띤 것들이 많
다. 따라서 다OJ=한 타깃 클래스와 메소드에 중복돼서 나타날 가능성이 높다.

두 번째 문제인 부가기능의 중복 문제는 중복되는 코드를 분리해서 어떻게든 해결해


보면 될 것 같지만， 첫 번째 문제인 인터페이스 메소드의 구현과 위임 기능 문제는 간단
해 보이지 않는다. 바로 이런 문제를 해결히는 데 유용한 것이 바로 JDK의 다이내믹 프
록시다.

리플렉션
다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다. 리플렉션은 자바
의 묘드 자체를 추상화해서 접근하도록 만든 것이다.
다음과 같이 만들어진 간단한 스트링 타입의 오브젝트가 있다고 하자.

String name = "Spring";

이 스트링의 길이를 알고 싶으면 String 클래스의 length( ) 메소드를 호출하면 된다.
일반적인 사용 방법은 name .length() 같이 직접 메소드를 호출하는 코드로 만드는 것이다.

자바의 모든 클래스는 그 클래스 자체의 구성정보를 담은 Class 타입의 오브젝트를
하나씩 갖고 있다. ‘클래스이름.class’라고 하거나 오브젝트의 getCl ass( ) 메소드를 호출
하면 클래스 정보를 담은 Cl ass 타입의 오브젝트를 가져올 수 있다. 클래스 오브젝트를
이용하면 클래스 코드에 대한 메타정보를 가져오거나 오브젝트를 조작할 수 있다. 예를
들어 클래스의 이름이 무엇이고 어떤 클래스를 상속하고 어떤 인터페이스를 구현했는
지， 어떤 필드를 갖고 있고， 각각의 타입은 무엇인지， 메소드는 어떤 것을 정의했고， 메
소드의 파라미터와 리턴 타입은 무엇인지 알아낼 수 있다. 더 니-ò)-가서 오브젝트 필드의
값을 읽고 수정할 수도 있고， 원하는 파라미터 값을 이용해 메소드를 호출할 수도 있다.
리플렉션에 대한 자세한 사항은 java.lang.reflect 패키지의 자바문서를 읽어보기 바
란다.

리플렉션 API 중에서 메소드에 대한 정의를 담은 Method
라는 인터페이스를 이용
해 메소드 호출히는 방법을 살펴보자. String 클래스의 정보를 담은 Class 타입의 정
보는 String. class
라고 하면 가져올 수 있다. 또는 스트링 오브젝트가 있으면 name.
get
Cl
ass()
라고 해도 된다. 그리고 이 클래스 정보에서 특정 이름을 가진 메소드 정보
를 가져올 수 있다
String의 length() 메소드라면 다음과 같이 하면 된다.

Method lengthMethod = String.class.getMethod("length");

스트링이 가진 메소드 중에서 “
length"라는 이름을 갖고 있고， 파라미터는 없는 메
소드의 정보를 가져오는 것이다. java.lang.reflect.Method 인터페이스는 메소드에
대한 자세한 정보를 담고 있을 뿐만 아니라， 이를 이용해 특정 오브젝트의 메소드를 실

6장:... AOP 437


행시킬 수도 있다. Method 인터페이스에 정의된 invoke( ) 메소드를 시용하면 된다.
invoke( ) 메소드는 메소드를 실행시킬 대상 오브젝트
(ob
j)와 따라미터 목록{args)을 받아
서 메소드를 호출한 뒤에 그 결과를 Object 타입으로 돌려준다.

public Object invoke(Object obj , Object .. . args)
이를 이용해 length() 메소드를 디음과 같이 실행할 수 있다.
int length = lengthMethod.invoke(name); // int length = name.length();

Method를 이용해 메소드를 호출하는 방법을 익히기 위해서 리스트 6-17과 같은 간
단한 학습 태스트를 만들어보자.

리스트 6-17 리플렉션 학습 테스트

package springbook.learningtest . jdk;

public class ReflectionTest {
@Test
public void invokeMethod() throws Exception {

String name = "Spring";

// length()
assertThat(name.length() , is(6));

Method lengthMethod =String.class.getMethod("length");
assertThat((Integer)lengthMethod.invoke(name) , is(6));

// charAt()
assertThat(name.charAt(0) , is('S ’));

Method charAtMethod =String.class.getMethod("charAt" , int.class);
assertThat((Character)charAtMethod.invoke(name , 0) , is( ’S’ ));

String 클래스의 length() 메소드와 charAt() 메소드를 묘드에서 직접 호출하는 방
법과. Method를 이용해 리플렉션 방식으로 호출하는 방법을 비교한 것이다.


프록시클래스
다이내믹 프록시를 이용한 프록시를 만들어보자. 프록시를 적용할 간단한 타깃 클래스
와인터페이스를 리스트
6-18과같이 정의한다. 구현할 인터페이스는디음과같다.

리스트 6-18 Hello 인터페이스

interface Hello (
String sayHello(String name);
String sayHi(String name);
String sayThankYou(String name);

그리고 이를 구현한 타깃 클래스는 리스트 6-19와 같이 정의하자.
리스트 6-19 타깃 클래스

public class HelloTarget implements Hello (
public String sayHello(String name) (
return "Hello " + name;

public String sayHi(String name) (
return "Hi " + name;

public String sayThankYou(String name) (
return "Thank You " + name;


이제 Hello 인터페이스를 통해 HelloTarget 오브젝트를 사용하는 클라이언트 역할
을 하는 간단한 태스트를 리스트 6-20과 같이 만든다. 간단한 기능과 테스트이니 별다
른 설명은 필요 없을 것이다.

리스트 6-20 클라이언트 역할의 테스트

@Test

public void simpleProxy() (
Hello hello = new HelloTarget();~ 타깃은 인터메이스를통해 접근하는습관을들이자
assertThat(hello. sayHello( "Toby") , is( "Hello Toby"));

6징:... AOP 439


assertThat(hello.sayHi("Toby") , is( ’‘ Hi Toby"));
assertThat(hello. sayThankYou( "Toby") , is( "Thank You Toby.));

이제 Hello 인터페이스를 구현한 프록시를 만들어보자. 프록시에는 데묘레이터
패턴을 적용해서 타깃인 HelloTarget
에 부가기능을 추가하겠다. 프록시의 이름은
HelloUppercase다. 추가할 기능은 리턴하는 문지를 모두 대문자로 바꿔주는 것이다.
SimpleTarget
이라는 원본 클래스는 그대로 두고， 경우에 따라 대문자로 출력이 필요한
경우를 위해서 HelloUppercase 프록시를 통해 문자를 바꿔준다. HelloUppercase 프록
시는 Hello 인터페이스를 구현하고 Hello 타입의 타깃 오브젝트를 받아서 저장해둔다.
Hello 인터페이스 구현 메소드에서는 타깃 오브젝트의 메소드를 호출한 뒤에 결과를 대
문자로 바꿔주는 부가기능을 적용하고 리턴한다. 위임과 기능 부가라는 두 가지 프록시
의 기능을 모두 처리하는 전형적인 프록시 클래스다. 리스트 6-21
은 이렇게 만들어진
HelloUppercase 프록시 클래스다.

리스트 6-:낀 프룩시 클래스

public class HelloUppercase implements Hello (

Hello hello; -•-위입할 타깃 오브젝트 여기서는 타깃 클래스의 오브젝트인 것은 일지만
다른 프룩시톨 추가할 수도 있으므로 인터때101스로 접근한다.

public HelloUppercase(Hello hello) (
this.hello =hello;

public String sayHello(String name) (
return hello.sayHello(name).toUpperCase();--률 위입과 부가기능 적용

public String sayHi(String name) (
return hello.sayHi(name).toUpperCase();

public String sayThankYou(String name) (
return hello.sayThankYou(name).toUpperCase();


리스트 6-22와 같이 테스트 코드를 추가해서 프록시가 동작히는지 확인해보자
리스트 6-22 Hel
lolJ
p야rcase 프록시 테스트

프록시훌 통해 타깃 오브젝트

Hello proxiedHello = new HelloUppercase(new HelloTarge
t
());--틀 에 접근하도록구성한다
assertThat (proxiedHello .sayHello( "Toby") , is( "HELLO TOBY" )) ;
assertThat(proxiedHello. sayHi ("Toby") , is (" HI TOBY"));
assertThat (proxiedHello.sayThankYou( “Toby") , is("THANK YOU TOBY"));

이 프록시는 프록시 적용의 일반적인 문제점 두 가지를 모두 갖고 있다. 인터페이스
의 모든 메소드를 구현해 위입하도록 묘드를 만들어야 하며， 부가기능인 리턴 값을 대
문자로 바꾸는 기능이 모든 메소드에 중복돼서 나타난다.

다이내믹프록시적용
클래스로 만든 프록시인 HelloUppercase를 다이내믹 프록시를 이용해 만들어보자.
다이내믹 프록시가 동작하는 방식은 그림 6-13과 같다.

InvocationHandler
프록시 요정
타깃


그림 6-13 다이내믹 프록시의 동작방식

다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝
트다. 다이내믹 프록시 오브젝트는타깃의 인터페이스와같은
타입으로만들어진다. 클
라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용할 수 있다. 이
덕분에 프록시를 만들 때 인터페이스를 모두 구현해가면서 클래스를 정의히는 수고를
덜 수 있다. 프록시 팩토리에게 인터페이
스 정보만 제공해주면 해당 인터페이스를 구현
한 클래스의 오브젝트를 자동으로 만들어주기 때문이다.

다이내믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어주지만， 프록시로
서 필요한 부가기능 제공 코드는 직접 작성해야 한다. 부가기능은 프록시 오브젝트와
독립적으로 InvocationHandler를 구현한 오브젝트에 담는다. InvocationHandler 인터
페이스는 다음과 같은 메소드 한 개만 가진 간단한 인터페이스다.

6장!_ AOP 441


public Object invoke(Object proxy , Method method , Object[] args)

invoke( ) 메소드는 리플렉션의 Method 인터페이스를 따라미터로 받는다. 메소드
를 호출할 때 전달되는 파라미터도 args로 받는다. 다이내믹 프록시 오브젝트는 클라
이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의
invoke() 메소드로 넘기는 것이다. 타깃 인터페이스의 모든 메소드 요청이 하나의 메소
드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.

남은 것은 각 메소드 요청을 어떻게 처리할지 결정하는 일이다. 리플렉션으로 메소
드와 파라미터 정보를 모두 갖고 있으므로 타깃 오브젝트의 메소드를 호출하게 할 수도
있다. 앞에서 리플렉션 학습 태스트를 만들어 Method와 따라미터 정보가 있으면 특정
오브젝트의 메소드를 실행할 수 있음을 확인했다. InvocationHandler 구현 오브젝트가
타깃 오브젝트 레퍼런스를 갖고 있다면 리플렉션을 이용해 간단히 위임 코드를 만들어
낼수있다.

Hello 인터페이스를 제공하면서 프록시 팩토리에게 다이내믹 프록시를 만들어달
라고 요청하면 Hello 인터페이스의 모든 메소드를 구현한 오브젝트를 생성해준다.
InvocationHandler 인터페이스를 구현한 오브젝트를 제공해주면 다이내믹 프록시가
받는 모든 요청을 InvocationHandler의 invoke() 메소드로 보내준다. Hello 인터페이
스의 메소드가 아무리 많더라도 invoke() 메소드 하나로 처리할 수 있다. 그림 6-14는
다이내믹 프록시 오브젝트와 InvocationHandler 오브젝트， 타깃 오브젝트 사이의 메소
드 호출이 일어나는 과정을 나타낸다.

다이내믹 프록시 InvocationHandler HelloTarget

sayHelloO sayHelloO

sayHiO invoke(Method) sayH’o

sayThankYouO sayThankYouO

그림 6-141nv∞alionHandler톨 통한 요청 처리 구조

다이내믹 프록시를 만들어보자. 먼저 다이내믹 프록시로부터 메소드 호출 정보를 받아
서 처리하는 InvocationHandler를 만들어보자. 리스트 6-23은 He lloUppercase 클래
스와 마찬가지로 모든 요청을 타깃에 위임하면서 리턴 값을 대문자로 바꿔주는 부가기
능을 가진 InvocationHandler 구현 클래스다.


리스트 6-23 InvocationHandler 구현 클래스

public class UppercaseHandler implements InvocationHandler (
rHe 110 target;

public UppercaseHandler(Hello target) (
다이내믹 프록시로부터 전달받은 요칭을 다시 타깃 오브
젝트에 위임해야 하기 때문에 타깃 오브젝트를 주입받아
this.target = target; 둔다

public Object invoke(Object proxy , Method method , Object[] args )
throws Throwable {
String ret = (String)method.invoke(target , args); ~
타깃으로 위임 인터페이스의 에소

return ret.toUpperCase(); ~ 부가기능 저|공
드 호출에 모두 적용된다


다이내믹 프록시로부터 요청을 전달받으려면 InvocationHandler를 구현해야 한다.
메소드는 invoke( ) 하나뿐이다. 다이내믹 프록시가 클라이언트로부터 받는 모든 요청
은 invoke() 메소드로 전달된다. 다이내믹 프록시를 통해 요청이 전달되면 리플렉션
API를 이용해 타깃 오브젝트의 메소드를 호출한다. 타깃 오브젝트는 생성자를 통해 미
리 전달받아둔다. Hello 인터페이스의 모든 메소드는 결과가
String 타입이므로 메소
드 호출의 결과를 String 타입으로 변환해도 안전하다. 타깃 오브젝트의 메소드 호출이
끝났으면 프록시가 제공하려는 부가기능인 리턴 값을 대문자로 바꾸는 작업을 수행하
고 결과를 리턴한다. 리턴된 값은 다이내믹 프록시가 받아서 최종적으로 클라이언트에
게전달될것이다.

이제 이 InvocationHandler를 시용하고 Hello 인터페이스를 구현하는 프록시를 만
들어보자. 다이내믹 프록시의 생성은 Proxy 클래스의 newProxylnstance() 스태틱 팩토
리 메소드를 이용하면 된다. 리스트 6-24는 다이내믹 프록시를 생성하는 묘드다.

리스트 6-24 프록시 생성


「을 생성된 다이내믹 프록시 뾰젝트는 H뼈 인터페이스를 구현하고 있으므로
Hel。
타입으로 캐스팅해도 안전하다

Hello proxiedHello = (Hello)Proxy.newProxylnstance(

getClass()
.
getClassLoader()，
-을 동적으로 생성되는 다이내믹 프록시 클래스의 로딩에

/ 사용할클래스로더
new Class[] { Hello .class} , __률 구현할인터페이스

new UppercaseHandler(new HelloTarget()));
--률 부가기능과 위임 코드를 당은 InvocationHandler

메소드 호출 한 번이지만 파라미터가 많으니 주의해야 한다.

6징
AOP 443


사용 방법을 자세히 살펴보자. 첫 번째 파라미터는 클래스 로더를 제공해야 한다.
다이내믹 프록시가 정의되는 클래스 로더를 지정하는 것이다. 두 번째 따라미터는 다
이내믹 프록시가 구현해야 할 인터페이스다. 다이내믹 프록시는 한 번에 하나 이상
의 인터페이스를 구현할 수도 있다. 따라서 인터페이스의 배열을 시용한다. 여기서는
Hello 인터페이스 한 가지만 구현하게 했다. 마지막 파라미터로는 부가기능과 위임 관
련 코드를 담고 있는 InvocationHandler 구현 오브젝트를 제공해야 한다. Hello 타입
의 타깃 오브젝트를 생성자로 받고， 모든 메소드 호출의 리턴 값을 대문자로 바꿔주는
UppercaseHandler 오브젝트를 전달했다.

newProxyInstance()
에 의해 만들어지는 다이내믹 프록시 오브젝트는 따라미터로 제
공한 Hello 인터페이스를 구현한 클래스의 오브젝트이기 때문에 Hello 타입으로 캐스
팅。l 가능하다. 이제 UppercaseHandler를 사용하는 Hello 인터페이스를 구현한 다이내
믹 프록시가 만들어졌으니 Hello 인터페이스를 통해서 사용하면 된다.

앞에서 만든 테스트를 이용해서 클래스로 만든 프록시인 HelloUppercase를 적용했
을 때와 동일하게 동작동}는지 테스트해보자.

다루기가 쉽지 않아 보이는 리플렉션 API를 적용하고 복잡한 다이내믹 프록시 생성
방법을 적용했는데도 원래 만들었던 HelloUppercase 프록시 클래스보다 그다지 코드의
양도 줄어들지 않은 것 같고， 코드 작성은 오히려 까다로워진 것 같다. 과연 다이내믹
프록시를 적용했을 때 장점이 있긴 있는 것일까?

다이내믹프록시의확장
물론 다이내믹 프록시 방식이 직접 정의해서 만든 프록시보다 훨씬 유연하고 많은 장점
이있다.
Hello 인터페이스의 메소드가 3개가 아니라 307M로 늘어나면 어떻게 될까? 인터페
이스가 바뀐다면 HelloUppercase처럼 클래스로 직접 구현한 프록시는 매번 코드를 추
가해야 한다. 하지만 UppercaseHandler와 다이내믹 프록시를 생성해서 시용하는 코드
는 전혀 손댈 게 없다. 다이내믹 프록시가 만들어질 때 추가된 메소드가 자동으로 포함
될 것이고， 부가기능은 invoke( ) 메소드에서 처리되기 때문이다.
UppercaseHandler는 모든 메소드의 리턴 타입이 스트링이라고 가정한다. 그런데 스
트링 외의 리턴 타입을 갖는 메소드가 추가되면 어떨까? 지금은 강제로 스트링으로 캐
스팅을 해버리니 런타임 시에 캐스팅 오류가 발생할 것이다. 리플렉션은 매우 유연하고
막강한 기능을 가진 대신에 주의 깊게 시용할 필요가 있다. 그래서 Method를 이용한 타


깃 오브젝트의 메소드 호출 후 리턴 타입을 확인해서 스트링인 경우만 대문자로 바꿔주
고 나머지는 그대로 넘겨주는 방식으로 수정하는 것이 좋겠다.

InvocationHandler 방식의 또 한 가지 장점은 타깃의 종류에 상관없이도 적용이 가
능하다는 점이다. 어차피 리플렉션의 Method 인터페이스를 이용해 타깃의 메소드를 호
출하는 것이니 Hello 타입의 타깃으로 제한할 필요도 없다.

어떤 종류의 인터페이스를 구현한 타깃이든 상관없이 재사용할 수 있고， 메소드의
리턴 타입이 스트링인 경우만 대문자로 결과를 바꿔주도록 UppercaseHandler를 만들
수 있다. 수정한 코드는 리스트 6-25와 같다. 이를 사용해서 다이내믹 프록시를 만드는
코드는 수정할 필요가 없다.

리스트 6-25 확장된 Uppserα，
iSeHandler

public class UppercaseHandler implements InvocationHandler (

Object target;

private UppercaseHandler(Object target) { 어떤 종류의 인터페이스를 구현한 타깃에도

this.target =target; 적용 가능하도록 Object 타입으로 수정

public Object invoke(Object proxy , Method method , Object[] args)

throws Throwable (
Object ret =method.invoke(target , args);
if (ret instanceof String) {

return ((String)ret).toUpperCase();
호출한 메소드의 리턴 타입이 String민 경우만
대문자 변경 기능을 적용하도록 수정

else {
return ret;


InvocationHandler는 단일 메소드에서 모든 요청을 처리하기 때문에 어떤 메소드에
어떤 기능을 적용할지를 선택히는 과정이 펼요할 수도 있다. 호출하는 메소드의 이름，
파라미터의 개수와 타입， 리턴 타입 등의 정보를 가지고 부가적인 기능을 적용할 메소
드를선택할수있다.

리턴 타입뿐 아니라 메소드의 이름도 조건으로 걸 수 있다. 메소드의 이름이 say
로 시작히는 경우에만 대문자로 바꾸는 기능을 적용하고 싶다면 리스트 6-26과 같이
Method 파라미터에서 메소드 이름을 가져와 확인히는 방법을 사용하면 된다.

6징:... AOP 445


리스트 6-26 메소드를 선별해서 부가기능올 적용하는 invoke()

public Object invoke(Object proxy, Method method , Object[] args )
throws Throwable (

Object ret =method .invoke(target, args);

if (ret instanceof String && method.getName().startsWith("say")) {

return ((String)ret) .toUpperCase () ; ~ 리턴 타입과
메소드이름이 일치핸
경우에만 부가기능을 적용한다
else {

return ret;-•-조건이 일치하지 않으면 타깃 오브젝트의 호출 결과률 그대로 리턴한다

6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능
UserServiceTx를 다이내믹 프록시 방식으로 변경해보자. UserServiceTx는 서비스 인
터페이스의 메소드를 모두 구현해야 하고 트랜잭션이 필요한 메소드마다 트랜잭션 처
리코드가 중복돼서 나타나는 비효율적인 방법으로 만들어져 있다. 트랜잭션이 필요한
클래스와 메소드가 증가하면 UserServiceTx처럼 프록시 클래스를 일일이 구현하는 것
은큰부담이다.
따라서 트랜잭션 부가기능을 제공하는 다이내믹 프록시를 만들어 적용하는 방
법이 효율적이다. 다이내믹 프록시와 연동해서 트랜잭션 기능을 부가해주는
InvocationHandler는 한 개만 정의해도 충분하기 때문이다.

트랜잭션 InvocationHandler
트랜잭션 부가기능을 가진 핸들러의 묘드는 리스트 6-27과 같이 정의할 수 있다.

리스트 6-Z1 다이내믹 프록시톨 위한 트랜잭션 부가기능

public class TransactionHandler implements InvocationHandler (
private Object target;~ 부가기능을 저밍힐 타깃 오브젝트 어떤 타입의 오브젝트에도 적용 가능응따
private PlatformTransactionManager transactionManager;~ 트랜잭션 기능을 제공하는 데

필요한트랜잭션매니저

private String pattern
;-웅-트랜잭션을 적용할 메소드 이름 때턴

public void setTarget(Object target) {
this.target = target;


public void setTransactionManager(PlatformTransactionManager
transactionManager) (
this.transactionManager = transactionManager;

public void setPattern(String pattern) (
this.pattern =pattern;

RJblic Ob ject invoke(Ob ject proxy , Method method , 0bject[] args) throws Throwable {
if (method.getName().startsWith(pattern)) ( 、
return invokelnTransaction (method , args);
} else ( 트랜잭션 적용 대상 메소드훌 선열해서
트랜잭션 경계설정 기능을 부여해준다

return method.invoke(target , args);

private Object invokelnTransaction(Method method , Object[] args) throws
Throwable (
TransactionStatus status =
this.transactionManager .getTransaction(new DefaultTransactionDefinition());

try
퍼
(
bject ret = method.invoke(target , args); 1| 트랜잭션을 시작하고 타깃 오브젝트의 메소

this.transactionManager .commit(status); 드훌 호출한 예외가 발생하지 없다연 커
return ret; 잇힌다

} catch (InvocationTargetException e) {
this. transactionManager . rollback( status); I 예외가 발생하연 트랜잭션을 훌백효다
throw e.getTargetException();


요청을 위임할 타깃을 DI로 제공받도록 한다. 타깃을 저장할 변수는 Object로 선
언했다. 따라서 UserServicelmpl 외에 트랜잭션 적용이 펼요한 어떤 타깃 오브젝트
에도 적용할 수 있다. UserServiceTx와 마찬가지로 트랜잭션 추상화 인터페이스인
PlatformTransactionManager를 DI 받도록 한다. 타깃 오브젝트의 모든 메소드에 무조
건 트랜잭션이 적용되지 않도록 트랜잭션을 적용할 메소드 이름의 패턴을 DI 받는다.
간단히 메소드 이름의 시작 부분을 비교할 수 있게 만들었다. pattern을 l
‘
get"
으로 주
면 get으로 시작하는 모든 메소드에 트랜잭션이 적용된다.

6당:... AOP 447


UserService txUserService UserService txUserService
InvocationHandler의 invoke() 메소드를 구현히는 방법은 UppercaseHandler
에 적
용했던 것과 동일하다. 타깃 오브젝트의 모든 메소드에 트랜잭션을 적용하는 게 아니라
선별적으로 적용할 것이므로 적용할 대상을 선별하는 작업을 먼저 진행한다.DI 받은
이름 패턴으로 시작되는 이름을 가진 메소드인지 확인한다. 패턴과 일치하는 이름을 가
진 메소드라면 트랜잭션을 적용하는 메소드를 호출하고， 아니라면 부가기능 없이 타깃
오브젝트의 메소드를 호출해서 결괴를 리턴하게 한다.

트랜잭션을 적용하면서 타깃 오브젝트의 메소드를 호출하는 것은 UserServiceTx에
서와 동일하다. 한 가지 차이점은 롤백을 적용하기 위한 예외는 RuntimeException 대
신에 InvocationTargetException을 잡도록 해야 한다는 점이다. 리플렉션 메소드인
Method . invoke( )를 이용해 타깃 오브젝트의 메소드를 호출할 때는 타깃 오브젝트에서
발생하는 예외가 InvocationTargetException으로 한 번 포장돼서 전달된다. 따라서 일
단 InvocationTargetException으로 받은 후 getTargetException() 메소드로 중첩되
어 있는 예외를 가져외야 한다.

이제 UserServiceTx보다 코드는 복잡하지 않으면서도 UserService뿐 아니라 모든
트랜잭션이 필요한 오브젝트에 적용 가능한 트랜잭션 프록시 핸들러가 만들어졌다.

TransactionHandler와 다이내믹 프록시률 이용하는 테스트
앞에서 만든 다이내믹 프록시에 시용되는 TransactionHandler가 UserServiceTx를 대신
할 수 있는지 확인하기 위해 UserServiceTest
에 적용해보자. upgradeAllOrNothing()
은
UserServiceTx를 프록시로 사용했을 때 트랜잭션 기능이 동작하는지 확인하는 태스트였
다. 이제 UserServiceTx 대신 TransactionHandler를 이용하는 다이내믹 프록시를 사용
하도록 리스트 6-28과 같이 수정하자.

리스트 1r28 다이내믹 프록시톨 이용한 트랜잭션 테스트

@Test
public void upgradeAllOrNothing() throws Exception {

TransactionHandler txHandler =new TransactionHandlerO;

txHandler.setTarget(testUserService);
| 트랜잭션 핸들러가 필요한 정보외

txHandler.setTransactionManager(transactionManager); I 오브젝트롤 미 해중다
txHandler.setPattern("upgradeLevels");
=(UserService)Proxy.newProxylnstance(
getClass().getClassLoader() ,new Class[) { UserService.class }, txHandler);

UserSeNice 인터페이스 타입의 다이내믹 프룩시 생성


UserServiceTx 오브젝트 대신 TransactionHandler를 만들고 타깃 오브젝트와 트랜

잭션 매니저， 메소드 패턴을 주입해준다. 이렇게 준비된 TransactionHandler 오브젝

트를 이용해 UserService 타입의 다이내믹 프록시를 생성하면 모든 필요한 작업은 끝

이다.

upgradeAIIOrNothing() 태스트를 실행해보자. 다이내믹 프록시를 이용한 트랜잭션
프록시가 적용됐으므로 테스트는 깔끔하게 성공할 것이다.

6.3.4 다이내믹 프록시를 위한 팩토리 민
앞 절에서는 어떤 타깃에도 적용 가능한 트랜잭션 부가기능을 담은 TransasctionHandler
를 만들었고， 이를 이용히는 다이내믹 프록시를 UserService에 적용히는 태스트를 만들
어봤다. 이제 TransactionHandler와 다이내믹 프록시를 스프링의 Dl를 통해 사용할 수
있도록만들어야할차례다.
그런데 문제는 Dl의 대상이 되는 다이내믹 프록시 오브젝트는 일반적인 스프링의 빈
으로는 등록할 방법이 없다는 점이다. 스프링의 빈은 기본적으로 클래스 이름과 프로
퍼티로 정의된다. 스프링은 지정된 클래스 이름을 가지고 리플렉션을 이용해서 해당 클
래스의 오브젝트를 만든다. 클래스의 이름을 갖고 있다면 다음과 같은 방법으로 새로운
오브젝트를 생성할 수 있다. Cl
ass
의 newlnstance() 메소드는 해당 클래스의 파라미터
가 없는 생성자를 호출하고， 그 결과 생성되는 오브젝트를 돌려주는 리플렉션 API
다.

Date now = (Date) Class.forName("java.uti l. Date").newlnstance();

스프링은 내부적으로 리플렉션 API를 이용해서 빈 정의에 나오는 클래스 이름을 가
지고 빈 오브젝트를 생성한다. 문제는 다이내믹 프록시 오브젝트는 이런 식으로 프록시
오브젝트가 생성되지 않는다는 점이다. 사실 다이내믹 프록시 오브젝트의 클래스가 어
떤 것인지 알 수도 없다. 클래스 자체도 내부적으로 다이내믹하게 새로 정의해서 사용
하기 때문이다. 따라서 사전에 프록시 오브젝트의 클래스 정보를 미리 알아내서 스프링
의 빈에 정의할 방법이 없다. 다이내믹 프록시는 Proxy 클래스의 newProxylnstance()
라는 스태틱 팩토리 메소드를 통해서만 만들 수 있다.

팩토리번
사실 스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외
에도 빈을 만들 수 있는 여러 가지 방법을 제공한다. 대표적으로 팩토리 빈을 이용한 빈

g장!_ AOP 449


생성 방법을 들 수 있다. 팩토리 빈이란 스프링을 대신해서 오브젝트의 생성로직을 담
당하도록 만들어진 특별한 빈을 말한다.

팩토리 빈을 만드는 방법에는 여러 가지가 있는데， 가장 간단한 방법은 스프링의
FactoryBean O 1
라는 인터페이스를 구현히는 것이다. FactoryBean 인터페이스는 리스트
6-29
에 나와 있는 대로 세 가지 메소드로 구성되어 있다.

리스트 &-29 Factαy않an 인터페이스

package org .springframework .beans .factory;

public interface FactoryBean<T> (

T getObject() throws Exception;
--용 빈 오브젝트톨 생성해서 돌려중다

Class<? extends T> getObjectType(); -융 생성되는 오브젝트의 타입올 알려준다

boolean isSingleton(); _ getObject()가돌려주는오브젝트가 항상 같은 싱글톤오브젝트인지 알려준다‘

FactoryBean 인터페이스를 구현한 클래스를 스프링의 빈으로 등록하면 팩토리 빈으
로 동작한다. 팩토리 빈의 동작원리를 확인할 수 있도록 만들어진 학습 태스트를 하나
살펴보자.

먼저 스프링
에서 빈 오브젝트로 만들어 사용하고 싶은 클래스를 하나 정의보자. 리
스트 6-30의 Message 클래스는 생성자를 통해 오브젝트를 만들 수 없다. 오브젝트를
만들려면반드시 스태틱 메소드를시용해야한다.

리스트 &-30 생성자를 제공하지 않는 클래스

public class Message (
String text;

private Message(String text) (

this.text =text; 생성자가 private으로 선언되어 있어서 외부에서 생성지률 통해
오브젝트를민들수없다

public String getText() (
return text;

public static Message newMessage(String text) (

return new Message(text); 생성자 대신 시용힐 수 있는 스태틱 팩토리
메소드훌제공한다


Message 클래스의 오브젝트를 만들려면 newMessage()
라는 스태틱 메소드를 사용해
야 한다. 따라서 이 클래스를 직접 스프링 빈으로 등록해서 사용할 수 없다. 즉 다음과
같은 방식으로 사용하면 안 된다.

(bean id="m" class=‘ springbook.learningtest.spring.factorybean.Message")

α1Vale 생성자를 가진 클래스의 직접 사용 금지

*

사실 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주변 리플렉션을 이용
해 오브젝트를 만들어준다. 리플렉션은 pnvate으로 선언된 접근 규약을 위반할 수 있
는 강력한 기능이 있기 때문이다. 하지만 생성자를 pnvate으로 만들었다는 것은 스태
틱 메소드를 통해 오브젝트가 만들어져야 하는 중요한 이유가 있기 때문이므로 이를 무
시하고 오브젝트를 강제로 생성하면 위험하다. Message 클래스는 간단한 예제니까 문
제가 되지 않겠지만， 일반적으로 prìvate 생성자를 가진 클래스를 빈으로 등록하는 일
은 권장되지 않으며， 등록하더라도 빈 오브젝트가 바르게 동작하지 않을 가능성이 있으
니주의해야한다.

Message 클래스의 오브젝트를 생성해주는 팩토리 빈 클래스를 만들어보자.
FactoryBean 인터페이스를 구현해서 리스트 6-31 과 같이 만들면 된다.

리스트 6-31 Message의 팩토리 빈 클래스

public class MessageFactoryBean implerrlents FactoryBean(Message) (
String text;

오브젝트률 생성할 때 필요한 정보룰 팩토리 빈의 프로떠티로 설정
public void setText(String text) ( 해서 대신 g 주입된 정보는 오브젝트 생성 중에

받을 수 있게 효κt
人
i용된다

this .text = text;


public Message getObject() throws Exception ( 실제 빈으로 사용될 오브젝트훌 직접 생성한다
return Message.newMessage(this.text); 코드를 이용하기 때문에 복잡한 방식의 오브젝트
생성과 초기화 ξH업도 가능하다

public Class(? extends Message) getObjectType() (
return Message.class;

public boolean isSingleton() {I gelOb빼) 메짚가 돌려뜯 오브젝트가 싱글톤인지를 알려준다 이 팩
return false; 토리 빈은 매번 요정할 때마다 새로운 오브젝트를 만들므로 ’alse.

로 설정
한다 이것은 팩토리 빈의 동ξ빵식에 관한 실정이고 만들어진 빈 오브젝
트는 싱글톤으로 스프링이 관리해줄 수 있디

6징:.. AOP 451


팩토리 빈은 전형적인 팩토리 메소드를 가진 오브젝트다. 스프링은 FactoryBean 인

/ 터페이스를 구현한 클래스가 빈의 클래스로 지정되면， 팩토리 빈 클래스의 오브젝트의
getObject() 메소드를 이용해 오브젝트를 가져오고， 이를 빈 오브젝트로 λF용한다. 빈
의 클래스로 등록된 팩토리 빈은 빈 오브젝트를 생성히는 과정에서만 사용될 뿐이다.

팩토리번의설정방법
리스트 6-32
에서 볼 수 있듯이 팩토리 빈의 설정은 일반 빈과 다르지 않다. id와 class
애트리뷰트를 사용해 빈의 아이디와 클래스를 지정한다는 변에서는 차이가 없다.

리스트 6-32 팩토리 빈 실정

(bean id="message"
class="springbook.learningtest.spring.factorybean.MessageFactoryBean">
(property name="text" value="Factory Bean" />
(/bean>

여타 빈 설정과 다른 점은 message 빈 오브젝트의 타입이 class 애트리뷰트에 정의
된 MessageFactoryBean
이 아니라 Message 타입이라는 것이다. Message 빈의 타입은
MessageFactoryBean
의 getObjec tType( ) 메소드가 돌려주는 타입으로 결정된다. 또，
getObject() 메소드가 생성해주는 오브젝트가 message 빈의 오브젝트가 된다.

정말 그런지 학습 태스트를 만들어서 확인해보자.

리스트 6-32의 설정을 담은 설정파일을 FactoryBeanTest-context.xml이라는 이름
으로 저장해두고 리스트 6-33과 같은 태스트를 작성한다.

리스트 6-33 팩토리 빈 테스트

@R unWith(SpringJUnit4ClassRunner.class)

@(ontextConfiguration • 설정며일 이름을 지정하지 않으면 클래스이률 + "-cone치 xmr'이 디폴트로
public class FactoryBeanTest ( 사용된다

@Autowired
ApplicationContext context;

@Test

public void getMessageFromFactoryBean() (
Object message = context.getBean("message");
assertThat(message, is(Message.class));--을 타입 확인
assertThat( ((Message )message) .getText() , is ("Factory Bean"));

4
실정과기능확인

452


학습 태스트를 작성하고 있는 지금은 message 빈의 타입이 무엇인지 확실하
지 않으므로 @Autowired
의 타입 자동와이어링으로 message 빈을 가져오는 대신
ApplicationContext를 이용해 getBean() 메소드를 사용하게 했다. getBean() 메소드
는 빈의 타입을 지정하지 않으면 Object 타입으로 리턴한다.

이제 message 빈의 타입을 확인해보자. message 빈 설정의 class 애트리뷰트는
MessageFactoryBean
이다. 하지만 getBean()
이 리턴한 오브젝트는 Message 타입이어야
한다. 마지막으로 기능을확인한다. MessageFactoryBean을통해 text 프로퍼티의 값이
바르게 주입됐는지 점검해보자.

테스트를 실행해보면 성공한다. 이제 FactoryBean 인터페이스를 구현한 클래스를
스프링 빈으로 만들어두면 getObject()
라는 메소드가 생성해주는 오브젝트가 실제 빈
의 오브젝트로 대치된다는 사실을 알 수 있다.

드물지만 팩토리 빈이 만들어주는 빈 오브젝트가 아니라 픽토리 빈 자체를 가져오고
싶을 경우도 있다. 이럴 때를 위해 스프링은 ‘&’를 빈 이름 앞에 붙여주변 팩토리 빈 자
체를 돌려준다. 따라서 리스트 6-34와 같은 테스트는 성공한다.

리스트 6-34 팩토리 빈올 가져오는 기능 테스트

@Test
public void getFactoryBean() throws Exception { &가 붙고 안 붙고에 따라 getBean() 메소

übject factory = context.getBean( “&message"(、) );--을 드가 돌려주는 오브젝트가 달라진다

assertThat(factory , is(MessageFactoryBean.class));


다이내믹 프록시를 만들어주는 팩토리 빈
Proxy
의 newProxylnstance() 메소드를 통해서만 생성이 가능한 다이내믹 프록시 오브
젝트는 일반적인 방법으로는 스프링의 빈으로 등록할 수 없다. 대신 팩토리 빈을 사용
하면 다이내믹 프록시 오브젝트를 스프링의 빈으로 만들어줄 수가 있다. 팩토리 빈의
getObject() 메소드에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 되기 때
문이다.
팩토리 빈 방식을 통해 그림 6-15와 같은 구조로 빈이 만들어지고 관계가 설정되게
하려는것이다.

6장:.. AOP 453


、생성
스프링 빈 설정
팩토리 빈디”
-
퍼
-
렐-、
1lIF---
‘
TransactionHandler
그림 6-15 팩토리 빈을 이용한 트랜잭션 다이내믹 프록시의 적용
、생성
스프링 빈 설정
팩토리 빈디”
-
퍼
-
렐-、
1lIF---
‘
TransactionHandler
그림 6-15 팩토리 빈을 이용한 트랜잭션 다이내믹 프록시의 적용
스프링 빈에는 팩토리 빈과 UserServicelmpl만 빈으로 등록한다. 팩토리 빈은 다이
내믹 프록시가 위입
할 타깃 오브젝트인 UserServicelmpl
에 대한 레퍼런스를 프로퍼
티를 통해 DI 받아둬야 한다. 다이내믹 프록시와 함께 생성
할 TransactionHandler
에게 타깃 오브젝트를 전달해줘야 하기 때문이다. 그 외에도 다이내믹 프록시나
TransactionHandler를 만들 때 펼요한 정보는 팩토리 빈의 프로퍼티로 설정해뒀다가
다이내믹 프록시를 만들면서 전달해줘야 한다.

다이내믹 프
록시
를 직접 만
들
어서 UserService
에 적용해봤던
upgradeAIIOrNothing() 태스트의 코드를 꽤토리 빈을 만들어서 getObject() 안에 넣
어주기만하면된다.

트랜잭션 프록시 팩토리 빈
리스트 6-35는 TransactionHandler를 이용하는 다이내믹 프록시를 생성하는 팩토리
빈클래스다.

리스트 6-35 트랜잭션 프록시 팩토리 빈

생성할 오브젝트 타입을 지정할 수도 있지만package springbook .user .service; 범용적으로 사용하기 위해 Object로 했다

P빼r Obj ect target;
PlatformTransactionManager transactionManager; I Trans∞ionHand
k:lr톨 생성할 때 밀요
String pattern;

Class<?> servicelnterface;
• 다이내믹 프록시률 생성할 때 필요하다 냉erServæ 외의 인터페이스를

가진 티깃에도 적용할 수 있다
public void setTarget (Object target ) (

this.target = target;

public void setTransactionManager(PlatformTransactionManager
transactionManager) {


this .transactionManager = transactionManager;

public void setPattern(String pattern) (
this .pattern =pattern;

public void setServicelnterface(Class<?> servicelnterface) (
this .servicelnterface = servicelnterface;

// FactoryBean 인터페이스 구현 메소드
01 받은 정보를 이용해서 Transaclion
Handler.훌

public Object getObject( ) throws Exception (
--융사용하는 다이내믹 프록시를 생성한다
TransactionHandler txHandler =new TransactionHandler();
txHandler .setTarget(target);
txHandler .setTransactionManager(transactionManager);
txHandler.setPattern(pattern);
return ProxY.newProxylnstance(

getClass() .getClassLoader() ,new Class[] { servicelnterface },
txHandler) ;

public Class<?> getObjectType () (

팩토리 빈이 생성하는 오브젝트의 타입은 미 받은 인터페이스 타입에

return servicelnterface; ~ 따라 달라진다. 따라서 다앙한 타입의 프록시 오브젝트 생성에 재사용
할수있다

public boolean isSingleton() (

return fal se; _싱글톤 빈이 아니라는 뭇이 아니라 gelObject( )가 매번
같은 오브젝트를 리턴하지 않는다는 의미다


앞에서 이미 작성하고 태스트까지 해봤던 코드를 조합해놓은 것이니 더 이상 자세한
설명은 필요 없을 것이다. 팩토리 빈이 만드는 다이내믹 프록시는 구현 인터페이
스나，
타깃의 종류에 제한이 없다. 따라서 UserService 외에도 트랜잭션 부가기능이 필요한
오브젝트를 위한 프록시를 만들 때 얼마든지 재시용이 가능하다. 설정이 다른 여러 개
의 TxProxyFactoryBean 빈을 등록하면 된다.

이제 리스트 6-36과 같이 UserServiceTx 빈 설정을 대신해서 userService라는 이
름으로 TxProxyFactoryBean 팩토리 빈을 등록한다. UserServiceTx 클래스는 이제 더
이상 펼요 없으니 제거해도 상관없다.

6당:.. AOP 455


리스트 6-36 UserServi∞어| 대한 트랜잭션 프록시 팩토리 빈

<bean id="userService" class=닝pringbook.user.service
.
TxProxyFactoryBean")
<property name="target" ref="userServicelmpl" /)
<property name="transactionManager" ref="transactionManager“ />
<property name="pattern" value="upgradeLevels" />
<property name=닝ervicelnterface" value=갱pringbook
.
user.service.UserService"
/>

</bean>

target, transactionManager 프로퍼티는 다른 빈을 가리키는 것이니 ref 애트리뷰
트로 설정했고， pattern은 스트링으로 된 문자열이니 value 애트리뷰트를 사용해 값을
지정했다. 그런데 servicelnterface는 숫자， 문자와 같은 단순한 타입이 아니라 Cl ass
타입이다. 이것은 어떻게 설정해야 할까? Class 타입은 value를 이용해 클래스 또는 인
터페이스의 이름을 넣어주면 된다. 스프링은 수정자 메소드의 따라미터의 타입을 확인
해서 프로퍼티의 타입이 Cl
ass
인 경우는 value로 설정한 이름을 가진 Class 오브젝트
로자동변환해준다.

트랜잭션 프록시 팩토리 빈 테스트
UserServiceTest 태스트를 살펴보자.
UserServiceTest 테스트 중에서 add()는 @Autowired로 가져온 userService 빈
을 사용하기 때문에 TxProxyFactoryBean 팩토리 빈이 생성하는 다이내믹 프록
시를 통해 UserService 기능을 사용하게 될 것이다. 반면에 upgradeLevels()
와
mockUpgradeLevels()
는 목 오브젝트를 이용해 비즈니스 로직에 대한 단위 태스트
로 만들었으니 트랜잭션과는 무관하다. 가장 중요한 트랜잭션 적용 기능을 확인하는
upgradeAIIOrNothing()
의 경우는 수동 DI를 통해 직접 다이내믹 프록시를 만들어서
사용하니 팩토리 빈이 적용되지 않는다.
add()
의 경우는 트랜잭션이 적용되지 않는 메소드이므로 다이내믹 프록시를 거쳐도
단순 위임 방식으로만 동작한다. TxProxyFactoryBean
이 다이내믹 프록시를 기대한 대
로 완벽하게 구성해서 만들어주는지를 확인하려면 트랜잭션 기능을 태스트해봐야 한다.
문제는 기존의 upgradeAIIOrNothing() 태스트다. 예외 발생 시 트랜잭션이 롤백
됨을 확인하려면 비즈니스 로직 코드를 수정한 TestUserService 오브젝트를 타깃 오
브젝트로 대신 사용해야 한다. 설정에는 정상적인 UserServicelmpl 오브젝트로 지정
되어 있지만 태스트 메소드에서 TestUserService 오브젝트가 동작하도록 해야 한다.


TransactionHandler와 다이내믹 프록시 오브젝트를 직접 만들어서 태스트했을 때는
타깃 오브젝트를 바꾸기가 쉬웠는데 이제는 스프링 빈에서 생성되는 프록시 오브젝트
에 대해 태스트를 해야 하기 때문에 간단하지 않다. 가장 문제는 타깃 오브젝트에 대
한 레퍼런스는 TransactionHandler 오브젝트가 갖고 있는데 TransactionHandler는
TxProxyFactoryBean 내부에서 만들어져 다이내믹 프록시 생성에 사용될 뿐 별도로 참
조할 방법이 없다는 점이다. 따라서 이미 스프링 빈으로 만들어진 트랜잭션 프록시 오
브젝트의 타깃을 변경해주기는 어렵다.

그렇다면 어떻게 해야 할까? TestUserService를 사용하는 테스트용 설정을 별도
로 만든다거나 프록시 팩토리 빈 코드를 확장한다거나 하는 방법도 가능하겠지만， 여
기서는 가장 단순한 방법
을 사용해보자. 어차피 TxProxyFactoryBean
의 트랜잭션을
지원하는 프록시를 바르게 만들어주는지
를 확인하는 게 목적이므로 빈으로 등록된
TxProxyFactoryBean을 직접 가져와서 프록시를 만들어보면 된다.

앞에서 팩토리 빈은 내부에서 생성하는 오브젝트가 빈 오브젝트로 사용되지만， 원한
다면 팩토리 빈 자체를 가져올 수도 있음을 확인했다. 그렇다면 스프링 빈으로 등록된
TxProxyFactoryBean을 가져와서 target 프로퍼티를 재구성해준 뒤에 다시 프록시 오
브젝트를 생성하도록 요청할 수도 있다. 이렇게 하면 컨텍스트의 설정을 변경해버리기
는 하지만， 어차피 트랜잭션 기능에 대한 학습 태스트로 특별히 만든 것이므로 이 정도
는 @DirtiesContext를 등록해주는 것으로 넘어가도 될 것이다.

리스트 6-37에 나온 수정된 태스트 코드를 살펴보자.

리스트 6-37 트랜잭션 프록시 팩토리 빈을 적용한 테스트


public class UserServiceTest {

OAutowired ApplicationContext context; ~ 팩토리 빈을 가져오려연 애툴리케이션 컨텍스트가

필요하다

@Test
디이내믹 프록시 팩토리 민을 직접 민들어 사용할 때는
flD irtiesContext ~ 없었다가 다시 동g엔 건텍스트 무효화 애노테이션
public void upgradeAIIOrNothing( ) throws Exception {
TestUserService testUserService = new
TestUserService(users .get(3).getld{));
testUserService .setUserDao{userDao);
testUserService.setMailSender{mailSender );

팩토리 빈 자체를 가져외야 하므로 민 이름에 &률

TxProxyFactoryBean txProxyFactoryBean =
-웅-반드시 넣어야 한다
(0onl

때때


,--..,

6장:... AOP 457


txProxyFactoryBean.setTarget(testUserService);
UserService txUserService =(UserService) txProxyFactoryBean.getObject();

변경된 타깃 실정을 이용해서 트랜잭션 다이

userDao.deleteAll(); 내믹 프록시 오브젝트툴 다시 *생성한다‘
for(User user users) userDao .add(user);

try (
txUserService.upgradeLevels();
fail( "TestUserServiceException expected");

catch(TestUserServiceException e) (

checkLevelUpgraded(users .get(l) , false);

다시 UserServiceTx를 사용할 때와 비슷한 코드가 됐다
. 단지 타깃 오브젝트를 변경

해주기 위해 팩토리 빈을 활용해 프록시를 다시 생성한다는 점만 다를 뿐이다. 이제 태

스트를 돌려보고 4개의 테스트가 모두 동작하는지 확인해보자.

TxProxyFactoryBean은 계속 재사용할 수 있다. 트랜잭션 부가기능이 필요한 빈이

추가될 때마다 리스트 6-36과 같은 빈 설정만 추가해주변 된다. 매번 트랜잭션 기능을

담은 UserServiceTx와 같은 프록시 클래스를 작성히는 번거로움을 완벽하게 제거할 수

있게 됐다. 자바의 다이내믹 프록시와 스프링의 팩토리 빈을 함께 적용해서 얻을 수 있

는멋진결과다.

6.3.5 프록시 팩토리 번 방식의 장점과 한계
이쯤에서 지금까지 적용했던 방법의 장점을 정리해보고 그 한계점도 생ζ빼보자.
다이내믹 프록시를 생성해주는 팩토리 빈을 사용하는 방법은 여러 가지 장점이 있
다. 한번 부가기능을 가진 프록시를 생성하는 팩토리 빈을 만들어두면 타깃의 타입에
상관없이 재시용할 수 있기 때문이다.

프록시 팩토리 빈의 재사용
TransactionHandler를 이용히는 다이내믹 프록시를 생성해주는 TxProxyFactoryBean
은 코드의 수정 없이도 다양한 클래스에 적용할 수 있다. 타깃 오브젝트에 맞는 프로퍼


티 정보를 설정해서 빈으로 등록해주기만 하면 된다. 하나 이상의 TxProxyFactoryBean
을 동시에 빈으로 등록해도 상관없다. 팩토리 빈이기 때문에 각 빈의 타입은 타깃 인터
페이스와일치한다.

UserService 외에 트랜잭션 경계설정 기능을 부여해줄 필요가 있는 펼요한 클래스
가 있다고 해보자. 인터페이스는 CoreService
라고 하고 인터페이스에 정의된 수십여
개의 메소드에 트랜잭션을 모두 적용해야 한다. CoreSerivce의 인터페이스를 구현하면
서 핵심 비즈니스 로직을 담은 클래스를 CoreServicelmpl
이라고 한다면 트랜잭션을 적
용하기 전에는 리스트 6-38과 같이 빈으로 등록해서 시용했을 것이다.

리스트 6-38 트랜잭션 없는 서비스 번 설정

(bean id="coreService" class="complex.module.CoreServicelmpl">
(property name="coreDao" ref="coreDao" />

(/bean>

coreService 빈에 트랜잭션 기능이 펼요해지면 UserService
에 적용하느라 만들
었던 TxProxyFactoryBean을 그대로 적용해주면 된다. 일단 기존의 coreService라
는 이름으로 등록했던 빈의 아이디를 리스트 6-39와 같이 다르게 변경한다. 여기서는
coreServiceTarget
이라고 하겠다.

리스트 6-39 아이디를 변경한 CoreServi∞ 빈


(bean id="coreServiceTarget" class="complex.module.CoreServicelmpl">
(property name="coreDao" ref=.. coreDao" />

(/bean>

이제 coreService라는 아이디를 가진 빈은 TxProxyFactoryBean을 이용해 리스트
6-40과 같이 등록해준다.

리스트 6-40
CαeServi∞에 대한 트랜잭션 프록시 팩토리 빈

(bean id='’coreService" class="springbook.service .TxProxyFactoryBean">
(property name="target" ref="coreServiceTarget" />
(property name="transactionManager" ref="transactionManager" />
(property name="pattern" value="" />
(property name="servicelnterface" value="complex.module.CoreService" />

(/bean>

앉L AOP 459


target 프로퍼티를 coreServiceTarget 빈으로 설정해주고 servicelnterface
에는 프록시가 구현할 인터페이스인 CoreService를 넣어주면 모든 준비가 끝난다.
CoreService 인터페이스에 정의된 모든 메소드에 트랜잭션 기능을 적용하려면 pattern
값을 빈 문자열로 설정해주변 된다. 이제 coreService라는 아이디를 가진 빈을 DI 받아
사용하는 클라이언트는 코드의 변경 없이도 프록시가 제공해주는 트랜잭션 기능이 적
용된 CoreService를 이용할 수 있다.

그림 6-16은 설정을 변경하기 전과 후의 오브젝트 관계를 나타낸다. 처음엔 트랜잭
션이 적용되지 않은， 비즈니스 로직만 가진 CoreServicelmpl 클래스의 빈만 존재했지
만， 간단히 프록시 팩토리 빈의 설정을 추가해주고 나서는 CoreServicelmpl
의 모든 메
소드에 트랜잭션 기능이 적용됐다.

| 클라이언트 i 서 CoreServicelmpl
￡과스프링질징의땐킹


TxProxyFactoryBean CoreServicelmpl 트랜잭션 기능 부가

그림 6-16 설정 변경올 통한 트랜잭션 기능 부가

프록시 팩토리 빈을 이용하면 프록시 기법을 아주 빠르고 효과적으로 적용할 수 있다.
코드한줄만들지 않고 기존코드에 부가적인 기능을추가해줄수 있다는 건 정말매력
적인 방법이 아닐 수 없다.

프록시 팩토리 빈 방식의 장점
앞에서 데코레이터 패턴이 적용된 프록시를 사용하면 많은 장점이 있음에도 적극적으
로 활용되지 못하는 데는 두 가지 문제점이 있다고 설명했다.
첫째는 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는 프록시 클래
스를 일일이 만들어야 한다는 번거로움이고 둘째는 부가적인 기능이 여러 메소드에 반
복적으로 나타나게 돼서 코드 중복의 문제가 발생한다는 점이다.
지금까지 살펴본 프록시 팩토리 빈은 이 두 가지 문제를 해결해준다.
다이내믹 프록시를 이용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만드는
번거로움을 제거할 수 있다. 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소
드에 부가기능을 부여해줄 수 있으니 부가기능 코드의 중복 문제도 사라진다. 다이내믹


프록시에 팩토리 빈을 이용한 0\까지 더해주면 번거로운 다이내믹 프록시 생성 코드도
제거할 수 있다.0\ 설정만으로 다%탤 타깃 오브젝트에 적용도 가능하다. 이 정도라면
프록시를 도입하려고 했을 때 고민했던 문제점을 거의 완벽하게 해결한 듯하다.

이 과정에서 스프링 0\는 매우 중요한 역할을 했다. 프록시를 사용하려면 0\가 필요
한 것은 물론이고 효율적인 프록시 생성을 위한 다이내믹 프록시를 사용하려고 할 때도
팩토리 빈을 통한 DI는 필수다. 앞으로 살펴보겠지만 프록시 팩토리 빈을 좀 더 효과적
으로 시용하고자 할 때도 0\가 중요한 역할을 한다.

프록시팩토리빈의한계
앞에서 만들었던 프록시 팩토리 빈은 더 이상 아쉬울 게 없다고 느끼게 할 만큼 프록시
기법을 편리하게 적용할 수 있게 해준다. 하지만 더 욕심을 내서 중복 없는 최적화된 코
드와 설정만을 이용해 이런 기능을 적용하려고 한다면 지금까지 살펴봤던 방법으로는
한계에부딪힐것이다.
프록시를 통해 타깃에 부가기능을 제공하는 것은 메소드 단위로 일어나는 일이다.
하나의 클래스 안에 존재히는 여러 개의 메소드에 부가기능을 한 번에 제공히는 건 어
렵지 않게 가능했다. 하지만 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공하
는 일은 지금까지 살펴본 방법으로는 불기능하다. 하나의 타깃 오브젝트에만 부여되는
부가기능이라면 상관없겠지만， 트랜잭션과 같이 비즈니스 로직을 담은 많은 클래스의
메소드에 적용할 펼요가 있다면 거의 비슷한 프록시 팩토리 빈의 설정이 중복되는 것을
막을수없다.
하나의 타깃에 여러 개의 부가기능을 적용하려고 할 때도 문제다. 같은 타깃 오브젝
트에 대해 트랜잭션 프록시뿐 아니라 보안 기능을 제공히는 프록시도 적용하고 싶고，
기능 검사를 위해 주고받는 메소드 정보를 저장해두는 부가기능을 담은 프록시도 추가
하고 싶다면 어떻게 될까? 적용 대상인 서비스 클래스가 2007H쯤 된다면 보통 하나당
3~4줄이면 되는 서비스 빈의 설정에 5~6줄씩 되는 리스트 6-40과 같은 프록시 팩토
리 빈 설정이 부가기능의 개수만큼따라붙어야한다. 결국
600라인이면 되는
XML 설
정이 4，
000라인으로 늘어날 수 있다. 이쯤 되면 XML 설정은 사람이 손으로 편집할 수
있는 한계를 벗어난다. 묘드 수정 없이 설정의 변경만으로 수천 개 이상의 메소드에 새
로운 기능을 추가할 수 있다는 점은 분명 대단한 일이긴 하지만， 설정파일이 급격히 복
잡해지는 것은 바람직하지 못하다. 텍스트로 된 빈 설정 작성은 실수하기 쉽고 점점 다
루기 힘들어진다. 게다가 타깃과 인터페이스만 다른， 거의 비슷한 설정이 자꾸 반복된
다는 점이 뭔가 찜찜하다.

6징:... AOP 461


또 한 가지 문제점은 TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만
들어진다는 점이다. TransactionHandler는 타깃 오브젝트를 프로퍼티로 갖고 있다. 따
라서 트랜잭션 부가기능을 제공히는 동일한 묘드임에도 불구하고 타깃 오브젝트가 달
라지면 새로운 TransactionHandler 오브젝트를 만들어야 한다. 과연 이런 중복은 허용
할 수밖에 없는 것일까?TransactionHandler는 다이내믹 프록시처럼 굳이 팩토리 빈에
서 만들지 않아도 된다. 스스로 빈으로 등록될 수도 있다. 하지만 타깃 오브젝트가 다르
기 때문에 타깃 오브젝트 개수만람 다른 빈으로 등록해야 하고 그만람 많은 오브젝트가
생겨날 것이다. 만약 타깃 오브젝트 외의 설정이 펼요하다면 같은 설정이 중복돼서 많
은 빈에 나타날 수 있다. TransactionHandler
의 중복을 없애고 모든 타깃에 적용 기능
한 싱글톤 빈으로 만들어서 적용할 수는 없을까?

더 이상 최적화될 수 없는 것처럼 보이는 이런 한계에도 불구하고， 새로운 부가기능
을 적용한다고 수천 개의 메소드를 찾아다니며 묘드를 일일이 고치는 것에 비해 설정파
일을 수정하는 정도로 그칠 수 있다는 사실에 감지덕지해야 할지도 모르겠다. 그러나
다%헨 영역에 등장하는 문제의 해결책이 되어준 스프링의 이의 무한한 가능성을 생각
해보면 이 한계에도 도전해볼 수 있을 것 같지 않은가?

a휴j평흐l 효’록I 팩로흩| 판 ω|

지금까지 기존 코드의 수정 없이 트랜잭션 부가기능을 추가해줄 수 있는 다OJ=한 방법을
살펴봤다. 이제 스프링은 이러한 문제에 어떤 해결책을 제시히는지 살펴볼 차례다. 언
제나 그렇지만 스프링은 매우 세련되고 깔끔한 방식으로 애플리케이션 개발에 자주 등
장히는 이런 문제에 대한 해법을 제공한다.

6.4.1 ProxyFactoryBean
스프링은 트랜잭션 기술과 메일 발송 기술에 적용했던 서비스 추상회를 프록시 기술에
도 동일하게 적용하고 있다. 뼈에는 JDK에서 제공하는 다이내믹 프록시 외에도 펀
리하게 프록시를 만들 수 있도록 지원해주는 다OJ=한 기술이 존재한다. 따라서 스프링은
일관된 방법으로 프록시를 만들 수 있게 도외주는 추상 레이어를 제공한다. 생성된 프
록시는 스프링의 빈으로 등록돼야 한다. 스프링은 프록시 오브젝트를 생성해주는 기술
을 추상화한 팩토리 빈을 제공해준다.

462


스프링의 Proxy
FactoryBean은 프록시를 생성해서 빈 오브젝트로 등록하게 해주는
팩토리 빈이다. 기존에 만들었던 TxProxyFactoryBean과 달리， ProxyFactoryBean은 순
수하게 프록시를 생성하는 작업만을 담당하고 프록시를 통해 제공해줄 부가기능은 별
도의빈에둘수있다.

ProxyFactoryBean이 생성하는 프록시에서 시용할 부가기능은 Methodlnterceptor
인터페이스를 구현해서 만든다. Methodlnterceptor는 InvocationHandler와 비슷하
지만 한 가지 다른 점이 있다. InvocationHandler
의 invoke() 메
소드는 타깃 오브
젝트에 대한 정보를 제공하지 않는다. 따라서 타깃은 InvocationHandler를 구현한
클래스가 직접 알고 있어야 한다. 반면에 Methodlnterceptor
의 invoke() 메소드는
Pro
xy
FactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받는다. 그 차
이 덕분에 Methodlnterceptor는 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있
다. 따라서 Methodlnterceptor 오브젝트는 타깃
이 다른 여러 프록시에서 함께 사용할
수 있고， 싱글톤 빈으로 등록 기능하다.

앞에서 만들었던 다이내
믹 프록시 학습 태스트를 리스트 6-41
과 같이 스프링
의
ProxyFactoryBean을 이용하도록 수정해보자.

리스트 6-41 스프링 ProxyFactαy많léln을 이용한 다이내믹 프록시 테스트

package springbook.learningtest.jdk.proxy;

public class DynamicProxyTest (
@Test
public void simpleProxy() {

Hello proxiedHello = (Hello)Proxy.newProxylnstance(

getClass() .getClassLoader() ’
JDK 다이내믹 프록시 샘성
new Class[] { Hello.class} ,

new UppercaseHandler(new HelloTarget ()));


@Test

public void proxyFactoryBean() (
ProxyFactoryBean pfBean =new ProxyFactoryBean();
pfBean.setTarget(new HelloTarget())
;--을 티깃 설정
pfBean.addAdvice(new UppercaseAdvice());
--용
부기기능을 담은 어드바이스를 추가한다

여러 개훌 추가할 수도 있다

FaclαyBeanOI므로 gel0bjec1( )로

Hello proxie배ello = (Hello) pfBean .getObject(); ~ 생성된프록시를가져온다‘

6앙L AOP 463


assertThat(proxiedHello.sayHello( ' Toby ‘L is("HEllO TOBY'));
assertThat(proxiedHello .sayHi('Toby" L is( "HI TOBY"));
assertThat(proxiedHello.sayThankYou("Toby") , is("THANK YOU TOBY"));

static class UppercaseAdvice implements MethodInterceptor (
public Object invoke(MethodInvocation invocation) throws Throwable {

String ret = (String)invocation.proceed();~ 리율렉션의 Method와 달리 메소드

return ret.toUpperCase();
--을 부가기능 적용 실행 시 타깃 오브젝트률 전달힐 일
요가 없다 Methodlnvα:atior을 메소

드 정보와 함께 타깃 오브젝트톨 알

고있기때문이다

static interface Hello (-티깃과프록시가구현힐인터페이스
String sayHello(String name);
String sayHi(String name);
String sayThankYou(String name);

static class HelloTarget implements Hello (
--을 타깃 클래스
public String sayHello(String name) { return "Hello " + name; }
public String sayHi(String name) { return "Hi " + name; }
public String sayThankYou(String name) { return "Thank You " + name; }

".추가할라이브러리
cαn.springsource.org.∞palliance-1.
0.0.jar
org.sprir갱framework.aφ-3.0.7.RELEASE.jar

어드바이스: 타깃이 필요 없는 순수한 부가기능
Proxy
FactoryBean을 적용한 코드를 기존의 JDK 다이내믹 프록시를 λF용했던 코드와
비교해보면 몇 가지 눈에 띄는 차이점이 있다.
InvocationHandler
를 구현했을 때와 달리 Methodlnterceptor
를 구현한
UppercaseAdvice에는 타깃 오브젝트가 등장하지 않는다. Methodlnterceptor로는 메
소드 정보와 함께 타깃 오브젝트가 담긴 Methodlnvocation 오브젝트가 전달된다.
Methodlnvocation은 타깃 오브젝트의 메소드를 실행할 수 있는 기능이 있기 때문에
Methodlnterceptor는 부가기능을 제공히는 데만 집중할 수 있다.


Methodlnvocation은 일종의 콜백 오브젝트로， proceed() 메소드를 실행하면 타깃
오브젝트의 메소드를 내부적으로 실행해주는 기능이 있다. 그렇다면 Methodlnvocation
구현 클래스는 일종의 공유 가능한 뱀플릿처럼 동작히는 것이다. 바로 이 점。
1 JDK의
다이내믹 프록시를 직접 사용히는 코드와 스프링이 제공해주는 프록시 추상화 기능인
ProxyFactoryBean을 사용하는 코드의 가장 큰 차이점이자 Pro
xyFactoryBean
의 장점
이다. Proxy
FactoryBean은 작은 단위의 빔플릿/콜백 구조를 응용해서 적용했기 때문에
뱀플릿 역할을 하는 Methodlnvocation을 싱글톤으로 두고 공유할 수 있다. 마치 SQL
파라미터 정보에 종속되지 않는 JdbcTemplate이기 때문에 수많은 DAO 메소드가 하나
의 JdbcTemplate 오브젝트를 공유할 수 있는 것과 마찬가지다.

ProxyFactoryBean에 이 Methodlnterceptor를 설정해줄 때는 일반적인 DI 경우
처럼 수정자 메소드를 사용하는 대신 addAdvice()
라는 메소드를 사용한다는 점도 눈
여겨봐야 한다. add
라는 이름에서 알 수 있듯이 ProxyFactoryBean
에는 여러 개의
Methodlnterceptor를 추가할 수 있다. ProxyFactoryBean 하나만으로 여러 개의 부가
기능을 제공해주는 프록시를 만들 수 있다는 돗이다. 따라서 앞에서 살펴봤던 프록시
팩토리 빈의 단점 중의 하나였던 새로운 부가기능을 추가할 때마다 프록시와 프록시
팩토리 빈도 추가해줘야 한다는 문제를 해결할 수 있다. 아무리 많은 부가기능을 적용
하더라도 ProxyFactoryBean 하나로 충분하다.

그런데 Methodlnterceptor 오브젝트를 추가하는 메소드 이름은
addMethodlnterceptor가 아니라 addAdvice다. Methodlnterceptor는 Advice 인터페이
스를 상속하고 있는 서브인터페이스이기 때문이다. 나중에 설명하겠지만 스프링은 단
순히 메소드 실행을 가로채는 방식 외에도 부가기능을 추가하는 여러 가지 다양한 방법
을 제공하고 있다. 이름에서 알 수 있듯이 Methodlnterceptor처럼 타깃 오브젝트에 적
용하는 부가기능을 담은 오브젝트를 스프링에서는 어드바01스advice라고 부른다. 어드바
이스라는용어는매우중요하니 잘기억해두자.

마지막으로 JDK 다이내믹 프록시에서 프록시 오브젝트를 만들 때는 필요했지만
ProxyFactoryBean을 적용한 후에는 없어진 것이 있다. ProxyFactoryBean을 적용한 코
드에는 프록시가 구현해야 하는 Hello라는 인터페이스를 제공해주는 부분이 없다. 프
록시를 직접 만들 때나 JDK 다이내믹 프록시를 만들 때 반드시 제공해줘야 히는 정보
가 Hello 인터페이스였다. 그래야만 다이내믹 프록시 오브젝트의 타입을 결정할 수 있
기 때문이다.

6징:... AOP 465


그런데 스프링의 ProxyFactoryBean은 어떻게 인터페이스 타입을 제공받지도 않고
Hello 인터페이스를 구현한 프록시를 만들어낼 수 있을까? 물론 ProxyFactoryBean도
setInterfaces( ) 메소드를 통해서 구현해야 할 인터페이스를 지정할 수 있다. 하지만
인터페이스를 굳이 알려주지 않아도 ProxyFactoryBean
에 있는 인터페이스 자동검출 기
능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아낸다. 그리고 알아
낸 인터페이스를 모두 구현히는 프록시를 만들어준다. 타깃 오브젝트가 구현하고 있는
모든 인터페이스를 동일하게 구현하는 프록시를 만들어주는 기능이다. 타깃 오브젝트
가 구현하는 인터페이스 중에서 일부만 프록시에 적용하기를 원한다면 인터페이스 정
보를 직접 제공해줘도 된다.

그 밖에도 ProxyFactoryBean은 프록시를 작성하고 빈으로 등록해서 사용히는 데 펼
요한 다OJ=한 기능을 제공하고 있다.

태스트는 물론 성공할 것이다. ProxyFactoryBean은 기본적으로 JDK가 제공히는 다
이내믹 프록시를 만들어준다. 경우에 따라서는 CGLib이라고 하는 오픈소스 바이트코
드 생성 프레임워크를 이용해 프록시를 만들기도 한다. 이에 대해서는 Vo1. 2에서 다시
설명하겠다.

어드바이스는 타깃 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트라
는 사실을 잘 기억해두고 다음으로 넘어가자.

포인트컷: 부가기능 적용 대상 메소드 선정 방법
기존에 InvocationHandler를 직접 구현했을 때는 부가기능 적용 외에도 한 가지 작업
이 더 있었다. 메소드의 이름을 가지고 부가기능을 적용 대상 메소드를 선정히는 것이
었다. TxProxyFactoryBean은 pattern이라는 메소드 이름 비교용 스트링 값을 DI 받아
서 TransactionHandler를 생성할 때 이를 넘겨주고. TransactionHandler는 요청이 들
어오는 메소드의 이름과 패턴을 비교해서 부가기능인 트랜잭션 적용 대상을 판별했다.
그렇다면 스프링의 ProxyFactoryBean과 Methodlnterceptor를 사용하는 방식에서도
메소드 선정 기능을 넣을 수 있을까? Methodlnterceptor에서 부가기능을 제공하고 있
으니 그 안에서 판별하게 하면 될 것 같지만 실제로는 불가능하다. 앞에서 살펴봤듯이
Methodlnterceptor 오브젝트는 여러 프록시가 공유해서 사용할 수 있다. 그러기 위해
서 Methodlnterceptor 오브젝트는 타깃 정보를 갖고 있지 않도록 만들었다. 그 덕분에
Methodlnterceptor를 스프링의 싱글톤 빈으로 등록할 수 있었다. 그런데 여기에다 트
랜잭션 적용 대상 메소드 이름 패턴을 넣어주는 것은 곤란하다. 트랜잭션 적용 메소드


패턴은 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 Methodlnterceptor에
특정 프록시에만 적용되는 패턴을 넣으면 문제가 된다.

이 문제는 어떻게 해결할 수 있을까? 어쩔 수 없이 Methodlnterceptor를 프록시마
다 따로 등록하고 독립적으로 만들어지게 해야 할까? 물론 그렇게 타협할 필요는 없다.
일단 l
장에서부터 꾸준히 적용했던 코드 개선 전략을 적용해보자. 함께 두기 곤란한 성
격이 다르고 변경 이유와 시점이 다르고， 생성 방식과 의존관계가 다른 코드가 함께 있
다면분리해주면된다.

Methodlnterceptor는 InvocationHandler와는 다르게 프록시가 클라이언트로부터
받는 요청을 일일이 전달받을 필요는 없다. Methodlnterceptor에는 재사용 가능한 순
수한 부가기능 제공 코드만 남겨주는 것이다. 대신 프록시에 부가기능 적용 메소드를
선택히는 기능을 넣자. 물론 프록시의 핵심 가치는 타깃을 대신해서 클라이언트의 요청
을 받아 처리하는 오브젝트로서의 존재 자체이므로， 메소드를 선별하는 기능은 프록시
로부터 다시 분리하는 편이 낫다. 메소드를 선정하는 일도 일종의 교환 가능한 알고리
즘이므로 전략 패턴을 적용할 수 있기 때문이다.

내용이 좀 복잡하니 그림을 통해 스프링의 ProxyFactoryBean
이 기존의 JDK 다이내
믹 프록시를 구조를 그대로 따르는 TxProxyFactoryBean
의 접근 방법과 어떻게 다른지
비교해보자.

그림 6-17에서 볼 수 있듯이 기존 방식도 다이내믹 프록시와 부가기능을 분리할 수
있고， 부가기능 적용 대상 메소드를 선정할 수 있게 되어 있다.


모든 메소드 요청
InvocationHandler 타깃
부가기능 +

빼소드 선정 알고리좀

그립 6-17 기존 JDK 다이내믹 프록시를 이용한 방식

하지만 문제는 부가기능을 가진 InvocationHandler가 타깃과 메소드 선정 알고리
즘 코드에 의존하고 있다는 점이다. 만약 타깃이 다르고 메소드 선정 방식이 다르다면
InvocationHandler 오브젝트를 여러 프록시가 공유할 수 없다. 타깃과 메소드 선정 알
고리즘은 DI를 통해 분리할 수는 있지만 한변 빈으로 구성된 InvocationHandler 오
브젝트는， 오브젝트 차원에서 특정 타깃을 위한 프록시에 제한된다는 뭇이다. 그래서
InvocationHandler는 굳이 따로 빈으로 등록하는 대신 TxProxyFactoryBean 내부에서

6징:... AOP 467


매번 생성하도록 만들었던 것이다. 따라서 타깃 변경과 메소드 선정 알고리즘 변경 같
은 확장이 펼요하면 팩토리 빈 내의 프록시 생성코드를 직접 변경해야 한다. 결국 확장
에는 유연하게 열려 있지 못하고 관련 없는 코드의 변경이 필요할 수 있는.OCP 원칙을
깔끔하게 잘 지키지 못하는 어정쩡한 구조라고 볼 수 었다.

반면에 그림 6-18
에 나타난 스프링의 ProxyFactoryBean 방식은 두 가지 확장 기능
인 부가캠Advi
ce과 메소드 선정 알고리즘Pointcut을 활용히는 유연한 구조를 제공한다.


포인트엇
때소드 선정 알고리즘

어드바이스(Methodlnterceptor)
부가기능

[4) 위임 | 타깃 오브젝트

그림 6-18 스프링 ProxyFactoryBean을 이용한 방식

스프링은 부가기능을 제공하는 오브젝트를 어드바01스라고 부르고， 메소드 선정 알고리
즘을 담은 오브젝트를 포인트컷이라고 부른다. 어드바이스와 포인트컷은 모두 프록시에
DI로주입돼서 사용된다. 두가지 모두 여러 프록시에서 공유가가능하도록만들어지기
때문에 스프링의 싱글톤 빈으로 등록이 가능하다.

프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할
메소드인지를 확인해달라고 요청한다. 포인트컷은 Pointcut 인터페이스를 구현해서 만
들면 된다. 프록시는 포인트컷으로부터 부가기능을 적용할 대상 메소드인지 확인받으
면. Methodlnteceptor 타입의 어드바이스를 호출한다. 어드바이스는 JDK의 다이내믹
프록시의 InvocationHandler와 달리 직접 타깃을 호출하지 않는다. 자신이 공유돼야
하므로 타깃 정보라는 상태를 가질 수 없다. 따라서 타깃에 직접 의존하지 않도록 일종
의 랩플릿 구조로 설계되어 있다. 어드바이스가 부가기능을 부여히는 중에 타깃 메소드
의 호출이 필요하면 프록시로부터 전달받은 Methodlnvocation 타입 콜백 오브젝트의
proceed() 메소드를 호출해주기만 하면 된다.

실제 위임 대상인 타깃 오브젝트의 레퍼런스를 갖고 있고， 이를 이용해 타깃 메소
드를 직접 호출히는 것은 프록시가 메소드 호출에 따라 만드는 Invocation 콜백의 역
할이다. 재사용 가능한 기능을 만들어두고 바뀌는 부분{콜백 오브젝트와 메셜 호출정보)만 외
부에서 주입해서 이를 작엽 흐릎부가기능부여) 중에 사용하도록 하는 전형적인 댐플릿/
콜백 구조다. 어드바이스가 일종의 랩플릿이 되고 타깃을 호출히는 기능을 갖고 있는


Methodlnvocation 오브젝트가 콜백이 되는 것이다. 뱀플릿은 한 번 만들면 재사용이
가능하고 여러 빈이 공유해서 사용할 수 있듯이， 어드바이스도 독립적인 싱글톤 빈으로
등록하고
DI를주입해서 여러 프록시가사용하도록만들수있다.

프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하게 한 것은 전형적
인 전략 패턴 구조다. 덕분에 여러 프록시가 공유해서 사용할 수도 있고， 또 구체적인
부가기능 방식이나 메소드 선정 알고리즘이 바뀌면 구현 클래스만 바꿔서 설정에 넣어
주면 된다. 프록시와 ProxyFactoryBean 등의 변경 없이도 기능을 자유롭게 확장할 수
있는 OCP를 충실히 지키는 구조가 되는 것이다.

Methodlnterceptor로 만들었던 어드바이스와 함께 이름 패턴을 이용해 메소드를 선
정하는 포인트컷까지 적용되는 학습 태스트를 만들어보자. 설정을 통해 빈으로 설정파
일에 등록해볼 수도 있겠지만 학습 테스트이니만큼 묘드만 가지고 DI 되는 구조를 살펴
가면서 만들어보는 편이 낫겠다.

리스트 6-42는 스프링이 제공하는 NameMatchMethodPointcut을 앞에서 만든
UppercaseAdvice와 함께 사용하도록 만든 테스트 코드다. 포인트컷을 직접 만들 수도
있겠지만， 스프링이 제공히는 다양한 Pointcut 구현 클래스가 있으므로 이를 사용하면
편리하다. 메소드 선정이 필요 없기 때문에 포인트컷을 적용하지 않았을 때의 태스트와
비교해보기바란다.

리스트 &-42 포인트컷까지 적용한 ProxyFactoryBean


@Test

public void pointcutAdvisor() (
ProxyFactoryBean pfBean = new ProxyFactoryBean();
pfBean.setTarget(new HelloTarget( )); 메소드 이름을 비교해서 대상을 선정하는

알고리즘을 제공하는 포인트컷 생성

N배뻐빼a
mnl
e

매빼빼앤에

맨떼아l

po따마
ujπt.setMappedNarmnle
매바
-→ sayH로 시직연i는

in1πt
Cl띠따
얀삐뻐뼈때때배뻐빼빼맨띤터('깨
a
yHf*");
.... 이름 비교조건 설정
모든 메소드를 선택하게 한다

pfBean.addAdvisor(new DefaultPointcutAdvisor(pointcut, UppercaseAdvice()));

L. 포인트킷과 (new ) 어드바01스를 뼈V없로
Hello proxiedHello = (Hello) pfBean .getObject(); 묶어서한번에추가

assertThat (proxiedHello. sayHello( "Toby") , is ("HELLO TOBY"));
assertThat(proxiedHello. sayHi ("Toby") , is( "HI TOBY"));
assertThat(proxiedHello.sayThankYou("Toby‘), is("Thank You Toby’));,

메소드 이름이 포인트컷의 선정조건에 맞지 않으므로 부가기능

(대문자연환)이 적용되지 않는다

6징:_ AOP 469


포인트컷이 필요 없을 때는 ProxyFactoryBean
의 addAdvice() 메소드를 호출해서 어
드바이스만 등록하면 됐다. 그런데 포인트컷을 함께 등록할 때는 어드바이스와 포인트
컷을 Advisor 타입으로 묶어서 addAdvisor() 메소드를 호출해야 한다. 어드바이스를
등록하듯이 포인트컷도 그냥 추가하면 될 것을 왜 굳이 별개의 오브젝트로 묶어서 등록
해야 할까? 그 이유는 ProxyFactoryBean
"11는 여러 개의 어드바이스와 포인트컷이 추
가될 수 있기 때문이다. 포인트컷과 어드바이스를 따로 등록하면 어떤 어드바이스(부가
기능)에 대해 어떤 포인트컷(메소드 선정)을 적용할지 애매해지기 때문이다. 그래서 이 둘을
Advisor 타입의 오브젝트에 담아서 조합을 만들어 등록히는 것이다. 여러 개의 어드바
이스가 등록되더라도 각각 다른 포인트컷과 조합될 수 있기 때문에 각기 다른 메소드
선정 방식을 적용할 수 있다. 예를 들어 트랜잭션은 add로 시작하는 메소드에만 적용하
지만， 보안 부가기능은 모든 메소드에 적용하고， 기능검사 부가기능은 get으로 시작하
는 메소드에만 적용할 수가 있다. 이렇게 어드바이스와 포인트컷을 묶은 오브젝트를 인
터페이스 이름을 따서 어드바01저라고 부른다.

이 세 가지 용어와 그 관계는 매우 중요하고 앞으로도 자주 언급될 태니 잘 기억해
두자. 다음식으로기억해두면좋을것이다.

어드바이저 = 포인트컷(메소드 선정 알고리즘)+ 어드바01스(부가기능)

pointcutAdvisor() 테스트에서 사용한 NameMatchPointcut은 mappedName 프로퍼티
값을 이용해 메소드의 이름을 비교하는 방식으로 대상을 선정한다. sayH*
라고 하면 sayH
로 시작히는 메소드에만 선택해준다. 따라서 마지막 메소드인 sayThankY이()는 포인트
컷에 의해 부가기능이 부여되지 않는 메소드가 됐음을 테스트에서 확인할 수 있다.

6.4.2 ProxyFactoryBean 적용
JDK 다이내믹 프록시의 구조를 그대로 이용해서 만들었던 TxProxyFactoryBean을 이
제 스프링이 제공하는 ProxyFactoryBean을 이용하도록 수정해보자
.

TransactionAdvice

부가기능을 담당히는 어드바이스는 테스트에서 만들어본 것처럼 Methodlnterceptor라
는 Advice 서브인터페이스를 구현해서 만든다. 리스트 6-43과 같이 JDK 다이내믹 프
록시 방식으로 만든 TransactionHandler의 묘드에서 타깃과 메소드 선정 부분을 제거
해주면된다.


리스트 &-43 트랜잭션 어드바01스

package springbook.learningtest.idk.proxy;

스프링의 어드바이스 인터페이스 구현

+

public class TransactionAdvice implements MethodInterceptor (
PlatformTransactionManager transactionManager;

public void setTransactionManager(PlatformTransactionManager
transactionManager) (
this.transactionManager = transactionManager;

타깃을 호출하는 기능을 가진 콜백 오브젝트를 프록시로부터 받는다

「을 덕분에 어드바01스는 특정 타깃에 의존하지 않고 X뼈 캠헤

public Object invoke(MethodInvocation invocation) throws Throwable (
TransactionStatus status =
this .transactionManager .getTransaction(new
DefaultTransactionDefinition());
try ( 콜백을 호출해서 타깃의 메소드를 실행한다 타

기 메소드 호출 전후로 필요한 부가기능을 넣을Object ret = invocation.proceed(); ~
수 있다， 경우에 따라서 타깃이 아예 호출되지
this.transactionManager.commit(status); 않게 하거나 재시도를 위한 반목적인 호출도 기
return ret; 능하다

} catch (RuntimeException e) ( • JDK 다이내믹 프록시
7f 제공핸 Mel뼈와는
달리 스프링의 Melhoclln，∞alior을 통한 타깃

this.transactionManager.rollback(status ); 호출은 예외가 포장되지 않고 타깃에서 보낸
throw e; 그대로 전달된다

JDK 다이내믹 프록시의 InvocationHandler를 이용해서 만들었을 때보다 코드가
간결하다. 리플렉션을 통한 타깃 메소드 호출 작업의 번거로움은 Methodlnvocation
타입의 콜백을 이용한 덕분에 대부분 제거할 수 있다. 타깃 메소드가 던지는 예외도
InvocationTargetException으로 포장돼서 오는 것이 아니기 때문에 그대로 잡아서 처
리하면된다.

스프링
XML
설정파일
코드는 더 이상 손볼 데가 없다. 이제 남은 것은 스프링 XML 설정뿐이다. 학습 태스트
에 직접 DI 해서 시용했던 코드를 단지 XML 설정으로 바꿔주기만 하면 된다.
먼저 리스트 6-44와 같이 어드바이스를 등록하자. 트랜잭션 기능 적용을 위해
transactionManager만 DI 해주면 된다.

E장:... AOP 471



리스트 6--44 트랜잭션 어드바이스 빈 설정

(bean id="transactionAdvice" class="springbook .user .service.TransactionAdvice")
(property name="transactionManager" ref="transactionManager" /)
(/bean)

다음은 리스트 6-45와 같이 트랜잭션 적용 메소드 선정을 위한 포인트컷 빈을 등
록하자. 스프링이 제공하는 포인트컷 클래스를 사용할 것이므로 빈 설정만 만들어주
면 된다. 메소드 이름 패턴은 upgrade로 시작하는 모든 메소드를 선택하도록 만든다.
mappedName 프로퍼티에 upgrade*라고 넣어주면 된다.

리스트 6--45 포인트컷 민 설정

(bean id="transactionPointcut"
class="org .springframework .aop .support.NameMatchMethodPointcut'’>
(property name="mappedName" value="upgrade*" />
(/bean)

이제 어드바이스와 포인트컷을 담을 어드바이저를 리스트 6-46과 같이 빈으로 등록
한다. 학습 테스트에서는 생성자로 넣어줬지만 프로퍼티를 이용해 DI 해도 된다.

리스트 용-46 어드바이저 빈 설정

(bean id="transactionAdvisor"

class="org .springframework .aop .support .DefaultPointcutAdvisor")
(property name="advice" ref="transactionAdvice'’ /)
(property name="pointcut" ref="transactionPointcut" />

(/bean>

이제 ProxyFactoryBean을 등록할 차례다. 리
스트 6-47과 같이 프로퍼티에 타깃 빈
과 어드바이저 빈을 지정해주면 된다.

리스트 운47 ProxyFactory뼈n 설정

(bean id="userService'’ class="org.springframework.aop.framework .ProxyFactoryBean">
(property name="target" ref="userServicelmpl" />
(property name=" interceptorNames ">--용 어드바01스와 어드바이저를 동시에 설정해줄 수 있는 프

로퍼티 리스트에 어드바이스나 어드바이저의 아이 디

(li st > 롤 값으로 넣어주연 된다
. 기존의 ref 애트리뷰트(빈 ) 를 사용
(value)transactionAdvisor(/value) 하는 다외는 방식이 다름에 주의해야 한다
L•-한 개 이상의 (value) 태그를 넣을 수 있다


</list)
</property)
</bean)

어드바이저는 interceptorNames
라는 프로퍼티를 통해 넣는다. 프로퍼티 이름
이 advisor7} 아닌 이유는 어드바이스와 어드바이저를 혼합해서 설정할 수 있도록
하기 위해서다. 그래서 property 태그의 ref 애트리뷰트를 통한 설정 대신 list와
value 태그를 통해 여러 개의 값을 넣을 수 있도록 하고 있다. value 태그에는 어드바
이스 또는 어드바이저로 설정한 빈의 아이디를 넣으면 된다. 한 개 이상을 넣을 수 있
다. 만약 타깃의 모든 메소드에 적용해도 좋기 때문에 포인트컷의 적용이 필요 없다면
transactionAdvice라고 넣을 수 있다.

ProxyFactoryBean으로 변환이 모두 끝났다. 코드는 훨씬 간단해졌고 설정만 조금 추
가됐을 뿐이다. 어드바이스와 포인트컷， 어드바이저 등으로 빈의 숫자가 늘어나서 설정
이 더 복잡해진 것 같기도 하지만 어드바이스와 포인트컷은 여러 ProxyFactoryBean
에
서 재사용 가능하기 때문에 복잡해진 건 아니다.

테스트
테스트 코드도 정리하자.
여타 테스트는 문제가 되지 않는다. 순수하게 UserService가 제공히는 기능의 테스
트가 목적인 테스트는 프록시 구현이나 설정 방식이 어떤 것이든 상관없이 UserService
를 구현한 userService 빈을 가져다 사용하거나 트랜잭션 따위는 신경 쓰지 않고 고립
된 태스트로 만들면 되기 때문이다.
문제는 학습 태스트로 만든 upgradeAIIOrNothing()
이다. 트랜잭션이 적용됐는지를
확인하는 테스트인 만람 스프링의 ProxyFactoryBean을 통해 제공되는 트랜잭션 부가
기능에 대한 테스트를 무시할 수는 없다. 예외상황을 강제로 만들어서 테스트하다 보니
로우레벨의 기술이나 구성에 민감한 테스트가 되어서 지금까지 꽤 여러 번 변신을 거쳐
왔다.
다행히 이번에는 간단한 수정으로 충분하다. 스프링의 ProxyFactoryBean도 팩토리
빈이므로 기존의 TxProxyFactory
Bean과 같은 방법으로 태스트할 수 있기 때문이다. 리
스트 6-48처럼 팩토리 빈을 직접 가져올 때 캐스팅할 타입만 ProxyFactoryBean으로
간단히 변경해주면 된다.

앉L AOP 473



리스트 &-48 ProxyFacIαyBE경n을 이용한 트랜잭션 테스트

@Test

@D
irtiesContext-융 컨텍스트 설정을 변경하기 때문에 여전히 필요하t

public void upgradeAIIOrNothing() {
TestUserService testUserService =new TestUserService(users .get(3).getld());
testUserService .setUserDao(userDao);

testUserService
.
set
Maì
때der
띠nl
ai

배
니lSen1띠
디(rm뻐떠
니lSender) ;

user않NICe 빈은 이제 스프링의 ProxyFactαyBean이다

ProxyFactoryBean txProxyFactoryBean = •

context.getBean("&userService" , ProxyFactoryBean.class );
txProxyFactoryBean.setTarget(testUserService);
UserService t xUserService = (UserService) txProxyFactoryBean.getObject();

+

FactαyBean 타입이므로 동일하게 getObjeα()로
프록시룰가져온다‘

이제 스프링이 지원하는 ProxyFactoryBean
으로 전환을 모두 마쳤다.
UserServiceTest 테스트를 실행해보자.

어드바01스와 포인트컷의 재사용
ProxyFactoryBean은 스프링의 01와 댐플릿/콜백 패턴， 서비스 추상화 등의 기법이 모
두 적용된 것이다. 그 덕분에 독립적이며 여러 프록시가 공유할 수 있는 어드바이스와
포인트컷으로 확장 기능을 분리할 수 있었다. 이제 UserService 외에 새로운 비즈니스
로직을 담은 서비스 클래스가 만들어져도 이미 만들어둔 TransactionAdvice를 그대로
재시용할 수 있다. 메소드의 선정을 위한 포인트컷이 필요하면 이름 패턴만 지정해서
Pro
x
yFactoryBean
에 등록해주면 된다. 트랜잭션을 적용할 메소드의 이름은 일관된 명
명 규칙을 정해두면 하나의 포인트컷으로 충분할 수도 있다.
그림 6-19는 ProxyFactoryBean을 이용해서 많은 수의 서비스 빈에게 트랜잭션 부
가기능을 적용했을 때의 구조다. 트랜잭션 부가기능을 담은 TransactionAdvice는 하나
만 만들어서 싱글톤 빈으로 등록해주면，
01 설정을 통해 모든 서비스에 적용이 기능하
다. 메소드 선정 방식이 달라지는 경우만 포인트컷의 설정을 따로 등록하고 어드바이저
로 조합해서 적용해주변 된다.


ProxyFactoryBean

ProxyFactoryBean

TransactionAdvice

ProxyFactoryBean

ProxyFactoryBean


스프링 설정으로 만들어지는 빈 구현 클래스의 빈

그림 6-19 ProxyFactoryBean, Advice, Poi
ntcu!올 적용한 구조

[ ~ 스프링 ~.J; 洲|


지금까지 해왔던 작업의 목표는 비즈니스 로직에 반복적으로 등장해야만 했던 트랜잭
션 묘드를 깔끔하고 효과적으로 분리해내는 것이다. 이렇게 분리해낸 트랜잭션 코드는
투명한 부가기능 형태로 제공돼야 한다. 투명하다는 건 부가기능을 적용한 후에도 기
존 설계와 코드에는 영향을 주지 않는다는 뭇이다. 마치 투명한 유리를 사이
에 둔 것처
럼 다른 코드에서는 그 존재가 보이지 않지만， 메소드가 호출되는 과정에 다이내믹하게
참여해서 부가적인 기능을 제공해주도록 만드는 것이다. 투명하기 때문에 언제든지 자
유롭게 추가하거나 제거할 수도 있고， 기존 묘드는 항상 원래의 상태를 유지할 수 있다.
DI의 멋진 응용 방식 중 하나다.

6.5.1 자동 프록시 생성
투명한 부가기능을 적용하는 과정에서 발견됐던 거의 대부분의 문제는 제거했다. 타깃
코드는 여전히 깔끔한 채로 남아 있고 부가기능은 한 번만 만들어 모든 타깃과 메소드
에 재사용이 가능하고， 타깃의 적용 메소드를 선정하는 방식도 독립적으로 작성할 수
있도록분리되어있다.
하지만 아직 한 가지 해결할 과제가 남아 있다. 프록시 팩토리 빈 방식의 접근 방법
의 한계라고 생각했던 두 가지 문제가 있었다. 그중에서 부가기능이 타깃 오브젝트마다
새로 만들어지는 문제는 스프링 ProxyFactoryBean의 어드바이스를 통해 해결됐다.

6장!_ AOP 475



남은 것은 부가기능의 적용이 펼요한 타깃 오브젝트마다 거의 비슷한 내용의
ProxyFactoryBean 빈 설정정보를 추가해주는 부분이다. 새로운 타깃이 등장했다고 해
서 코드를 손댈 필요는 없어졌지만， 설정은 매번 복사해서 붙이고 target 프로퍼티의
내용을 수정해줘야 한다. 하루 만에 수천 개의 ProxyFactoryBean 설정을 추가할 수 있
을 만큼 단순하고 쉬운 일이지만 단순하고 쉬운 작업인 만큼 실수하기도 쉽다. 게다가
단순하고 쉬운 이유는 내용이 거의 동일하기 때문이다. target 프로퍼티를 제외하면 빈
클래스의 종류， 어드바이스， 포인트컷의 설정이 동일하다. 이런 류의 중복은 더 이상 제
거할 방법은 없는 것일까?

중복문제의접근방법
지금까지 다뤄봤던 반복적이고 기계적인 코드에 대한 해결책을 생각해보자.
먼저 JDBC API를 사용하는 DAO 코드가 있었다. 메소드마다 JDBC try / catch/
finally 블록으로 구성된 비슷한 코드가 반복해서 나타났다. 이 코드는 바뀌지 않는 부
분과바뀌는부분을구분해서 분리하고， 템플릿과콜백， 클라이언트로 나누는방법을통
해 깔끔하게 해결했다. 전략 패턴과 DI를 적용한 덕분이다.
그런데 이외는 좀 다른 방법으로 반복되는 코드의 문제를 해결했던 것이 있다. 바로
반복적인 위임 묘드가 필요한 프록시 클래스 코드다. 타깃 오브젝트로의 위임 코드와
부가기능 적용을 위한 묘드가 프록시가 구현해야 하는 모든 인터페이스 메소드마다 반
복적으로 필요했다. 이는 단순한 분리와 DI와는 다른 독특한 방법으로 해결했다. 다이
내믹 프록시라는 런타임 묘드 자동생성 기법을 이용한 것이다. JDK의 다이내믹 프록
시는 특정 인터페이스를 구현한 오브젝트에 대해서 프록시 역할을 해주는 클래스를 런
타임 시 내부적으로 만들어준다. 런타임 시에 만들어져 사용되기 때문에 클래스 소스가
따로 남지 않을 뿐이지 타깃 인터페이스의 모든 메소드를 구현하는 클래스가 분명히 만
들어진다. 그 덕분에 개발자가 일일이 인터페이스 메소드를 구현하는 프록시 클래스를
만들어서 위임과 부가기능의 코드를 중복해서 넣어주지 않아도 되게 해췄다.
변하지 않는 타깃으로의 위임과 부가기능 적용 여부 판단이라는 부분은 코드 생성
기법을이용하는다이내믹 프록시 기술에 맡기고， 변히는부가기능묘드는 별도로만들
어서 다이내믹 프록시 생성 팩토리에 DI로 제공하는 방법을 사용한 것이다. 좀 독특하
긴 하지만 변하는 로직과 변하지 않는 기계적인 코드를 잘 분리해낸 셈이다. 의미 있는
부가기능 로직인 트랜잭션 경계설정은 코드로 만들게 하고， 기계적인 코드인 타깃 인터
페이스 구현과 위임， 부가기능 연동 부분은 자동생성하게 한 것이다.


반복적인 프록시의 메소드 구현을 코드 자동생성 기법을 이용해 해결했다면 반복적
인 ProxyFactoryBean 설정 문제는 설정 자동등록 기법으로 해결할수 없을까? 또는 실
제 빈 오브젝트가 되는 것은 ProxyFactoryBean을 통해 생성되는 프록시 그 자체이므
로 프록시가 자동으로 빈으로 생성되게 할 수는 없을까? 마치 다이내믹 프록시가 인터
페이스만 제공하면 모든 메소드에 대한 구현 클래스를 자동으로 만들듯이， 일정한 타깃
빈의 목록을 제공하면 자동으로 각 타깃 빈에 대한 프록시를 만들어주는 방법이 있다
면 ProxyFactoryBean 타입 빈 설정을 매번 추가해서 프록시를 만들어내는 수고를 덜 수
있을것같다.

하지만 지금까지 살펴본 방법에서는 한 번에 여러 개의 빈에 프록시를 적용할 만한
방법은없었다.

번 후처리기를 이용한 자동 프록시 생성기
스프링은
OCP
의 가장중요한요소인 유연한확장이라는 개념을스프링 컨태이너 자신
에게도 다양한 방법으로 적용하고 있다. 스프링의 DI를 이용해 만들어지는 애플리케이
션의 묘드가 OCP
에 충실할 수 있다면 스프링 스스로도 그런 가치를 따르는 게 마땅하
다. 그래서 스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분
외에는 대부분 확장할 수 있도록 확장 포인트를 제공해준다.
그중에서 관심을 가질 만한 확장 포인트는 바로 BeanPostProcessor 인터페이스를
구현해서 만드는 빈 후처리기다. 빈 후처리기는 이름 그대로 스프링 빈 오브젝트로 만
들어지고 난 후에， 빈 오브젝트를 다시 가공할 수 있게 해준다. 이 빈 후처리기의 구조
와 자세한 사용법은 Vol.2
에서 다시 다룰 것이다.
여기서는 스프링이 제공하는 빈 후처리기 중의 하나인
DefaultAdvisorAutoProxyCreator
를 살펴보겠다. 이름을 보면 알 수 있듯이
DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기다. 빈 후
처리기를 스프링에 적용히는 방법은 간단하다. 빈 후처리기 자체를 빈으로 등록히는 것
이다. 스프링은 빈 후처리기가 빈으로 등록되어 있으면 빈 오브젝트가 생성될 때마다 빈
후처리기에 보내서 후처리 작업을 요청한다. 빈 후처리기는 빈 오브젝트의 프로퍼티를
강제로 수정할 수도 있고 별도의 초기화 작업을 수행할 수도 있다. 심지어는 만들어진 빈
오브젝트를 자체를 바꿔치기할 수도 있다. 따라서 스프링이 설정을 참고해서 만든 오브
젝트가 아닌 다른 오브젝트를 빈으로 등록시키는 것이 가능하다.
이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고， 프
록시를빈으로대신등록할수도있다. 바로이것이 지동프록시 생성 빈후처리기다.

6앙:_ AOP 477


그림 6-20
은 빈 후처리기를 이용한 자동 프록시 생성 방법을 설명한다.
DefaultAdvisorAutoProxyCreator 빈 후처 리기가 등록되어 있으면 스프링은 빈 오브젝
트를 만들 때마다 후처리기에게 빈을 보낸다. DefaultAdvisorAutoProxyCreator는 빈
으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상
인지 확인한다. 프록시 적용 대상이면 그때는 내장된 프록시 생성기에게 현재 빈에 대
한 프록시를 만들게 하고 만들어진 프록시에 어드바이저를 연결해준다. 빈 후처리기는
프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨
테이너에게 돌려준다. 컨테이너는 최종적으로 빈 후처기가 돌려준 오브젝트를 빈으로
등록하고시용한다.

빈 오브젝트 생성

빈 생성 완료/사용

스프링 컨테이너
그립 운20 민 후처리기를 이용한 프록시 자동생성

적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처
리기를 시용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자
동으로 프록시가 적용되게 할 수 있다. 마지막 남은 번거로운 ProxyFactoryBean 설정
문제를 말끔하게 해결해주는 놀라운 방법이다.

확장된포인트컷
그런데 한 가지 이상한 점이 있다. 지금까지 포인트컷이란 타깃 오브젝트의 메소드 중
에서 어떤 메소드에 부가기능을 적용할지를 선정해주는 역할을 한다고 했다. 그런데 여
기서는 갑자기 포인트컷이 등록된 빈 중에서 어떤 빈에 프록시를 적용할지를 선택한다
는 식으로 설명하고 있다. 어떻게 된 일일까? 포인트컷은 오브젝트 내의 메소드를 선택
하는 것이 아니고 빈 오브젝트 자체를 선택하는 기능을 가졌다는 뭇일까?
물론 아니다. 사실 포인트컷은 두 가지 기능을 모두 갖고 있다. 리스트 6-49
의
Pointcut 인터페이스를 잘 살펴보자. 포인트컷은 클래스 필터와 메소드 매처 두 가지를
돌려주는 메소드를 갖고 있다. 실제 포인트컷의 선별 로직은 이 두 가지 타입의 오브젝
트에담겨 있다.


리스트 6--49 두 가지 기능을 정의한 Pointcut 인터페이스

public interface Pointcut {
ClassFilter getClassFilter(); ~ 프록시를적용할클래스인지확인해준다
MethodMatcher getMethodMatcher();
--용 어드바이스를 적용힐 메소드인지 확인해준다

지금까지는 포인트컷이 제공하는 두 가지 기능 중에서 MethodMatcher라는 메소드를
선별하는 기능만 사용해온 것이다. 기존에 사용한 NameMatchMethodPointcut은 메소드
선별 기능만 가진 특별한 포인트컷이다. 메소드만 선별한다는 건 클래스 필터는 모든
클래스를 다 받아주도록 만들어져 있다는 뭇이다. 따라서 클래스의 종류는 상관없이 메
소드만 판별한다. 어차피 ProxyFactoryBean
Oij
서 포인트컷을 사용할 때는 이미 타깃이
정해져 있기 때문에 포인트컷은 메소드 선별만 해주면 그만이었다.

만약 Pointcut 선정 기능을 모두 적용한다면 먼저 프록시를 적용할 클래스인지 판단
하고 나서， 적용 대상 클래스인 경우에는 어드바이스를 적용할 메소드인지 확인히는 식
으로 동작한다. 클래스 자체가 프록시 적용 대상이 아니라면 어드바이스를 통한 부가기
능 부여는 물 건너간 셈이다. 결국 이 두 가지 조건이 모두 충족되는 타깃의 메소드에
어드바이스가 적용되는 것이다.

ProxyFactoryBean
에서는 굳이 클래스 레벨의 펼터는 필요 없었지
만， 모든 빈에 대해 프록시 자동 적용 대상을 선별해야 하는 빈 후처리기인
DefaultAdvisorAutoProxyCreator는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는
포인트컷이 필요하다. 정확히는 그런 포인트컷과 어드바이스가 결합되어 있는 어드바
이저가등록되어 있어야한다.

포인트컷테스트
포인트컷의 기능을 간단한 학습 태스트로 확인해보자. 앞에서 사용한
NameMatchMethodPointcut은 클래스 필터 기능이 아예 없다고 했다. 사실은 모든 클래
스에 대해 무조건 OK 해버리는， 있으나 마나 한 필터가 들어 있다. 이번엔 이 클래스를
확장해서 클래스도 고를 수 있도록 하겠다. 그리고 프록시 적용 후보 클래스를 여러 개
만들어두고 이 포인트컷을 적용한 ProxyFactoryBean으로 프록시를 만들도록 해서 과연
어드바이스가 적용되는지 아닌지를 확인하겠다.
Hello 인터페이스와 이를 구현한 HelloTarget 그리고 부가기능인 HelloAdvice를
사용했던 DynamicProxyTest에 리스트 6--50의 태스트 메소드를 추가한다.

6장:... AOP 479



리스트 • 50 확장 포인트컷 테스트

@Test
public void classNamePointcutAdvisor() (

// 포인트컷 준비

NameMatchMethodPointcut classMethodPointcut =new NameMatchMethodPointcut() (
public ClassFilter getClassFilter() (--용 의영 내부클꽤스방식으로클래스훌정의한다
return new ClassFilter() (
public boolean matches(Class<?) clazz) (
return clazz .getSimpleName() .startsWi th( "HelloT");

L늦 클래스 이름이 HeI
IoT로 시작핸 것만 선정챔

classMethodPointcut
.
setMappedName("sayH*");--융
y
H로 시작하는 메소드 이름올 가진 메소드만

선정효tq

// 테스트

checkAdviced(new HelloTarget() , classMethodPointcut , true);

L•-적용클래스다

class HelloWorld extends HelloTarget {};
checkAdviced(new HelloWorld() , classMethodPointcut , false);

4 적용 클래스가 아니대

class HelloToby extends HelloTarget {};
checkAdviced(new HelloToby() , classMethodPointcut , true);

L→~ 적용 클래스다‘

적용 대상인가?

•

private void checkAdviced(Object target , Pointcut pointcut , boolean adviced) ( [3]
ProxyFactoryBean pfBean = new ProxyFactoryBean();
pfBean .setTarget(target);
pfBean.addAdvisor(new DefaultPointcutAdvisor(pointcut , new UppercaseAdvice()));
Hello proxiedHello = (Hello) pfBean.getObject();

if (adviced) (
assertThat(proxiedHello .sayHello("Toby") , is("HELLO TOBY')); I메소드 선정 방식을
assertThat(proxiedHello. sayHi ("Toby") , is ("HI TOBY")); 용해어드바이스적용

assertThat(proxiedHello. sayThankYou( "Toby") , is( 'Thank You Toby ’));

else (

rassertThat(proxiedHello.sayHello( "Toby") , is( "Hello Toby"));
assertThat(proxiedHello. sayHi("Toby") , is ("Hi Toby"));
assertThat(proxiedHello.sayThankYou( "Toby") , is( "Thank You Toby"));

4 어드비이스 적용 대상 후보에서 이여| 탈락


포인트컷은 NameMatchMethodPointcut을 내부 익 명 클래스 방식으로 확장해서 만들

었다. 원래 모든 클래스를 다 받아주는 클래스 필터를 리턴하던 getClassFilter()
를 오

버라이드해서 이름이 HelloT로 시작하는 클래스만을 선정해주는 필터로 만들었다. 메

소드 이름 선정기준은 기존에 사용한 것을 그대로 유지했다.

태스트는 세 가지 클래스에 대해 진행한다. 모두 기존에 있던 HelloTarget이라는 클

래스를 그대로 상속한 것이라 메소드 내용은 동일하다. 단지 클래스 이름만 다를 뿐이

다. 이 세 개의 클래스에 모두 통일한 포인트컷을 적용했다. 메소드 선정기준으로만 보

자면 두 개의 메소드에는 어드바이스를 적용하고 마지막 것은 적용되지 않으면 된다.

하지만 두 번째 HelloWorld라는 클래스는 클래스 펼터에서 이미 탈락해버리기 때문에

메소드 이름과 무관하게 모든 메소드가 어드바이스 적용 대상에서 제외된다.

세 개의 클래스를 포인트컷을 적용할 타깃 오브젝트로 각각 등록하고 각 메소드에

대해 어드바이스 적용 여부를 확인한다. 테스트를 돌려보면 성공이다. 클래스 펼터를

통과하지 못히는 HelloWorld 클래스로 만든 타깃 오브젝트는 모든 메소드에 어드바이

스가 적용되지 않았다는 사실을 기억해두자.

포인트컷이 클래스 필터까지 동작해서 클래스를 걸러버리면 아무리 프록시를 적용

했다고 해도 부가기능은 전혀 제공되지 않는다는 점에 주의해야 한다. 사실 클래스 필

터에서 통과하지 못한 대상은 프록시를 만들 필요조차 없다. 어차피 어떤 메소드에도

부가기능이 적용되지 않을 텐데 굳이 프록시를 둘 이유가 없기 때문이다.

6.5.2 DefaultAdvisorAutoProxyCreator의 적용
프록시 자동생성 방식에서 사용할 포인트컷을 만드는 방법을 학습 태스트를 만들어가
면서 살펴봤으니， 이제 실제로 적용할 차례다.

클래스 필터를 적용한 포인트컷 작성
만들어야 할 클래스는 하나뿐이다
. 메소드 이름만 비교하던 포인트컷인
NameMatchMethodPointcut을 상속해서 프로떠티로 주어진 이름 패턴을 가지고 클래스
이름을 비교하는 Cl
a
ssFilter를 추가하도록 만들 것이다. 학습 태스트에서 만들었던 포
인트컷과 유사한 클래스다. 리스트 6-51
은 클래스 펼터 기능이 추가된 포인트컷이다.

6앙:_ AOP 481


리스트 운51 클래스 필터가 포함된 포인트컷

package springbook.learningtest .jdk.proxy;

public class NameMatchClassMethodPointcut extends NameMatchMethodPointcut (
public void setMappedClassName(String mappedClassName) {
this .setClassFilter(new S
im띠
eClassFilter
(
mappedClas
s
Name
)
);
----.

모든 클래스훌 다 허용하던 디올트 클래스 띨터률 프로떠티로
받은 클래스 이름올 이용해서 밀터톨 만들어 덮어씌운다

static class SimpleClassFilter implements ClassFilter (
String mappedName;

private SimpleClassFilter(String mappedName) (
this .mappedName = mappedName;

public boolean matches(Class<?> clazz) (
return PatternMatchUtils.simpleMatch(mappedName ,
clazz. getSimpleName()) ; L-용 와일드쁘(
')기 들어간 문자열 비교훌 지원핸 스프링의

F

유틸리티 메소드다 'naπ1e. name’, *narnE!'’ 세 가지 방식을
모두지원한다

어드바이저를 이용하는 자동 프록시 생성기 등록
적용할 자동 프록시 생
성
기인 DefaultAdvisorAutoProxyCreator는 등록된 빈 중에서
Advisor 인터페이스를 구현한 것을 모두 찾는다. 그리고 생성되는 모든 빈에 대해 어드
바이저의 포인트컷을 적용해보면서 프록시 적용 대상을 선정한다. 빈 클래스가 프록시
선정 대상이라면 프록시를 만들어 원래 빈 오브젝트와 바꿔치기한다. 원래 빈 오브젝트
는 프록시 뒤에 연결돼서 프록시를 통해서만 접근 가능하게 바뀌는 것이다. 따라서 타
깃 빈에 의존한다고 정의한 다른 빈들은 프록시 오브젝트를 대신 DI 받게 될 것이다.
DefaultAdvisorAutoProxyCreator 등록은 디음 한 줄이면 충분하다.

<bean class=

"org
.
springframewor
k
.
aoP
.
framework
.
autoproxy.
Defa띠
tAdvi
sorAutoProxyCreator
" />

이 빈 정의에는 특이하게도 id 애트리뷰트가 없고 class뿐이다. 다른 빈에서 참조되
거나 묘드에서 빈 이름으로 조회될 필요가 없는 빈이라면 아이디를 등록하지 않아도 무
방하다.


포인트컷등록
리스트 6-52와 같이 기존의 포인트컷 설정을 삭제하고 새로 만든 클래스 펼터 지원 포
인트컷을 빈으로 등록한다. Servicelmpl
로 이름이 끝나는 클래스와 upgrade로 시작하
는 메소드를 선정해주는 포인트컷이다.

리스트 운52 포인트컷 빈

<bean id="transactionPointcut"

class="springbook .service.NameMatchCl assMethodPointcut")
<property name="mappedClassName" value="*Servicelmpl" /)-클래스 이름 패턴
<property name="mappedName" value=“upgrade*" /)-을 메소드 이름 때턴

</bean)

어드바이스와 어드바이저
어드바이스인 transactionAdvice 빈의 설정은 수정할 게 없다. 어드바이저인
transactionAdvisor 빈도 수정할 필요는 없다. 하지만 어드바이저로서 사용되는 방법
이 바뀌었다는 사실은 기억해두자. 이제는 ProxyFactoryBean으로 등록한 빈에서처럼
transactionAdvisor를 명시적으로 미 하는 빈은 존재하지 않는다. 대신 어드바이저를
이용하는 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator에 의해 자동수집되
고， 프록시 대상 선정 과정에 참여하며 자동생성된 프록시에 다이내믹하게 DI 돼서 동
작하는 어드바이저가 된다.

ProxyFactoryBean 제거와 서비스 빈의 원상복구
프록시를 도입했던 때부터 아이디를 바꾸고 프록시에 DI 돼서 간접적으로 사용돼야 했
던 userServicelmpl 빈의 아이디를 이제는 당당하게 userService로 되돌려놓을 수 있
다. 더 이상 명시적인 프록시 팩토리 빈을 등록하지 않기 때문이다. 마지막으로 남았던
ProxyFactoryBean 타입의 빈은 삭제해버려도 좋다. UserService와 관련된 빈 설정은
이제 리스트 6-53
의 userService 빈 하나로 충분하다.

리스트 운53 프록시 팩토리 빈을 제거한 후의 민 설정


<bean id="userService" class=닝
pringbook.service.UserServicelmpl")
<property name="userDao" ref="userDao" /)
<property name="mailSender" ref="mailSender" /)

</bean)

6징
AOP 483


프록시를 적용하기 전의 단순한 상태로 돌아왔다.

자동 프록시 생성기를 사용하는 테스트
다시 태스트다. @Autowired를 통해 컨텍스트에서 가져오는 UserService 타입 오브젝트
는 UserServicelmpl 오브젝트가 아니라 트랜잭션이 적용된 프록시여야 한다. 이를 검
증하려면 upgradeAIIOrNothing() 테스트가 필요한데， 기존의 태스트 코드에서 사용한
방법으로는 이제 한계가 있다. 지금까지는 ProxyFactoryBean
이 빈으로 등록되어 있었
으므로 이를 가져와 타깃을 태스트용 클래스로 바꿔치기히는 방법을 사용했다. 하지만
자동 프록시 생성기를 적용한 후에는 더 이상 가져올 ProxyFactoryBean 같은 패토리 빈
이 존재하지 않는다. 자동 프록시 생성기가 알아서 프록시를 만들어줬기 때문에 프록시
오브젝트만 남아 있을 뿐이다.
그렇다면 어떻게 해야 할까? 지금까지는 어떻게든 설정파일에는 정상적인 경우의 빈
설정만을 두고 롤백을 일으키는 예외상뺑 대한 태스트는 태스트 코드에서 빈을 가져
와 수동 DI로 구성을 바꿔서 사용했다. 하지만 자동 프록시 생성기라는 스프링 컨테이
너에 종속적인 기법을 사용했기 때문에 예외상황을 위한 태스트 대상도 빈으로 등록해
줄 필요가 있다. 이제는 타깃을 코드에서 바꿔치기할 방법도 없을뿐더러， 자동 프록시
생성기의 적용이 되는지도 빈을 통해 확인할 펼요가 있기 때문이다.
기존에 만들어서 사용하던 강제 예외 발생용 TestUserService 클래스를 이제는
직접 빈으로 등록해보자. 그런데 두 가지 문제가 있다. 첫째는 TestUserService가
UserServiceTest 클래스의 내부에 정의된 스태틱 클래스라는 점이고， 둘째는 포인트컷
이 트랜잭션 어드바이스를 적용해주는 대상 클래스의 이름 패턴이 *Servicelmpl
이라고
되어 있어서 TestUserService 클래스는 빈으로 등록을 해도 포인트컷이 프록시 적용
대상으로 선정해주지 않는다는 점이다.
두 가지 문제를 해결하기 위해 TestUserService 스태틱 맹버 클래스를 조금 수정
하자. 스태틱 클래스 자체는 스프링의 빈으로 등록되는 데 아무런 문제가 없다. 대
신 빈으로 등록할 때 클래스 이름을 지정히는 방법을 알아야 한다. 대신 클래스 이름
은 포인트컷이 선정해줄 수 있도록 Servicelmpl로 끝나야 한다. 그래서 클래스 이름을
TestUserServicelmpl
이라고 변경하자. 또， 태스트 코드에서 생성히는 것이 아니기 때
문에 태스트 벽스처로 만든 users 리스트에서 예외를 발생시킬 기준 id를 가져와 사용
할 방법이 없다. 그러므로 아예 예외를 발생시킬 대상인 네 번째 시용자 아이디를 클래
스에 넣어버리자. 살짝 테스트 정보의 중복이 발생하긴 하는데 이 정도는 눈감아주자.


리스트 6-54는 이렇게 수정한 트랜잭션 태스트용 예외 발생 클래스 코드다.

UserServiceTest 내부에 정의되어 있다는 점을 잊지 말자.

리스트 운54 수정한 테스트용 U똥rService 구현 클래스

r


포인트컷의 클래스 필터에 선정되도록 이름 변경
이래서 처음부터 이름을 질 지어야 한다

static class TestUserServicelmpl extends UserServicelmpl (
private String id = .madnitel.;~ 테스트 먹스처의 뼈r의3)의 b 값을 고정시쳐버렀다

protected void upgradeLevel(User user ) (
if (user.getld().equals(this .id)) throw new TestUserServiceException();
super.upgradeLevel (user);

이제 TestUserServicelmpl을 빈으로 등록하자. UserServicelmpl 클래스로 정의한
userService 빈은 그대로 둔 채로 리스트 6-55와 같은 설정을 추가한다.

리스트 융공5 테스트용 UserService의 등록

<bean id칸es
tU
serService" r-스태닥 엠버 클래스는 뾰 지정한다
class=당
pringbook.user.service
.
UserServiceTest$TestUserServiceImpl"
parent="userService" /> 프로떠티 정의훌 포호k해서 userService
~ 빈의 실정율 상속받는다

testUserService 빈 설정에는 특이한 사항 두 가지가 눈에 띈다.

하나는 클래스 이름에 사용한 $ 기호인데， 이는 스태틱 멤버 클래스를 지정할 때 사
용하는 것이다. TestUserServicelmpl 클래스는 UserServiceTest의 스태틱 뱀버 클래
스이므로 $를 사용해서 클래스 이름을 지정해주면 된다. 특정 태스트 클래스에서만 사
용되는 클래스는 스태틱 멤버 클래스로 정의히는 것이 편리하다. 원한다면 이렇게 스프

링 빈으로 등록해서 사용할 수도 있음을 기 억해두자.
또 한 가지 특이한 점은 parent 애트리뷰트다. <bean) 태그에 parent 애트리뷰
트를 사용하면 다른 빈 설정의 내용을 상속받을 수 있다. TestUserServicelmpl
은

UserServicelmpl을 상속받F아서 만들었다. UserServicelmpl
의 기능을 그대로 가져오
고 일부 기능만 태스트에 맞게 수정해서 사용한 것이다. 마찬가지로 스프링에서는 빈의
설정도 상속받을 수 있다. parent="userService"
라고 하면 userService 빈의 모든 설
정을 그대로 가져와서 사용하겠다는 뭇이다. 클래스는 물론이고， 프로퍼티 설정도 모두

6장:_ AOP 485



상속받는다. 물론 오버라이드도 가능하다. testUserService는 userService 빈의 설정
을 상속받은 뒤 클래스만 변경했다.01를 위한 프로퍼티 설정은 userService 빈의 프로
퍼티를 그대로 상속받는다. 따라서 별도로 userDao나 mailSender 프로퍼티를 지정해줄
필요가없다.

마지막으로 upgradeAIIOrNothing() 태스트를 새로 추가한 testUserService 빈을
사용하도록 수정하자. 트랜잭션 테스트에 사용할 testUserService 빈도 UserService
타입이므로 @Autowired로 가져오면 된다. 단 userService 빈과 타입이 중복되므로 타
입뿐 아니라 변수 이름을 빈 이름과 일치시켜줘야 한다. 테스트 자체는 01 히는 묘드가
사라지니 매우 단순해진다. 리스트 6-56은 이렇게 수정된 테스트 코드다.

리스트 운56 testUserService 빈율 사용하도록 수정된 테스트

public class UserServiceTest (
@Autowired UserService userService; 같은 타입의 빈이 두 개 존재하기 때문에 띨드 이릅율
ftAutowired UserService testUserService;~ 기준으로 주입될 빈이 결정된다 자동 프록시 생성기에

의해 트랜잭션 부가기능01 t뼈JserService 빈에 적용됐
는지를 확인하는 것이 목적이다

@Test 스프링 컨텍스트의 빈 설정을 변경하지 않으므로
public void upgradeAIIOrNothing() ( • @DirtiesCo미e잉 애노테이션은 제거됐다 모든 테

스트를 위한 미 작업은 설정따일올 통해 서버에서

userDao.deleteAll(); 진행되므로테걷코드자체는단순해진다
for (User user users) userDao.add(user);

try (
this.testUserService.upgradeLevels( );
fail("TestUserServiceException expected");

catch(TestUserServiceException e) (

checkLevelUpgraded(users.get(1) , false);

이제 모든 준비가 끝났다. 자동 프록시 생성 방식 덕분에 설정과 태스트 코드 모두
깔끔해졌다. upgradeAIIOrNothing() 태스트도 테스트 묘드에서 예외상횡을 적용하기
위한 01 작업이 제거됐기 때문에 코드가 단순해졌다. 물론 태스트 묘드 자체는 단순해
졌지만 테스트의 내용을 이해하려면 설정따일의 01 정보까지 참고해야 하니 테스트의
내용을 이해하기는 조금 어려워
졌다.


이제 테스트를 실행해서 모든 기능이 정상적으로 동작하는지 확인하자. 특히
upgradeAIIOrNothing() 테스트를 통해서 자동 프록시 생성기가 펑범한 비즈니스 로직
만 담고 있는 userService 빈을 자동으로 트랜잭션 부가기능을 제공해주는 프록시로
대체했는지 확인해보자.

자동생성프록시확인
테스트는 모두 성공했다. 몇 가지 특별한 빈 등록과 포인트컷 작성만으로 프록시가 자
동으로 만들어질 수 있게 됐다는 게 잘 믿겨지지 않는다면 확인을 해보면 된다. 무슨 기
술이든 자동으로 무엇을 해준다고 하면 정말 그런지 한 번쯤은 직접 확인해보는 습관을
들이는 편이 좋다. 눈에 보이는 결과도 아니고 확인할 수 있는 코드가 만들어지는 것도
아닌 자동 프록시 생성기 같은 건， 잘못 사용하는 바람에 기능이 예상한 대로 동작하지
않아도 예외적인 상횡어 발생하기 전에는 쉽게 확인이 안 되는 심각한 문제를 초래할
수도있기때문이다.
지금까지 트랜잭션 어드바이스를 적용한 프록시 자동생성기를 빈 후처리기 메커니
즘을 통해 적용했다. 최소한 두 가지는 확인해야 한다.
첫째는 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는가이다. 트랜잭션이
정상적으로 커빗되는 경우에는 트랜잭션 적용 여부를 확인하기 힘들기 때문에 예외상
황에서 트랜잭션이 롤백되게 함으로써 트랜잭션 적용 여부를 태스트해야 한다. 이는 앞
에서 만든 upgradeAIIOrNothing() 테스트를 통해 검증했다.
둘째는 아무 빈에나 트랜잭션이 부가기능이 적용된 것은 아닌지 확인해야 한다. 프
록시 자동생성기가 어드바이저 빈에 연결해둔 포인트컷의 클래스 필터를 이용해서 정
확히 원하는 빈에만 프록시를 생성했는지 확인이 펼요하다. 제대로 하려면 모든 빈을
다 가져와서 프록시로 변했는지 확인해야겠지만， 여기서는 간단히 클래스 필터가 제대
로 동작하는지를 확인해보는 것만으로도 충분할 듯싶다. 즉 클래스 필터가 제대로 동작
해서 프록시 생성 대상을 선별하고 있는지 여부를 알고 싶은 것이다.
방법은 간단하다. 포인트컷 빈의 클래스 이름 패턴을 변경해서 이번엔
testUserService 빈에 트랜잭션이 적용되지 않게 해보자. 이를 확인할 수 있다면 클래
스 필터가 제대로 동작하고 있다는 최소한의 확신을 얻을 수 있다. 이 태스트도 제대로
하려면 전용 설정파일을 만들어 포인트컷을 재구성하는 등의 복잡한 과정이 필요할 텐
데， 여기서는 간단히 현재 테스트 설정파일을 수정해서 확인하고 다시 원상복귀시키는
것으로 하자. 학습 테스트도 계속 유지하는 편이 좋긴 하지만 한 번쯤 학습한 내용에 대
한확신을목적으로해보는정도라면 이렇게 일시적인 테스트를 거치고 넘어가도좋다.

6징:.. AOP 487


트랜잭션 포인트컷 빈의 클래스 필터용 이름 패턴인 mapped
Cl
assName을 리스트
6-57과 같이 수정하자. 트랜잭션 태스트 대상인 TestUserServicelmpl 클래스는 이 클
래스 펼터의 조건에 부합하지 않으니 트랜잭션이 적용되지 않아야 한다.

리스트 • 57 클래스 필터용 이륨울 변경한 포인트컷 설정

<bean id="transactionPointcut"

class=재pringbook
.
user.service.NameMatchCl
assMethodPointcut">

<property name="mappedCl assName" value="*NotServiceImpl' />
<property name="mappedName" value="upgrade*" />

</bean>

테스트를 실행하면 트랜잭션 테스트인 upgradeAIIOrNothing()
만 실패해야 한다. 실
패의 원인은 트랜잭션이 적용되지 않아서 예외가 발생하기 전에 수정한 내용이 롤백되
지 않은 것이어야 한다. 이로써 적어도 포인트컷의 클래스 필터가 바르게 동작하고 있
다고 확신할 수 있다. 실패히는 테스트를 놔두면 안 되니 리스트 6-57
의 수정 내용은
다시 원상복귀시켜서 태스트가 모두 성공하도록 만들자.

또， 다른 방법으로 자동생성된 프록시를 확인할 수 있다.

DefaultAdvisorAutoProxyCreator에 의해 userService 빈이 프록시로 바꿔치기됐
다면 getBean("userService")
로 가져온 오브젝트는 TestUserService 타입이 아니라
JDK의 Proxy 타입일 것이다. 모든 JDK 다이내믹 프록시 방식으로 만들어지는 프록시
는 Proxy 클래스의 서브클래스이기 때문이다.

포인트컷 설정을 원래대로 해놨으면 테스트에 리스트 6-58과 같이 컨테이너가 돌려
준 서비스 빈의 타입을 확인하는 묘드를 넣자.

리스트 • 58 자동생성된 프륙시 확인

@Test
public void advisorAutoProxyCreator() (
assertThat(testUserService , is(java.lang.reflect.ProxY.class));

4 프록시로 변경된 오브젝트인지

확인효떼

이 정도면 자동 프록시 생성용 빈 후처리기인 DefaultAdvisorAutoProxyCreator가 자
동으로 빈 오브젝트를 프록시 빈으로 바꿔준다는 사실을 충분히 알 수 있을 것이다.


6.5.3 포인트컷 표현식을 이용한 포인트컷
이번에는 좀 더 편리한 포인트컷 작성 방법을 알아보자. 지금까지 사용했던 포인트컷은
메소드의 이름과 클래스의 이름 패턴을 각각 클래스 펼터와 메소드 매처 오브젝트로 비
교해서 선정하는 방식이었다. 일일이 클래스 펼터와 메소드 매처를 구현하거나， 스프링
이 제공하는 펼터나 매처 클래스를 가져와 프로퍼티를 설정하는 방식을 사용해야 했다.
지금까지는 단순한 이름을 비교하는 일이 전부였다. 이보다 더 복잡하고 세밀한 기
준을 이용해 클래스나 메소드를 선정하게 하려면 어떻게 해야 할까? 펼터나 매처에서
클래스와 메소드의 메타정보를 제공받으니 어떤 식이든 불가능할 것은 없다. 리플렉션
API를 통해서 클래스와 메소드의 이름， 정의된 패키지， 파리미터， 리턴 값은 물론이고
부여된 애노테이션이나 구현한 인터페이스 상속한 클래스 등의 정보까지도 알아낼 수
있기 때문이다. 하지만 리플렉션 API는 코드를 작성하기가 제법 번거롭다는 단점이 있
다. 또한 리플렉션 API를 이용해 메타정보를 비교하는 방법은 조건이 달라질 때마다 포
인트컷 구현 코드를 수정해야 히는 번거로움도 있다.
스프링은 아주 간단하고 효과적인 방법으로 포인트컷의 클래스와 메소드를 선정하
는 알고리즘을 작성할 수 있는 방법을 제공한다. 정규식이나 JSP의 EL과 비슷한 일종
의 표현식 언어를 사용해서 포인트컷을 작성할 수 있도록 하는 방법이다. 그래서 이것
을 포인트컷 표현식
pointcut expressiono 1
라고 부른다.

포인트컷표현식
포인트컷 표현식을 지원하는 포인트컷을 적용하려면 AspectJExpressionPointcut 클래
스를 사용하면 된다. Pointcut 인터페이스를 구현해야 히는 스프링의 포인트컷은 클래
스 선정을 위한 클래스 펼터와 메소드 선정을 위한 메소드 매처 두 가지를 각각 제공해
야 한다. 앞에서 만들었던 NameMatchClassMethodPointcut은 클래스와 메소드의 이름
의 패턴을 독립적으로 비교하도록 만들어져 있다. 이를 위해 비교할 조건을 가진 두 가
지 패턴을 프로퍼티로 넣어줬다.
하지만 AspectJExpressionPointcut은 클래스와 메소드의 선정 알고리즘을 포인트
컷 표현식을 이용해 한 번에 지정할 수 있게 해준다. 포인트컷 표현식은 자바의 RegEx
클래스가 지원하는 정규식처럼 간단한 문자열로 복잡한 선정조건을 쉽게 만들어낼 수
있는 강력한 표현식을 지원한다. 사실 스프링이 사용히는 포인트컷 표현식은 AspectJ
라는 유명한 프레임워크에서 제공하는 것을 가져와 일부 문법을 확장해서 사용하는 것
이다. 그래서 이를 AspectJ 포인트컷 표현식이라고도 한다.

6짐!_ AOP 489


학습 태스트를 만들어서 표현식의 사용 방법을 살펴보자. 리스트 6-59는 포인트컷
의 선정 후보가 될 여러 개의 메소드를 가진 클래스다.

리스트 운59 포인트컷 테스트용 클래스

package springbook.learningtest.spring.pointcut;

public class Target implements Targetlnterface {

public void hello() {}

public void hello(String a) {}

public int minus(int a, int b) throws RuntimeException { return ø; }

public int plus(int a, int b) { return ø; }

public void method() {}

Target 클래스는 5개의 메소드를 갖고 있다. 이 중 처음 4개는 TargetInterface 인터
페이스에 정의된 메소드를 구현한 것이고 마지막 메소드는 Target 클래스에서 정의한
것이다. 포인트컷 표현식을 이용해서 원히는 메소드만 선정하는 방법을 일아볼 것이다.

여러 개의 클래스 선정 기능을 확인해보기 위해 리스트 6-60과 같이 한 개의 클래스
를더준비한다.

리스트 6용0 포인트컷 테스트용 추가 클래스

package springbook.learningtest.spring.pointcut;

public class Bean {
public void method() throws RuntimeException {

이제 이 두 개의 클래스와 총 6개의 메소드를 대상으로 포인트컷 표현식을 적용해보자.

포인트컷표현식문법
AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성한다. 포인트컷 지시자 중
에서 가장 대표적으로 사용되는 것은 execution( )이다.6징F에서는 execution( ) 지시자
를 이용한 포인트컷 표현식을 주로 사용한다. 그 밖의 지시지는 14장에서 디룰 것이다.
execution() 지시자를 사용한 포인트컷 표현식의 문법구조는 기본적으로 다음과 같다.

[] 괄호는 옵션항목이기 때문에 생략이 가능하다는 의미이며， |는 OR 조건이다.


리턴값의타입때턴~ 메소드이룡때턴+기

execution( [접근제한자 패턴
l 타입패턴 [타입패턴
.
1
이름때턴 (타입패턴 i " .. ", ... )
[throws 예외 패턴]) L.. pu바 privale과 같은 | •
| 접근제한자 생략 가능 • ’

V 따라미터의 타입 때턴을 순서
대로 넣을

예외 o덤 때턴 하다 때키지와 클래스 01름어
1 대한 수 있다 와일드쁘를 01용해 따라미터

패턴 생략 가능하다 사용할 때 개수에 상관없는 때턴을 묘될 수 있다
는 ”을 두어서 연결해야 효빠

처음 보면 복잡해 보일 수도 있는데， 메소드의 풀 시그니처를 문자열로 비교히는 개
념이라고 생각하면 간단하다. 리플렉션으로 Target 클래스의 minus()
라는 메소드의 풀
시그니처를 가져와 비교해보면 이해하기 쉬울 것이다. 다음 문장을 실행하면 리플렉션
의 Method 오브젝트가 제공하는 Target .minus() 메소드의 풀 시그니처를 볼 수 있다.

System .out .println(Target.class .getMethod( "minus" , int. class , int. class));

출력된 결과는 디음과 같다.

public int springbook.learningtest.spring.pointcut.Target .minus(int , int) throws
java.lang .RuntimeException

출력된 내용을 하나씩 살펴보자.

• public
접근제한자다. public, protected, private 등이 올 수 있다. 포인트컷 표현식에서
는 생략할 수 있다. 생략이 가능하다는 건 이 항목에 대해서는 조건을 부여하지 않는
다는의미다.

• int
리턴 값의 타입을 나타내는 패턴이다. 포인트컷의 표현식에서 리턴 값의 타입 패턴
은 펼수항목이다. 따라서 반드시 하나의 타입을 지정해야 한다. 또는 *를 써서 모든

타입을 다 선택하겠다고 해도 된다. 생략은 불가능하다.

• springbook.learningtest.spring.pointcut.Target
여기까지가 패커지와 타입 이름을 포함한 클래스의 타입 패턴이다. 역시 생략 기능

하다. 생략하면 모든 타입을 다 허용하겠다는 돗이다. 뒤에 이어나오는 메소드 이름
패턴과 C
’으로 연결되기 때문에 작성할 때 잘 구분해야 한다. 여기까지가 타입 패턴
이다. 패키지 이름과 클래스 또는 인터페이스 이름에 *를 시용할 수 있다. 또 ‘ .. ’를
사용하면한번에 여러 개의 패커지를선택할수있다.

6징:... AOP 491


• mlnus
메소드 이름 패턴이다. 필수항목이기 때문에 반드시 적어야 한다. 모든 메소드를 다
선택하겠다면 *를 넣으면 된다.

• (i nt, int)
메소드 파라미터의 타입 패턴이다. 메소드 파라미터의 타입을 ;’로 구분하면서 순서
대로 적으면 된다. 따라미터가 없는 메소드를 지정하고 싶다면 ()로 적는다. 파라미
터의 타입과 개수에 상관없이 모두 다 허용하는 패턴으로 만들려면 ‘..’을 넣으면 된
다. ‘ ... ’을 이용해서 뒷부분의 따라미터 조건만 생략할 수도 있다. 펼수항목이므로 반
드시 넣어야한다.

• throws java.lang.RuntimeException
예외 이름에 대한 타입 패턴이다. 생략 가능하다.

Method 오브젝트를 출력했을 때 나오는 메소드 시그니처와 동일한 구조를 가지고
비교히는 것이기 때문에 이해하기 어렵지 않을 것이다. Target 클래스의 minus() 메
소드만 선정해주는 포인트컷 표현식을 만들고 이를 검증해보는 테스트를 작성해보자.
PointcutExpressionTest 태스트 클래스를 추가하고 리스트 6-61과 같은 태스트 메소
드를넣는다.

리스트 6용1 메소드 시그니처률 이용한 포인트컷 표현식 테스트

@Test

public void methodSignaturePointcut () throws SecurityException ,
NoSuchMethodException {
AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
pointcut.setExpression("execution(public int " +
"springbook.learningtest.spring.pointcut.Target.minus(int, int) " +
"throws iava.lang.RuntimeException)"); --률 Tan맹 클래스 mlnu의 ) 메소드 시그니처

// Target.minus ()
클래스밀터와
메소
assertThat(pointcut .getClassFilter() .matches(Target .class) &&
--을 드 매처훌 가져와
pointcut.getMethodMatcher() .matches( 각각 비교효벼
Target .class .ge얀때Met
센tth여
("'f까fmwus
τ int.class, int.class) , null) , is(true) );

야개깨
’


+

// Target.plus() 포인트컷조건통과

assertThat(pointcut.getClassFilter().matches(Target.class) &&
pointcut .getMethodMatcher().matches(


Target.class .getMethod("plus" , int.class, int.class) , null) , is(false));

+

메소드매처에서실패

// Bean.method()
assertThat(pointcut.getClassFilter().matches(Bean .clas5) &&
pointcut.getMethodMatcher() .matches(
Target .class.getMethod( “ method") , null) , is(false));-을 클래스 일터

에서실패

a
후가힐라이브러리
∞m.spring∞urce.α.g.aspe이.1，∞Is-1.
6.6.RELEASE.jar

AspectJExpressionPointcut 클래스의 오브젝트를 만들고 포인트컷 표현식을
expression 프로퍼티에 넣어주면 포인트컷을 사용할 준비가 된다. 포인트컷 표현식은
메소드 시그니처를 execution( ) 안에 넣어서 작성한다. execution()
은 메소드를 실행
에 대한 포인트컷이라는 의미다.

먼저 Target 클래스의 minus() 메소드에 대해 태스트를 해본다. 포인트컷의 선정 방
식은 클래스 펼터와 메소드 매처를 각각 비교해보는 것이다. 두 가지 조건을 모두 만족
시키면 해당 메소드는 포인트컷의 선정 대상이 된다. 포인트컷 자체가 minus() 메소드
의 시그니처이니 당연히 결과는
true
r:t.

Target 클래스의 다른 메소드를 비교해본다. 클래스， 파라미터 등은 모두 통과하겠
지만 메소드 이름과 예외 패턴이 포인트컷 표현식과 일치하지 않기 때문에 때문에 결과
는 falser:t.

Bean.class
의 메소드에 대해 태스트해보면 당연히 클래스부터 맞지 않으니 포인트
컷 적용 결과는 falser:t.

포인트컷표현식테스트
메소드 시그니처를 그대로 사용한 포인트 표현식을 문법구조를 참고로 해서 정리해보
자. 이 중에서 필수가 아닌 항목인 접근제한자 패턴， 클래스 타입 패턴， 예외 패턴은 생
략할 수 있다. 옵션 항목을 생략하면 다음과 같이 간단하게 만들 수 있다.

execution(int minus(int，i
nt))-융 Inl 타입의 리턴 값 mlnus라는 메소드 이를 두 개의 Inl 따라미터를 가진 모든

메소드를 선정하는 포인트컷 표현식

옵션 항목을 제거하니 간결해서 보기 좋다. 단， 생략한 부분은 모든 경우를 다 허용
하도록 되어 있기 때문에 이 포인트컷 표현식은 어떤 접근제한자를 가졌든， 어떤 클래

6갚 AOP 493



스에 정의됐든， 어떤 예외를 던지든 상관없이 정수 값을 리턴하고 두 개의 정수형 파라
미터를 갖는 minus라는 이름의 모든 메소드를 선정하는 좀 더 느슨한 포인트컷이 됐다
는점에주의하자.

리턴 값의 타입에 대한 제한을 없애고 어떤 리턴 타입을 가졌든 상관없이 선정하도
록 만들려면 다음과 같이 * 와일드카드를 쓰면 된다.

리턴 타입은 상관없이 mlnus라는 메人
C 이름 두 개의 Int 따라미터훌 가진 모든

execution(* minus (int , int ))•

i

메소드를 선정하는 포인트컷 표현식

또 파라미터의 개수와 타입을 무시하려면 () 안에 ..를 넣어준다.

execution(* minus( .. )) ~ 리턴 타입과 따라미터의 종류， 개수어| 상관없01 띠뼈랜 메셜 01뚫 가진 모든 메소

드률 선정하는 포인트컷 표현식

만약 모든 선정조건을 다 없애고 모든 메소드를 다 허용하는 포인트것이 필요하다면
다음과 같이 메소드 이름도 와일드카드로 바꾸면 된다. 이렇게 만들면 포인트컷이 검사
히는 모든 오브젝트의 모든 메소드를 다 선택하는 가장 느슨한 포인트컷이 된다.

execution(* *( .. )) ~ 리턴 타입. 따라미터， 메쓰 이름에 상관없이 모든 메알 조건을 다 허용핸 포인트킷 표현식

다OJ=한 활용 방법을 보기 위해 테스트를 보충해보자. 앞에서 만든 Target, Bean 클래
스의 6개 메소드에 대해 각각 포인트컷을 적용해서 결과를 확인하는 테스트다.

주어진 포인트컷을 이용해 특정 메소드에 대한 포인트컷을 적용해보고 결괴를 확인
히는 리
스트 6-62와 같은 메소드를 추가한다. 메소드를 지정하려면 클래스와 메소드
이름， 메소드 파라미터 타입 정보가 펼요하다.

리스트 &-62 포인트컷과 메소드흩 비교해주는 테스트 헬퍼 메소드

public void pointcutMatches(String expression , Boolean expected , Class<?> clazz ,
String methodName , Class<?) ... args) throws Exception (
AspectJExpressionPointcut pointcut =new AspectJExpressionPointcut();
pointcut .setExpression(expression);

포인트컷의 클래스 필터와 메소드 매처

~ 두 가지률 동시에 인족S는지 뺀한다

assertThat(pointcut .getClassFilter() .matches(clazz)
&& pointcut.getMethodMatcher().matches(clazz.getMethod(methodName,
args) , null) , is(expected)) ;


다음은 pointcutMatches() 메소드를 활용해서 타깃으로 만든 두 클래스의 모든 메
소드에 대해 포인트컷 선정 여부를 확인하는 리스트 6-63과 같은 메소드를 추가한다.
표현식과 6개의 메소드에 대한 예상 결과를 주면 이를 검증하는 기능을 제공한다.

리스트 6용3 타깃 클래스의 메소드 6개에 대해 포인트컷 선정 여부톨 검사하는 헬퍼 메소드

public void tagetClassPointcutMatches(String expression, boolean ... expected)
throws Exception (
pointcutMatches(expression, expected[0 ], Target .class , "hello");
pointcutMatches(expression, expected[1] , Target.class , "hello" , String.class);
pointcutMatches(expression, expected[2], Target.class , 'plus', int.class , int .class);
pointcutMatches(expression , expected[3], Target.class, 깨
inus"， int .class , int .class);
pointcutMatches(expression, expected[4] , Target.class , 깨ethod'’ );
pointcutMatches (express ion , expected [5 ], Bean. class , "method");

이제 다양한 포인트것을 만들어서 모든 메소드에 대한 포인트컷 적용 결괴를 확인해
보자. 표 6-1
은 포인트컷 표현식과 그에 대한 targetClassPointcutMatches()
의 각 메
소드별 포인트컷 검사 결과다. 총 19가지의 포인트컷 표현식에 대해 결과를 검증할 수
있토록 만들어진 태스트의 결괴를 정리한 것이다.

리스트 6•)4 포인트컷 표현식 테스트

@Test

public void pointcut() throws Exception {
tagetClassPointcutMatches( 'execution(* *(..))", true, true, true, true, true, true);
// 나머지는 생략 -표 6-1
의 내용과 동일하다
.


첫 번째 표현식은 모든 메소드를 다 허용하는 표현식이다. 당연히 모든 메소드에 대
해 true
다. 표 6-1
에 테스트 결과를 정리해뒀다.

tm_ AOP 495


표 6-1 AspectJ 포인트것 표현식의 메소드 선정 결과

l 포인트컷 표헌식 1 摩]펌템.버a 웹

execution(* hello(..)) O O
2 execution(’‘ helloO) O
3 execution(* hello(String)) O
4 execution(* meth*(..)) O O
5 execution(* *(int,int)) o O
6 execution(* *()) O O O
7 execution(* springbook.learningtest. O O O O O
spring.pointcut.Target.*(..))
8 execution(* springbook.learningtest. O o O O O O
spnng.p이ntcut.션(..))
9 execution(* spring∞。k.learningtest.o O O O O O
spring.pointcul..서(..))
10 execution(* springb∞k..*.*(..)) O O O O O O
11 execution(* com..*.*(..))
12 execution(* *..Target.*(..)) O O O O O
13 execution(* *..Tar션(..)) O O O O O
14 execution(* *.. *get.*(..)) O O O O O
15 execution(* *.. 8*.*(..)) O
16 execution(* *..Targetlnteηace.*(..)) O O O O
17 execution(* *(..) throws Runtime*) O O
18 execution(int *(..)) O O
19 execution(void *(..)) O O O O
l 번은 hello라는 이름을 가진 메소드를 선정하는 것이다. 따라미터는 모든 종류를
다 허용한다. 따라서 hello()
와 hello(String)
이 선택된다. 반면에 2
번은 파라미터 패
턴이 ()로 되어 있으니 hello 메소드 중에서 파라미터가 없는 것만 선택한다. 마찬가지
로 3
번은 파라미터의 개수가 한 개이며 String 타입인 것을 찾는다.

4
번은 메소드 이름에 와일드카드를 사용하는 경우다. 이름의 시작과 끝에 모두

*를 적용할 수 있다. 메소드가 정의된 타입
(클래스
. 인터메이
스)은 지정하지 않았으므로 meth
로 시작히는 모든 클래스의 메소드가 다 허용된다. 따라서 Target . method ( )와 Bean.
method( ) 두 가지가 선택된다.

5
번은 파라미터 타입만으로 선정히는 방법이다. 메소드 이름에는 상관없이 두 개의

정수 파라미터를 가진 메소드가 선정된다.6번은 파라미터가 없는 모든 메소드를 선택

히는것이다.

7, 8, 9는 모두 패키지와 클래스 타입 패턴을 사용하는 방법이다. 기본적으로 타입
패턴을 적을 때는 메소드 시그니처에 볼 수 있는 것처럼 패키지를 포함시켜야 한다.
7
번은 클래스를 직접 지정한 것이다. 따라서 Bean 클래스의 메소드는 선정되지 않았다.
8
번은 클래스 이름에 와일드카드를 사용한 것이다. 따라서 springbook .learningtest.
spring.pointcut 패키지의 모든 클래스에 적용된다. 하지만 서브패키지의 클래스는 포
함되지 않는다. 반면에 9번은 ‘ .. ’를 사용해서 서브패키지의 모든 클래스까지 포함시키
는 식이다. ‘ .. ’를 이용하면 10번처럼 특정 패키지의 모든 서브패커지를 다 지정하는 방

법도 가능하다. springbook으로 시작하는 모든 패키지의 모든 클래스를 다 선정한다.
그래서 11 번은 com으로 시작히는 패키지를 선정하는 식이기 때문에 어떤 메소드도 적
용되지않는다.

12
번은 패키지에는 상관없이 Target
이라는 이름의 모든 클래스에 적용하는 식이다.

다른 패키지에 같은 이름의 클래스가 있어도 적용된다는 점에 주의해야 한다. 이렇게

정의하면 앞에서 만들었던 클래스의 이름만을 이용한 클래스 펼터와 같은 결과를 낼 것
이다. 13, 14, 15
번은 클래스 이름에 와일드카드를 부여한 것이다. 모든 패키지 이름，
클래스 이름， 메소드 이름에는 와일드카드를 사용할 수 있다.

16
번은 Target 클래스가 아니라， Target 클래스가 구현한 Targetlnterface 인터페
이스를 선정조건으로 한 것이다. 이렇게 인터페이스를 사용하면 Target 클래스의 메소
드 중에서 이 인터페이스를 구현한 메소드에만 포인트컷이 적용된다. 따라서 인터페이
스에는 정의되지 않은 method( ) 메소드는 제외된다. 빈으로 등록된 클래스의 단순한 이
름만 비교했던 방식과 달리 포인트컷 표현식은 인터페이스 슈퍼클래스의 타입도 인식
해준다. 그래서 클래스 이름 패턴이라기보다는 타입 패턴이라고 부르는 것이다.

17
번은 메소드와 클래스와는 상관없이 예외 선언만 확인해서 메소드를 선정하는 포
인트컷이다. Runtime으로 시작하는 어떤 예외라도 던진다면 이 포인트컷의 조건을 만

족할것이다.

18, 19번은 리턴 타입을 이용해 메소드를 선정하는 예다.

결과를 미리 보지 말고 각 포인트컷이 적용될 메소드가 어떤 것인지 생각해보면서

포인트컷 표현식에 익숙해지도록 충분히 연습해두자.

6장，_ AOP 497


포인트컷 표현식을 이용하는 포인트컷 적용

AspectJ 포인트컷 표현식은 메소드를 선정동1는 데 편리하게 쓸 수 있는 강력한 표현
식 언어다. 아직 설명하지 않은다OJ"한문법과활용방법이 많이 있다. 포인트컷 표현식
은 메소드의 시그니처를 비교하는 방식인 execution( ) 외에도 몇 가지 표현식 스타일
갖고 있다. 대표적으로 스프링에서 사용될 때 빈의 이름으로 비교히는 bean()
이 있다.
bean(*Service)
라고 쓰면 아이디가 Service로 끝나는 모든 빈을 선택한다. 단지 클래

스와 메소드라는 기준을 넘어서는 유용한 선정 방식이다.

또 특정 애노테이션이 타입 메소드 파라미터에 적용되어 있는 것을 보고 메소드를

선정하게 하는 포인트컷도 만들 수 있다. 아래와 같이 쓰면 @Transactional
이라는 애

노테이션이 적용된 메소드를 선정하게 해준다. 까다로운 명명 규칙을 사용하지 않아도
애노테이션만 부여해놓고 포인트컷을 통해 자동으로 선정해서， 부가기능을 제공하게
해주는 방식은 스프링 내에서도 애용되는 편리한 방법이다.

@annotation(org .springframework .transaction .annotation.Transactional)

지금까지 포인트컷 표현식을 사용히는 방법을 알아봤으니 적용해볼 차례다. 앞에서
만든 transactionPointcut 빈은 제거하자. 이제 NameMatchclassMethodPointcut과 같
이 직접 만든 포인트컷 구현 클래스를 사용할 일은 없을 것이다. 기존 포인트컷 빈의 프
로퍼티 선언에 담긴 포인트컷 선정조건을 다시 살펴보자. mappedClassName 프로퍼티는
클래스 이름에 대한 패턴이고. mappedName 프로퍼티는 메소드 이름에 대한 패턴이다.

<property name="mappedCl assName" value=냐ServiceImpl" />

<property name="mappedName" value="upgrade* “ />

이제 기존 포인트컷과 동일한 기준으로 메소드를 선정하는 알고리즘을 가진 포인트
컷 표현식을 만들어보자. 이렇게 만든 포인트컷 표현식은 AspectJExpressionPointcut
빈을 등록하고 expression 프로퍼티에 넣어주면 된다. 클래스 이름은 Servicelmpl로
끝나고 메소드 이름은 upgrade로 시작하는 모든 클래스에 적용되도록 하는 표현식을 만
들어보면 execution(* *.. *Servicelmpl.upgrade*( .. ))와 같이 된다. 이를 적용한 빈
설정을 만들어보면 리스트 6-65와 같다.


리스트 6용5 포인트컷 표현식을 사용한 빈 설정

<bean id="transactionPointcut"
class="org.springframework.aoP .aspectj.AspectJExpressionPointcut")
<property name="expression" value="execution(* * .. *Servicelmpl .upgrade*( .. ))" /)
</bean)

설정파일을 수정했으면 UserServiceTest 태스트를 실행해서 포인트컷이 이전과 동
일하게 동작하는지를 확인해보자.

포인트컷 표현식을 사용하면 로직이 짧은 문자열에 담기기 때문에 클래스나 코드를
추가할 필요가 없어서 코드와 설정이 모두 단순해진다. 반면에 문자열로 된 표현식이므
로 런타임 시점까지 문법의 검증이나 기능 확인이 되지 않는다는 단점도 있다. 기뜩이
나 눈에 보이지 않는 백그라운드 작업을 수행히는 자동 프록시 생성기와 맞물려도 동작
하는 것이라 결과를 확인하기도 쉽지 않은데， 표현식까지 사용하면 실수할 가능성이 높
아진다. 포인트컷 표현식의 사용으로 얻을 수 있는 장점이 많은 만큼 시간을 투자해서
충분히 학습하고， 다양한태스트를 미리 만들어서 검증한표현식을가져다사용하자.

포인트컷 표현식을 이용히는 포인트컷이 정확히 원히는 빈만 선정했는지를 확인하
는 일은 만만치 않다. 테스트를 만들면 가능은 하지만 상당히 번거롭다. 하지만 염려할
것은 없다.Vi이
.2에서 자세히 소개하겠지만 스프령 개발팀이 제공하는 스프링 지원 툴
을 사용하면 아주 간단히 포인트컷이 선정한 빈이 어떤 것인지 한눈에 확인하는 방법이
있기 때문이다.

타입 패턴과 클래스 이름 패턴
포인트컷 표현식을 적용하기 전에는 클래스 이름의 패턴을 이용해 타깃 빈을 선정
하는 포인트컷을 사용했다. UserService를 구현한 UserServicelmpl 클래스와 테스
트를 위한 강제로 예외를 발생시키는 TestUserServicelmpl 클래스 두 개를 모두 빈
으로 등록하고 이 두 개의 빈에 모두 트랜잭션을 적용하기 위해 Servicelmpl
로 꿀
나는 클래스 이름을 가진 빈을 선정하도록 포인트컷을 구성했다. 이를 위해 기존에
TestUserService였던 테스트용 UserService 구현 클래스의 이름을 이름 패턴에 맞추
려고 TestUserServicelmpl로 변경하기까지 했다.
클래스 이름에 일정한 패턴이 있으니 포인트컷 표현식을 적용할 때도 타입 패턴을

*. .*Servicelmpl로 해서 클래스 이름이 Servicelmpl로 끝나는 것을 선택하도록 만들
었다. 당연히 UserServicelmpl과 TestUserServicelmpl 클래스로 등록된 두 개의 빈이
선정되고 태스트는 성공한다.
6징:.. AOP 499



그런데 앞에서 사용했던 단순한 클래스 이름 패턴과 포인트컷 표현식에서 사용히는

타입 패턴은 중요한 차이점이 있다. 이를 확인하기 위해서 TestUserServicelmpl
이라고

변경했던 태스트용 클래스의 이름을 다시 TestUserServi
ce라고 바꿔보자. 그리고 테스

트를 실행하면 어떻게 될까? 포인트컷 표현식에 따르면 타입 패턴은 *.. *Servicelmpl

이므로 TestUserService 클래스의 빈은 선정되지 않을 것이고， 테스트는 실패로 끝날

것같다.과연그럴까?

그런데 막상 태스트를 실행해보면 결과는 성공이다. 어떻게 된 것일까? 포인트컷 표

현식은 변함없이 execution(* * . . *Servicelmpl.upgrade*( .. ))로 되어 있는데 어떻게

TestUserService 클래스로 등록된 빈이 선정됐을까?

그 이유는 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이

아니라 타입 패턴이기 때문이다. TestUserService의 클래스 이름은 TestUserService

일 뿐이지만， 타입을 따져보면 TestUserService 클래스이자， 슈퍼클래스인

UserService Impl , 구현 인터페이스인 UserService 세 가지가 모두 적용된다. 즉

TestUserService 클래스로 정의된 빈은 UserServicelmpl 타입이기도 하고， 그 때문에

Servicelmpl로 끝나는 타입 패턴의 조건을 충족하는 것이다. 포인트컷 표현식 테스트

의 16
변을 다시 생각해보면 이해가 될 것이다. Targetlnterface 인터페이스를 표현식

에 사용했을 때 Target 클래스의 오브젝트가 포인트컷에 의해 선정된 것과 마찬가지다.

Target은 Targetlnterface를 구현했기 Target 클래스의 오브젝트는 Targetlnterface

타입이기도하다.

포인트컷 표현식의 타입 패턴 항목을 *.. UserService라고 직접 인터페이스 이름을
명시해도 두 개의 빈이 모두 선정된다. 두 클래스 모두 UserService 인터페이스를 구현
하고 있기 때문이다. 여러 가지 변화가 가능하겠지만， 포인트컷 표현식의 타입 패턴은
그대로 *.. *Servicelmpl로 남겨두자.

포인트컷 표현식에서 타입 패턴이라고 명시된 부분은 모두 동일한 원리가 적용된다
는점을기억해두자.

6.5.4 AOP란 무엇인가?
비즈니스 로직을 담은 UserService
에 트랜잭션을 적용해온 과정을 정리해보자.

트랜잭션서비스추상화
트랜잭션 경계설정 묘드를 비즈니스 로직을 담은 묘드에 넣으면서 맞닥뜨린 첫 번째 문
제는 특정 트랜잭션 기술에 종속되는 코드가 돼버린다는 것이었다. JDBC
의 로컬 트랜
잭션 방식을 적용한 묘드를， JTA를 이용한 글로벌/분산 트랜잭션 방식으로 바꾸려면
모든 트랜잭션 적용 코드를 수정해야 한다는 심각한 문제점이 발견됐다. 트랜잭션을 처
리한다는 기본적인 목적은 변하지 않더라도 그것을 어떻게 해야 한다는 구체적인 방법
이 변하면， 트랜잭션과는 직접 관련이 없는 코드가 담긴 많은 클래스를 일일이 수정해
야했다.
그래서 트랜잭션 적용이라는 추상적인 작업 내용은 유치한 채로 구체적인 구현 방법
을자유롭게 비꿀수 있도록서비스추상화기법을적용했다. 이 덕분에 비즈니스로직
코드는 트랜잭션을 어떻게 처리해야 한다는 구체적인 방법과 서버환경에서 종속되지
않는다. 구체적인 구현 내용을 담은 의존 오브젝트는 런타임 시에 다이내믹하게 연결해
준다는 DI를 활용한 전형적인 접근 방법이었다.
트랜잭션 추상화란 결국 인터페이스와 DI를 통해 무엇을 하는지는 남기고， 그것을
어떻게 하는지를 분리한 것이다. 어떻게 할지는 더 이상 비즈니스 로직 묘드에는 영향
을 주지 않고 독립적으로 변경할 수 있게 됐다.

프록시와 데코레이터 패턴
트랜잭션을 어떻게 다룰 것인가는 추상회를 통해 코드에서 제거했지만， 여전히 비즈니
스 로직 코드에는 트랜잭션을 적용하고 있다는 사실은 드러나 있다. 트랜잭션이라는 부
가적인 기능을 어디에 적용할 것인가는 여전히 코드에 노출시켜야 했다. 문제는 트랜잭
션은 거의 대부분의 비즈니스 로직을 담은 메소드에 필요하다는 점이다. 게다가 트랜잭
션의 경계설정을 담당하는 코드의 특성 때문에 단순한 추상화와 메소드 추출 방법으로
는더 이상제거할방법이 없었다.
그래서 도입한 것이 바로 DI를 이용해 데코레이터 패턴을 적용히는 방법이었다. 투
명한 부가기능 부여를 가능하게 하는 데코레이터 패턴의 적용 덕에 비즈니스 로직을 담
당하는 클래스도 자신을 사용하는 클라이언트와 DI 관계를 맺을 이유를 찾게 됐다. 클
라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고， 데코레이터 패턴을 적용해
서， 비즈니스 로직을 담은 클래스의 코드에는 전혀 영향을 주지 않으면서 트랜잭션이라
는 부가기능을 지유롭게 부여할 수 있는 구조를 만들었다.
트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨서 클라이언트와 비즈니스

6징:... AOP 501


로직을 담은 타깃 클래스 사이에 존재하도록 만들었다. 그래서 클라이언트가 일종의 대
리자인 프록시 역할을 히는 트랜잭션 데코레이터를 거쳐서 타깃에 접근할 수 있게 됐다.
결국 비즈니스 로직 코드는 트랜잭션과 같은 성격이 다른 코드로부터 자유로워졌고，

독립적으로 로직을 검증히는 고립된 단위 테스트를 만들 수도 있게 됐다.

다이내믹 프록시와 프록시 팩토리 번
프록시를 이용해서 비즈니스 로직 코드에서 트랜잭션 코드는 모두 제거할 수 있었지만，
비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어
프록시 클래스를 만드는 작업이 오히려 큰 짐이 됐다. 트랜잭션 기능을 부여하지 않아
도 되는 메소드조차 프록시로서 위임 기능이 필요하기 때문에 일일이 다 구현을 해줘야
했다.
그래서 프록시 클래스 없이도 프록시 오브젝트를 런타임 시에 만들어주는 JDK 다이
내믹 프록시 기술을 적용했다. 그 덕분에 프록시 클래스 묘드 작성의 부담도 덜고， 부가
기능부여 코드가 여기저기 중복돼서 나타나는문제도 일부 해결할수 있었다. 일부 메
소드에만 트랜잭션을 적용해야 히는 경우에는 메소드를 선정하는 패턴 등을 이용할 수
도 있었다. 하지만 통일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단
위로는중복이 일어나는문제는해결하지 못했다.
JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을
이용해서 다이내믹 프록시 생성 방법에 DI를 도입했다. 내부적으로 템플릿/콜백 패턴
을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와 부가기
능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고 여러 프록시에서 공
유해서 사용할 수 있게 됐다.

자동 프록시 생성 방법과 포인트컷
트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야 한다는 부담
이남아있었다.
이를 해결하기 위해서 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너
초기화 시점에서 지동으로 프록시를 만들어주는 방법을 도입했다. 프록시를 적용할 대
상을 일일이 지정하지 않고 패턴을 이용해 자동으로 선정할 수 있도록， 클래스를 선정
하는 기능을 담은 확장된 포인트컷을 사용했다. 결국 트랜잭션 부가기능을 어디에 적용
하는지에 대한 정보를 포인트컷이라는 독립적인 정보로 완전히 분리할 수 있었다. 처음
에는 클래스와 메소드 선정 로직을 담은 코드를 직접 만들어서 포인트컷으로 시용했지


만， 최종적으로는 포인트컷 표현식이라는 좀 더 편리하고 깔끔한 방법을 활용해서 간단
한 설정만으로 적용 대상을 손쉽게 선택할 수 있게 됐다.

부가기능의모률화
관심사가 같은 묘드를 분리해 한데 모으는 것은 소프트웨어 개발의 가장 기본이 되는
원칙이다. 그렇게 관심사가 같은 코드를 객체지향 설계 원칙에 따라 분리하고， 서로 낮
은 결합도를 가진 채로 독립적이고 유연하게 확장할 수 있는 모률로 만드는 것이 초난
감
DAO로부터 시작해서 지금까지 해온작업이다.
코드를 분리하고， 한데 모으고， 인터페이스를 도입하고，
DI를 통해 런타임 시에 의
존관계를 만들어줌으로써 대부분의 문제를 해결할 수 있었다. 하지만 이 트랜잭션 적용
코드는 기존에 써왔던 방법으로는 간단하게 분리해서 독립된 모률로 만들 수가 없었다.
왜냐하면 트랜잭션 경계설정 기능은 다른 모율의 코드에 부가적으로 부여되는 기능
이라는 특징이 있기 때문이다. 그래서 트랜잭션 코드는 한데 모을 수 없고， 애플리케이
션 전반에 여기저기 흩어져 있다. 따라서 트랜잭션 경계설정 기능을 독립된 모률로 만
들려면 특별한 기법이 펼요하다. 클래스를 만들지 않고도 새로운 구현 기능을 가진 오
브젝트를 다이내믹하게 만들어내는 다이내믹 프록시라든가 IoC/DI 컨테이너의 빈 생
성 작업을 가로채서 빈 오브젝트를 프록시로 대체하는 빈 후처리 기술과 같은 복잡한
기술이요구된다.
트랜잭션 같은 부가기능은 핵심기능과 같은 방식으로는 모률화하기가 매우 힘들다.
이름 그대로 부가기능이기 때문에 스스로는 독립적인 방식으로 존재해서는 적용되기
어렵기 때문이다. 트랜잭션 부가기능이란 트랜잭션 기능을 추가해줄 다른 대상， 즉 타
깃이 존재해야만 의미가 있다. 따라서 각 기능을 부가할 대상인 각 타깃의 코드 안에 침
투하거나 긴밀하게 연결되어 있지 않으면 안 된다. 기능이 부여되는 타깃은 애플리케이
션의 핵심기능이다. 사용자 관리와 같은 핵심기능을 가진 모율은 그 자체로 독립적으로
존재할 수 있으며， 독립적으로 태스트도 가능하고， 최소한의 인터페이스를 통해 다른
모률과 결합해 사용되면 된다. 반면에 부가기능은 여타 핵심기능과 같은 레벨에서는 독
립적으로 존재하는 것 자체가 불가능하다.
그래서 많은 개발지는 핵심기능을 담당하는 코드 여기저기에 흩어져 나타나야 했던
이런 부가기능을 어떻게 독립적인 모률로 만들 수 있을까를 고민해왔다. 지금까지 살펴
본 DI, 데코레이터 패턴， 다이내믹 프록시， 오브젝트 생성 후처리， 자동 프록시 생성，
포인트컷과 같은 기법은 이런 문제를 해결하기 위해 적용한 대표적인 방법이다. 덕분에
부가기능인 트랜잭션 경계설정 기능은 TransactionAdvice라는 이름으로 모율화될 수

6갚 AOP 503


있었다. 독립적으로 모률화되어 있기 때문에 이 묘드는 중복되지 않으며， 변경이 펼요
하면 한 곳만 수정하면 된다. 또한 포인트것이라는 방법을 통해 부가기능을 부여할 대
상을 선정할 수 있었다. 이런 기법을 잘 활용한 덕분에 핵심기능을 담은 묘드와 설정에
는 전혀 영향을 주지 않아도 됐다.

결국 지금까지 해온 모든 작업은 핵심기능에 부여되는 부가기능을 효과적으로 모률
화히는 방법을 찾는 것이었고， 어드바이스와 포인트컷을 결합한 어드바이저가 단순하
지만 이런 특성을 가진 모률의 원시적인 형태로 만들어지게 됐다.

AOP: 애스펙트 지향 프로그래밍
전통적인 객체지향 기술의 설계 방법으로는 독립적인 모률화가 불가능한 트랜잭션 경
계설정과 같은 부가기능을 어떻게 모율화할 것인가를 연구해온 사람들은， 이 부가기
능 모율화 작업은 기존의 객체지향 설계 패러다임과는 구분되는 새로운 특성이 있다
고 생각했다. 그래서 이런 부가기능 모율을 객체지향 기술에서 주로 사용하는 오브젝
트와는 다르게 특별한 이름으로 부르기 시작했다. 그것이 바로 애스펙트aspect다. 애스
펙트란 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만， 애플리케이션을
구성하는 중요한 한 가지 요소이고 핵심기능에 부가되어 의미를 갖는 특별한 모률을
가리킨다.
애스펙트는 부가될 기능을 정의한 코드인 어드바이스와， 어드바이스를 어디에 적용
할지를 결정하는 포인트컷을 함께 갖고 있다. 지금 사용하고 있는 어드바이저는 아주
단순한 형태의 애스펙트라고 볼 수 있다.
애스펙트는 그 단어의 의미대로 애플리케이션을 구성하는 한 가지 측면이라고 생각
할 수 있다. 그림 6-21
을 살펴보자. 왼쪽은 애스펙트로 부가기능을 분리하기 전의 상
태다. 핵심기능은 깔끔한 설계를 통해서 모률화되어 있고 객체지향적인 장점을 잘 살
릴 수 있도록 만들었지만 부가기능이 핵심기능의 모률에 침투해 들어가면서 설계와 코
드가 모두 지저분해졌다. 트랜잭션 경계설정 코드를 처음 사용자 관리 서비스 클래스에
추가했을 때를 생각해보자. 핵심기능을 담은 묘드는 부가기능인 트랜잭션 코드와 함께
섞여 있어서 핵심기능인 사용자 관리 로직을 파악하고， 수정하고， 태스트하기가 매우
불편했다. 트랜잭션 외에도 핵심기능이 아닌 다OJ=한 부가기능을 모두 넣으면 아마도 핵
심기능은 부가기능 코드에 가려서 보이지 않을지도 모른다. 게다가 이런 부가기능 코드
는 여기저기 메소드에 마구 흩어져서 나타나고 코드는 중복된다. 나름 트랜잭션 추상화
까지는 적용했지만 더 이상은 기존의 객체지향 설계 기법으로 해결할 방법은 없었다.


、

부가기능
11 ‘~~~---..

、



、
、
I
I

애스펙트

、


、
、

、、
부가기능
2 t

‘ _______________________________ J t

그림 6-21 독립 애스펙트률 이용한 부가기능의 분리와 모률화

오른쪽 그림은 이렇게 핵심기능 묘드 사이에 침투한 부가기능을 독립적인 모률인 애스
펙트로 구분해낸 것이다.2차원적인 평면 구조에서는 어떤 설계 기법을 동원해도 해결
할 수 없었던 것을，
3차원의 다변체 구조로 가져가면서 각각 성격이 다른 부가기능은 다
른 면에 존재하도록 만들었다. 이렇게 독립된 측면에 존재하는 애스펙트로 분리한 덕에
핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고 독립적으로 살펴볼 수 있도록
구분된 면에 존재하게 된 것이다.

물론 애플리케이션의 여러 다른 측면에 존재하는 부가기능은 결국 핵심기능과 함께
어우러져서 동작하게 되어 있다. 하나 이상의 부가기능이 핵심기능과 함께 동시에 동작
할수도 있다. 결국 런타임 시에는 왼쪽의 그림처럼 각부가기능 애스펙트는자기가 펼
요한 위치에 다이내믹하게 참여하게 될 것이다. 하지만 설계와 개발은 오른쪽 그림처럼
다른특성을띤애스펙트들을독립적인관점으로작성하게할수있다.

이렇게 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라
는 독특한 모율로 만들어서 설계하고 개발하는 방법을 애스펙트 지항 프로그래밍
Aspect
Oriented Programming 또는 약자로 AOP라고 부른다. 이름만 들으면 마치 OOP가 아닌 다

른 프로그래밍 언어 또는 패러다임이라고 느껴지지만 AOP는 OOP를 돕는 보조적인
기술이지 OOP를완전히 대체하는새로운개념은아니다. 그림 6-21
의 왼쪽과같이 부
가기능이 핵심기능 안으로 침투해서 들어가 버리연 핵심기능 설계에 객체지향 기술의
가치를 온전히 부여하기가 힘들어진다. 부가된 코드로 인해 객체지향적인 설계가 주는
장점을 잃어버리기 십상이다. AOP는 애스펙트를 분리함으로써 핵심기능을 설계하고
구현할 때 객체지향적인 가치를 지킬 수 있도록 도외주는 것이라고 보면 된다.

AOP는 결국 애플라케이션을 다OJ=한 측면에서 독립적으로 모델링하고， 설계하고，
개발할 수 있도록 만들어주는 것이다. 그래서 애플리케이션을 다OJ=한 관점에서 바라보

6징:... AOP 505



며 개발할 수 있게 도외준다. 애플리케이션을 시용자 관리라는 핵심 로직 대신 트랜잭
션 경계설정이라는 관점에서 바라보고 그 부분에 집중해서 설계하고 개발할 수 있게 된
다는 돗이다. 트랜잭션 기술의 적용에만 주목하고 싶다면 TransactionAdvice에만 집중
하면 된다. 그리고 그 대상을 결정해주는 transactionPointcut 빈의 설정만 신경 써주
변 된다. 이렇게 애플리케이션을 특정한 관점을 기준으로 바라볼 수 있게 해준다는 의
미에서 AOP를 관점 지항 프로그래밍이라고도 한다.

6.5.5 AOP 적용기술
프록시를이용한
AOP
스프링은 IoC/DI 컨테이너와 다이내믹 프록시， 데코레이터 패턴， 프록시 패턴， 자동 프
록시 생성 기법， 빈 오브젝트의 후처리 조작 기법 등의 다OJ=한 기술을 조합해 AOP를
지원하고 있다. 그중 가장 핵심은 프록시를 이용했다는 것이다. 프록시로 만들어서 DI
로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가기능을 제공해주
도록 만들었다. 따라서 스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외에는 특
별한 기술이나 환경을 요구하지 않는다. 스프링 컨테이너인 애플리케이션 컨텍스트는
특별한 환경이나 JVM 설정 등을 요구하지 않는다. 서버환경이라면 가장 기초적인 서
블릿 컨테이너만으로도 충분하며 원한다면 독립형 애플리케이션에서도 사용 기능하
다. 스프링 AOP 또한 마찬가지다.
스프링 AOP의 부가기능을 담은 어드바이스가 적용되는 대상은 오브젝트의 메소드
다. 프록시 방식을 사용했기 때문에 메소드 호출 과정에 참여해서 부가기능을 제공해주
게 되어 있다. 어드바이스가 구현하는 MethodInterceptor 인터페이스는 다이내믹 프
록시의 InvocationHandler와 마찬가지로 프록시로부터 메소드 요청정보를 전달받아서
타깃 오브젝트의 메소드를 호출한다. 타깃의 메소드를 호출히는 전후에 다OJ=한 부가기
능을제공할수있다.
독립적으로 개발한 부가기능 모률을 다양한 타깃 오브젝트의 메소드에 다이내믹하
게 적용해주기 위해 가장 중요한 역할을 맡고 있는 게 바로 프록시다. 그래서 스프링
AOP는 프록시 방식의 AOP라고 할 수 있다.

바이트코드 샘성과 조작을 통한 AOP
그렇다면 프록시 방식이 아닌 AOP도 있다는 뭇인가? 물론 있다. AOP 기술의 원조이
자， 가장 강력한 AOP 프레임워크로 꼽히는 AspectJ는 프록시를 사용하지 않는 대표적


인 AOP 기술이다. 스프링도 AspectJ의 뛰어난 포인트컷 표현식을 차용해서 사용할 만
큼 매우 성숙하고 발전한 AOP 기술이다. AspectJ는 스프링처럼 다이내믹 프록시 방식
을 샤용하지 않는다. 프록시를 사용하지 않고 어떻게 독립적으로 만든 부가기능을 다이
내믹하게 다OJ=한 타깃 오브젝트에 적용해줄 수 있을771-7

AspectJ는 프록시처럼 간접적인 방법이 아니라， 타깃 오브젝트를 묻어고쳐서 부가
기능을 직접 넣어주는 직접적인 방법을 사용한다. 부가기능을 넣는다고 타깃 오브젝트
의 소스묘드를 수정할 수는 없으니， 컴따일된 타깃의 클래스 파일 자체를 수정하거나 클
래스가 NM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용
한다. 트랜잭션 코드가 UserService 클래스에 비즈니스 로직과 함께 있었을 때처럼 만
들어버리는 것이다. 물론 소스코드를 수정하지는 않으므로 개발지는 계속해서 비즈니스
로직에 충실한 묘드를 만들 수 있다.

그렇다면 AspectJ는 프록시 같은 방법이 있음에도 왜 검파일된 클래스 파일 수정
이나 바이트코드 조작과 같은 복잡한 방법을 사용할까? 두 가지 이유를 생각해볼 수
있다.

첫째는 바이트코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은
DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP를 적

용할 수 있기 때문이다. 스프링과 같은 컨테이너가 사용되지 않는 환경에서도 손쉽게
AOP의 적용이 가능해진다.

둘째는 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문이다. 프록시
를 AOP의 핵심 메커니즘으로 사용하면 부가기능을 부여할 대상은 클라이언트가 호출
할 때 사용히는 메소드로 제한된다. 하지만 바이트코드를 직접 조작해서 AOP를 적용
하면 오브젝트의 생성， 펼드 값의 조회와 조작， 스태틱 초기화 등의 다양한 작업에 부가
기능을 부여해줄 수 있다. 타깃 오브젝트가 생성되는 순간 부가기능을 부여해주고 싶을
수도 있다. 하지만 프록시 방식에서는 이런 작업이 불기능하다. 타깃 오브젝트의 생성
은프록시 패턴을적용할수있는대상이 아니기 때문이다. 또 프록시 적용이 불가능한
private 메소드의 호출， 스태틱 메소드 호출이나 초기화， 심지어 펼드 입출력 등에 부
가기능을 부여하려고 하면 클래스 바이트코드를 직접 조작해서 타깃 오브젝트나 호출
클라이언트의 내용을수정하는것밖에는방법이 없다.

물론 대부분의 부가기능은 프록시 방식을 사용해 메소드의 호출 시점에 부여히는
것으로도 충분하다. 게다가 AspectJ 같은 고급 AOP 기술은 바이트코드 조작을 위해
JVM의 실행 옵션을 변경하거나， 별도의 바이트코드 컴파일러를 λF용하거나， 특별한
클래스 로더를 사용하게 히는 등의 번거로운 작업이 필요하다. 따라서 일반적인 AOP를

6장!_ AOP 507


적용하는 데는 프록시 방식의 스프링 AOP로도 충분하다. 간혹 특별한 AOP 요구사항
이 생겨서 스프링의 프록시 AOP 수준을 넘어서는 기능이 펼요하다면， 그때는 AspecÙ
를 사용하면 된다. 스프링 AOP를 기본적으로 사용하면서 동시에 AspecÙ를 이용할 수
도있다.

스프링 AOP와 AspecÙ
의 적용 방법 등에 대해서는 14장에서 자세히 설명할 것이다.

6.5.6 AOP의 용어
AOP에서 많이 사용하는 몇 가지 용어를 살펴보고 넘어가자. AOP에는 새로운 용어와
개념이 많이 등장한다. 한 번에 모두 알려고 하면 머리가 이플 테니， 일단 지금까지 사
용했던 용어들만 정리해보고 넘어가자. AOP에 대한 상세한 내용은 14장에서 다시 설
명할것이다.

• 타깃
타깃은 부가기능을 부여할 대상이다. 핵심기능을 담은 클래스일 수도 있지만 경우에
따라서는 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있다.

• 어드바이스
어드바이스는 타깃에게 제공할 부가기능을 담은 모률이다. 어드바이스는 오브젝트
로 정의하기도 하지만 메소드 레벨에서 정의할 수도 있다.
어드바이스는 여러 가지 종류가 있다. Methodlnterceptor처럼 메소드 호출 과정
에 전반적으로 참여히는 것도 있지만 예외가 발생했을 때만 동작하는 어드바이스처
럼 메소드 호출 과정의 일부에서만 동작하는 어드바이스도 있다.

• 조인포인트
처음 소개핸 용어다. 조인 포인트join ∞int란 어드바이스가 적용될 수 있는 위치를 말
한다. 스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계뿐이다. 타깃 오
브젝트가 구현한 인터페이스의 모든 메소드는 조인 포인트가 된다.

·포인트컷
포인트컷이란 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정
의한 모률을 말한다. 스프링 AOP
의 조인 포인트는 메소드의 실행이므로 스프령의
포인트컷은 메소드를 선정하는 기능을 갖고 있다. 그래서 포인트컷 표현식은 메소드
의 실행이라는 의미인 execu
ti
on으로 시작하고 메소드의 시그니처를 비교히는 방


법을 주로 이용한다. 메소드는 클래스 안에 존재히는 것이기 때문에 메소드 선정이
란 결국 클래스를 선정하고 그 안의 메소드를 선정하는 과정을 거치게 된다.

·프륙시

프록시는 클라이언트와 타깃 λ에에 투명하게 존재하면서 부가기능을 제공히는 오
브젝트다.DI를 통해 타깃 대신 클라이언트에게 주입되며 클라이언트의 메소드 호
출을 대신 받아서 타깃에 위임해주면서， 그 과정에서 부가기능을 부여한다. 스프링

은 프록시를 이용해 AOP를 지원한다.

l 어드바이저

어드바이저는 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트다. 어드바이저
는 어떤 부가기능어드바이스)을 어디에
(포인트컷) 전달할 것인가를 알고 있는 AOP의 가장
기본이 되는 모률이다. 스프링은 자동 프록시 생성기가 어드바이저를 AOP 작업의
정보로 활용한다. 어드바이저는 스프링 AOP에서만 사용되는 특별한 용어이고， 일
반적인 AOP에서는 시용되지 않는다.

·애스펙트

OOP의 클래스와 마찬가지로 애스펙트는 AOP의 기본 모률이다. 한 개 또는 그 이상
의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로
존재한다. 따라서 클래스와 같은 모률 정의와 오브젝트와 같은 실제
(인스턴스)의 구분

이 특별히 없다. 두 가지 모두 애스펙트라고 불린다. 스프링의 어드바이저는 아주 단
순한 애스펙트라고 볼 수도 있다.

이 외에도 제법 다양한 AOP 용어가 존재하는데 일단은 이 정도만 기억해도 충분
하다.

6.5.7 AOP 네임스페이스
스프링 AOP를 적용하기 위해 추가했던 어드바이저， 포인트컷， 자동 프록시 생성기 같
은 빈들은 애플리케이션의 로직을 담은 UserDao나 UserService 빈괴는 성격이 다르
다. 비즈니스 로직이나 DAO처럼 애플리케이션의 일부 기능을 담고 있는 것도 아니고
dataSource 빈처럼 DI를 통해 애플리케이션 빈에서 시용되는 것도 아니다.

이런 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용
된다.

6갚 AOP 509


스프링의 프록시 방식 AOP를 적용하려면 최소한 네 가지 빈을 등록해야 한다.

• 자동프록시생성기
스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다. 다른 빈을
DI 하지도 않고 자신도 DI 되지 않으며 독립적으로 존재한다. 따라서 id도 굳이 필
요하지 않다. 애플리케이션 컨텍스트가 빈 오브젝트를 생성히는 과정에 빈 후처리기
로 참여한다. 빈으로 등록된 어드바이저를 이용해서 프록시를 자동으로 생성하는 기
능을담당한다.

• 어드바이스
부가기능을 구현한 클래스를 빈으로 등록한다. TransactionAdvice는 AOP 관련 빈
중에서 유일하게 직접 구현한 클래스를 사용한다.
·포인트컷

스프링의 AspectJExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에

포인트컷 표현식을 넣어주면 된다. 코드를 작성할 펼요는 없다.

• 어드바이저
스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용한다. 어드바이
스와 포인트컷을 프로퍼티로 참조하는 것 외에는 기능은 없다. 자동 프록시 생성기
에 의해 자동 검색되어 사용된다.

이 중에서 부가기능을 담은 코드로 만든 어드바이스를 제외한 나머지 세 가지는 모두
스프링이 직접 제공하는 클래스를 빈으로 등록하고 프로퍼티 설정만 해준 것이다. 이 세
가지 클래스를 이용해 선언하는 빈은 AOP를 적용하면 반복적으로 등장하게 된다.

AOP
네임스페이스

스프링에서는 이렇게 AOP를 위해 기계적으로 적용하는 빈들을 간편한 방법으로 등록
할 수 있다. 스프링은 AOP와 관련된 태그를 정의해둔 aop 스키마를 제공한다. aop 스
키마에 정의된 태그는 별도의 네임스페이스를 지정해서 디폴트 네임스페이스의 <bean>
태그와 구분해서 사용할 수 있다.

aop 스키마에 정의된 태그를 사용하려면 설정파일에 리스트 6-66과 같은 aop 네임
스페이스 선언을 설정따일에 추가해줘야 한다.


리스트 6경6 ∞p 네임스페이스 선언

beans 스키마는 디를트 네임스메이스
01므로

<?xml version="1 .0' encoding="UTF-8' ?) I을 접두어 없이 사용할수 있다
<beans xmlns=''http://www.springframework.org/schema/beans"

xmlns:xsi="http ://www.w3.org/2001/XMLSchema-instance''
|마는 ∞p 네임스메이스를

xmlns:ao
p=
"http://www.springframework.org/schema/aop"
--을 a。
λ --


}지므로 ∞p 접두어릎 사용한다

xsi :schemaLocation=''http://www.springframework.org/schema/beans
http ://www.springframework .org/schema/beans/spring-beans.xsd

http://빼w.springframework.org/schema/aop

http://www.springframework.org/schema/aop/spring-aop-3.Ð.xsd")

</beans)

이제 aop 네임스페이스를 이용해 기존의 AOP 관련 빈 설정을 변경해보자. 꼭 필요
한 핵심 정보만 가지고 리스트 6-67과 같이 간단히 바꿀 수 있다.

리스트 6명7 ∞p 너|임스페이스를 적용한 AOP 설정 빈

AOP 설정을 담는 부모 태그다 필요에 따라r 敏빼빼어。xyCreat，。흘 빈엎 [ expre앓뼈 표현석을 덮퍼티로
둥록해훈다 「→-가진 As∞ctJ
Ex
pressionPointcut을
<aop:config) | 빈으로등록해준다，

<aop:pointcut id="transasctionPointcut"
expression="execution( * *.. *Servicelmpl. upgrade*( .. ))“ /)
<aop:advisor advice-ref="transactionAdvice" pointcut-ref="transasctionPointcut" /)
</aop:config) I advice와 ∞
ntc띠의 ref를 므로머티로 갖는
~ DefaultBeanFactoryPointcutAdvisor훌 등록

해준다


<aop:config>. <aop:pointcut>. <aop:advisor> 세 가지 태그를 정의해두면 그에 따
라 세 개의 빈이 자동으로 등록된다. 이 세 개의 태그에 의해 등록되는 빈들은 지금까지
사용해온 것들과 동일하거나 기능이 좀 더 확장된 것들이다.

포인트컷이나 어드바이저， 자동 포인트컷 생성기 같은 특별한 기능을 가진 빈들은
별도의 스키마에 정의된 전용 태그를 사용해 정의해주면 편리하다. 애플리케이션을 구
성하는 컴포넌트 빈과 컨테이너에 의해 사용되는 기반 기능을 지원히는 빈은 구분이 되
는 것이 좋다. 직접 구현한 클래스로 등록한 빈인 transactionAdvice를 제외한 AOP
관련 빈들은 의미를 잘 드러내는 독립된 전용 태그를 시용하도록 권장된다. <bean> 태
그를 시용했을 때와 비교해보면 이해하기도 쉬울뿐더러 묘드의 양도 대폭 줄었음을 알
수있다.

6장:_ AOP 511


어드바이저 내장 포인트컷
AspectJ 포인트컷 표현식을 활용하는 포인트컷은 스트링으로 된 표현식을 담은
express lOn 프로퍼티 하나만 설정해주면 시용할 수 있다. 또， 포인트컷은 어드바이
저에 참조돼야만 시용된다. 그래서 aop 스키마의 전용 태그를 사용히는 경우에는 굳
이 포인트컷을 독립적인 태그로 두고 어드바이저 태그에서 참조히는 대신 어드바이
저 태그과 결합히는 방법도 기능하다. 리스트 6-67
의 설정은 포인트컷 표현식을 직접
<aop:advisor) 태그에 담아서 리스트
6-68과같이 만들수도 있다.

리스트 6낸B 포인트컷올 내장한 어드바이저 태그

<aop:config)
<aop:advisor advice-ref="transactionAdvice"
pointcut=녕xecution(* * .. *Servicelmp1. upgrade*(. .))" /)
</aop:config)

태그가 하나 줄었으니 포인트컷을 독립적으로 정의히는 것보다 간결해서 보기 좋다.
하지만 하나의 포인트컷을 여러 개의 어드바이저에서 공유하려고 히는 경우에는 포인
트컷을 독립적인 <aop:pointcut) 태그로 등록해야 한다.

포인트컷을 내장하는 경우에는 <aop:advisor) 태그 하나로 두 개의 빈이 등록된다.
전용 스키미를 갖는 태그는 한 번에 하나 이상의 빈을 둥록할 수 있다. <aop:advisor)
처럼 애트리뷰트 설정에 따라 등록되는 빈의 개수와 종류가 달라질 수도 있다. 또한 서
버환경이나 클래스패스에 존재히는 라이브러리에 따라서 등록되는 빈이 달라지는 경우
도있다.

[ [~;J 트랜잭션 속성 것끽 I

PlatformTransactionManager로 대표되는 스프령의 트랜잭션 추상화를 설명하면서 얼
렁뚱땅 넘어간 게 한 가지 있다. 트랜잭션 매니저에서 트랜잭션을 가져올 때 시용한
DefaultTransactionDefinition 오브젝트다.

리스트 6-69에 나와 있는 TransactionAdvice의 트랜잭션 경계설정 코드를 다시 살
펴보자.

512


리스트 융용9 트랜잭션 경계설정 코드

public Object invoke(Methodlnvocation invocation) throws Throwable (
TransactionStatus status • 트랜잭션 시직η
this.transactionManager.getTransaction(new DefaultTransactionDefinition());
try ( •
Object ret = invocation.proceed(); 트랜잭션 정의 트랜잭션 경계

this . transactionManager .commit(status); ------,

return ret;
뉴----을 트랜잭션 종료
} catch (RuntimeException e) (
this. transactionManager . rollback( status); -----'
throw e;

트랜잭션의 경계는 트랜잭션 매니저에게 트랜잭션을 가져오는 것과 commi t().
rollback() 중의 하나를 호출하는 것으로 설정되고 있다. 트랜잭션을 시작
(beginT떼saction
)
한다고 하지 않고 트랜잭션을 가져옹다(
ge
tT
ra뼈ction)
고 하는 이유는
차차 설명하기로 하고， 일단 트랜잭션을 가져올 때 파라미터로 트랜잭션 매니저에게 전
달하는 DefaultTransactionDefinition
의 용도가 무엇인지 알아보자.

6.6.1 트랜잭션 정의
트랜잭션이라고 모두 같은 방식으로 동작하는 것은 아니다. 물론 트랜잭션의 기본 개념
인 더 이상 쪼갤 수 없는 최소 단위의 작업이라는 개념은 항상 유효하다. 따라서 트랜잭
션 경계 안에서 진행된 작업은
commit()
을통해 모두 성공하든지 아니면 rollback()
을
통해 모두 취소돼야 한다. 그런데 이 밖에도 트랜잭션의 동작방식을 제어할 수 있는 몇
가지조건이 있다.
DefaultTransactionDefinition
이 구현하고 있는 TransactionDefinition 인터페이
스는 트랜잭션의 동작방식에 영향을 줄 수 있는 네 가지 속성을 정의하고 있다.

트랜잭션전파

트랜잭션 전파transaclion propagalion란 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있

을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식을 말한다.

그림 6-22
의 트랜잭션 전파와 같이 각각 독립적인 트랜잭션 경계를 가진 두 개의 코

드가 있다고 하자. 그런데 A의 트랜잭션이 시작되고 아직 끝나지 않은 시점에서 B를 호

앉!t_ AOP 513



출했다면 B
의 코드는 어떤 트랜잭션 안에서 동작해야 할까? 여러 가지 시나리오를 생
각해볼 수 있다
A에서 트랜잭션이 시작돼서 진행 중이라면 B의 코드는 새로운 트랜잭
션을 만들지 않고 A에서 이미 시작한 트랜잭션에 참여할 수 있다. 이 경우 B를 호출한
작업까지 마치고 (2)의 묘드를 진행하던 중에 예외가 발생했다고 하자. 이 경우에는 A
와 B
의 코드에서 진행했던 모든 DB 작업이 다 취소된다
A와 B가 하나의 트랜잭션으
로 묶여 있기 때문이다. 반대로 B의 트랜잭션은 이미 앞에서 시작한 A의 트랜잭션과 무
관하게 독립적인 트랜잭션으로 만들 수 있다. 이 경우 B
의 트랜잭션 경계를 빠져나오는
순간 B
의 트랜잭션은 독자적으로 커빗 또는 롤백될 것이고，
A 트랜잭션은 그에 영향을
받지 않고 진행될 것이다. 만약 이후에 A의 (2)에서 예외가 발생해서 A의 트랜잭션은

롤백되는 경우에라도 B에서 이미 종료된 트랜잭션의 결과에는 영향을 주지 않는다.

A B

-센떼

-작

-션-잭

-탬

작서…’

m

…

m

뺀

트

-

트랜잭션 종료

--ι

ιm

·

찌

1 트랜잭션 종료

| “

그림 6-22 트랜잭션 전파

이렇게 B와 같이 독자적인 트랜잭션 경계를 가진 코드에 대해 이미 진행 중인 트랜잭션

이 어떻게 영향을 미칠 수 있는가를 정의히는 것이 트랜잭션 전파 속성이다.
대표적으로 다음과 같은 트랜잭션 전파 속성을 줄 수 있다.

• PROPAGATION REQUIRED
가장 많이 사용되는 트랜잭션 전파 속성이다. 진행 중인 트랜잭션이 없으면 새로 시
작하고， 이미 시작된 트랜잭션이 있으면 이에 참여한다. PROPAGATION_REQUIRED 트
랜잭션 전파 속성을 갖는 코드는 다양한 방식으로 결합해서 하나의 트랜잭션으로
구성하기 쉽다.A와 B가 모두 PROPAGATION_REQUIRED로 선언되어 었다면，
A， B,
A→B，
B→A와 같은 네 가지의 조합된 트랜잭션이 모두 기능하다.

DefaultTransactionDefinition의 트랜잭션 전파 속성은 바로 이 PROPAGATION_
REQUIRED다.


• PROPAGATION_REQUIRES_NEW
항상 새로운 트랜잭션을 시작한다. 즉 앞에서 시작된 트랜잭션이 있든 없든 상관없
이 새로운트랜잭션을만들어서 독자적으로동작하게 한다. 독립적인 트랜잭션이 보
장돼야 하는 묘드에 적용할 수 있다.

• PROPAGATION_NOT_SUPPORTED
이 속성을 사용하면 트랜잭션 없이 동작하도록 만들 수도 있다. 진행 중인 트랜잭션
이 있어도 무시한다. 트랜잭션 없이 동작하게 할 거라면 뭐하러 트랜잭션 경계를 설
정해두는 것일까? 그냥 트랜잭션 경계설정을 하지 않으면 되는 게 아닐까?

트랜잭션을 무시하는 속성을 두는 데는 이유가 있다. 트랜잭션 경계설정은 보통
AOP를 이용해 한 번에 많은 메소드에 동시에 적용하는 방법을 사용한다. 그런데 그
중에서 특별한 메소드만 트랜잭션 적용에서 제외하려면 어떻게 해야 할까? 물론 포
인트컷을 잘 만들어서 특정 메소드가 AOP 적용 대상이 되지 않게 하는 방법도 있
겠지만 포인트컷이 상당히 복잡해질 수 있다. 그래서 차라리 모든 메소드에 트랜잭
션 AOP가 적용되게 하고 특정 메소드의 트랜잭션 전파 속성만 PROPAGATION_NOT_
SUPPORTED로설정해서 트랜잭션 없이 동작하게 만드는편이 낫다.

이 외에도 다OJ=한 트랜잭션 전파 속성을 사용할 수 있다. 트랜잭션 매니저를 통해 트
랜잭션을 시작하려고 할 때 getTransaction()
이라는 메소드를 사용히는 이유는 바로
이 트랜잭션 전파 속성이 있기 때문이다. 트랜잭션 매니저의 getTransaction( ) 메소드
는 항상 트랜잭션을 새로 시작하는 것이 아니다. 트랜잭션 전파 속성과 현재 진행 중인
트랜잭션이 존재하는지 여부에 따라서 새로운 트랜잭션을 시작할 수도 있고， 이미 진행
중인 트랜잭션에 참여하기만 할 수도 있다. 진행 중인 트랜잭션에 참여하는 경우는 트
랜잭션 경계의 끝에서 트랜잭션을 커멋시커지도 않는다. 최초로 트랜잭션을 시작한 경
계까지 정상적으로 진행돼야 비로소 커빗될 수 있다.

격리수준
모든 DB 트랜잭션은 격리수준isolation level을 갖고 있어야 한다. 서버환경에서는 여러 개
의 트랜잭션이 동시에 진행될 수 있다. 가능하다면 모든 트랜잭션이 순차적으로 진행돼

서 다른 트랜잭션의 작업에 독립적인 것이 좋겠지만 그러자면 성능이 크게 떨어질 수
밖에 없다. 따라서 적절하게 격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에
진행시키면서도 문제가 발생하지 않게 하는 제어가 펼요하다. 격리수준은 기본적으로
DB
에 설정되어 있지만 JDBC 드라이버나 DataSource 등에서 재설정할 수 있고， 필요

6장
AOP 515


하다면 트랜잭션 단위로 격리수준을 조정할 수 있다. DefaultTransactionDefinition
에 설정된 격리수준은 ISOLATION_DEFAULT다. 이는 DataSource에 설정되어 있는 디폴트
격리수준을 그대로 따른다는 뭇이다. 기본적으로는 DB나 DataSource에 설정된 디폴트
격리수준을 따르는 편이 좋지만， 특별한 작업을 수행하는 메소드의 경우는 독자적인 격
리수준을 지정할 필요가 있다.

제한시간
트랜잭션을 수행하는 제한시간
t i m e 0 u t을 설정할 수 있다.
DefaultTransactionDefinition
의 기본 설정은 제한시간이 없는 것이다. 제한시간은
트랜잭션을 직접 시작할 수 있는 PROPAGATION_REQUIRED나 PROPAGATION_REQUIRES_NEW
와함께사용해야만의미가있다.

읽기전용
읽기전용Jead only으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄
수 있다. 또한 데이터 액세스 기술에 따라서 성능이 향상될 수도 있다.

TransactionDefinition 타입 오브젝트를 사용하면 네 가지 속성을 이용해 트랜잭션
의동작방식을제어할수있다.

트랜잭션 정의를 수정하려면 어떻게 해야 할까? TransactionDefinition
오브젝트를 생성하고 사용하는 코드는 트랜잭션 경계설정 기능을 가진
TransactionAdvice
다. 트랜잭션 정의를 바꾸고 싶다면 디폴트 속성을 갖
고 있는 DefaultTransactionDefinition
을 사용하는 대신 외부에서 정의
된 TransactionDefinition 오브젝트를 01 받아서 사용하도록 만들면 된다.
TransactionDefinition 타입의 빈을 정의해두변 프로퍼티를 통해 원하는 속성을 지정
해줄 수 있다. 하지만 이 방법으로 트랜잭션 속성을 변경하면 TransactionAdvice를 사
용하는 모든 트랜잭션의 속성이 한꺼번에 바뀐다는 문제가 있다. 원히는 메소드만 선
택해서 독자적인 트랜잭션 정의를 적용할수 있는방법은 없을까?

6.6.2 트랜잭션 인터셉터와 트랜잭션 속성
메소드별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야 한다. 마
치 초기에 TransactionHandler에서 메소드 이름을 이용해 트랜잭션 적용 여부를 판단
했던 것과 비슷한 방식을 사용하면 된다. 메소드 이름 패턴에 따라 다른 트랜잭션 정의
가 적용되도록 만드는 것이다.


Transactionlnterceptor

이를 위해 기존에 만들었던 TransactionAdvice를 다시 설계할 필요는 없다. 이미 스
프링에는 펀리하게 트랜잭션 경계설정 어드바이스로 사용할 수 있도록 만들어진
Transactionlnterceptor가 존재하기 때문이다. TransactionAdvice는 어드바이스
의 동작원리를 알아보려고 만들었던 것이므로 그만 사용하고， 이제부터는 스프링의
Transactionlnterceptor를 이용해보자.

Transactionlnterceptor 어드바이
스
의 동작방식은 기존에 만들
었던
TransactionAdvice와 다르지 않다. 다만 트랜잭션 정의를 메소드 이름 패턴을 이용해
서 다르게 지정할 수 있는 방법을 추가로 제공해줄 뿐이다. Transactionlnterceptor는
PlatformTransactionManager와 Properties 타입의 두 가지 프로퍼티를 갖고 있다. 트
랜잭션 매니저 프로퍼티는잘알고 있지만
Properties 타입의 프로퍼티는 처음보는 것
이다.

Properties 타입인 두 번째 프로퍼티 이름은 transactionAttributes로， 트랜잭션
속성을 정의한 프로퍼티다. 트랜잭션 속성은 TransactionDefinition
의 네 가지 기본
항목에 rollbackOn( )이라는 메소드를 하나 더 갖고 있는 TransactionAttribute 인터
페이스로 정의된다. rollbackOn() 메소드는 어떤 예외가 발생하면 롤백을 할 것인가를
결정하는 메소드다. 이 TransactionAttribute를 이용하면 트랜잭션 부가기능의 동작
방식을모두 제어할수 있다.

리스트 6-70의 TransactionAdvice 트랜잭션 경계설정 코드를 다시 살펴보변 트랜
잭션 부가기능의 동작방식을 변경할 수 있는 곳이 두 군데 있다는 사실을 알 수 있다.

리스트 &-70 트랜잭션 경계설정 묘드의 동작방식 변경 포인트


public Object invoke(Methodlnvocation invocation) throws Throwable {
TransactionStatus status =
this .transactionManager.getTransaction(new DefaultTransactionDefinition());
try { •
Object ret = invocation .proceed();

트랜잭션 정의를 통한 네 가지 조건

this.transactionManager .commit(status);
return ret;
} catch (RuntimeException e) {--을 롤백 대
S엔 예외 종류 이 두 가지
*
항목이 결합해서

‘

i 트랜잭션 부가기능의 행동을
this.transactionManager .rollback(status); 결정하는 T떠%없α1Attr α.rte
속성이된다.

throw e;

6갚 AOP 517


TransactionAdvice는 RuntimeException
이 발생하는 경우에만 트랜잭션을 롤백시
킨다. 하지만 런타임 예외가 아닌 경우에는 트랜잭션이 제대로 처리되지 않고 메소드
를 빠져나가게 되어 있다. UserService는 런타임 예외만 던진다는 사실을 알기 때문에
일단 이렇게 정의해도 상관없지만， 체크 예외를 던지는 타깃에 사용한다면 문제가 될
수 있다. 그렇다면 런타임 예외만이 아니라 모든 종류의 예외에 대해 트랜잭션을 롤백
시키도록 해야 할까? 그래서는 안 된다. 비즈니스 로직상의 예외 경우를 나타내기 위
해 타깃 오브젝트가 체크 예외를 던지는 경우에는 DB 트랜잭션은 커맛시켜야 하기 때
문이다
2장에서 설명했듯이 일부 체크 예외는 정상적인 작업 흐름 안에서 시용될 수도
있다.

스프링이 제공히는 Transactionlnterceptor에는 기본적으로 두 가지 종류의 예외
처리 방식이 있다. 런타임 예외가 발생하면 트랜잭션은 롤백된다. 반면에 타깃 메소드
가 런타임 예외가 아닌 체크 예외를 던지는 경우에는 이것을 예외상황으로 해석하지 않
고 일종의 비즈니스 로직에 따른， 의미가 있는 리턴 방식의 한 가지로 인식해서 트랜잭
션을 커빗해버린다. 스프링의 기본적인 예외처리 원칙에 따라 비즈니스적인 의미가 있
는 예외상햄만 체크 예외를 사용하고， 그 외의 모든 복구 불가능한 순수한 예외의 경
우는 런타임 예외로 포장돼서 전달하는 방식을 따른다고 가정하기 때문이다.

그런데 Transactionlnterceptor
의 이러한 예외처리 기본 원칙을 따르지 않는 경
우가 있을 수 있다. 그래서 TransactionAttribute는 rollbackOn( )이라는 속성을 둬
서 기본 원칙과 다른 예외처리가 가능하게 해준다. 이를 활용하면 특정 체크 예외의 경
우는 트랜잭션을 롤백시키고， 특정 런타임 예외에 대해서는 트랜잭션을 커빗시킬 수도
있다.

Transactionlnterceptor는 이런 TransactionAttribute를 Properties
라는 일종의
맹 타입 오브젝트로 전달받는다. 컬렉션을 사용히는 이유는 메소드 패턴에 따라서 각기
다른 트랜잭션 속성을 부여할 수 있게 하기 위해서다.

메소드 이름 패턴을 이용한 트랜잭션 속성 지정
Properties 타입의 transactionAttributes 프로퍼티는 메소드 패턴과 트랜잭션 속성을
커와 값으로 갖는 컬렉션이다. 트랜잭션 속성은 다음과 같은 문자열로 정의할 수 있다.

트랜잭션 전파 방식 필수항목이다 읽기전용 항목 생략 가능하다 처|크 예외 중에서 롤백 대상으로 추가할 것을
PROPAGATION 으로 시작한다 디올트는 읽기전용이 아니다 넣는다 한 개 이상올 등록할 수 있다.
• • •

PROPAGATION_NAME , ISOLATION_NAME , readOnly , timeout_NNNN , -Exceptionl , +Exception2

• • •

격리수준 ISOLATIαι으로 시작한다 제한시간 timeαA 으로 시ξt하고 련타임 예외지만 톨백시키
생략 가능하다 샘략되연 디를트 격리 초 딘위 시간을 뒤에 붙인다 생 지 않을 예외들을 넣는다
수준으로 지정된다 략 가능하다 한 개 이상 등록할 수 있다


이 중에서 트랜잭션 전파 항목만 필수이고 나머지는 다 생략 가능하다. 생략하면 모
두 DefaultTransactionDefinition
에 설정된 디폴트 속성이 부여된다. 모든 항목이 구
분 가능하기 때문에 순서는 바꿔도 상관없다. 이 중에서 + 또는 -로 시작하는 건 기본
원칙을 따르지 않는 예외를 정의해주는 것이다. 모든 런타임 예외는 롤백돼야 하지만
+XXXRuntimeException
이라고 해주변 런타임 예외라도 커빗하게 만들 수 있다. 반대로
체크 예외는 모두 커빗하는 것이 기본 처리 방식이지만 -를 붙여서 넣어주면 트랜잭션
은롤백대상이된다.

이렇게 속성을 하나의 문자열로 표현하게 만든 이유는 트랜잭션 속성을 메소드 패턴
에 따라 여러 개를 지정해줘야 하는데 일일이 중첩된 태그와 프로퍼티로 설정하게 만
들면 번거롭기 때문이다. 또， 대부분은 디폴트를 샤용해도 충분하므로 생략 가능하다는
점도한가지이유다.

리스트 6-71
은 메소드 이름 패턴과 문자열로 된 트랜잭션 속성을 이용해서 정의한
Transactionlnterceptor 타입 빈의 예다.

리스트 6--'꺼 트랜잭션 속성 정의 예

<bean id="transactionAdvice"
class="org.springframework.transaction.interceptor.Transactionlnterceptor"
〈
때야
name="transactionManager" ref="transactionManager" /)

φprop
erπty

<property name="transactionAttributes")

<props)
<prop key="get*")PROPAGATION_REQUIRED , readOnly , timeouC30</prop)
<prop key=“ upgrade*")PROPAGATION_REQUIRES_NEW , ISOLATION_SERIALIZABL E
</prop)
<prop key=사“
)PROPAGATION_REQUIRED</prop)

</props)
</property)
</bean)


세 가지 메소드 이름 패턴에 대한 트랜잭션 속성이 정의되어 있다.

첫 번째는 이름이 get으로 시작하는 모든 메소드에 대한 속성이다. PROPAGATION
REQUIRED이면서 읽기전용이고 시간제한은 30초다. 보통 읽기전용 메소드는 get 또는
find 같은 일정한 이름으로 시작한다. 명명 규칙을 잘 정해두면 조회용 메소드의 트랜
잭션은 읽기전용으로 설정해서 성능을 향상시킬 수 있다.

그런데 읽기전용이 아닌 트랜잭션 속성을 가진 메소드에서 읽기전용 속성을 가진，
get으로 시작하는 메소드를 호출하면 어떨깨 get 메소드는 PROPAGATION_REQUIRED

6장!_ AOP 519


이기 때문에 다른 트랜잭션이 시작되어 있으면 그 트랜잭션에 참여한다. 그렇다면 이
미 DB
에 쓰기 작업이 진행된 채로 읽기전용 트랜잭션 속성을 가진 작업이 뒤따르게 돼
서 충돌이 일어나진 않을까? 그렇지는 않다. 다행히도 트랜잭션 속성 중 readOnly나
timeout 등은 트랜잭션이 처음 시작될 때가 아니라면 적용되지 않는다. 따라서 get으로
시작하는 메소드에서 트랜잭션을 시작하는 경우라면 읽기전용에 제한시간이 적용되지
만 그 외의 경우에는 진행 중인 트랜잭션의 속성을 따르게 되어 있다.

두 번째는 upgrade로 시작하는 메소드는 항상 독립적인 트랜잭션으로 동작하도록 트
랜잭션 전파 항목을 PROPAGATION_REQUIRES_NEW로 설정했다. 또， 다른 동시 작업에 영
향을 받지 않도록 완벽하게 고립된 상태에서 트랜잭션이 동작하도록 격리수준을 최고
수준인 ISOLATION_SERIALIZABLE로 설정했다.

세 번째는 *만 사용해서 위의 두 가지 조건에 해당하지 않는 나머지 모든 메소드에
시용될 속성을 지정했다. 필수 항목인 PROPAGATION_REQUIRED만 지정하고 나머지는 디
폴트 설정을 따르게 했다.

때로는 메소드 이름이 하나 이상의 패턴과 일치히는 경우가 있다. 이때는 메소드 이
름 패턴 중에서 가장 정확히 일치하는 것이 적용된다. 이렇게 메소드 이름 패턴을 사용
하는 트랜잭션 속성을 활용하면 하나의 트랜잭션 어드바이스를 정의하는 것만으로도
다OJ=한 트랜잭션 설정이 가능해진다.

k 네임스페이스를 이용한 설정 방법
Transactionlnterceptor 타입의 어드바이스 빈과 TransactionAttribute 타입의 속성
정보도 tx 스키마의 전용 태그를 이용해 정의할 수 있다. 트랜잭션 어드바이스도 포인
트컷이나 어드바이저만큼 지주 사용되고， 애플리케이션의 컴포넌트가 아닌 컨테이너가
사용하는 기반기술 설정의 한 가지이기 때문이다.
Transactionlnterceptor 빈으로 정의한 트랜잭션 어드바이스와 메소드 패턴에 따
른 트랜잭션 속성 지정은 tx 스키마의 태그를 이용해 리스트 6-72와 같이 간단하게 정
의할수있다.

리스트 6-72 tx 스키마의 전용 태그

<?xml version="1.0" encoding="UTF-8"?>

<beans xmlns=''http://www.springframework.org/schema/beans''
xmlns:xsi=''http ://www .w3.org/2001/XMLSchema-instance “
xmlns:aop=''http://www.springframework .org/schema/aop“
xmlns:tx=
‘
http://www.springframework.org/schema/tx.~ α 네임스떼이스 선언


xsi:schemaLocation=''http ://www .springframework.org/schema/beans

http://www.springframework
.
org/sch댄녕/beans/spring낸Jeans-3
.
0
.
xsd

http://www .springframework .org/schema/aop
http://www .springframework.org/schema/aop/spring-aop-3 .0.xsd
http://www.springframework.org/schema/tx

k
스키마
위치
지정 l
http://www.springframework.org/schema/tx/spring-tx-2.5.xs찌d"

트랜잭션 매니저의 빈 이이디가

「률 이 태그에 의해 T떠nsaclionlnterceptα 빈이 둥록된다 |I ~ IransaclionManager라연 생락 가능
<tx:advice id="transactionAdvice" transaction-manager=“ transactionManager")
<tx :attributes)
<tx :method name="get*" propagation="REQUIRED“ read-only="true" timeout="30" /)
<tx:method name="upgrade*“ propagation="REQUIRES_NEW"
isolation="SERIALIZABLE" /)
<tx:method name="*" propagation="REQUIRED" /) 타ume떼io~로 l키디에 값이 정의되어 있
</tx :attributes) L • 모로 오타가 있으연 XML 유효성 검사만으로

,

디올트 값이 스키마에 정의되어 있으
므로 확인 가능하다

</tx :advice) R없JIRED라연 O
뼈l 생략도 가능하
다

트랜잭션 속성이 개별 애트리뷰트를 통해 지정될 수 있으므로 설정 내용을 읽기가
좀 더 쉽고，
XML 에디터의 자동완성 기능을 통해 편하게 작성할 수 있다. 문자열로 입
력할때 지주발생하는오타문제도
XML 스키마에 미리 등록해둔값을통해 검증할수
있어서 편리하다. (bean> 태그로 등록히는 경우에 비해 장점이 많으므로 tx 스카마의
태그를 사용해 어드바이스를 등록하도록 권장한다.

6.6.3 포인트컷과 트랜잭션 속성의 적용 전략
트랜잭션 부가기능을 적용할 후보 메소드를 선정하는 작업은 포인트컷에 의해 진행된
다. 그리고 어드바이스의 트랜잭션 전파 속성에 따라서 메소드별로 트랜잭션의 적용
방식이 결정된다. aop와 tx 스키마의 전용 태그를 사용한다면 애플리케이션의 어드바
이저， 어드바이스， 포인트컷 기본 설정 방법은 바뀌지 않을 것이다. expression 애트리
뷰트에 넣는 포인트컷 표현식과 (tx:attributes>로 정의하는 트랜잭션 속성만 결정하
면된다.
포인트컷 표현식과 트랜잭션 속성을 정의할 때 따르면 좋은 몇 가지 전략을 생각해
보자.


~_ AOP 521


트랜잭션 포인트컷 표현식은 타입 패턴이나 번 이름을 이용한다
일반적으로 트랜잭션을 적용할 타깃 클래스의 메소드는 모두 트랜잭션 적용 후보
가 되는 것이 바람직하다. 지금까지는 포인트컷의 메소드 선정 기능을 살펴보기 위해
UserService의 upgradeLevels() 메소드 하나에만 트랜잭션이 적용되게 해왔다. 하지
만 이렇게 비즈니스 로직을 담고 있는 클래스라면 메소드 단위까지 세밀하게 포인트컷
을 정의해줄 펼요는 없다.
UserService의 add( ) 메소드도 트랜잭션 적용 대ÀJ-이어야 한다. 사용자 등록에 무슨
트랜잭션이 펼요할까 싶겠지만， 트랜잭션 전파 방식을 생각해보면 add()
는 다른 트랜
잭션에 참여할 가능성이 높다. add() 메소드 자체만 생각해보더라도 UserDao.add()를
호출해서 사용자 정보를 DB에 추가하는 것 외에도 DB의 정보를 다루는 작업이 추가될
가능성이 높다. 따라서 add() 메소드는 트래잭션 안에서 동작하도록 정의하는 게 바람
직하다.
쓰기 작업이 없는 단순한 조회 작업만 히는 메소드에도 모두 트랜잭션을 적용하는
게 좋다. 조회의 경우에는 읽기전용으로 트랜잭션 속성을 설정해두면 그만큼 성능의 향
상을 가져올 수 있다. 또， 복잡한 조회의 경우는 제한시간을 지정해줄 수도 있고， 격리
수준에 따라 조회도 반드시 트랜잭션 안에서 진행해야 할 필요가 발생하기도 한다.
따라서 트랜잭션용 포인트컷 표현식에는 메소드나 따라미터， 예외에 대한 패턴을 정
의하지 않는 게 바람직하다. 트랜잭션의 경계로 삼을 클래스들이 선정됐다면， 그 클래
스들이 모여 있는 패커지를 통째로 선택하거나 클래스 이름에서 일정한 패턴을 찾아서
표현식으로 만들면 된다. 관례적으로 비즈니스 로직 서비스를 담당히는 클래스 이름은
Service 또는 ServiceImpl
이라고 끝나는 경우가 많은데 그런 경우라면 execution(*

*.. *ServiceImpl .*( .. ))과 같이 포인트컷을 정의하면 된다. 기능하면 클래스보다는
인터페이스 타입을 기준으로 타입 패턴을 적용하는 것이 좋다. 인터페이스는 클래스에
비해 변경 빈도가 적고 일정한 패턴을 유지하기 쉽기 때문이다.
메소드의 시그니처를 이용한 execution( ) 방식의 포인트컷 표현식 대신 스프링의
빈 이름을 이용하는 bean() 표현식을 시용하는 방법도 고려해볼 만하다. bean() 표현식
은 빈 이름을 기준으로 선정하기 때문에 클래스나 인터페이스 이름에 일정한 규칙을 만
들기가 어려운 경우에 유용하다. 포인트컷 표현식 자체가 간단해서 읽기 편하다는 장점
도 있다. 빈의 아이디가 Service로 끝나는 모든 빈에 대해 트랜잭션을 적용하고 싶다면
포인트컷 표현식을 bean(*Service) 라고 하면 된다. 이름이 비슷한 다른 빈이 있는 경우
주의해야한다.


그 외에 애노태이션을 이용한 포인트컷 표현식을 만드는 방법이 있는데， 이는 다음
절에서 설명하겠다.

공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을

정의한다
실제로 하나의 애플리케이션에서 사용할 트랜잭션 속성의 종류는 그다지 다양하지 않
다. 너무 다양하게 트랜잭션 속성을 부여하면 관리만 힘들어질 뿐이다. 따라서 기준이
되는 몇 가지 트랜잭션 속성을 정의하고 그에 따라 적절한 메소드 명명 규칙을 만들어
두변 하나의 어드바이스만으로 애플리케이션의 모든 서비스 빈에 트랜잭션 속성을 지
정할수있다.

그런데 기끔 트랜잭션 속성의 적용 패턴이 일반적인 경우와 크게 다른 오브젝트가
존재하기도 한다. 이런 예외적인 경우는 트랜잭션 어드바이스와 포인트컷을 새롭게 추
가해줄필요가있다.

가장 간단한 트랜잭션 속성 부여 방법은 다음과 같이 모든 메소드에 대해 디폴트 속
성을 지정하는 것이다. 일단 트랜잭션 속성의 종류와 메시지 패턴이 결정되지 않았으면
리스트 6-73과 같이 가장 단순한 디폴트 속성으로부터 출벌하면 된다. 개발이 진행됨
에 따라 단계적으로 속성을 추가해주면 된다.

리스트 &-73 디폴트 트랜잭션 속성 부여

<tx:advice id="transactionAdvice")
<tx:attributes)
<tx:method name=나
， 1)-모든 타깃 메소드에 기본 트랜잭션 속성 지정
</tx:attributes)
</tx:attributes)


디폴트 속성을 일괄적으로 부여한 것에서 한 단계 더 나아간다면， 리스트 6-74와
같이 간단한 메소드 이름의 패턴을 적용해볼 수 있다. 조회용 메소드에 대해 읽기전
용 속성을 준 것이다. get 또는 find와 같이 조회전용 메소드의 접두어를 정해두는 것
이 좋다. 두 가지를 동시에 사용할 수도 있다. 읽기전용 속성을 주고 나면 get으로 시작
하는 메소드에 얼마나 많은 데이터 조작 기능을 넣었는지 쉽게 확인할 수 있다. 트랜잭
션의 읽기전용 속성이 부여됐는데 데이터 조작이 일어나면 예외가 발생하기 때문이다.
이런 경우에는 의미를 좀 더 잘 드러내는 이름으로 변경하도록 유도할 필요가 있다.

6징:... AOP 523


리스트 &-74 읽기전용 속성 추가

<tx:advice id="transactionAdvice'>

<tx :attributes> get으로 시ξf하는 메소드에 대해서는 읽기전
용 속성율 부여한다 이 메소드가 트랜잭션의

<tx :method name=’ get*" read-only=‘ true" 1>-실제 시작 위치가 아니라연 읽기전용 속성은
<t x: method name=샤" /> ---, 무시된다

</tx:attributes> get.9.로 시작하지 않는 나머지 메소드에는 기몬 트랜잭션
</tx:attributes> 속성올 지정한다 순서가 뒤비뀌지 않도록 주의효다

트랜잭션 적용 대상 클래스의 메소드는 일정한 명명 규칙을 따르게 해야 한다.

일반화하기에는 적당하지 않은 특별한 트랜잭션 속성이 필요한 타깃 오브젝트에 대
해서는 별도의 어드바이스와 포인트컷 표현식을 사용하는 편이 좋다.

리스트 6-75는 두 개의 포인트컷과 어드바이스를 적용한 예다. 비즈니
스 로직을 정
의한 서비스 빈에는 기본적인 메소드 이름 때턴을 따르는 트랜잭션 속성을 지정해둔다.
반면에 트랜잭션의 성격이 많이 다른 배치 작업용 클래스를 위해서는 트랜잭션 어드바
이스를 별도로 정의해서 독자적인 트랜잭션 속성을 지정해준다.

리스트 &-75 두 가지 트랜잭션 속성 때턴올 사용한 예

<aop :config>
<aop :advisor(advice-ref="transactionAdvice" pointcut="bean( *Service)" />
<aop:advisorf advice-ref="batchTxAdvice" pointcut='execution(a .b. *BatchJob. *. ( .. ))" 1>

\ I

비즈니스 로직 서비스 클래</aop:config> \ ‘:쓰에 적용되는 기본 트랜잭
션속성

‘

m l mnUn” p ”/ 배치 작업 클래스에 적용되는
‘

m

=

V

<

아

빼

싸띠

빼때

L

특별한트랜잭션속성

k

j

LL

U.
143

+t

Y

뼈

.·

따

잉/

따

때

빼

qm

따

<

+L

〈
ν


e

이

<t x:advice id="batchTxAdVìce">

<t x:attributes> ... </tx:attributes>
</t x:attributes>

프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용

되지않는다
이건 전략이라기보다는 주의사항이다. 프록시 방식의 AOP에서는 프록시를 통한 부가
기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하다. 여기서 클라이언트는
인터페이스를 통해 타깃 오브젝트를 사용하는 다른 모든 오브젝트를 말한다. 반대로 타


깃 오브젝트가 자기 자신의 메소드를 호출할 때는 프록시를 통한 부가기능의 적용이 일
어나지 않는다. 프록시가 적용되는 방식을 생각해보면 왜 그런지 알 수 있을 것이다.
그림 6-23은 트랜잭션 프록시가 타깃에 적용되어 있는 경우의 메소드 호출 과정을
보여준다. de!ete()
와 update( )는 모두 트랜잭션 적용 대상인 메소드다. 따라서 [1 ]과

[3]
처럼 클라이언트로부터 메소드가 호출되면 트랜잭션 프록시를 통해 타깃 메소드로
호출이 전달되므로 트랜잭션 경계설정 부가기능이 부여될 것이다.
트랜잭션 프록시
-------바 updateO ----
[3]
타깃
클라이언트 deleteO ---. ‘J: ~ [2]
updateO .


그림 6-23 타깃 안에서의 호훌에는 적용되지 않는 프록시

하지만 띠]의 경우는 다르다. 일단 타깃 오브젝트 내로 들어와서 타깃 오브젝트의 다른
메소드를호출하는경우에는프록시를 거치지 않고 직접 타깃의 메소드가호출된다. 따
라서 [1] 클라이언트를 통해 호출된 de!ete( ) 메소드에는 트랜잭션 속성이 적용되지만，

[2]를 통해 update( ) 메소드가 호출될 때는 update() 메소드에 지정된 트랜잭션 속성이
전혀 반영되지 않는다.
만약 update( ) 메소드에 대해 트랜잭션 전파 속성을 REQUIRES_NEW라고 해놨더라
도 같은 타깃 오브젝트에 있는 de!ete( ) 메소드를 통해 update()
가 호출되면 트랜잭
션 전파 속성이 적용되지 않으므로 REQUIRES_NEW는 무시되고 프록시의 de!ete() 메소
드에서 시작한 트랜잭션에 단순하게 참여하게 될 뿐이다. 또는 트랜잭션이 아예 적용되
지 않는 타깃의 다른 메소드에서 update()
가 호출된다면 그때는 트랜잭션이 없는 채로
update() 메소드가 실행될 것이다.

이렇게 같은 타깃 오브젝트 안에서 메소드 호출이 일어나는 경우에는 프록시 AOP
를 통해 부여해준 부가기능이 적용되지 않는다는 점을 주의해야 한다. 따라서 같은 오
브젝트 안에서의 호출은 새로운 트랜잭션 속성을 부여하지 못한다는 사실을 의식하고
개발할 펼요가 있다. 기껏해야 get으로 시작하는 메소드에 읽기전용 속성을 부여하고
REQUIRED 전파 속성을 사용히는 일반적인 경우에는 문제 될 게 없다. 하지만 복잡한 트
랜잭션 전파 속성을 적용히는 경우라면 기대와 다르게 트랜잭션 속성이 무시될 가능성
이 있으니 주의해야한다.

타깃 안에서의 호출에는 프록시가 적용되지 않는 문제를 해결할 수 있는 방법은 두
가지가있다.

6징L AOP 525



하나는 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같

은 오브젝트의 메소드 호출도 프록시를 이용하도록 강제하는 방법이다. 하지만 복잡한

과정을 거쳐서 순수한 비즈니스 로직만을 남겨두려고 노력했는데， 거기에 스프링 API

와 프록시 호출 코드가 등장하는 건 그다지 바람직하지 않다. 따라서 별로 추천되지 않

는다.

다른 방법은 AspectJ와 같은 타깃의 바이트코드를 직접 조작하는 방식의 AOP 기술

을 적용하는 것이다. 스프링은 프록시 기반의 AOP를 기본적으로 사용하고 있지만 필

요하면 언제든지 AspectJ 방식으로 변경할 수 있다. 지금까지 검토했던 대부분의 설정

은 그대로 둔 채로 간단한 옵션을 바꿈으로써 AspectJ 방식으로 트랜잭션 AOP가 적용

되게 할 수 있다. 하지만 그만큼 다른 불편도 뒤따르기 때문에 콕 펼요한 경우에만 사용

해야 한다. Aspec
tJ를 통한 AOP 방법은 14징써l
서 자세히 설명하겠다.

6.6.4 트랜잭션 속성 적용
트랜잭션 속성과 그에 따른 트랜잭션 전략을 UserService에 적용해보자. 지금까지 살
펴봤던 몇 가지 원칙과 전략에 따라 작업을 진행할 것이다.

트랜잭션 경계설정의 일원화
트랜잭션 경계설정의 부가기능을 여러 계층에서 중구난방으로 적용히는 건 좋지 않다.
일반적으로 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직하다. 비즈니
스 로직을 담고 있는 서비스 계층 오브젝트의 메소드가 트랜잭션 경계를 부여하기에 가
장적절한대상이다.
서비스 계층을 트랜잭션이 시작되고 종료되는 경계로 정했다면， 태스트와 같은 특별
한 이유가 아니고는 다른 계층이나 모률에서 DAO에 직접 접근하는 것은 차단해야 한
다. 트랜잭션은 보통 서비스 계층의 메소드 조합을 통해 만들어지기 때문에 DAO가 제
공하는 주요 기능은 서비스 계층에 위임 메소드를 만들어둘 필요가 있다. 가능하면 다
른 모률의 DAO에 접근할 때는 서비스 계층을 거치도록 하는 게 바람직하다. 그래야
만 UserService의 add()
처럼 부가 로직을 적용할 수도 있고 트랜잭션 속성도 제어할
수 있기 때문이다. 예를 들어 UserService가 아니라면 UserDao에 직접 접근하지 않고
UserService의 메소드를 이용히는 편이 좋다. 물론 순수한 조회나 간단한 수정이라면
UserService 외의 서비스 계층 오브젝트에서 UserDao를 직접 사용해도 상관없다. 하지
만등록이나수정， 삭제가포함된 작업이라면 다른모률의 DAO를직접 이용할때 신중


을 기해야 한다. 안전하게 사용하려면 다른 모률의 서비스 계층을 통해 접근히는 방법
이좋다.

아키텍처를 단순하게 가져가면 서비스 계층과 DAO가 통합될 수도 있다. 비즈니스
로직이 거의 없고 단순 DB 입출력과 검색 수준의 조회가 전부라면 서비스 계층을 없애
고 DAO를 트랜잭션 경계로 만드는 것이다. 하지만 비즈니스 로직을 독자적으로 두고
태스트하려면 서비스 계층을 만들어 사용해야 한다.

UserDao 인터페이스에 정의된 6개의 메소드 중에서 이미 서비스 계층에 부가적인 로
직을 담아서 추가한 add( )를 제외한 나머지 5개가 UserService에 새로 추가할 후보 메
소드다. 이 중에서 단순히 레코드 개수를 리턴하는 getCount()를 제외하면 나머지는
독자적인 트랜잭션을 가지고 사용될 가능성이 높다. 따라서 이 4개의 메소드를 리스트
6-76과 같이 UserService에 추가한다.

리스트 6-76U똥rServ
ice어| 추가된 메소드

publ ic interface UserService (
Void add (User user) ;
User get(String id) ;
List<U ser) getAll();
void deleteAll() ;
void update(User user);


void upgradeLevel s() ;

DAO 메소드와 1:1 대응되는 CRUD 메소드이지만 잉d()
처렁 단순 위임 이상의 로직을 가질 수 있다

신규추가메소드


다음은 리스트 6-77처럼 UserServicelmpl 클래스에 추가된 메소드 구현 코드를 넣
어준다.
리스트 6-77 추가 메소드 구현

public class UserServicelmpl implements UserService (
UserDao userDao;

public void deleteAll() ( userDao.deleteAll();}
public User get(String id) ( return userDao .get(id) ; }

DAO로 위임하도록 만든다 일요한

public List<User) getAll() ( return userDao .getAll() ; }

부가로직을넣어도출다

public void update(User user) ( userDao.update(user); }

g앙1_ AOP 527


이제 모든 User 관련 데이터 조작은 UserService라는 트랜잭션 경계를 통해 진행할
경우 모두 트랜잭션을 적용할 수 있게 됐다.

서비스 번에 적용되는 포인트컷 표현식 등록
upgradeLevels()
에만 트랜잭션이 적용되게 했던 기존 포인트컷 표현식을 모든 비즈니
스 로직의 서비스 빈에 적용되도록 수정한다. 표현식은 가장 단순한 빈 이름 패턴을 이
용해도 좋을 것 같다. aop 스키마의 태그를 이용해 포인트컷， 어드바이저 등의 설정을
리스트 6-78과 같이 만들어준다.

리스트 &-78 빈 이륨율 사용한 표현식율 갖는 포인트컷과 어드바이저

<aop:config>

<aop :advisor advice-ref="transactionAdvice" pointcut="bean(*Service)" />
</aop :config>

이제 아이디가 Service로 끝나는 모든 빈에 transactionAdvice 빈의 부가기능이 적
용될것이다.

트랜잭션 속성을 가진 트랜잭션 어드바이스 등록
다음은 TransactionAdvice 클래스로 정의했던 어드바이스 빈을 스프링의
Transactionlnterceptor를 이용하도록 변경한다. 메소드 패턴과 트랜잭션 속성은 가
장 보펀적인 방법인 get으로 시작하는 메소드는 읽기전용속성을두고 나머지는 디폴트
트랜잭션 속성을 따르는 것으로 설정하겠다.
<bean>을 이용한다면 리스트 6-79와 같이 만들면 된다.

리스트 &-79 트랜잭션 속성올 사용하는 어드바이스

<bean id="transactionAdvice"

class="org.springframework.transaction .interceptor.Transactionlnterceptor’
<proφperπty name="transactionManager" ref="transactionManager'’ />
<property n1녕뻐얀
히매
다
매At
tribujπt
es'“.

매arme="tra
nsac
tioαon1내깐
따앤


<props>
<prop key="get*">PROPAGATION_REQUIRED , readOnly</prop>
<prop key=샤
">PROPAGATION_REQUIRED</prop>

</props>
</property>
</bean>


이미 aop 스키마의 태그를 적용했으니 어드바이스도 이왕이변 tx 스키마에 정의된
태그를 이용하도록 만드는 게 나을 것 같다. tx 네임스페이스와 스키마를 추가하고 리
스트 6-80과 같이 트랜잭션 어드바이스와 속성을 정의해준다.

리스트 6-80 tx 스키마의 태그톨 이용한 트랜잭션 어드바이스 정의

<?xml version=’'1 .0" encoding="UTF-8“7)

<beans xmlns='http://www.springframework.org/schema/beans''
xmlns:xsi=‘ http://www .w3.org/2001/XML Schema-instance''
xmlns :aop=''http: //www .springframework.org/schema/aop"

xmlns
:
tx='http
:
//w빼ww.s때pnnl때gfra히빼

맨m

ew빼ork.org/schema/tx.

xsi:schemaLocation="http ://www .springframework .org/schema/beans

http://빼w.springframework.org/sch댄녕/beans/spring매eans-3
.
0
.
xsd

http://www.springframework.org/schema/aop
끼I


http ://www.springframework .org/schema/aop/spring-aop-3.0 .xsd
http://www.springframework.org/schema/tx

http://뼈w.springframework.org/schema/tx/spring-tx-3
.
Ð
.
xsd')
<tx:advice id="transactionAdvice")
-용 Iransaclio매Aan멍er는 트랜잭션 매니저 빈 O
fO
l디가

ransaclionMa떠양F라연 생락할 수 있다

’/)

<tx:attributes)
<tx:method name="get*" read-only="true'”

@

뼈m



써m

-

prα:>agalion
O I "REOUIRED"라면 생락할 수 있다


따


뼈
아-빼

뼈

비슷비슷해 보이는 <bean> 태그와 긴 클래스 이름 대신 용도를 명확히 드러내주는
태그를 사용한 덕분에， 트랜잭션 어드바이스와 속성 정의가 훨씬 이해하기 쉽고 간결해
졌다.

이쯤에서 태스트를 수행해서 새로 추가한 전용 태그가 잘 동작하는지 확인해보자.

트랜잭션속성테스트
트랜잭션 부가기능의 적용 전략을 수정했고 새로운 메소드도 추가했으니 학습 태스트
를만들어보자.
<tx:attributes>로 지정한 트랜잭션 속성을 보면 get으로 시작히는 메소드에는 읽
기전용 속성이 true로 되어 있다. 따라서 이 메소드를 경계로 시작되는 트랜잭션에는
쓰기 작업이 허용되지 않는다. 정말 그럴까? 궁금하다면 학습 태스트를 만들어보자.
예외적인 상황을 만들어야 하기 때문에 트랜잭션 롤백 테스트를 위해 만든

6앙!_ AOP 529


TestUserService를 활용해보겠다. 새로 추가한 getAll() 메소드를 오버라이드해서 강
제로 DB에 쓰기 작업을 추가할 것이다. getAll() 메소드는 get으로 시작되는 메소드이
므로 읽
기전용 트랜잭션 속성
이 적용된 채로 동작해야 한다. 트랜잭션 안에서 쓰기 시
도를 하면 그에 따른 예외가 발생할 것이다.

예외 발생을 기대히는 테스트라면 @Test(expected=)를 이용하면 되긴 할 댄데， 문제
는 정확히 어떤 예외가 발생할지 잘 모른다는 점이다. 이
럴 땐 일단 expected 조건을 주
지 않고 태스트를 수행해서 예외 때문에 태스트가 실패히는 것을 먼저 확인하고， 그때
어떤 예외가 던져졌는지를 확인해서 이를 다시 테스트 조건에 넣어주면 된다.

TestUserService를 리스트 6-81과 같이 수정한다.

리스트 6-81 읽기전용 메소드에 쓰기 작업올 추가한 테스트용 클래스

static class TestUserService extends UserServicelmpl (

~ 읽기전용 트랜잭션의 대상인 get으로 시작핸 메소드훌 오버라이드랜

public List<U ser> getAll() (
for(User user super.getAll()) (

super.update(user)
;
~ 강제로 쓰기 시도흘 한다 여기서 읽기전용
속성으로 인한 예외가 발생해야 한다

메소드가 묻나기 전에 예외가 발생해야 하니 리턴 강은 return null;~ 멸 의미 없다， 적당한 값을 넣어서 검띠일만 되게 한다

이제 UserServiceTest
에 조작된 getAl
l()을 호출하는 태
스트를 만들어보자.

TestUserService를 testUserService 빈으로 등록해뒀으니 리스트 6-82와 같이 DI 받

은
testUserService 변수를
시용해서 getAll() 메소드를호출하면 된다.

리스트 6-82 읽기전용 속성 테스트

「용 일단은 어떤 예외가 던져질지 모르기 때문에
ex∞cted 없이 테스트훌 작성효다

@Test
public void readOnlyTransactionAttribute() {

testUserService
.
QetAll
()
;
--융 트랜잭션 속성이 제대로 적용됐디언 여기서 읽기전용 속성을 위반했기

때문에 예외가 발생해야 효κ}

지금은 예외 발생을 확인하는 게 목적이므로 테스트가 실패하면 성공히는 것이고，
성공하면 실패한 것이다. 테스트를 돌려보자.


예외가 발생하며 태스트가 실패한다. 실패와 함께 다음과 같은 에러 메시지가 출력
될 것이다. 읽기전용 속성이 원인이 돼서 발생한 예외인지 확인해보자. 메시지를 잘 살
펴보면 읽기전용으로 설정된 DB 커넥션에 대해 데이터를 조작하는 작업을 시도했기 때
문에 발생했음을 확인할 수 있다.

org .springframework.dao.TransientDataAccessResourceException:
PreparedStatementCallback; SQL [update users set name = ι password = 7, email
ι level = 7, login = 7, recommend = 7 where id = 7 j; Connection is read-only.
Queries leading to data modification are not allowed; nested exception is java.
sql.SQLException: Connection is read-only. Queries leading to data modification
are not allowed

이제 테스트를 성공으로 만들기 위해 예외 타입을 확인해보자.
TransientDataAccessResourceException
이라는 처음 보는 생소한 예외다. 이 예외는
스프링의 DataAccessException
의 한종류로 일시적인 예외상황을 만났을 때 발생하는
예외다. 일시적이라는 건 재시도를 하면 성공할 가능성이 있다는 의미다. 무슨 얘긴가
하면 getAll()
의 userDao
.
update()
에 의해 일어나는 DB 쓰기 작업은 원래 정상적으
로 처리돼야 함에도 일시적인 제약조건 때문에 예외를 발생시켰다는 뭇이다. 읽기전용

트랜잭션이 걸려 있지 않다면 성공할 것이기 때문이다.
이제 읽기전용 속성을 위반했을 때 발생하는 예외의 종류를 알았으니 이를 리스트
6-83과 같이 테스트에 반영하자.

리스트 6-83 예외 확인 테스트로 수정


@Test(expected=TransientDataAccessResourceException.class)
public void readOnlyTransactionAttribute() {

태스트를 다시 돌려보면 모두 성공할 것이다.

이제 전용 스키마의 태그를 사용해서 정의한 트랜잭션 AOP가 바르게 동작하고， 메
소드에 따라 적절한 트랜잭션 속성이 부여되고 있음을 확인할 수 있을 것이다.

6징:... AOP 531


I~ 애노테이션 트랜잭션 속성과 포인트컷 :폐|

포인트컷 표현식과 트랜잭션 속성을 이용해 트랜잭션을 일괄적으로 적용하는 방식은
복잡한 트랜잭션 속성이 요구되지 않는 한 대부분의 상황에 잘 들어맞는다. 그런데 가
끔은 클래스나 메소드에 따라 제각각 속성이 다른， 세밀하게 튜닝된 트랜잭션 속성을
적용해야 하는 경우도 있다. 이런 경우라면 메소드 이름 패턴을 이용해서 일괄적으로
트랜잭션 속성을 부여히는 방식은 적합하지 않다. 기본 속성과 다른 경우가 있을 때마
다 일일이 포인트컷과 어드바이스를 새로 추가해줘야 하기 때문이다. 포인트컷 자체가
지저분해지고 설정파일도 복잡해지기 쉽다.

이런 세밀한 트랜잭션 속성의 제어가 펼요한 경우를 위해 스프링이 제공하는 다른
방법이 있다. 설정파일에서 패턴으로 분류 가능한 그룹을 만들어서 일괄적으로 속성을
부여하는 대신에 직접 타깃
에 트랜잭션 속성정보를 가진 애노테이션을 지정하는 방법
이다.

6.7.1 트랜잭션 애노테이션
타깃에 부여할 수 있는 트랜잭션 애노테이션은 다음과 같이 정의되어 있다. 스프링 3.0
은 자바 5에서 등장한 애노테이션을 많이 사용한다. 필요에 따라선 애노테이션 정의를
읽고 그 내용과 특정을 이해할 수 있도록 애노테이션의 정의에 사용되는 주요 메타애노
테이션을 알고 있어야 한다.

@Transactional

리스트 6-84는 @Transaction 애노테이션을 정의한 코드다. 애노태이션 코드는 단순하
고 직관적이라서 쉽게 이해할 수 있다.

리스트 &-84 @Transaction 애노테이션

package org .springframework.transaction .annotation;

애노테이션을 사용힐 대상올 지정효삐 여기에 사용

r 된

메소택 타입(클래스 인터페이스) 처럼 한 개
이싱의 대상을 지정할 수 있다

@Target ({ElementType .METHOD , ElementType.TYPE} )
@Retention(RetentionPolicY .RUNTIME) ~ 애노테이선 정보가 언제까지 유지되는지훌 지정효삐 이렇게 설정하

면 런타임 때도 애노테이션 정보톨 리율렉션을 통해 얻을 수 있다

@Inheri ted -상속을 통해서도 애노테이션

정보훌 얻올 수 있게 한다，

OOocumented

532


public @interface Transactional (
String value() default '";
Propagation propagation() default Propagation.REQUIRED;
Isolation isolation() default Isolation.DEFAULT;
int timeout() default TransactionDefinition .TIMEOUT_DEFAULT;
boolean readOnly() default false;
Class<? extends Throwable>[] rollbackFor() default {};
String[] rollbackForClassName() default {};
Class<? extends Throwable>[] noRollbackFor() default {};
String[] noRollbackForClassName() default {};

트랜잭션 속성의 모든
항목을 엘리먼트로 지
정할수있다.
디를트 값이 설정되어
있으므로
모두생략가
능하다

@Transactional 애노테이션의 타깃은 메소드와 타입이다. 따라서 메소드， 클래스， 인
터페이스에 시용할 수 있다. @Transactional 애노테이션을 트랜잭션 속성정보로 시용
하도록 지정하면 스프링은 @Transactional
이 부여된 모든 오브젝트를 자동으로 타깃 오
브젝트로 인식한다. 이때 사용되는 포인트컷은 TransactionAttributeSourcePointcut
이다. TransactionAttributeSourcePointcut은 스스로 표현식과 같은 선정기준을 갖
고 있진 않다. 대신 @Transactional
이 타입 레벨이든 메소드 레벨이든 상관없이 부여
된 빈 오브젝트를 모두 찾아서 포인트컷의 선정 결과로 돌려준다. @Transactional
은
기본적으로 트랜잭션 속성을 정의하는 것이지만， 동시에 포인트컷의 자동등록에도 사
용된다.

트랜잭션 속성을 이용하는 포인트컷
그림 6-24는 @Transactional 애노태이션을 시용했을 때 어드바이저의 동작방식을 보
여준다. Transactionlnterceptor는 메소드 이름 패턴을 통해 부여되는 일괄적인 트랜
잭션 속성정보 대신 @Transactional 애노테이션의 엘리먼트에서 트랜잭션 속성을 가져
오는 AnnotationTransactionAttributeSource를 시용한다. @Transactional은 메소드
마다 다르게 설정할 수도 있으므로 매우 유연한 트랜잭션 속성 설정이 가능해진다.
동시에 포인트컷도 @Transactional을 통한 트랜잭션 속성정보를 참조하도록 만든
다. @Transactional
로 트랜잭션 속성이 부여된 오브젝트라면 포인트컷의 선정 대상이
기도하기때문이다.


6앙!_ AOP 533


속성이 부여된 대상을 확인해서
포인트것을한다
Txlnterceptor
@Transactional
애노테이션에 담긴 트랜잭션
속성정보를사용한다
속성이 부여된 대상을 확인해서
포인트것을한다
Txlnterceptor
@Transactional
애노테이션에 담긴 트랜잭션
속성정보를사용한다
그림 6-24 애노테이션 트랜잭션 속성과 포인트컷

이 방식을 이용하면 포인트컷과 트랜잭션 속성을 애노테이션 하나로 지정할 수 있다.
트랜잭션 속성은 타입 레벨에 일괄적으로 부여할 수도 있지만 메소드 단위로 세분화해
서 트랜잭션 속성을 다르게 지정할 수도 있기 때문에 매우 세밀한 트랜잭션 속성 제어
가가능해진다.

트랜잭션 부가기능 적용 단위는 메소드다. 따라서 메소드마다 @Transactional을 부
여하고 속성을 지정할 수 있다. 이렇게 하면 유연한 속성 제어는 가능하겠지만 코드는
지저분해지고， 동일한 속성 정보를 가진 애노테이션을 반복적으로 메소드마다 부여해
주는 바람직하지 못한 결과를 가져올 수 있다.

대체정책
그래서 스프링은 @Transactional을 적용할 때 4단계의 대체fallback 정책을 이용하게 해
준다. 메소드의 속성을 확인할 때 타깃 메소드， 타깃 클래스， 선언 메소드， 선언 타입
(클래스‘ 인터메이스)의 순서에 따라서 @Transactional이 적용됐는지 차례로 확인하고， 가
장 먼저 발견되는 속성정보를 사용하게 하는 방법이다. 가장 먼저 타깃의 메소드에
@Transactional
이 있는지 확인한다. @Transactional
이 부여되어 었다면 이를 속성
으로 λF용한다. 만약 없으면 다음 대체 후보인 타깃 클래스에 부여된 @Transactional
애노태이션을 찾는다. 타깃 클래스의 메소드 레벨에는 없었지만 클래스 레벨에
@Transactional
이 존재한다면 이를 메소드의 트랜잭션 속성으로 사용한다. 이런 식으
로 메소드가 선언된 타입까지 단계적으로 확인해서 @Transactional
이 발견되면 적용하
고， 끝까지 발견되지 않으면 해당 메소드는 트랜잭션 적용 대상이 아니라고 판단한다
.
리스트 6-85와 같이 정의된 인터페이스와 구현 클래스가 있다고 하자. 인터페이스
에는 두 개의 메소드가 있고， 구현 클래스 역시 인터페이스의 정의된 두 개의 메소드를
갖고 있다. 구현 클래스인 Servicelmpl
이 빈으로 등록됐고 그 두 개의 메소드가 트랜잭
션의 적용 대상이 돼야 한다면 @Transactional을 부여할 수 있는 위치는 총 6개다.


리스트 &-85 @Transactional 대체 정책의 예

[1]

public interface Service (

[2]

void method1 ();

[3]

void method2();

[4]
public class Servicelmpl implements Service (

[5]

public void method1() (

[6]

public void method2() {

스프링은 트랜잭션 기능이 부여될 위치인 타깃 오브젝트의 메소드부터 시작
해서 @Transactional 애노테이션이 존재하는지 확인한다. 따라서 [5]
와 [6]
이
@Transactional
이 위치할 수 있는 첫 번째 후보다. 여기서 애노테이션이 발견되면 바

로 애노테이션의 속성을 가져다 해당 메소드의 트랜잭션 속성으로 사용한다.

메소드에서 @Transactional
을 발견하지 못하면， 다음은 타깃 클래스인 [4]
에
@Transactional
이 존재하는지 확인한다. 이를 통해서 @Transactional
이 타입 레
벨， 즉 클래스에 부여되면 해당 클래스의 모든 메소드의 공통적으로 적용되는 속성
이 될 수 있다. 메소드 레벨에 @Transactional
이 없다면 모두 클래스 레벨의 속성을
사용할 것이기 때문이다. 메소드가 여러 개라면 클래스 레벨에 @Transactional을 부
여하는 것이 편리하다. 특정 메소드만 공통 속성을 따르지 않는다면 해당 메소드에
만 추가로 @Transactional
을 부여해주면 된다. 대체 정책에서 지정한 순서에 따라
서 항상 메소드에 부여된 @Transactional
이 가장 우선이기 때문에 @Transactional
이 붙은 메소드는 클래스 레벨의 속성을 무시하고 메소드 레벨의 속성을 사용할 것이
다. 반면에 @Transactional을 붙이지 않은 여타 메소드는 클래스 레벨에 부여된 공통
@Transactional을 따르게 된다.

타깃 클래스에서도 @Transactional을 발견하지 못하면， 스프링은 메소드가 선언된
인터페이스로 넘어간다. 인터페이스에서도 먼저 메소드를 확인한다. 따라서 [2]와 디]에

6장:... AOP 535



@Transactional
이 부여됐는지 확인하고 있다면 이 속성을 적용한다. 인터페이스 메소

드에도 없다면 마지막 단계인 인터페이스 타입 [1]
의 위치에 애노태이션이 있는지 확인

한다.

@Transactional을 사용하면 대체 정책을 잘 활용해서 애노태이션 자체는 최소한으

로 사용하면서도 세밀한 제어가 가능하다. @Tra
nsactional은 먼저 타입 레벨에 정의

되고 공통 속성을 따르지 않는 메소드에 대해서만 메소드 레벨에 다시 @Transactional

을 부여해주는 식으로 사용해야 한다
. 기본적으로 @Transactional 적용 대상은 클라이

언트가 사용하는 인터페이스가 정의한 메소드이므로 @Transactiona
l
도 타깃 클래스보

다는 인터페이스에 두는 게 바람직하다. 하지만 인터페이스를 사용히는 프록시 방식의

AOP가 아닌 방식으로 트랜잭션을 적용하면 인터페이스에 정의한 @Transactional은

무시되기 때문에 안전하게 타깃 클래스에 @Transactional을 두는 방법을 권장한다. 프

록시 방식 AOP의 종류와 특정 또는 비 프록시 방식 AOP의 동작원리를 잘 이해하고

있고 그에 따라 @Transactional
의 적용 대상을 적절하게 변경해줄 확신이 있거나， 반

드시 인터페이스를 사용하는 타깃에만 트랜잭션을 적용하겠다는 확신이 있다변 인터페

이스에 @Transactional을 적용하고 아니라면 마음 편하게 타깃 클래스와 타깃 메소드

에적용히는편이낫다.

인터페이스에 @Transactional을 두면 구현 클래스가 바뀌더라도 트랜잭션 속성을

유지할수있다는장점이 있다.

트랜잭션 애노테이션 A땀을 위한 설정
@Transactional을 이용한 트랜잭션 속성을 사용히는 데 필요한 설정은 매우 간단하다.
스프링이 이 방법을 위한 모든 설정을 디음 태그 하나에 담아뒀기 때문이다. 이 태그 하
나로 트랜잭션 애노태이션을 이용히는 데 펼요한 어드바이저， 어드바이스， 포인트것，
애노테이션을 이용하는 트랜잭션 속성정보가 등록된다. 지금까지 사용했던 트랜잭션
기능 적용을 위한 설정 중에서 가장 간단하다.

<tx :annotation-driven />

6.7.2 트랜잭션 애노테이션 적용
@Transactional을 UserService에 적용해보자.
아직 세밀한 트랜잭션 속성 설정이 필요하진 않다. 하지만 목 세밀한 트랜잭션 설정
이 필요할 때만 @Transactional을 사용해야 하는 것은 아니다. @Transactional을 이용


히는 트랜잭션 설정이 직관적이고 간단하다고 생각해서 사용하는 경우도 많다. 클래
스，
빈， 메소드의 이름에 일관된 패턴을 만들어 적용하고 이를 활용해 포인트컷과 트랜잭션
속성을 지정하는 것보다는 단순하게 트랜잭션이 펼요한 타입 또는 메소드에 직접 애노
태이션을 부여하는 것이 훨씬 편리하고 코드를 이해하기도 좋다.

다만 트랜잭션 적용 대상을 손쉽게 파악할 수 없고， 사용 정책을 잘 만들어두지 않으
면 무분별하게 사용되거나 자칫 빼먹을 위험도 있다. 트랜잭션이 적용되지 않았다는 사
실은 파악하기가 쉽지 않다. 일반적으로는 트랜잭션이 적용되지 않았다고 기능이 동작
하지 않는 것도 아니므로 예외적인 상황이 발생해서 롤백이 필요한 시점이 돼야 비로소
이상하다는 걸 느끼고 트랜잭션 적용 여부를 확인해보게 된다. 따라서 @Transactional
을 사용할 때는 실수하지 않도록 주의하고. @Transactional 적용에 대한 별도의 묘드
리뷰를 거칠 펼요가 있다. 다행히 일부 데이터 액세스 기술은 트랜잭션이 시작되지 않
으면 아예 DAO에서 예외가 발생하기도 한다. 하지만 JDBC를 직접 사용하는 기술의
경우는 트랜잭션이 없어도 DAO가 동작할 수 있기 때문에 주의해야 한다.

tx 스키마의 <tx:attributes) 태그를 이용해 설정했던 트랜잭션 속성을 그대로 애
노테이션으로 바꿔보자.XML에서는 리스트 6-86과 같이 메소드 이름 패턴을 이용해
두 가지 종류의 속성을 지정했다.

리스트 6-86 tx 스키마의 태그률 이용한 트랜잭션 속성 정의

<tx:attributes>

，~----


<tx:method name=‘get*" read-only="true" /> I 9잉‘ 메소드의 속성이 우선 적용되고 나머지
<tx:method name="*" /> 메소드는 디롤트 속성을 갖는다

</tx:attributes>


애노태이션을 이용할 때는 이 두 가지 속성 중에서 많이 시용되는 한 가지를 타입 레
벨에 공통 속성으로 지정해주고， 나머지 속성은 개별 메소드에 적용해야 한다. 메소드
레벨의 속성은 메소드마다 반복돼야 하므로 속성의 종류가 두 가지 이상이고 적용 대상
메소드의 비율이 비슷하다면 메소드에 많은 @Transactional 애노테이션이 반복될 수
있다.

@Transactional 애노테이션은 UserServicelmpl 클래스 대신 UserService 인터페
이스에 적용하겠다. 그래야 UserServicelmpl과 TestUserService 양쪽에 트랜잭션이
적용될 수 있기 때문이다. 인터페이스 방식의 프록시를 사용히는 경우에는 인터페이스
@Transactional을 적용해도 상관없다. UserService에는 get으로 시작하지 않는 메소
드가 더 많으므로 리스트 6-87처럼 인터페이스 레벨에 디폴트 속성을 부여해주고， 읽

6장
AOP 537


기전용 속성을 지정할 get으로 시작하는 메소드에는 읽기전용 트랜잭션 속성을 반복해
서지정해야한다.

리스트 6-87@Transact때181 애노테이션올 이용한 속성 부여

@Transactional
public interface UserService (
void add(User user);
void deleteAll(); (tx:melhod name=..... f)과 같은 설정 효과훌 가져온다

메소드 레옐 @Transaclα1<3oH노테이션이 없으므로
void update(User user); ! 대체 정책에 따라 티입 레벨에 (1 ) 부여된 디율트 속성이
void upgradeLevels(); | 적용된다，

@Transactional(readOnly=true)
(tx:met뼈 name="1뱅!’ re혀잉nly="lrue'f)톨 애노테이션 방User get(String id); ~ 식으로변경한것이다
메소드 단위로 부여된 트랜잭션의 속성이 타입 레벌에 부여

1 된 것에 우선해서 적용된다 같은 속성울 기졌어도 메소드 레@Transactional(readOnly=true) !
| 벨에 부여될 때는 메소드마다 반복휠 수밖에 없다
List<User> getAll(); 를~

애노테이션을 이용한 트랜잭션 속성 지정은 tx 스키마를 사용할 때와 마찬가지로
IDE의 자동완성 기능을 활용할 수 있고 속성을 잘못 지정한 경우 컴파일 에러가 발생
해서 손쉽게 확인할수 있다는장점이 있다.

@Transactional 적용을 모두 마쳤으니 태스트를 돌려보자. 트랜잭션에 대한 태스트
와읽기전용속성에대한태스트가모두성공할것이다.

@Trans actional 적용에 대한 스프링의 대체 정책을 확인해보고 싶다면
@Transactiona l 설정을 UserService와 UserServicelmpl
에 넣고 빼보면서 테스트
를 통해 어떤 애노테이션이 우선시되는지 등을 확인해보면 된다. 예를 들어 지금
UserService에 지정한 @Transactional 애노테이션은 그대로 두고 리스트 6-88과 같
이 타깃 클래스에 @Transactional을 넣으면 태스트 결과는 어떻게 될까?

리스트 6-88 타깃 클래스에 부여한 @Transactional

@Transactional -아무런 속성 엘리먼트훌 지정하지 않았으므로 디율트 트랜잭션 속성 값이 적용된다

public class UserServicelmpl implements UserService {


애노테이션에 대한 대체 정책의 순서는 타깃 클래스가 인터페이스보다 우선하므로
모든 메소드의 트랜잭션은 디폴트 속성을 갖게 된다. 따라서 UserService 인터페이스
의 getAll() 메소드에 부여한 읽기전용 속성은 무시되고 읽기전용 속성을 검증하는
readOnlyTransactionAttribute() 태스트는 실패할 것이다. 굳이 완전한 태스트로 만
들어두지 않더라도 이런 식으로 스프링의 기능을 검증해보는 건 좋은 습관이다. 때로는
어설프게 이해하고 넘어갈 수 있는 지식을 바로잡아주는 데 도움이 되기 때문이다.

E컨 탤챔선진원 텐같트 펠I

6.8.1 선언적 트랜잭션과 트랜잭션 전파 속성
트랜잭션을 정의할 때 지정할 수 있는 트랜잭션 전파 속성은 매우 유용한 개념이다. 예
를 들어 REQUIRED로 전파 속성을 지정해줄 경우 앞에서 진행 중인 트랜잭션이 있으면
참여하고 없으면 자동으로 새로운 트랜잭션을 시작해준다. REQUIRED 전파 속성을 가진

메소드를 결합해서 다양한 크기의 트랜잭션 작업을 만들 수 있다. 트랜잭션 적용 때문
에 불필요하게 코드를 중복하는 것도 피할 수 있으며， 애플리케이션을 작은 기능 단위
로 쪼개서 개발할 수가 있다.

예를 들어 시용자 등록 로직을 담당히는 UserService
의 add() 메소드를 생각해보자.
add() 메소드는 트랜잭션 속성이 디폴트로 지정되어 있으므로 트랜잭션 전파 방식은
REQUIRED
다. 만약 add() 메소드가 처음 호출되는 서비스 계층의 메소드라면 한 명의 사
용자를 등록히는 것이 하나의 비즈니
스 작업 단위가 된다. 이때는 add() 메소드가 실행
되기 전에 트랜잭션이 시작되고 add() 메소드를 빠져나오면 트랜잭션이 종료되는 것이
맞다.DB 트랜잭션은 단위 업무와 일치해야 하기 때문이다.

그런데 작업 단위가 다른 비즈니스 로직이 있을 수 있다. 예를 들어 그날의 이
벤트의 신청 내역을 모아서 한 번에 처리하는 기능이 있다고 해보자. 처리되지 않
은 이벤트 신청정보를 모두 가져와 DB
에 등록하고 그에 따른 정보를 조작해주는 기
능이다. 그런데 신청정보의 회원가입 항목이 체크되어 있는 경우에는 이벤트 참가
자를 자동으로 시용자로 등록해줘야 한다. 하루치 이벤트 신청 내역을 처리하는 기
능은 반드시 하나의 작업 단위로 처리돼야 한다. 이 기능을 EventService 클래스
의 processDailyEventRegistration() 메소드로 구현했다고 한다면， 이 메소드가
비즈니스 트랜잭션의 경계가 된다. 그런데 processDailyEventRegistration() 메

6징:.. AOP 539


소드는 작업 중간에 사용자 등록을 할 필요가 있다. 직접 UserDao의 add() 메소드
를 사용할 수도 었지만， 그보다는 UserService
의 add() 메소드를 이용해서 사용

자 등록 중 처리해야 할， 디폴트 레벨 설정과 같은 로직을 적용하는 것이 바람직
하다. 이때 UserService
의 add( ) 메소드는 독자적인 트랜잭션을 시작하는 대신
processDailyEventRegistration() 메소드에서 시작된 트랜잭션의 일부로 참여하게
된다. 만약 add() 메소드 호출 뒤에 processDailyEventRegistration() 메소드를 종료
하지 못하고 예외가 발생한 경우에는 트랜잭션이 롤백되면서 UserService의 add() 메
소드에서 등록한 사용자 정보도 취소된다.

트랜잭션 전파라는 기법을 사용했기 때문에 UserService
의 add ( )는 독자적
인 트랜잭션 단위가 될 수도 있고， 다른 트랜잭션의 일부로 참여할 수도 있다. 트
랜잭션의 전파 방식을 이용할 수 없었다면 어떻게 될까? 그렇다면 UserService
의 add( ) 메소드는 매번 트랜잭션을 시작하도록 만들어졌을 것이고， 이 때문에
processDailyEventRegistration() 등의 메소드에서 호출해서 시용할 수 없었을 것이
다. processDailyEventRegistration()
에서 시용자 등록 기능이 펼요하긴 하지만 시용
자 등록 작업도 같은 트랜잭션에 넣어야 하는데 add() 메소드는 독자적인 트랜잭션을
만들어버리기 때문이다. 그래서 어쩔 수 없이 processDailyEventRegistration() 안에
add() 메소드의 코드를 그대로 복사해서 시용하게 된다. 이런 식의 중복이 일어나기 시
작하면서 중복된 코드를 함께 관리히는 불편이 뒤따르게 된다. 사용자 등록 중에 처리
해야 할 작업이 추가될 때마다 add( ) 메소드의 묘드를 복사해간 다른 메소드를 모두 찾
아서 일일이 수정해줘야 한다. 한 군데라도 실수해서 빠뜨리면 사용자 데이터에 문제가

발생할수도있다.
다행히 스프링은 트랜잭션 전따 속성을 선언적으로 적용할 수 있는 기능을 제공하기
때문에 이런 고민을 할 펼요는 없다. 그렇다고 트랜잭션 전파 속성이 개발자의 부주의

나 게으름으로 인해 발생하는 불필요한 코드 중복을 막아주지는 못한다.

그림 6-25는 add() 메소드에 REQUIRED 방식의 트랜잭션 전따 속성을 지정했을 때
트랜잭션이 시작되고 종료되는 경계를 보여준다. add() 메소드도 스스로 트랜잭션 경계
를 설정할 수 있지만， 때로는 다른 메소드에서 만들어진 트랜잭션의 경계 안에 포함된
다. 이 덕분에 사용자 등록 기능이 다양한 비즈니스 트랜잭션에서 사용되더라도 add()
메소드는 하나만 존재하면 되고 불필요한 코드 중복이 일어나지 않는다.


processEventReQistration()


methodXXXO --------


트
랜잭션이 이미 시작된 상
태에서

REOUIRED 속성을 가진 메소드의 호훌이

트랜잭션이 시작되고 종료되는 경계 일어나연 기존 트랜잭션이 그대로 진띠돼

서 하나의 커다란 트랜잭션으로 통합된다

그림 6-25 트랜잭션 경계와 트랜잭션 전파

AOP
를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정
할 수 있게 하는 방법을 선언적 트랜잭션de미arative transaction이라고 한다. 반대로

TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 묘드 안에

서 사용히는 방법은 프로그램에 의한 트랜잭션programmatic transaction이라고 한다. 스프링은

이 두 가지 방법을 모두 지원하고 있다. 물론 특별한 경우가 아니라면 선언적 방식의 트

랜잭션을 사용하는 것이 바람직하다.

이런 선언적인 트랜잭션 개념은 EJB에도 있었다. 검포넌트 기반의 서비스를 지향하

던 EJB
의 특성상 트랜잭션 전따가 가능한 선언적인 트랜잭션은 중요한 기능이었다. 스

프링은 복잡한 EJB 컴포넌트가 아닌 평범한 자바 클래스로 만든 오브젝트에도 선언적

트랜잭션을 적용할 수 있다. 트랜잭션 추상화를 함께 제공하기 때문에 EJB
처럼 특정 트

랜잭션 기술과 환경에 종속되지도 않는다.

6.8.2 트랜잭션 동기화와 테스트
이렇게 트랜잭션의 자유로운 전파와 그로 인한 유연한 개발이 가능할 수 있었던 기술적
인 배경에는 AOP가 있다. AOP 덕분에 프록시를 이용한 트랜잭션 부가기능을 간단하
게 애플리케이션 전반에 적용할수 있었다. 또한가지 중요한 기술적인 기반은바로스
프링의 트랜잭션 추상화다. 데이터 액세스 기술에 상관없이 또 트랜잭션 기술에 상관
없이 DAO에서 일어나는 작업들을 하나의 트랜잭션으로 묶어서 추상 레벨에서 관리하
게 해주는 트랜잭션 추상화가 없었다면 AOP를 통한 선언적 트랜잭션이나 트랜잭션 전
파등은불기능했을것이다.


6징:.. AOP 541


트랜잭션 매니저와 트랜잭션 동기화
트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다.
PlatformTransactionManager 인터페이스를 구현한 트랜잭션 매니저를 통해 구체적인
트랜잭션 기술의 종류에 상관없이 일관된 트랜잭션 제어가 가능했다. 또한 트랜잭션 동
기화 기술이 있었기에 시작된 트랜잭션 정보를 저장소에 보관해뒀다가 DAO에서 공유
할수있었다.
트랜잭션 동기화 기술은 트랜잭션 전파를 위해서도 중요한 역할을 한다. 진행 중인
트랜잭션이 있는지 확인하고 트랜잭션 전파 속성에 따라서 이에 참여할 수 있도록 만
들어주는 것도 트랜잭션 동기화 기술 덕분이다.
그렇다면 이런 생각을 해볼 수도 있다. 트랜잭션 전파 속성 중 REQUIRED는 이미 시작
된 트랜잭션이 있으면 그 트랜잭션에 참여하게 해준다. 진행 중인 트랜잭션에 동기화되
는 것이다. 지금은 모든 트랜잭션을 선언적으로 AOP로 적용하고 있지만， 펼요하다면
프로그램에 의한 트랜잭션 방식을 함께 사용할 수도 있다. 어차피 트랜잭션 어드바이스
에서도 트랜잭션 매니저를 통해 트랜잭션을 제어히는 것이니 묘드에서 직접 트랜잭션
매니저를 이용해 트랜잭션에 참여히는 것이 안 될 이유는 없다. 물론 특별한 이유가 없
다면 트랜잭션 매니저를 직접 이용히는 묘드를 작성할 필요는 없다. 선언적 트랜잭션이
훨씬편리하다.
그런데 특별한 이유가 있다면 트랜잭션 매니저를 이용해 트랜잭션에 참여하거나 트
랜잭션을 제어히는 방법을 사용할 수도 있다. 지금까지 진행했던 특별하고 독특한 작업
은모두한군데서 일어났다. 바로태스트다.
스프링의 테스트 컨텍스트를 이용한 테스트에서는 @Autowired를 이용해 애플리케이
션 컨텍스트에 등록된 빈을 가져와 태스트 목적으로 활용할 수 있었다. 그렇다면 당연
히 트랜잭션 매니저 빈도 가져올 수 있다. 트랜잭션 매니저는 리스트 6-89와 같이 빈으
로선언되어 있다.

리스트 6용
9 트랜잭션 매니저 빈

(bean id="transactionManager"
class="org .springframework . jdbc .datasource.DataSourceTransactionManager"

따라서 리스트 6-90에서처럼 @Autowired를 샤용해 태스트에서 시용할 수 있다.


리스트 운90 트랜잭션 매니저톨 참조하는 테스트

@R unWith(SpringJUnit4ClassRunner.class)
OContextConfiguration( locations = "/test-appl icationContext .xml ")
public class UserServiceTest (

OAutowired
PlatformTransactionManager transactionManager;

이제 리스트 6-91
과 같은 간단한 테스트 메소드를 추가하자. 사실 태스트라고 할 것
도 없다. 간단히 서비스 메소드를 호출하는 코드뿐이다. 당연히 테스트는 성공할 것이다.

리스트 운91 간단한 테스트 메소드

@Test
public void transactionSync() (
userService.deleteAll();

userService .add(users.get(0));
userService .add(users.get( l) );

transactionSync() 테스트 메소드가 실행되는 동안에 몇 개의 트랜잭션이 만들어졌
을까? UserService의 모든 메소드에는 트랜잭션을 적용했으니 당연히 3
개다. 각 메소
드가 모두 독립적인 트랜잭션 안에서 실행된다. 태스트에서 각 메소드를 실행시킬 때는
기존에 진행 중인 트랜잭션이 없고 트랜잭션 전파 속성은 REQUIRED이니 새로운 트랜잭
션이 시작된다. 그리고 그 메소드를 정상적으로 종료히는 순간 트랜잭션은 커빗되면서
종료될 것이다. de leteAll () 메소드가 실행되는 시점에서 트랜잭션이 시작됐으니 당연
히 그 메소드가 끝나면 트랜잭션도 같이 종료된다. 그 후에 다시 add() 메소드가 호출되
면 현재 진행 중인 트랜잭션은 없으니 마찬가지로 새로운 트랜잭션이 만들어질 것이다.
마지막 add() 메소드도 마찬가지다.

트랜잭션 매니저를 이용한 테스트용 트랜잭션 제어
그렇다면 이 테스트 메소드에서 만들어지는 세 개의 트랜잭션을 하나로 통합할 수는 없
을까? 즉 하나의 트랜잭션 안에서 deleteAll ()과 두 개의 add() 메소드가 동작하게 할
방법은없을까?

6장:... AOP 543



세 개의 메소드 모두 트랜잭션 전파 속성이 REQUIRED이니 이 메소드들이 호출되기
전에 트랜잭션이 시작되게만 한다면 가능하다. UserService
에 새로운 메소드를 만들고
그 안에서 deleteAll ()과 add()를 호출한다면 물론 가능하다. UserService의 모든 메
소드는 트랜잭션 경계가 되니 새로 만든 메소드에서 시작한 트랜잭션이 deleteAll ()과
add() 메소드를 묶어서 하나의 트랜잭션 안에서 동작하게 할 것이다.

그런데 메소드를 추가하지 않고도 테스트 코드만으로 세 메소드의 트랜잭션을 통합
하는 방법이 있다. 태스트 메소드에서 UserService의 메소드를 호출하기 전에 트랜잭
션을 미리 시작해주면 된다. 트랜잭션의 전파는 트랜잭션 매니저를 통해 트랜잭션 동기
화 방식이 적용되기 때문에 가능하다고 했다. 그렇다면 테스트에서 트랜잭션 매니저를
이용해 트랜잭션을 시작시키고 이를 동기화해주면 된다. 테스트도 트랜잭션 동기화에
참여하는것이다.

이미 %에서 트랜잭션 매니저를 사용해 직접 트랜잭션을 시작하고 제어하는 방법을
적용해본 적이 있다. 그 방법을 그대로 여기에 사용해보자.

트랜잭션을 시작하기 위해서는 먼저 트랜잭션 정의를 담은 오브젝트를 만들고 이를
트랜잭션 매니저에 제공하면서 새로운 트랜잭션을 요청하면 된다. 트랜잭션 매니저는
이미 @Autowired를 태스트 코드로 주입하게 해놨다. 이를 사용해서 트랜잭션을 시작하
는 코드를 넣은 테스트 메소드로 만들어보면 리스트 6-92와 같이 될 것이다.

리스트 • 92 트랜잭션 매니저톨 이용해 트랜잭션올 미리 시작하게 만드는 테스트

@Test

public void transactionSync() ( 트랜잭션 정의는 기본 값율 사용한다 +기
DefaultTransactionDefinition txDefinition = new DefaultTransactionDefinition();
TransactionStatus txStatus = transactionManager.getTransaction(txDefinition);

userService .deleteAll(); 트랜잭션 매니저에게
•
트랜잭션율 요청햄 기즌에
앞에서 만들어 시작된 트랜잭션이 없으니 새로운 트랜잭션을 시작

1

진 트랜잭션에 시키고 트랜잭션 정보톨 몰려중다 동시에 만들어진

userService .add(users.get(0)); I모두참여한다 트랜잭션올다른곳에서도생힐수있도록동기회
userService .add(users.get(l)); I 한다

transactionManager.commit(txStatus);~ 앞에서 시작한 트랜잭션올 커잇효빠

예외처리나 롤백 등은 없는 좀 무책임한 트랜잭션 묘드이긴 하다. 학습 테스트로 만
들고 있는 것이니 이해하기 바란다. 어쨌든， 이렇게 하면 태스트 코드에서 트랜잭션 매
니저를 이용해서 트랜잭션을 만들고 그 후에 실행되는 UserService
의 메소드들이 같은


트랜잭션에 참여하게 만들 수 있다. 세 개의 메소드 모두 속성이 REQUIRED이므로 이미
시작된 트랜잭션이 있으면 참여하고 새로운 트랜잭션을 만들지 않는다.

트랜잭션동기화검증
태스트를 돌려보면 별문제 없이 작업을 마칠 테니 성공이라고 나올 것이다. 하지만 정
말 이 세 개의 메소드가 태스트 코드 내에서 시작된 트랜잭션에 참여하고 있는지는 알
수 없다. 그래서 트랜잭션의 속성을 변경해서 이를 증명해보자.
트랜잭션 속성 중에서 읽기전용과 제한시
간 등은 처음 트랜잭션이 시작할 때만 적
용되고 그 이후에 참여하는 메소드의 속성은 무시된다. 즉 deleteAll ()의 트랜잭션
속성은 쓰기 가능으로 되어 있지만 앞에서 시작된 트랜잭션이 읽기전용이라고 하면
deleteAll ()의 모든 작업도 읽기전용 트랜잭션이 적용된 상태에서 진행된다는 말이다.
이번엔 트랜잭션 속성을 리스트 6-93과 같이 강제로 읽기전용으로 만들고 다시 태
스트를돌려보자.

리스트 6경3 트랜잭션 동기화 검증용 테스트

public void transactionSync() (
DefaultTransactionDefinition txDefinition = new DefaultTransactionDefinition();
txDefinition.setReadOnly(true);
-을 읽기전용 트랜잭션으로 정의한다

TransactionStatus txStatus = transactionManager .getTransaction(txDefinition);

userService.deleteAll();--률 테스트 코드에서 시작한 트랜잭션에 ε뼈한다연 읽기전용 속성올 위반했으니
예외가발생해야한다


태스트를 실행해보면 예외 발생으로 인해 실패할 것이다. 예외
를 확인해보면
TransientDataAccessResourceException
이고， 메시지는 Connection is read-only2.}
고 니올 것이다. 읽기전용 트랜잭션에 대해 쓰기 작업을 했을 때 발생히는 예외다. 예
외가 발생한 위치를 살펴보면 deleteAll() 메소드를 호출한 곳이다. 이를 통해， 테스트
코드 내에서 시작한 트랜잭션에 de leteAll () 메소드가 참여하고 있다는 확신을 얻을
수있다.

태스트를 통해 확인할 수 있듯이 스프링의 트랜잭션 추상화가 제공하는 트랜잭션 동
기화 기술과 트랜잭션 전파 속성 덕분에 태스트도 트랙잭션으로 묶을 수 있다. 이를 잘
이용하면 DB 작업이 포함되는 태스트를 원하는 대로 제어하면서 효과적인 테스트를 만
들수있다.

g앙!_ AOP 545


이런 방법은 선언적 트랜잭션이 적용된 서비스 메소드에만 적용되는 것이 아니다.
JdbcTemplate과 같이 스프링이 제공히는 데이터 액세스 추상화를 적용한 DAO에도 통
일한 영향을 미친다. JdbcTemplate은 트랜잭션이 시작된 것이 있으면 그 트랜잭션에 자
동으로 참여하고， 없으면 트랜잭션 없이 자동커멋 모드로 JDBC 작업을 수행한다. 개념
은 조금 다르지만 JdbcTemplate의 메소드 단위로 마치 트랜잭션 전파 속성이 REQUIRED
인것처럼동작한다고볼수있다.

따라서 리스트 6-94와 같이 DAO를 직접 호출해도 동일한 결과를 얻을 수 있다.

리스트 6용4DAO훌 사용하는 트랜잭션 동기화 테스트

public void transactionSync() {
DefaultTransactionDefinition txDefinition =new DefaultTransactionDefinition();
txDefinition .setReadOnly(true);
TransactionStatus txStatus =transactionManager.getTransaction(txDefinition);

Jd
bcTern이ate:을 통해 이미 시작되 E
랜잭션이 있다연 자동으로 침K껴효빠

userDao.deleteAll();~ 따라서예외가알생효되 ~


트랜잭션이라면 당연히 롤백도 가능해야 한다. 리스트 6-95와 같이 태스트를 만들
면 전체 트랜잭션이 한꺼번에 롤백되는지도 확인할 수 있다.

리스트 6-95 트랜잭션의 톨백 테스트

@Test
public void transactionSync () {
userDao.deleteAll(); 트랜잭션옳 흩액했올 때 돌아갈 초기 상태톨 만들기 위해

assertThat(userDao .getCount() , iS(0)); 1 트랜잭션 시작 전에 초기화톨 해둔다

DefaultTransactionDefinition txDefinition =new DefaultTransactionDefinition();
TransactionStatus txStatus = transactionManager.getTransaction(txDefinition);
userService.add(users.get (0));

userService.add(users.get(1));
useñ)ao의 양tCou
n~) 메소드도 같은 트랜잭션에서 동작

assertThat(userDao.getCount() , is(2));• 뻔 빼()어|의해두개가등록됐는지확인해둔다，
transactionManager.rollback(txStatus); ~ 강저널 훌백한다， 트랜잭션 시작 전 상태로 돌아7삐 효떼
assertThat(userDao.getCount() , is(0));~
엉이)의 작업이 취소되고 트랜잭션 시작 이전의 상태임율
확인힐수있다


UserService
의 add() 작업이 테스트에서 시작한 트랜잭션에 참여하고 있으므로 태
스트에서 만든 트랜잭션을 롤백하면 당연히 add() 작업도 롤백돼야 한다. 테스트를 돌
려보면 성공할 것이다. rollback() 대신 commit()
을 하면 결과가 어떻게 달라지는지도
확인해보자.

이제 태스트 안에서 어떻게 트랜잭션을 조작할 수 있는지 충분히 이해할 수 있을 것
이다.

테스트에서 트랜잭션을 시작하거나 조작할 수 있는 기능은 매우 유용하다. 테스트
코드에서 미리 트랜잭션을 시작해놓으면 직접 호출하는 DAO 메소드도 하나의 트랜잭
션으로 묶을 수 있다. 트랜잭션 결과나 상태를 조작하면서 태스트하는 것도 가능하다.
예를 들어 하이버네이트 같은 ORM에서 세션에서 분리된detached 엔티티의 동작을 확
인할 때도 유용하다. 태스트 메소드 안에서 트랜잭션을 여러 번 만들 수도 있다. 트랜잭
션 속성에 따라서 여러 메소드를 조합해 사용할 때 어떤 결과가 나오는지도 미리 검증
가능하다.

롤백테스트
태스트 코드로 트랜잭션을 제어해서 적용할 수 있는 테스트 기법이 있다. 바로 롤백 테
스트다. 롤백 테스트는 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게
하고 태스트가 끝나면 무조건 롤백해버리는 테스트를 말한다. 예를 들어 리스트 6-96
은 전형적인 롤백 태스트다.

리스트 • 96 훌백 테스트


.,

미

」

새미

떼

떠

엠

따

때

。

매

떼

떠

따라

써

따라

빼때

ω

@Test
T



public void transactionSync() (
DefaultTransactionDefinition txDefinition =new DefaultTransactionDefinition();

|
f

n ,+ ,+ ’• --’+ m , 9 m ,+ a lf m m

‘ ‘ ‘ ‘ ‘

|
try ( •
userService.deleteAll();
userService.add(users.get(0)); •-. 테스트 안의 모든 작업올 하나의 트랜잭션으로 통합한다
userService.add(users.get(l));

finally ( 테스트 결과가 어떻든 상관없이 테스트가 몰나면
transactionManager
.
rollback(txStatus);~ 무조건 롤백한다 테스트 중에 빌생했던 D8의 변경
사항은 모두 이전 상태로 복구된다

6장:_ AOP 547


롤백 태스트는 DB 작업이 포함된 태스트가 수행돼도 DB
에 영향을 주지 않기 때문
에 장점이 많다. DB를 사용하는 코드를 테스트하는 건 여러 가지 이유로 작성하기 힘들
다. 간단한 CRUD 태스트야 별문제가 안 되겠지만 복잡한 데이터를 바탕으로 동작하는
기능을 테스트하려면 테스트가 실행될 때의 DB 데이터와 상태가 매우 중요하다. 문제
는 태스트에서 DB
에 쓰기 작업을 하는 기능을 실행하면서 태스트를 수행하고 나면 DB
의 데이터가 바뀐다는 점이다. 따라서 태스트를 실행하기 전에 적절한 DB 상태를 만들
어놓더라도 태스트가끝나고 나면 데이터와상태가바뀐다. 테스트는 어떤 순서로 어떻
게 진행될지 보장할 수 없고， 성공했을 때와 실패했을 때 DB
에 다른 방식으로 영향을
줄 수 있다. 그래서 테스트용 데이터를 DB
에 잘 준비해놓더라도 앞에서 실행된 테스트
에서 DB
의 데이터를 바꿔버리면 이후에 실행되는 태스트에 영향을 미칠 수 있다.

결국 DB를 액세스하는 테스트를 위해서는 테스트를 할 때마다 테스트 데이터를 초
기화하는 번거로운 작업이 필요해진다. 테스트의 목적에 따라서 테스트용 DB 데이터
는 제각각이겠지만， 그중에서 레퍼런스 데이터처럼 읽기전용인 것도 있고， 다른 태스트
에 의해 데이터가 변경되지만 않는다면 많은 태스트에서 공유 가능한 마스터 데이터도
있다. 이렇게 테스트를 위해 어느 정도 미리 준비해둘 수 있는 공통 태스트 데이터가 있
는데. DB 데이터를 수정하고 삭제하는 등의 작업을 진행하는 태스트 때문에 준비된 데
이터가 바뀌면 기껏 준비한 태스트 데이터는 무용지물이 된다.

예를 들어 add() 테스트는 새로운 λF용자 정보가 등록되는지를 테스트하기 위해 일
단 User 테이블의 데이터를 모두 삭제해버린다. 그리고 새로 등록한 데이터만으로 테스
트를 수행한다. 다른 테스트에서 활용하려고 기껏 준비한 User 테이블의 테스트용 샘플
데이터가 있었더라도 add() 태스트를 거치고 나면 엉망이 되고 만다.

바로 이런 이유 때문에 롤백 태스트는 매우 유용하다. 롤백 태스트는 태스트를 진행
하는 동안에 조작한 데이터를 모두 롤백하고 테스트를 시작하기 전 상태로 만들어주기
때문이다. add() 태스트를 롤백 테스트로 수행하면 태스트가 진행되는 동안 User 테이
블에 가해진 변경사항이 모두 취소되고 add() 테스트 수행 전과 동일한 상태로 복구된
다. 어떤 경우에도 트랜잭션을 커빗하지 않기 때문에 테스트가 성공하든 실패하든 상관
없다. 예외가 발생해도 괜찮다. 전체 태스트를 수행하기 전에 여러 태스트에서 공통적
으로 펼요한 사용자 정보를 테스트 데이터로 DB
에 넣어뒀다면， 롤백 태스트 덕분에 매
태스트마다 처음과 동일한 User 태이블의 테스트 데이터로 태스트를 수행할 수 있다.

물론 테스트에 따라서 고유한 태스트 데이터가 필요한 경우가 있다. 이때는 테스트
앞부분에서 그에 맞게 DB를 초기화하고 테스트를 진행하면 된다. 초기화한 작업까지


도모두롤백되므로어떤 변경을가하든상관없다. add() 태스트처럼 아예특정 태이블

의 데이터를 모두 날려버려도 상관없다. 특별한 검색조건을 만족시키기 위해 기본적인

테스트 데이터에 부가정보를 넣을 수도 있다.

롤백 태스트는 심지어 여러 개발자가 하나의 공용 테스트용 DB를 사용할 수 있게도

해준다. 적절한 격리수준만 보장해주면 동시에 여러 개의 테스트가 진행돼도 상관없다.

이처럼 태스트에서 트랜잭션을 제어할 수 있기 때문에 얻을 수 있는 가장 큰 유익이

있다면 바로 이 롤백 테스트다.
DB
에 따라서 성공적인 작업이라도 트랜잭션을 롤백하

면 커빗할 때보다 성능이 더 향상되기도 한다. 예를 들어 MySQL에서는 통일한 작업을

수행한 뒤에 롤백하는 게 커맛하는 것보다 더 빠르다. 하지만 DB
의 트랜잭션 처리 방

법에 따라롤백이 커맛보다 더 많은부하를주는경우도 있으니 단지 성능때문에 롤백

테스트가 낫다고는 볼 수 없다.

6.8.3 테스트를 위한 트랜잭션 애노테이션
@Transactional 애노태이션을 타깃 클래스 또는 인터페이스에 부여하는 것만으로 트랜
잭션을 적용해주는 건 매우 편리한 기술이다. 그런데 이 편리한 방법을 태스트 클래스
와 메소드에도 적용할 수 있다.
스프링의 컨텍스트 태스트 프레임워크는 애노테이션을 이용해 태스트를 편리하게
만들 수 있는 여러 가지 기능을 추가하게 해준다. @Co
n
textCo
n
f
i
gura
t
ion을 클래스에
부여하면 태스트를 실행하기 전에 스프링 컨테이너를 초기화하고， @Autowired 애노테
이션이 붙은 펼드를 통해 태스트에 필요한 빈에 자유롭게 접근할 수 있다. 그 외에도 스
프링 컨텍스트 태스트에서 쓸 수 있는 유용한 애노태이션이 여러 개 있다.

@Transactional

테스트에도 @
T
ransactiona
l
을 적용할 수 있다. 태스트 클래스 또는 메소드에

@Transactional 애노태이션을 부여해주면 마치 타깃 클래스나 인터페이스에 적용된 것

처럼 테스트 메소드에 트랜잭션 경계가 자동으로 설정된다. 이를 이용하면 테스트 내에

서 진행하는 모든 트랜잭션 관련 작업을 하나로 묶어줄 수 있다. @Tr
ansactiona
l
에는

모든 종류의 트랜잭션 속성을 지정할 수 있기도 하다.

테스트의 @Transactional은 앞에서 태스트 메소드의 코드를 이용해 트랜잭션을 만

들어 적용했던 것과 동일한 결과를 가져온다. 트랜잭션 매니저와 번거로운 묘드를 사용

6장
AOP 549


하는 대신 간단한 애노테이션만으로 트랜잭션이 적용된 테스트를 손쉽게 만들 수 있는
것이다.

물론 테스트에서 사용히는 @Transactional은 AOP를 위한 것은 아니다. 단지 컨텍
스트 테스트 프레임워크에 의해 트랜잭션을 부여해주는 용도로 쓰일 뿐이다. 하지만 기
본적인 동작방식과 속성은 UserService 등에 적용한 @Transactional과 동일하므로 이
해하기 쉽고 사용하기 편리하다.

태스트의 트랜잭션 속성을 메소드 단위에 부여한다면 리스트 6-97과 같이 만들 수
있다. UserSerivce의 메소드에 적용했을 때와 마찬가지로 테스트 메소드 실행 전에 새
로운 트랜잭션을 만들어주고 메소드가 종료되면 트랜잭션을 종료해준다. 당연히 메소
드 안에서 실행되는 deleteAll (), add() 등은 태스트 메소드의 트랜잭션에 참여해서 하
나의 트랜잭션으로 실행된다.

리스트 6용7 테스트에 적용된 @Transactional

@Test

OTransactional

public void transactionSync() (
userService .deleteAll ();
userService .add (users .get(Ø));
userService .add(users .get(l));

트랜잭션 적용 여부를 확인해보고 싶다면 앞에서 해봤던 것처럼 태스트의 트랜잭션
을 리스트 6-98과 같이 읽기전용으로 바꾸고 태스트를 실행해 예외가 발생하는지 확인
해보면된다.

리스트 운98 트랜잭션 적용 확인

@Test
@Transactional(readOnly=true)

public void transactionSync() (
@Transactional에 의해 시작된 트랜잭션에 참여하므로 읽기전용 속성 위반으로 u
serS
ervice
.
deleteAll();~
예외가
일생한다

@Transactional은 테스트 클래스 레벨에 부여할 수도 있다. 그러면 태스트 클래스
내의 모든 메소드에 트랜잭션이 적용된다. 각 메소드에 @Transactional을 지정해서 클
래스의 공통 트랜잭션괴는 다른 속성을 지정할 수도 있다. 메소드의 트랜잭션 속성이
클래스의 속성보다 우선한다.


@Rollback

태스트 메소드나 클래스에 사용히는 @Transactional은 애플리케이션의 클래스에 적용
할 때와 디폴트 속성은 동일하다. 하지만 중요한 차이점이 있는데， 태스트용 트랜잭션
은 테스트가 끝나면 자동으로 롤백된다는 것이다. 태스트에 적용된 @Transactional은
기본적으로 트랜잭션을 강제 롤백시키도록 설정되어 있다. @Transactional을 지정해주
면 롤백 태스트가 되는 것이다.

정말 그런지 확인을 해보자. transactionSync() 메소드는 태스트가 정상적으로 끝
나면 태스트용으로 넣은 두 개의 사용자 정보가 DB에 남아 있어야 한다. 테스트 메
소드의 @Transactional
을 제거하고. DB
의 Users 태이블 정보를 모두 삭제한 후에
trnansactionSync() 태스트 한 개만 실행해보자. 태스트가 끝나고 DB를 확인해보면
두 개의 사용자 정보가등록되어 있음을확인할수 있을 것이다.

다시 태이블의 내용을 모두 삭제하고 이번에는 transactionSync() 태스트 메소
드에 @Transactional을 부여하고 해당 테스트만 실행해보자. 그리고 DB
의 Users
태이블을 살펴보면 이번에는 아무런 데이터가 남아 있지 않음을 확인할 수 있다.
transactionSync() 안에서 진행된 모든 DB 관련 작업이 @Transactional
에 의해 롤백
됐기 때문이다.


활
단월태;똥임행
JUnit 테스트는 보통 쿨래스 단위로 실행된다. 따라서 테스트 쿨래스 내의 모든 테스트가 함께
실행된다. 이클립스에서는 ?l딴히 륙정 테스트 메소드만 실행되게 할 수도 있다. JUnit 뷰에 나
타난 테스트 목록애서 하나톨 쿨릭하고 테스트훌 실행하거나， 테스트 코드에서 톨정 메소드의
이홈옳 률릭하고 테스트톨 실행하면 선택한 테스트 메소드 하나만 실행이 된다.

이렇게 스프링의 컨텍스트 태스트는 @Transactional을 태스트에서도 편리하게 쓸
수 있도록 해준다. 그런데 태스트 메소드 안에서 진행되는 작업을 하나의 트랜잭션으로
묶고 싶기는 하지만 강제 롤백을 원하지 않을 수도 있다. 트랜잭션을 커빗시켜서 테스
트에서 진행한 작업을 그대로 DB
에 반영하고 싶다면 어떻게 해야 할까?

이때는 @Rollback이라는 애노테이션을 이용하면 된다. @Transactional은 기본적
으로 태스트에서 사용할 용도로 만든 게 아니기 때문에 롤백 태스트에 관한 설정을
담을 수 없다. 따라서 롤백 기능을 제어하려면 별도의 애노태이션을 사용해야 한다.
@Rollback은 롤백 여부를 지정하는 값을 갖고 있다. @Rollback의 기본 값은 true다. 따
라서 트랜잭션은 적용되지만 롤백을 원치 않는다면 @Rollback(false)
라고 해줘야 한다.

6장:.. AOP 551


리스트 6-99와 같이 테스트 메소드를 설정해주면 태스트 전체에 걸쳐 하나의 트랜
잭션이 만들어지고 예외가 발생하지 않는 한 트랜잭션은 커빗된다.

리스트 6용9 테스트 트랜잭션올 커잇시키도록 설정한 테스트

@Test

@Transactional

ORollback(false)

public void transactionSync() (

@TransactionConfiguration

@Transactional은 테스트 클래스에 넣어서 모든 태스트 메소드에 일괄 적용할 수 있지
만
@Rollback 애노테이션은메소드 레벨에만적용할수 있다.

태스트 클래스의 모든 메소드에 트랜잭션을 적용하면서 모든 트랜잭션
이 롤백되지 않고 커맛되게 하려면 어떻게 해야 할까? 무식하게 모든 메소드에
@Rollback(false)를 적용할 수도 있다. 하지만 그보다는 클래스 레벨에 부여할 수 있
는 @TransactionConfiguration 애노테이션을 이용하면 펀리하다.

다음과 같이 @TransactionConfiguration을 사용하면 롤백에 대한 공통 속성을 지정
할 수 있다. 디폴트 롤백 속성은 false로 해두고， 테스트 메소드 중에서 일부만 롤백을
적용하고 싶으면 메소드에 @Rollback을 부여해주면 된다. @Rollback
의 기본 값은 true
이므로 이때는 트랜잭션을 롤백해준다.

리스트 6-100 @TransactionConfiguration의 사용 여|

@R unWith(SpringJUnit4ClassRunner.class)
@(ontextConfiguration(locations = "/test-applicationContext. xml ")

@Transactional 훌백 여부에 대한 기본 설정과 트랜잭션
@TransactionConfiguration(defaultRollback=false)--을 매니저 빈울 지정하는 데 사용할 수 있다
public class UserServiceTest ( 디룰트 트랜잭션 매니저 아이디는 관려l를

따라서 transactionMaπ앵er로 되어 있다，

@Test

ORollback ~ 메소드에서 디올트 설징과 그 밖의 롤백 방법으로 재설정할 수 있다

public void add() throws SQLException { ... }


NotTransactional과 Propagation.NEVER
태스트 클래스 안에서 일부 메소드에만 트랜잭션이 필요하다면 메소드 레벨의
@Transactional을 적용하면 된다. 반면에 대부분의 메소드에서 트랜잭션이 필요하다면
테스트 클래스에 @Transactional을 지정하는 것이 편리하다. 그런 경우 굳이 트랜잭션
이 필요 없는 메소드는 어떻게 해야 할까? 트랜잭션이 만들어지든 말든 상관없다변 그
냥 놔둬도 된다. 하지만 펼요하지도 않은 트랜잭션이 만들어지는 것이 꺼림칙하거나 트
랜잭션이 적용되면 안 되는 경우에는 해당 메소드에만 태스트 메소드에 의한 트랜잭션
이 시작되지 않도록 만들어줄 수 있다.
@NotTransactional을 태스트 메소드에 부여하면 클래스 레벨의 @Transactional
설정을 무시하고 트랜잭션을 시작하지 않은 채로 테스트를 진행한다. 물론 테스트 안
에서 호출하는 메소드에서 트랜잭션을 사용하는 데는 영향을 주지 않는다. 그런데
~NotTransactional은스프링 3.0에서 제거 대상이 됐기 때문에 사용하기가조금 꺼림
칙하다. 스프링의 개발자들은 트랜잭션 테스트와 비 트랜잭션 테스트를 아예 클래스를
구분해서 만들도록 권장한다. 그래도 적용하고 싶다면 시용해도 된다.
@NotTransactional 대신 @Transactional
의 트랜잭션 전파 속성을 사용하
는 방법도 있다. @Transactional
을 다음과 같이 NEVER 전파 속성으로 지정해주면
@NotTransactional과 마찬가지로 트랜잭션이 시작되지 않는다.

@Transactional(propagation=팎ropagation
.
NEVER)

효과적인
08
테스트
태스트 내에서 트랜잭션을 제어할 수 있는 네 가지 애노테이션을 잘 활용하면 DB가 사
용되는 통합 태스트를 만들 때 매우 편리하다.
일반적으로 의존， 협력 오브젝트를 사용하지 않고 고립된 상태에서 테스트를 진행하
는 단위 태스트와.DB 같은 외부의 리소스나 여러 계층의 클래스가 참여히는 통합 태
스트는 아예 클래스를 구분해서 따로 만드는 게 좋다. UserServiceTest는 단지 테스트
를 만드는 다OJ=한 예제를 보여주기 위해 단위 태스트와 통합 테스트， 학습 테스트를 함
께 갖고 있지만， 실전에서는 깔끔하게 태스트 클래스를 분리히는 것이 바람직하다.
DB가 사용되는 통합 태스트를 별도의 클래스로 만들어둔다면 기본적으로 클래스 레
벨에 @Transactional을 부여해준다.DB가 사용되는 통합 테스트는 가능한 한 롤백 태
스트로 만드는 게 좋다. 애플리케이션의 모든 테스트를 한꺼번에 실행히는 빌드 스크립
트 등에서 태스트에서 공통적으로 이용할 수 있는 태스트 DB를 셋업해주고， 각 태스트

6갚 AOP 553


는 자신이 필요한 테스트 데이터를 보충해서 태스트를 진행하게 만든다. 테스트가 기본

적으로 롤백 태스트로 되어 있다면 테스트 사이에 서로 영향을 주지 않으므로 독립적이

고 자동화된 테스트로 만들기가 매우 편하다.

테스트는 어떤 경우에도 서로 의존하면 안 된다. 테스트가 진행되는 순서나 앞의 태
스트의 성공 여부에 따라서 다음 테스트의 결과가 달라지는 태스트를 만들면 안 된다.
코드가 바뀌지 않는 한 어떤 순서로 진행되더라도 테스트는 일정한 결과를 내야 한다.
트랜잭션을 지원하는 롤백 태스트는 매우 유용한 도구가 돼줄 것이다.

[m 칠리 렐I

6장에서는 트랜잭션 경계설정 기능을 성격이 다른 비즈니스 로직 클래스에서 분리하
고 유연하게 적용할 수 있는 방법을 찾아보면서 애플리케이션에 산재해서 나타나는 부
가기능을 모률화할 수 있는 AOP 기술을 알아봤다. 여기서 다룬 주요한 내용은 다음과
같다.

• 트랜잭션 경계설정 코드를 분리해서 별도의 클래스로 만들고 비즈니스 로직 클래스와 동일
한 인터페이스를 구현하면 DI의 확장 기능을 이용해 클라이언트의 변경 없이도 깔끔하게
분리된 트랜잭션 부가기능을 만들 수 있다.
• 트랜잭션처럼 환경과 외부 리소스에 영향을 받는 코드를 분리하면 비즈니스 로직에만 충실
한 태스트를 만들 수 있다.
• 목 오브젝트를 활용하면 의존관계 속에 있는 오브젝트도 손쉽게 고립된 테스트로 만들 수
있다.
• DI를 이용한 트랜잭션의 분리는 데코레이터 패턴과 프록시 패턴으로 이해될 수 있다.
• 번거로운 프록시 클래스 작성은 JDK의 다이내믹 프록시를 사용하면 간단하게 만들 수
있다.
• 다이내믹 프록시는 스태틱 팩토리 메소드를 사용하기 때문에 빈으로 둥록하기 번거롭다. 따
라서 팩토리 빈으로 만들어야 한다. 스프링은 자동 프록시 생성 기술에 대한 추상화 서비스
를 제공하는 프록시 팩토리 빈을 제공한다.
• 프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기와 포인트컷
을 활용할 수 있다. 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공히는 프록시
를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다.
• 포인트컷은 AspecU 포인트컷 표현식을 사용해서 작성하면 면리하다.

• AOP는 OOP만으로는 모률화하기 힘든 부가기능을 효과적으로 모률화하도록 도외주는 기
술이다.
• 스프링은 자주 사용되는 AOP 설정과 트랜잭션 속성을 지정하는 데 사용할 수 있는 전용 태
그를제공한다.
• AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메소드 이름 패턴
을 이용하는 방법과 타깃에 직접 부여하는 @Transactional 애노테이션을 사용하는 방법이
있다.
• @Transactional을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용히는 코드
의 태스트를 만들 수 있다.
6장~ AOP 555


Al 금쩨 스프링의 3대 핵심 기술인 IoC/DI, 서비스 추상화 AOP
에 대해 간단히

| 살펴봤다. 스프링이 가장 가치를 두고 적극적으로 활용하려고 하는 것은 결국 자
바 언어가 기반을 두고 있는 객체지향 기술이다. 스프링의 모든 기술은 결국 객체지향
적인 언어의 장점을 적극적으로 활용해서 묘드를 작성하도록 도와주는 것이다. 스프링
은 이 세 가지 핵심 기술을 자바 엔터프라이즈 개발을 필요로 하는 다OJ=한 분야에 적용
해서 개발자가 손쉽게 이용할 수 있는 기능으로 만들어 제공해주기도 한다. 스프링이
자신의 핵심 기술을 다양한 분야에 적용했듯이， 스프링을 사용하는 개발자도 스프링이
제공하는 세 가지 기술을 필요에 따라 스스로 응용할 수 있어야 한다.

7장에서
는 지금까지 살펴봤던 세 가지 기술을 애플리케이션 개발에 활용해서 새로운
기능을 만들어보고 이를 통해 스프링의 개발철학과 추구하는 가치， 스프링 사용자에게
요구되는 게 무엇인지를 살펴보겠다.

; 7.1 SQ뎌[1.'411]으| 분리 :헬|

다시 UserDao로 돌아가보자. UserDao는 더 이상 손댈 데가 없다고 생각할 만큼 충분히
다듬고 개선해왔다. 하지만 마지막으로 한 가지 더 욕심을 내보고 싶은 부분이 있다. 바
로 SQL을 DAO에서 분리하는 것이다.

반복적인 JDBC 작업 흐름은 댐플릿을 이용해 DAO에서 완벽하게 제거했다. 트랜
잭션과 예외처리 작업도 서비스 추상화와 AOP 등을 이용해 처리했기 때문에 DAO 안
에서 모두 제거할 수 있었다. 데이터 액세스 작업을 둘러싼 다OJ=한 코드를 책임과 성격

7장-스프링 핵심 기솔의 응용 557


이 다른 부분끼리 분리하고， 독립적으로 확장하거나 변경할 수 있도록 인터페이스를 이
용해 연결하고，
DI로 다이내믹하게 관계를 설정할 수 있도록 만들어췄다. 이렇게 해서
DAO에는 깔끔하게 다듬어진 순수한 데이터 액세스 코드만 남게 했다. 하지만 한 가지
더 분리해내고 싶은 게 있다. 바로 DB 테이블과 펼드정보를 고스란히 담고 있는 SQL
문장이다.

데이터를 가져오고 조작히는 작업의 인터페이스 역할을 하는 것이 DAO다. DAO
인터페이스가 바뀌지 않고， JDBC라는 처리 기술도 바뀌지 않으며， 정보를 담을 오브
젝트가 바뀌지 않는다면 DAO 코드가 바뀔 이유는 없을 것 같다. 하지만 데이터 액세스
로직은 바뀌지 않더라도 DB
의 테이블， 필드 이름과 SQL 문장이 바뀔 수 있다. 테이블
이나 필드 이름이 바뀔 수도 있고 하나의 필드에 담았던 정보가 두 개의 필드로 쪼개져
서 들어가거나 그 반대가 될 수도 있다. 하나의 테이블에 담겨 있던 정보가 두 개 이상
의 태이블로 분산될 수도 있고，
DB 검색 쿼리의 최적화를 위해 SQL에 부가적인 내용
을 넣어야 할 수도 있다. 어떤 이유든지 SQL 변경이 필요한 상황이 발생하면 SQL을
담고 있는 DAO 묘드가 수정될 수밖에 없다.

물론 처음부터 최적화된 SQL을 잘 준비해서 DAO 코드에 넣어두면 새로운 기능
이 추가되거나 데이터 액세스 로직이 크게 바뀌지 않는 한 SQL이 변경되지 않게 만드
는 것이 이상적이다. 하지만 현실적으로 SQL의 변경 작업은 생각보다 빈번히 일어난
다. 개발 중에는 물론이고 운영 중인 시스탱의 SQL을 변경해달라는 요청도 드물지 않
다. 그렇다고， 그때마다 DAO 코드를 수정하고 이를 다시 컴파일해서 적용하는 건 번거
로울 뿐만 아니라 위험하기도 하다. 펼드 이름이 바뀌어서 수정하다가 실수로 필드 이
름 한 개를 잘못 수정하면， 에러가 발생할 테고 다시 코드를 수정하고 빌드하는 작업이
반복돼야 한다. 일부 개발팀은 SQL 작성을 DBA에게 전담시키고 개발자는 미리 검증
된 SQL을 사용하기도 한다. 하지만 SQL을 전달받아서 DAO 코드에 복사해넣고 적용
하는 건 개발자가 해야 할 일이고， 그 과정에서 실수로 SQL을 잘못 복사하더라도 DBA
가 쉽게 확인하기 힘들다. 현재 동작하고 있는 애플리케이션에서 사용되는 SQL
이 정확
히 어떤 것인지 알려연 최종 빌드에 시용한 자바 코드를 가져와 일일이 묘드를 뒤져봐
야하기때문이다.

따라서 SQL을 적절히 분리해 DAO 코드와 다른 따일이나 위치에 두고 관리할 수 있
다면 좋을 것이다. 그래서 7조에서는 SQL을 DAO에서 분리히는 작업에 도전해본다.


7.1.1 XML 설정을 이용한 분리
가장 손쉽게 생각해볼 수 있는 SQL 분리 방법은 SQL을 스프링의 XML 설정파일로 빼
내는 것이다. 스프링은 설정을 이용해 빈에 값을 주입해줄 수 있다.SQL은 문자열로 되
어 있으니 설정따일에 프로퍼티 값으로 정의해서 DAO에 주입해줄 수 있다. 이렇게 하
면 설정파일에 있는 SQL을 코드외는 독립적으로 수정할 수가 있다.

개별 SQL 프로퍼티 방식
UserDao의 JDBC 구현 클래스인 UserDaoJdbc에는 6개의 SQL 문장이 있다. 조회할 때
필드 매핑을 위해 사용하는 userMapper도 SQL은 아니지만 필드 이름을 갖고 있다. 일
단 userMapper는 제외하고 순수한 SQL 문장만을 먼저 다뤄보자.
UserDaoJdbc 클래스의 SQL 6개를 프로퍼티로 만들고 이를 XML에서 지정하도록
해보자. 이렇게 하면 간단히 SQL을 DAO 코드에서 분리할 수 있다.
add() 메소드의 SQL을 외부로 빼는 작업을 살펴보자. 먼저 리스트 7-1
과 같이
add() 메소드에서 사용할 SQL을프로퍼티로 정의한다.

리스트 7-1 a여() 메소드률 위한 SOL 필드

public class UserDaoJdbc implements UserDao (
private String sqlAdd;

public void setSqlAdd(String sqlAdd) (
this.sqlAdd =sqlAdd;

리스트 7-2와 같이 add() 메소드의 SQL 문장을 제거하고 외부로부터 DI 받은 SQL
문장을 담은 sqlAdd를 사용하게 만든다.

리스트 7-2 주입받은 SOL 사용


public void add(User user) (

this . jdbcTemplate.update(
this .sqlAdd , -'insert inlo LISeIS ‘’룰 제거하끄 외부에서 주입받은 SOL을 사용하게 한다
user.getld() , user .getName() , user.getPassword() , user.getEmail () ,
user.getLevel() .intValue() , user .getLogin() , user .getRecommend());

F당-스프링 핵심 기슐의 응용 559


디음은 XML 설정의 userDao 빈에 리스트 7-3과 같이 sqlAdd 프로퍼티를 추가하고
SQL을넣어준다.

리스트 7-3 설정파일에 넣은 SQL 문장

<bean id="userDao‘’ class="springbook.user.dao.UserDaoJdbc">

<property name="dataSource" ref="dataSource'’ />

(property name="sQIAdd" value="insert into users(id , name , password ,

email , level , login , recommend) values(?,?,?,?,?,?,?)" 1>

이제 UserDaoTest 테스트를 실행해서 아무런 문제 없이 동작하는지를 확인해보자.
UserDaoTest를 미리 만들어뒀기 때문에 이런 큰 변화를 시도할 때도 든든하다. 태스트
결괴는성공이다.

이제 add()
에서 사용할 SQL은 코드의 수정 없이 XML 설정을 바꾸는 것만으로
도 자유롭게 수정이 가능하다. 비밀번호 펼드 이름이 password에서 pwd로 바뀌더라도
UserDaoJdbc 묘드 수정 없이 XML 파일만 수정해주면 된다. 나머지 5
개의 SQL도 모
두 같은 방법으로 분리해보자. 실수를 막기 위해서 매 작업 시 테스트를 실행해 혹시
잘못 옮기거나 빼먹은 내용은 없는지 확인하면서 진행하자.

스프링에서는 스트링 값을 외부에서 DI 해서 사용할 수 있기 때문에 손쉽게 SQL을
분리하는 데 성공했다. 하지만 이 방법은 조금 불편해 보인다. 매번 새로운 SQL이 필요
할 때마다 프로퍼티를 추가하고 DI를 위한 변수와 수정자 메소드도 만들어줘야 한다.

SQL
맙프로퍼티 방식
SQL이 점점 많아지면 그때마다 DAO에 DI용 프로퍼티를 추가하기가 상당히 귀찮다.
그래서 이번에는 SQL을 하나의 컬렉션으로 담아두는 방법을 시도해보자. 랩을 이용하
면 키 값을 이용해 SQL 문장을 가져올 수 있다. 뱀을 이용하면 프로퍼티는 하나만 만들
어도 되기 때문에 DAO의 코드는 더 간결해진다.SQL이 더 멸요하더라도 프로퍼티 추
가 없이 설정파일의 랩 정보만 변경하면 된다.
UserDao에서 SQL을 주입받기 위해 개별적으로 정의한 프로퍼티를 모두 제거하자.
그리고 Map 타입의 sqlMap 프로퍼티를 대신 추가한다.


리스트 7-4 업 타입의 SOL 정보 프로퍼티

public class UserDaoJdbc implements UserDao (

private Map<String , String) sqlMap;

public void setSqlMap(Map<String , String) sqlMap) (

this.sqlMap = sqlMap;

각메소드는미리 정해진 키 값을이용해 sqlMap으로부터 SQL을가져와사용하도록
만든다. 키 값은 간단하게 메소드 이름을 그대로 따르기로 하자. add() 메소드의 경우
라면 리스트 7-5와 같이 수정하면 된다.

리스트 7-5 sqlMap을 사용하도록 수정한 add()

public void add(User user) ( 프로떠티로 제공받은 업으로부터 키를
this.idbcTemplate.update( 이용해서 필요효f
SQL을 가져온다
this.sqlMap.get( ‘ add" ), ____

-1

user.getld() , user.getName() , user.getPassword() , user.getEmail() ,
user.getLevel().intValue() , user .getLogin() , user.getRecommend());

이제 XML 설정을 수정하자. 그런데 sqlMap 프로퍼티의 타입은 Map이다
Map은 하
나 이상의 복잡한 정보를 담고 있기 때문에 <property) 태그의 value 애트리뷰트로는
정의해줄 수가 없다. 이때는 스프링이 제공하는 <map) 태그를 사용해야 한다. 컬렉션
타입의 정보는 애플리케이션에서 자주 사용되기 때문에 스프링은 다양한 컬렉션 타입
의 프로퍼티 값을 정의하는 태그를 제공한다.

뱀을 초기화해서 sqlMap 프로퍼티에 넣으려면 다음과 같이 <map)과 <entry) 태그를
<property) 태그 내부에 넣어주면 된다. <entry) 태그에 선언된 카와 값을 담은 Map 타
입 오브젝트가 만들어져서 프로퍼티에 주입된다. 리스트 7-6은 SQL을 맴으로 정의해
서 sqlMap 프로퍼티 값으로 지정한
userDao 빈 설정이다.

리스트 7냉 랩율 이용한 SOL 설정


<bean id="userDao “ class="springbook.user.dao.UserDaoJdbc">
<property name="dataSource“ ref=“dataSource" />
(property nlame
찌띠씨뼈매때녀폐히빼
얀=딛's
q
l
Ma
p'

<m빼ap)

7징-스프링 핵심 기술의 응용 561


<entry key="add" value="insert into users(id , name , password ,

email , level , login , recommend) values(?,?,?,?,?,?,?)" />

<entry key="get" value=‘ select * from users where id = ?" />

<entry key=“getAll" value="select * from users order by id" />

<entry key="deleteAll" value="delete from users" />

<entry key=껴etCount" value="select count(*) from users" />

<entry key=피pdate" value="update users set name = ?, password = ?,

email = ?, level = ?, login = ?, recommend = ? where id =?" />
</map>
</property>
</bean)

SQL을 랩으로 전환하는 작업을 모두 마쳤다. 태스트를 돌려보고 성공을 확인해

보자.

랩으로 만들어두면 새로운 SQL이 필요할 때 설정에 <entry)만 추가해주면 되니 모

든 SQL을 일일이 프로퍼티로 등록하는 방법에 비해 작업량도 적고 코드도 간단해서 좋

다. 대신 메소드에서 SQL을 가져올 때 문자열로 된 커 값을 사용하기 때문에 오타와 같

은 실수가 있어도， 해당 메소드가 실행되기 전에는 오류를 확인하기 힘들다는 단점이

있다. 따라서 UserDaoTest 같은 DAO 코드에 대한 포괄적인 테스트를 만들어서 모든

SQL을 바르게 가져오는지， 키 값을 잘못 적지는 않았는지 미리미리 검증해볼 필요가

있다.

7.1.2 SQL
저|공서비스
스프링의 설정파일 안에 SQL을 두고 이를 DI 해서 DAO가 사용하게 하면 손쉽게 SQL
을 코드에서 분리해낼 수 있긴 하지만 본격적으로 적용하기엔 몇 가지 문제점이 있다.
SQL과 DI 설정정보가 섞여 있으면 보기에도 지저분하고 관리하기에도 좋지 않다.
데이터 액세스 로직의 일부인 SQL 문장을 애플리케이션의 구성정보를 가진 설정정보
와함께 두는건 바람직하지 못하다.SQL을따로분리해둬야독립적으로
SQL
문의 리
뷰나 SQL 튜닝 작업을 수행하기도 편하다.
SQL을 꼭 스프링의 빈 설정 방법을 사용해 XML에 담아둘 이유도 없다.SQL을 편
집하고 관리할 수 있는 툴에서 생성해주는 SQL 정보 파일이 있다면， 그런 파일 포뱃 그
대로사용할수있어야편할것이다. 때로는
XML이 아니라프로퍼티 파일이나엑셀파
일 또는 임의 포뱃의 파일에서 SQL을 저장해두고 읽어와야 할 수도 었다. 목 파일에서
만 SQL을 가져올 이유도 없다.SQL을 DB에 담아두고 DB에서 가져오게 할 수도 있지


않을까? 또는 웹 서비스나 리모팅을 이용해 최신 SQL 정보를 보관해두는 외부 시스템
에서 가져오는 방법도 가능하다.

스프링의 설정파일로부터 생성된 오브젝트와 정보는 애플리케이션을 다시 시작하기
전에는 변경이 매우 어렵다는 점도 문제다. 주입된 SQL 뱀 오브젝트를 직접 변경하는
방법을 생각해볼 수는 있겠지만 싱글톤인 DAO의 인스턴스 변수에 접근해서 실시간으
로 내용을 수정히는 건 간단한 일이 아니다. 운영 중인 애플리케이션에서 빈번하게 참
조되는 맴 내용을 수정할 경우 동시성 문제를 일으킬 수도 있다.

이런 문제점을 해결하고 요구사항을 모두 충족하려면 DAO가 사용할 SQL을 제공해
주는 기능을 독립시킬 필요가 있다. 독립적인 SQL 제공 서비스가 필요하다는 돗이다.

SQL 제공 기능을 본격적으로 분리해서 다OJ=한 SQL 정보 소스를 사용할 수 있고，
운영 중에 동적으로 갱신도 가능한 유연하고 확장성이 뛰어난 SQL 서비스를 만들어
보자.

SQL 서비스 인터폐이스
가장 먼저 할 일은 SQL 서비스의 인터페이스를 설계하는 것이다. 이제는 더 이상 설명
하지 않아도 이런 경우에는 클라이언트인 DAO를 SQL 서비스의 구현에서 독립적으
로 만들도록 인터페이스를 사용하고 DI로 구현 클래스의 오브젝트를 주입해주어야 한
다는 사실쯤은 바로 떠올릴 수 있을 것이다.DAO가 사용할 SQL 서비스의 기능은 간
단하다.SQL에 대한 키 값을 전달하면 그에 해당하는 SQL을 돌려주는 것이다. 주어진
키를 이용해 어떤 식으로 SQL을 가져오는지. SQL은 어디에 저장되어 있었는지， 어떻
게 검색하도록 했는지는 DAO의 관심사항이 아니다.DAO는 적절한 커를 제공해주고
그에 대한 SQL을 돌려받기만 하면 된다.
인터페이스의 이름은 SqlService
라고 하자. 그리고 리스트 7-7과 같이 하나의 메소
드를정의해둔다.

리스트 7-7 혀IService 인터페이스


package springbook.user.sqlservice;

런탁입 예외이므로 특별히 목구해야 할

public interface SqlService (
I -필요가 없다연 무시해도 된다
String getSql(String key) throws SqlRetrievalFailureException;

낀!t 스프링 핵심 기슐의 응용 563


주어진 키를 가지고 SQL을 가져오다가 어떤 이유에서든 실패하는 경우에는
SqlRetrievalFailureException 예외를 던지도록 정의한다. 물론 대개 이 예외는 복
구 불가능하다. 따라서 런타임 예외로 정의해둔다. 예외의 원인을 구분해야 한다면
SqlRetrievalFailureException
의 서브클래스를 만들어 사용하면 된다.

리스트 7-8과 같이 메시지와 원인이 되는 예외를 담을 수 있는
SqlRetrievalFailureException 클래스를 정의하자.

리스트 7-8 SOL 조회 실때 시 예외

package springbook .user .sqlservice;

public class SqlRetrievalFailureException extends RuntimeException (
public SqlRetrievalFailureException(String message) {
super (mes sage ) ;

public SqlRetrievalFailureException (String message , Throwable cause ) (
super (message, cause); •

SQL을 가져오는 데 실때한 근본 원인을
담을 수 있도록 중업 예외톨 저장할 수
있는 생성자틀 만들어둔다.

이제 UserDaoJdbc는 SqlService 인터페이스를 통해 필요한 SQL을 가져와 시용할
수 있게 만들어준다. 일단 리스트 7
-9와 같이 SqlService 타입의 빈을 DI 받을 수 있
도록프로퍼티를정의해준다.

리스트 7냉 SQlService 프로퍼티 추가

public class UserDaoJdbc implements UserDao (

private SQlService sQlService;

public void setSQlService(SQlService sQlService) {

this.sQlService = sQlService;

이제 모든 메소드에서 인스턴스 변수인 sqlService를 이용해 SQL을 가져오도록
수정한다. 이때 기존에 sqlMap에서 사용했던 커 값은 변경해줘야 한다. DAO별로 독
립적인 SQL 뱀을 가질 때와 달리 SqlService는 모든 DAO에서 서비스 빈을 시용하


게 만들 것이다. 따라서 키 이름이 DAO
별로 중복되지 않게 해야 한다. 따라서 add 대
신 userAdd와 같은 식으로 DAO나 도메인 오브젝트의 이름을 함께 λF용해서 키를 작
성한다.

리스트 7-10은 SqlService를 이용하도록 수정한 UserDao의 메소드다.

리스트 7-10 sql용m∞를 사용하도록 수정한 메소드

public void add(User user) (

this . jdbcTemplate.update(this.sQlService.getSQl("userAdd"),
user.getld() , user.getName() , user .getPassword() , user .getEmail() ,
user.getLevel().intValue() , user .getLogin() , user.getRecommend());

public User get(String id )
return this.jdbcTemplate.queryForObject(this.sQlService.getSQl( ‘ userGet"L
new Object[) {id} , this.userMapper);

public 니
stωser) getAll () (
return this.jdbcTemplate .query(this.sQlService.getSQl("userGetAll") ,
this .userMapper);

public void deleteAll() (
this. jdbcTemplate.update(this.sQlService .getSQl("userDeleteAll"));

public int getCount() (
return this.jdbcTemplate.queryForlnt(this.sQlService.getSQl( ‘ userGetCount") );

public void update(User user) (

간
뼈때띠l퍼댄
uJpda
te
t
h너
따
안싸대
야“띠1("피.

this .피j
dbc
Temnpp
at
e
.
때라터(야배
is.s찌q
lServ
ic
e.g
et
SQ
user.
ge얀애히메
user.
getPassword
user
.
getE
nla
l
l()
’
，

t
Na
me()， 얀
따띠이()， 얀티m뻐떠리니


user .getLevel().intValue() , user .getLogin() , user.getRecommend() ,
user .getId());


이제 UserDao가 SqlService 타입의 구현 클래스로 정의된 빈을 DI 받도록 설정을 변
경해줘야 한다. 워낙 큰 변화인지라 아직은 태스트를 실행해볼 수가 없어서 조금 답답
하다. 가능한 한 빨리 태스트를 해볼 수 있도록 만들어보자.

얻L 스프링 핵심 기솔의 응용 565


스프링 설정을 사용하는 단순 SQL 서비스
SqlService 인터페이스에는 어떤 기술적인 조건이나 제약사항도 담겨 있지 않다. 어떤
방법을 사용하든 상관없이 DAO가 요구하는 SQL을 돌려주기만 하면 된다.
일단 가장 간단한 방법으로 SqlService를 구현해보자. 앞에서 키와 SQL을 엔트리
로 갖는 랩을 빈 설정에 넣었던 방법을 SqlService에도 그대로 적용할 수 있다.
리
스트 7-11
과 같이 SqlService 인터페이스를 구현하는 클래스를 만들고 Map 타
입 프로퍼티를 추가한다. 그리고 랩에서 SQL을 읽어서 돌려주도록 SqlService
의
getSql() 메소드를 구현해보자.

리스트 7-11 랩을 이용한 S에SeNiæ의 구현

package springbook.user .sqlservice;

public class SimpleSqlService implements SqlService {
private Map<String , String> sqlMap;

실정따일에 (map)
으

public void setSqlMap(Map<String , String> sqlMap) { ~ 로 정의된 앓 정보를

l 가져오도록 프로떠티

this.sqlMap = sqlMap; 로 등록해둔다

public String getSql(String key) throws SqlRetrievalFailureException {
String sql = sqlMap.get(key);~ 내부Sql뼈p에서잃L올가져온다
if (sql == null)

throw new SqlRetrievalFailureException(key +

“에 대한 SQL올 장을 수 없습니다
");1

else 인터페이스에 정의된 규약대로 SOL율 기져오는 데 실때하면
return sql; 예외훌 던지게 한다

SimpleSqlService 클래스를 빈으로 둥록하고 UserDao가 DI 받아 사용하도록 설정
해준다.SQL 정보는 이 빈의 프로퍼티에 <map)을 이용해 등록한다.


(bean id=‘ userDao" class="springbook.dao.UserDaoJdbc “>
(property name="dat aSource “ ref="dataSource" />
(property name="sQlService" ref="sQlServi ce" />>

〈이얘아b
뼈야〉


뼈/
ea
n
ζ----


(bean 피바=냥
sqlServicαe
" 뎌없
딛닝sprin1띠뼈야
띠
sqlservice.S1mnpleSqlService
"

얹하뻐
id
"찌따
싸
class=
"’얘
때gb00k.uJser .찌띠
싸대
혀빼띠냐애따
대
〈따때야
n1녀매빼
e
낭찌띠씨lI
a
p
‘

φproperty 때am애얀=
"
sql
뼈
<m뼈ap>

<entry key="userAdd" value='’insert into users(id , name , password , email ,

level , logi n, recommend) values(7 , 7, 7, 7, 7, 7, 7)" />
<entry key=’ userGet " value="select * from users where id = 7" 1>
<entry key="userGetAll" value="select * from users order by id" 1>
<entry key="userDeleteAll " value="delete from users" 1>
<entry key=피serGetCount
‘ value=닝elect count(*) from users " 1>
<entry key="userUpdate" value=피pdate users set name = 7, password = 7,

email = 7, level = 7, login = 7, recommend = 7 where id = 7" 1>
</map>
</property>

</bean>

이제 UserDaoTest 태스트를 돌려보자. 제
법 많은 수정을 거쳤으므로 실수한 부분은
없는지 테스트를통해항상꼼꼼하게 점검하고넘어가야한다. 결과는성공이다.

현재 코드와 설정만 놓고 보자면 앞에서 사용했던 방법과 별로 다를 게 없어 보인다.
sqlSer vice 빈은 여전히 설정파일 안에 (map)을 이용해 SQL 정보를 가져오게 되어 있
다. 하지만 사실은 큰 차이가 있다. 이제 U
serDao를 포함한 모든 DAO는 SQL을 어디
에 저장해두고 가져오는지에 대해서는 전혀 신경 쓰지 않아도 된다. 구체적인 구현 방
법과 기술에 상관없이 SqlService 인터페이
스 타입의 빈을 DI 받아서 펼요한 SQL을
가져다쓰기만하면 된다.

동시
에 sql Ser vi ce 빈에는 DAO에는 전혀 영향을 주지 않은 채로 다OJ한 방법으로
구현된 SqlService 타입 클래스를 적용할 수 있다. 지금은 새롭게 도입한 Sql Ser vice
를 이용하는 구조가 바르게 동작하는지를 빠르게 검사하기 위해 가장 간단한 구현을 사
용했을 뿐이
다. 앞으로 얼마든지 유연하고 효과적인 방법을 시용해 SQL 서
비스를 발전
시
켜
나갈수있다.

스프링이 지원하는 편리한 DI 구조를 활용할 수 있는 기본적인 준비는 마쳤다. 이제
DAO의 수정 없이도 얼마나 편리하고 자유롭게 SQL 서비스 구현을 발전시켜나갈 수
있는지살펴보자.

7징-스프링 핵심 기술의 응용 567


[ 7.2 인터페이스의 분리와 자기참조 빈 :펠|
이제 SqlService 인터페이스의 구현 방법을 고민해보자. 인터페이스가 하나 있으니 기
계적으로 구현 클래스 하나만 만들면 될 거라고 생각하면 오산이다. 어떤 인터페이스는
그 뒤에 숨어 있는 방대한 서브시스템의 관문에 불과할 수도 있다. 인터페이스로 대표
되는 기능을 구현 방법과 확장 가능성에 따라 유연한 방법으로 재구성할 수 있도록 설
계할필요도있다.

7.2.1 XML 파일 매핑
스프링의 XML 설정따일에서 <bean> 태그 안에 SQL 정보를 넣어놓고 활용하는 건 좋
은 방법이 아니다. 그보다는 SQL을 저장해두는 전용 포뱃을 가진 독립적인 따일을 이
용히는 편이 바람직하다. 독립적이라고 해도 가장 편리한 포뱃은 역시 XML이다. 검색
용 키와 SQL 문장 두 가지를 담을 수 있는 간단한 XML 문서를 설계해보고， 이 XML
따일에서 SQL을 읽어뒀다가 DAO에게 제공해주는 SQL 서비스 구현 클래스를 만들어
보자.

JAXB

XML에 담긴 정보를 파일에서 읽어오는 방법은 다양하다. 여기서는 가장 간단하게 사

용할 수 있는 방법 중 하나인 JAXBJJava 띠에배애뼈잉tlωu뼈J

‘
뻐
Arcth11itec


라면 java.xml.bind 패키지 안에서 JAXB
의 구현 클래스를찾을수 있다.

DOM과 같은 전통적인 XML API와 비교했을 때 JAXB의 장점은 XML 문서정보
를 거의 동일한 구조의 오브젝트로 직접 매핑해준다는 것이다. DOM은 XML 정보를
마치 자바의 리플렉션 API를 시용해서 오브젝트를 조작하는 것처럼 간접적으로 접근

해야 송}는 불편이 있다. 그에 비해 JAXB는 XML의 정보를 그대로 담고 있는 오브젝
트 트리 구조로 만들어주기 때문에 XML 정보를 오브젝트처럼 다룰 수 있어 편리하다.
DAO가 DB 태이블의 내용을 U
ser라는 자바오브젝트와 List 컬렉션으로 매핑해주는
것과 비슷하다고 볼 수 있다.

JAXB는 XML 문서의 구조를 정의한 스키마를 이용해서 매핑할 오브젝트의 클래스
까지 자동으로 만들어주는 컴파일러도 제공해준다. 스키마 컴따일러를 통해 자동생성
된 오브젝트에는 매핑정보가 애노태이션으로 담겨 있다. JAXB API는 애노테이션에
담긴 정보를 이용해서 XML과 매핑된 오브젝트 트리 사이의 자동변환 작업을 수행해준

다. 그림 7-1
은
JAX
B
의 동작방식을보여준다.

568


그림 7-1JAXB 동작방식

SQL 랩을 위한 스키마 작성과 컴파일

담율 수

XML
문서정보훌담은
오E젝트 트리

SQL 정보는 키와 SQL
의 목록으로 구성된 랩 구조로 만들어두면 편리하다. 리스트
7-12와 같이 키와 SQL 정보를 담은 <sql> 태그를 가진 XML 문서를 사용하자.

리스트 7-12 SOL 업 XML 문서

XML정보훌
있는 매핑용 클래스
<sQlmap>
<sQl key="userAdd">insert into users (. .. ) ... </sQl>
<sQl key="userGet">select * from users .. .</sQl>

</sQlmap>

이 XML 문서의 구조를 정의하는 스키마를 만들어보자.XML 스키마는 XML 툴이
나 이클립스의 스키마 에디터 등을 이용하면 어렵지 않게 만들 수 있다. 리스트 7-13은
리스트 7-12
의 XML 문서 구조를 정의하고 있는 XML 스키마다.

리스트 7-13 SOL 업 문서에 대한 스키마

<7xml version="1 .8" encoding="UTF-8“7>

<schema xmlns=''http://www .w3.org/2881/XMLSchema''
targetNamespace=.. http://www .epril .com/sQlmap ..
xmlns:tns="http ://www.epril.com/sQlmap .. elementFormDefault=
피uali fied">

<element name="sQlmap">-용 〈밍때p) 엘리언트룰 정의한다
<complexType>
<seQuence>
<element na뼈="sQl" maxOccurs="unbounded" type=' tns:sQlType" />
</seQuence> 나 필요한 개수만큼 〈외1)을 포함할 수 있맨떼
</complexType>
</element>


7징-스프링 핵심 기술의 응용 569


<complexType nam얀
"s
q
lT
ype
") -용 〈쩍O에 대한 정의롤 시작한다
<simpleContent)
<extension base="string") -융 SOL 문징을 넣을 스트링 타입율 정의한다
<attribute name="떼. use="requi때’ type="string" /) 1

</extension)
검색을 위한 키 값은 (sql)의 key 애트리뷰트에 넣는다
</simpleContent) 빈드시 입력해야 하는 필수 값이다
</complexType)
</schema)

이렇게 만든 스키마 따일을 sq
lmap.xsd라는 이름으로 프로젝트 루트에 저장하고，
JAXB 컴파일러로 컴따일해보자. 컴파일할 때는 자동으로 생성되는 바인딩용 클래스
들이 위치할 패키지 이름을 제공해줘야 한다. SqlService를 정의한 패키지 아래에 jaxb
패키지를 추가한 뒤에 이를 사용하자.

셀이나 도스호에서 프로젝트 루트 폴더로 이동한 뒤에 다음 명령을 사용해 컴파일하
면된다.

생성된피일이 저장될

변환힐 스키마 파일 -기 「→
위치다 소스 폴더에

xjc -p springbook.user .sqlservice.jaxb sqlmap.xsd -d src 추가해준디

생성할 클래스의 때키지률 지정한다 .-J

명령을 실행하면 다음과 같은 메시지가 출력되면서 두 개의 바인딩용 자바 클래스와
팩토리 클래스가 만들어진다.

parsing a schema . . .

compiling a schema .. .

springbook\user\sqlservice\jaxb\ObjectFactorY.]ava

springbook\user\sQlservice\jaxb\SQlType.java 1
(sqlrnap)과 (sql)에 대한 바인딩 클래스

springbook\user\sQlservice\jaxb\SQlmap. java

springbook\user\sqlservice\jaxb\package-info.java

컴파일러가 만들어준 XML 문서 바인딩용 클래스를 살펴보자. 리스트 7-14는
<sqlmap)
이 바인딩될 SqlmapType 클래스다.

리스트 7-14 SqlmapType 클래스

@XmlAccessorType(XmlAccessType.FIELD) 변환작업에서 침고할정
@Xm lType(name = 닝qlmapType"， propOrder = { 'sql"}) 보훌 애노테이션으로 갖
@XmlRootElement(name = 갱qlmap
“ ) 고있다
public class Sqlmap {
@이
mlElement(required = true)


protected List<SqlType) sql; ~
(sql) 태그의 정보률 담은 Sqllype
오브젝트흘 리스트로 갖고 있다

public List<SqlType) getSql() {
if (sql == null) {
sql = new ArrayList<SqlType)( );

return this.sql;

리스트 7-15는 <sql) 태그의 정보를 담을 Sq lType 클래스다.

리스트 7-15 sqπype 클래스

@XmlAccessorType(XmlAccessType .FIELD)

@Xm lType(name = "sqlType", propOrder = { 피alue" })

public class S띠
Type {• 〈떠〉 태그 한 개딩 SqfType 오브젝트가 빠씩 만들어진다
@XmlValue
protected String value;~ SOL 값올 저ε옐 스트링 타입의 띨드
@XmlAttribute(required =true )
protected String key;
-웅~ key 애트리뷰트에 담긴 검색용 키 값올 위한 스트링 타입의 띨드

public String getValue() {
return value;

public void setValue(String value) {
this.value = value;

public String getKey() {
return key;

public void setKey(String value) {
this .key =value;


자바빈 스타일의 접근자와 수정자 메소드를 갖는 프로퍼티와 컬렉션으로 정의되어
있기 때문에 어떻게 XML 문서가 오브젝트로 전환될지는 쉽게 파악할 수 있을 것이다.

견it 스프링 핵심 기술의 응용 571


언마살링
생성된 매핑 클래스를 적용하기 전에 먼저 JAXB API의 시용법을 익힐 수 있도록 간
단한 학습 테스트를 만들어보자. 리스트 7-16과 같은 태스트용 XML을 만들고， 이를
JAXB API를 이용해 XML 문서의 내용이 자바오브젝트로 변환되는지를 확인하는 간
단한 태스트를 만들어보겠다.

리스트 7-16 테스트용 SQL 랩 XML 문서

<?xml version="1.0" encoding="UTF-8‘ 7>

<sqlmap xmlns= .. http://www .epri l.com/sqlmap..
xmlns:xsi=“ http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation=‘ http://www.epril.com/sqlmap .. / .. / .. / .. / .. /sqlmap.
xsd ">

<sq 1 key=" add" >i nsert</sq1>
<sql key="get">select</sql>
<sql key="delete">delete</sql>

</sqlmap>

<sql) 요소를 세 개 갖는 간단한 XML 문서다. 이 XML 문서를 sqlmap.xml이라는
이름으로저장해두자.

이제 JAXB API를 이용해 sqlmap.xml 파일의 내용을 가져오는 학습 테스트용 클래
스를 만들어보자.XML 문서를 읽어서 자바의 오브젝트로 변환하는 것을 JAXB에서는
언마살링
unmarshalling
이라고 부른다. 반대로 바인딩 오브젝트를 XML 문서로 변환히는
것은 마살링
ma때히ling이라고 한다. 자바오브젝트를 바이트 스트림으로 바꾸는 걸 직렬화
se때ization라고 부르는 것과 비슷하다.

리스트 7-17은 sqlmap.xml
이 JAXB 언마살링을 통해 매핑 오브젝트로 변환되는지
를 확인해보는 태스트다.

리스트 7-17 JAXB 학습 테스트

package springbook.learningtest.idk.iaxb;

public class JaxbTest ( 바인딩용 클래스들 위치훌 가지고
JAXB 컨텍스트를 만든다

@Test ...

public void readSqlmap() throws JAXBException , IOException (
String contextPath = Sqlmap .class .getPackage().getName();
JAXBContext context = JAXBContext.newlnstance(contextPath);~


Unmarshaller unmarshaller = context.createUnmarshaller();~ 언
마실러 성성

어마응‘을 하면 매밍된 오브젝트 트Sqlmap sqlmap = (Sqlmap) unmarshaller .unmarshal( ~
리의 루트인 Sq
l때p을 돌려준다 getClass().getResoujπrπce 이('’갱 q

l 띠lmap.xml"));

L(따) . (태) 테똥 클래(AsStream) 스(미) 와 같은 올더에 있는 XML파일을 A용한다
List<SqlType) sqlList = sqlmap.getSql();
assertThat(sqlList.size() , is(3));
assertThat(sqlList .get(0).getKey() , is("add"));
assertThat(sqlList .get(0).getValue() , is("insert"));
assertThat(sqlList.get(l).getKey() , is("get"));
assertThat(sqlList .get(l).getValue() , is(
닝
elect"
)
) ;
assertThat(sqlList .get(2) .getKey() , is("delete"));
assertThat(sqlList .get(2).getValue() , is( "delete"));

니 빼| 담겨 있는 없| 엎빨훌 가져와 씨L

문서와 같은 정보률 갖고 있는지 확인한다

태스트를 실행해보고 테스트 코드에 나타난 JAXB API의 사용 방법을 잘 기 억해
두자.

7.2.2 XML 파일을 이용하는 SQL 서비스
이제 JAXB를 이용해 XML 문서를 변환하는 방법을 알이봤으니 SqlService
에 적용할
차례다.

SQL랩 XML파일
UserDaoJdbc
에서 사용할 SQL
이 담긴 XML 문서부터 만들어보자. 스프링의 설정
따일에 <map)으로 만들어뒀던 SQL을 모두 옮긴다면 리스트 7-18과 같이 될 것이
다. 스프링 설정의 <map) , <entry) 태그에 담아뒀을 때보다 의미가 명확하게 드러나
는 <sqlmap). <sql) 태그를 사용하니 한결 보기 좋다. SQL은 DAO의 로직의 일부라
고 볼 수 있으므로 DAO와 같은 패키지에 두는 게 좋다. sq
lmap
.
xml이라는 이름으로
UserDao와 같은 패키지에 저장해두자.

리스트 7-18SQL업 XML 문서


<?xml version="1.0" encoding="UTF-8"?)
<sqlmap xmlns=.. http://www.epri 1. com/sqlmap ..
xmlns:xsi=''http://www .w3 .org/2001/XMLSchema-instance''

7징-스프링 핵심 기술의 응용 573


xsi:schemaLocation="http://www.epril.com/sqlmap

http://www.epril.com/sqlmap/sqlmap.xsd">

<sql key="userAdd">insert into users(id , name , password , email , level ,

login , recommend) values(7 ,7,7,7,7,7,7)</sql>

<sql key="userGet">select * from users where id = 7</sql>

<sql key="userGetAll">select * from users order by id</sql>

<sql key=“userDeleteAll")delete from users</sql>

<sql key="userGetCount ‘ >select count(*) from users</sql>

<sql key="userUpdate">update users set name = ι password = 7, email = 7,

level = 7, login = 7, recommend = 7 where id = 7</sql>
</sqlmap>

XML SQL
서비스
이제 sqlmap.xml에 있는 SQL을 가져와 DAO에 제공해주는 SqlService 인터페이스의
구현 클래스를 만들어보자.XML 문서에서 SQL을 가져올 때는， 학습 테스트로 만들어
봤듯이 JAXB API를 사용하면 된다.
그런데 언제 JAXB를 사용해 XML 문서를 가져올지 생각해봐。F 한다. DAO가 SQL
을 요청할 때마다 매번 XML 파일을 다시 읽어서 SQL을 찾는 건 너무 비효율적인 방
법이다. 특별한 이유가 없는 한 XML 파일은 한 번만 읽도록 해야 한다.XML 파일로
부터 읽은 내용은 어딘가에 저장해두고 DAO에서 요청이 올 때 시용해야 한다.
처음 SQL을 읽어들이는 건 어디서 해야 할까? SqlService를 구현한 클래스는 스프

령이 관리하는 빈으로 등록이 될 것이다. 스프링이 언제 어떻게 빈 오브젝트를 생성할
지 알 수 없으니 SQL을 읽는 초기 작업을 어디서 어떻게 해야 할지 조금 막믹송}다. 일
단은 간단히 생성자에서 SQL을 읽어와 내부에 저장해두는 초기 작업을 하자. 항상 그
래 왔듯이 일단 가장 간단한 방법으로 기능이 동작하게 만든 다음， 차근차근 좀 더 나은

구조와 묘드로 개선해나가면 된다.

JAXB 컴파일러가 생성해준 XML 문서 바인딩용 클래스들이 있다. JAXB로 XML
문서를 언마살링하면 SQL 문장 하나는 Sql 클래스의 오브젝트에 하나씩 담길 것이다.
이 Sql 오브젝트를 리스트 등에 저장해뒀다가 사용하는 방법은 어떨까? 나쁘지는 않다.
하지만 매번 검색을 위해 리스트를 모두 검사히는 방법은 비효율적이다. 차라리 상대적
으로 검색 속도가 빠르고 λF용하기 간펀한 Map 타입 오료젝트에 저장해두는 게 더 나은
방법일 것 같다. Sql
의 key와 value 프로떠티를 각각 뱀의 키와 값으로 저장하면 된다.

생성자에서 JAXB를 이용해 XML로 된 SQL 문서를 읽어들이고， 변환된 Sql 오브


젝트들을 랩으로 옮겨서 저장해뒀다가.DAO의 요청에 따라 SQL을 찾아서 전달히는
방식으로 SqlService를 구현해보자. 리스트 7-19는 이렇게 만들어진 XmlSqlService
클래스다.

리스트 7-19 생성자 초기화 방법울 사용하는 Xml얼IService 클래스

package springbook.user.sqlservice;

읽어온 SOL을 저장해둘 업

pα매삐

Jb

뼈u


private Map<String , String> sqlMap =new HashMap<String , String>();

r-스프링이 뾰젝트훌 만드는 시점에서 없을 읽어오도록 생성X털 이용한다

public XmlSqlService() ( ~ JAXB 매’를 이용해 XML 문서를 오브젝트 트리로 읽어온다
rString contextPath = Sqlmap.class.getPackage().getName();

try (
JAXBContext context = JAXBContext.newlnstarκe(contextPath);
Unmarshaller unmarshaller =context.createUnmarshaller();
InputStream is =UserDao.class.getResourceAsStream("sqlmap .xml “);

Sql뼈 ’

for(SqlType sql : sqlmap.getSql()) (
sqlMap.put(sql.getKey() , sql.getValue());
뻐뺀원爛
뼈뼈
} catch (JAXBException e) (
뻐햄

throw

new Runt빠xception(e);-그

JAXBException은 복구 물가능한 예외다 물필요한
thr.α%툴 피히도록 런타임 예외로 포εh해서 던진다.

public String getSql(String key) throws SqlRetrievalFailureException (
String sql = sqlMap .get(key);
if (sql == null)

throw new SqlRetrievalFailureException(key +

”를 이용해서 SQL을 장을 수 없습니다·’);

else
return sql;


생성자에서 XML 파일을 읽어서 랩에 저장하고， 앞에서 만들었던 SimpleSqlService
와 동일한 방법으로 SQL을 뱀에서 찾아서 돌려주는 getSql()
을 구현하면 된다.
이제 설정을 수정하자. SQL을 직접 갖고 있었던 sqlProvider 빈의 설정을 리스트
7-20처럼 간단히 변경할 수 있다.

깐~ 스프링 핵심 기술의 응용 575


리스트 7-20 sql용M∞ 설정 변경

<bean id=닝
qlService" class='springbook.user.sqlservice .XmlSQlService">
</bean>

UserDaoTest를 실행해서 DAO 기능이 모두 정상적으로 통작히는지 확인해보자. 준
비해둔 XML 파일에서 SQL을 제대로 읽어올 수만 있다면 아무런 문제 없이 테스트가
성공할것이다.

이제 SQL 문장을 스프링의 빈 설정에서 완벽하게 분리하는 데 성공했다. 독자적인
스키마를 갖는 깔끔한 XML 문서이므로 작성하고 검증하기에도 편리하고， 필요하다면
다른 툴에서도 불러서 사용할 수 있다. DBA에 의한 SQL 리뷰나 튜닝이 필요하다면
sqlmap.xml 파일만 제공해주면 된다.DAO 로직이나 따라미터가 바뀌지 않는 한 SQL

내용을 변경하더라도 애플리케이션의 묘드나 DI 설정은 전혀 수정할 필요가 없어졌다.

7.2.3 빈의초기화작업
XmlSqlService 코드를 다시 한번 살펴보자. 몇 가지 개선했으면 히는 점이 눈에 띈다.

생성자에서 예외가 발생할 수도 있는 복잡한 초기화 작업을 다루는 것은 좋지 않다.

오브젝트를 생성하는 중에 생성자에서 발생히는 예외는 다루기 힘들고， 상속하기 불편

하며， 보안에도 문제가 생길 수 있다. 일단 초기 상태를 가진 오브젝트를 만들어놓고 별

도의 초기화 메소드를 사용하는 방법이 바람직하다.

또 다른 문제점으로는 읽어들일 파일의 위치와 이름이 코드에 고정되어 있다는 점을

들 수 있다.SQL을 담은 XML 따일의 위치와 이름을 코드에 고정히는 건 별로 좋은 생

각이 아니다. 코드의 로직과 여타 이유로 바뀔 기능성이 있는 내용은 외부에서 DI로 설

정해줄 수 있게 만들어야 한다.

XmlSqlService 클래스를 수정해보자. 먼저 파일 이름을 외부에서 지정할 수 있도록
리스트
7-21
과같이 프로퍼티를추가한다.

리스트 7-，낀 SQL 업 파일 이륨 프로떠티

private String sqlmapFile;

public void setSqlmapFile(String sqlmapFile) {
this.sqlmapFile = sqlmapFile;


디음은 생성자에서 진행하던 작업을 리스트 7-22와 같이 별도의 초기화 메소드를
만들어옮긴다.
리스트 7-22 생성자 대신 사용할 초기화 메소드

public void loadSql() (
String contextPath = Sqlmap.class.getPackage().getName();
try (

InputStream is = UserDao.class.getResourceAsStream(this.sqlmapFile);

•

프로퍼티로 설정을 통해 제공받은
따일이름을사용효삐

이제 외부에서 XML 따일을 지정할 수 있고， 이를 이용해 SQL을 읽어들이는 초
기화 작업을 담당할 메소드도 별도로 만들어뒀다. sqlmapFile 프로퍼티는 빈 설정의
<property) 태그를 이용해 지정해주면 된다. 하지만 loadSql() 이라는 초기화 메소드는
언제 실행돼야 할까? 또， 어떻게 실행시킬 수 있을까?

이 XmlSqlService 오브젝트에 대한 제어권이 우리가 만드는 코드에 있다면， 오브젝
트를 만드는 시점에서 리스트 7-23과 같이 초기화 메소드를 한 번 호출해주면 된다.

리스트 7-23 XmlSq
I용Nice 오브젝트의 초기화 방법

XmlSqlService sqlProvider = new Xm1SqlService();

sq1Provider.setSq1mapFile(
닝q띠1mnl
ap
.
xm1");

뻐떠


sqlProvider.loadSql();


그러나 XmlSqlService 오브젝트는 빈이므로 제어권이 스프링에 있다. 생성은 물론
이고 초기화도 스프링에게 맡길 수밖에 없다. 그래서 스프링은 빈 오브젝트를 생성하고
DI 작업을 수행해서 프로머티를 모두 주입해준 뒤에 미리 지정한 초기화 메소드를 호출
해주는 기능을 갖고 있다.

AOP를 살펴볼 때 스프링의 빈 후처리기에 대해 설명했다. 빈 후처리기는 스프링 컨
테이너가 빈을 생성한 뒤에 부가적인 작업을 수행할 수 있게 해주는 특별한 기능이다.
AOP를 위한 프록시 자동생성기가 대표적인 빈 후처리기다. 프록시 자동생성기 외에
도 스프링이 제공하는 여러 가지 빈 후처리기가 존재한다. 그중에서 애노테이션을 이용
한 빈 설정을 지원해주는 몇 가지 빈 후처리기가 있다. 이 빈 후처리기는 <bean) 태그를
이용해 하나씩 등록할 수도 있지만， 그보다는 context 스키마의 annotation-config 태

7징-스프링 핵심 기술의 응용 577


그를 사용하면 더 편리하다. context 네임스페이스를 사용해서 <context:annotationconfig/>
태그를 만들어 설정파일에 넣어주면 빈 설정 기능에 사용할 수 있는 특별한
애노테이션 기능을 부여해주는 빈 후처리기들이 등록된다.

리스트 7-24는 aop. tx와 함께 context 스키마의 태그를 사용할 수 있도록 네임스
페이스와 스키마를 설정해준 설정파일의 앞부분이다. 새롭게 context 스키마의 태그를
사용할 수 있도록 선언했고， 그 중에서 <co
nte
xt
:annotation-config/>를 추가했다.

리스트 7-24 ∞nte.

써 네임스페이스 선언과 annotation-config 태그 설정

<beans xmlns=''http://www.springframework .org/schema/beans''
αlI1te치 스키마에 정의된 태그

xmlns:xsi=''http ://www.w3.org/2ÐÐ1/XMLSchema-instance '' ~ 를 αlI1t얹 네임스떼이스률 통
xmlns :aop=''http://www.springframework .org/schema/aop" 해 사용하도록 정의한다
xmlns:context="http://www.springframework.org/schema/context"
xmlns:tx=''http ://www.springframework.org/schema/tx''

xsi:sche
maLocation=''http:
//새www.s
pnn밍gframeworkκ.org/sc
hema/be
ans

http ://www.springframework .org/schema/beans/spring-beans-3.Ð.xsd
http ://www.springframework .org/schema/aop
http: //www.springframework.org/schema/aop/spring-aop-3.Ð.xsd
http://www.springframework.org/schema/context
http ://www.springframework.org/schema/context/spring-context-3.a.xsd
http ://www.springframework .org/schema/tx
http://www .springframework.org/schema/tx/spring-tx-3.Ð.xsd")

<tx :annotation-driven /)
--을
@Transactional이 붙은 타입과 메소드에 트랜잭션 부가기능을 담은
프록시를 추가하도록 만들어주는 후처리기 등록

<context :annotation-config 1>
--을 코드의 애노테이션을 이용해서 부가적인 빈 실정

또는 초기화 ξ엠을 해주는 후처리기를 등록

<context :annotation-config /> 태그에 의해 등록되는 빈 후처리기는 몇 가지 특별
한 빈 설정에 시용되는 애노테이션을 제공한다. <tx:annotation-driven /> 선언에 의
해 @Transactional을 사용할 수 있었던 것과 비슷하다고 보면 된다.

여기서 사용할 애노테이션은 @PostConstruct
다. @PostConstruct는 java.lang.

annotation 패키지에 포함된 공통 애노테이션Common Annotations의 한 가지로 JavaEE 5
나 JDK6
에 포함된 표준 애노테이션이다. 스프링은 @PostConstruct 애노테이션을 빈
오브젝트의 초기화 메소드를 지정하는 데 사용한다.

리스트 7-25와 같이 @PostConstruct를 초기화 작업을 수행할 메소드에 부여해주면
스프링은 XmlSqlService 클래스로 등혹된 빈의 오브젝트를 생성하고 DI 작업을 마친
뒤에 @PostConstruct가 붙은 메소드를 자동으로 실행해준다. 생성자외는 달리 프로퍼


티까지 모두 준비된 후에 실행된다는 면에서 @PostConstruct 초기화 메소드는 매우 유
용하다.

리스트 7-25 @PostConstruct 초기화 메소드

public class XmlSqlService implements SqlService (

OPostConstruct -α영SqK) 메소드를 빈의 초기회 메소드로 지정한다

public void loadSql() { .. . }

남은 작업은 리스트 7-26과 같이 sqlmapFile 프로퍼티의 값을 sqlService 빈의 설
정에 넣어주는 것이다. sqlmapFile 프로퍼티 값은 XML 파일의 클래스패스로. UserDao
인터페이스의 패키지로부터 상대적으로 지정할 수 있다. 여기서는 UserDao와 같은 클
래스패스에 있으므로 파일 이름만 지정해주면 된다.

리스트 7-26 sqlmapRle 프로퍼티 추가

<bean id="sqlService" class="springbook.user.sqlservice.XmlSqlService")
<property name="sqlmapFile" value="sqlmap.xml" />

</bean)

이제 UserDaoTest 테스트를 돌려보자. 프로퍼티를 통해 이름을 제공받은 XML 파일
은
@PostContruct가달린 loadSql() 메소드에서 읽혀 사용될 것이다. 그림 7-2는스프
링 컨테이너인 애플리케이션 컨텍스트가 XML 설정파일을 읽고 진행하는 작업의 순서
를 보여준다. @PostConstruct 애노태이션은 빈 오브젝트가 생성되고 의존 오브젝트와
설정 값을 넣어주는 DI 작업까지 마친 후에 호출된다. 따라서 @PostConstruct를 단 메
소드의 코드는 모든 프로퍼티의 값이 준비됐다고 가정하고 작성하면 된다.


XML 빈 설정율 읽는다

빈의 오므젝트훌 생성한다

프로떠티에 의존 오브젝트 또는 강율 주입한다

app미야lic떠ationConext
.x
ml

<bean id=‘ ’ class="ClassName" >

<
propeπy name=‘ " value="xyz’ />
<
propeπy name=" ’ ref=‘beanld’ />


빈이나 태그로 둥혹된 후저리기훌 동작시킨다

@PostConstruct
코드에 달린 애노테이션에 대한 부가작업 진행 1-1-내 ------public void initO { ... }

그림 7-2 스프링 컨테이너의 초기 작업 순서

7징-스프링 핵심 기술의 응용 579


7.2.4 변화를 위한 준비: 인터페이스 분리
XmlSqlService는 충분히 잘 만들어졌다고 볼 수도 있겠지만， 스프링의 유연한 확장구
조를 경험한 개발자라면 아직 만족할 수 없어야 정상이다. SQL 서비스 기능에는 아직
확장할 영역이 많이 남아 있다.
현재 XmlSqlService는 특정 포뱃의 XML에서 SQL 데이터를 가져오고， 이를
HashMap 타입의 뱀 오브젝트에 저장해둔다.SQL을가져오는방법에 있어서는특정 기
술에 고정되어 있다. XML 대신 다른 포뱃의 파일에서 SQL을 읽어오게 하려면 어떻
게 해야 할까? 지금 구조에서라면 SqlService 인터페이스를 구현하는 완전히 새로운
클래스를 처음부터 만들거나 XmlSqlService의 코드를 직접 튿어고쳐야 한다.XML에
서 SQL을 가져오는 방법은 바뀌지 않지만， 가져온 SQL 정보를 HashMap 타입 컬렉션
이 아닌 다른 방식으로 저장해두고 이를 검색해서 가져오려면 지금까지 만든 코드를 직
접 고치거나 새로 만들어야 한다. 두 가지 기술의 변화 모두 XmlSqlService 코드를 직
접 수정히는 것을 강제한다. XmlSqlService가 변경되는 이유가 두 가지라면 이는 단일
책임 원칙을 위반히는 셈이다. 그렇다고 한 가지 기술의 변화 때문에 0때 새로운 클래
스를 만들면 상당 부분의 코드가 중복되는 결괴를 초래할 것이다.
SQL을 가져오는 것과 보관해두고 시용하는 것은 충분히 독자적인 이유로 변경 가
능한 독립적인 전략이다. 서로 변하는 시기와 성질이 다른 것， 변하는 것과 변하지 않는
것을 함께 두는 건 바람직한 설계구조가 아니다. 지금까지 해왔듯이 서로 관심이 다른
코드들을 분리하고， 서로 코드에 영향을 주지 않으면서 유연하게 확장 가능하도록 DI를
적용해보자.

책임에 따른 인터페이스 정의
가장 먼저 할 일은 분리 가능한 관심사를 구분해보는 것이다. XmlSqlService 구현을 참
고해서 독립적으로 변경 가능한 책임을 뽑아보자. 두 가지를 생각해볼 수 있다.
첫째는 SQL 정보를 외부의 리소스로부터 읽어오는 것이다. 리소스는 단순한 텍스트
파일일 수도 있고， 미리 정의된 스키마를 가진 XML일 수도 있고， 엑셀 파일일 수도 있
고， DB일 수도 있다. SQL이 담겨 있는 리소스가 어떤 것이든 상관없이 애플리케이션
에서 활용 가능하도록 메모리에 읽어들이는 것을 하나의 책임으로 생각해볼 수 있다.
두 번째 책임은 읽어옹 SQL을 보관해두고 있다가 필요할 때 제공해주는 것이다.
SQL의 양에 따라 다OJ=한 방식의 저장 방법을 생각해볼 수 있다. 키를 이용해 SQL을
검색하는 방법과 성능에 대해서도 여러 가지 고려할 사항이 있다. 아무튼 이 SQL에 대
한 애플리케이션 내의 저장소를 제공하는 것이 두 번째 책임이다.


여기에 좀 더 부가적인 책임을 생각해볼 수 있다. 일단 서비스를 위해서 한 번 가져
온 SQL을 필요에 따라 수정할 수 있게 히는 것이다. 시스템 운영 중에 서버를 재시작하
거나 애플리케이션을 재설치하지 않고도 SQL을 긴급히 변경해야 하는 경우가 있다. 이
를 위해 필요하다면 시용 중인 SQL을 수정하는 기능도 생각해볼 수 었다.

이 두 가지 책임을 어떻게 조합해서 사용할지를 생각해보자. 기본적으로 SqlService
를 구현해서 DAO에 서비스를 제공해주는 오브젝트가 이 두 가지 책임을 가진 오브젝
트와 협력해서 동작하도록 만들어야 한다. 변경 가능한 기능은 전략 패턴을 적용해 별
도의 오브젝트로 분리해줘야 한다.

SqlService 서비스 오브젝트의 구조는 그림 7-3과 같이 만들어질 것이다.DAO 관
점에서는 SqlService라는 인터페이스를 구현한 오브젝트에만 의존하고 있으므로 달라
질 것은 없다. 대신 SqlService의 구현 클래스가 변경 가능한 책임을 가진 SqlReader와
SqlRegistry 두 가지 타입의 오브젝트를 λF용하도록 만든다. 당연히 인터페이스를 이
용하게 하고，
01를 통해 의존 오브젝트를 제공받게 해야 한다. 각 기능의 구현은 지유롭
게 변경할 수 있다. SqlRegistry의 일부 인터페이스는 SqlService가 아닌 다른 오브젝
트가 사용할 수도 있다. 대표적으로 SQL을 런타임 시에 변경하도록 요청하는 오브젝트
가 필요에 따라 이를 호출해서 SQL을 갱신하도록 요청할 수 있다.


SqlService 편햇| SqlReader 터-----칸웰프7
SQL 연경
SqlRegistry SqlUpdater

요정

그림 7-3 SqIService 서비스 오브젝트 구조

인터페이스를 실제로 정의하기 전에 한 가지 생각해볼 사항이 있다. SqlReader
가
읽어오는 SQL 정보는 다시 SqlRegistry
에 전달해서 등록되게 해야 한다. SQL을
SqlReader에서 SqlRegistry로 전달히는 과정과 전달되는 형식을 어떻게 할지 생각해
보자.

SqlReader가 제공하는 메소드의 리턴 타입은 무엇으로 해야 할까? SqlReader는
SQL을 임의의 리소스로부터 가져올 수 있기 때문에 JAXB에서 만들어준 Sql 클래스를
시용하는 건 곤란하다. SqlReader라는 범용적인 인터페이스를 JAXB라는 특정 구현에
의존하도록 정의해서는 안 되기 때문이다. SqlReader가 가져올 내용은 간단하니 간단
히 SQL과 커를 쌍으로 히는 배열을 만들고， 이를 다시 리스트에 담아서 가져오거나 지
금까지 많이 써왔던 방식대로 랩을 이용할 수 있다.

7장-스프링 핵심 기술의 응용 581



SqlReader
가 리소스로부터 읽어온 SQL 정보를 뱀으로 몰려준다고 정의하면
SqlService 구현 클래스에서는 리스트 7-27과 같은 코드가 만들어질 것이다.

리스트 7-'Z1 없IService 구현 클래스 코드

Map(String , String) sqls = sqlReade
r.
readSql();~ ~，~이라는구체적인전송
타입을

강제하게된다

sqlRegistrY .addSqls(sqls);

그런데 이런 방식은 어딘가 번거로워 보인다. SqlReader와 SqlRegistry는 각각
SQL 정보를 읽어 가져오는 방법과 이를 저장해두는 방법의 구체적인 기술과 구현으로
부터 독립적으로 사용 가능하도록 인터페이스로 만들 것이다. 그런데 이 둘 사이에서
정보를 전달하기 위해 일시적으로 Map 타입의 형식을 갖도록 만들어야 한다는 건 불면
하다.JAXB를 쓴 SqlReader라면 Sqlmap과 Sql 타입의 오브젝트로 SQL 정보를 읽어
오는데 이를 다시 Map으로 옮겨 담아서 리턴해줘야 하기 때문이다. 이를 Map 타입으로
SqlRegistry
에 전달했는데 SqlRegistry 내부에서는 2차원 배열로 저장해두는 방식을
시용한다면， 다시 랩에서 배열로 옮기는 과정이 펼요하다. 이렇게 구현 방식이 다양한
두 개의 오브젝트 사이에서 복잡한 정보를 전달하기 위해서는， 전달 과정 중에 일정한
포뱃으로 변환하도록 강제하는 것은 피할수 없는 일일까?

그건 아니다. 발상을 조금 바꿔보면 이러한 번거로움을 제거할 방법을 찾을 수 있
다. SqlService가 일단 SqlReader에게서 정보를 전달받은 뒤. SqlRegistry에 다시 전
달해줘야 할 필요는 없다. SqlService에서 가져옹 SQL 정보를 활용한다면 모를까， 리
스트 7-27에서처럼 두 오브젝트 사이의 정보를 전달히는 것이 전부라면 SqlService
가 중간 과정에서 아예 빠지는 방법을 생각해볼 수도 있다.

SqlService가 SqlReader에게 데이터를 달라고 요청하고， 다시 SqlRegistry에게 이
데이터를 시용하라고 히는 것보다는 SqlReader에게 SqlRegistry 전략을 제공해주면서
이를 이용해 SQL 정보를 SqlRegistry
에 저장하라고 요청히는 편이 낫다.

그렇다면 SqlService의 코드를 리스트 7-28과 같이 비꿀 수 있다.

리스트 7-28 변경된 SqIServi∞ 코드

sqlReader .readSql (sqlRegistry); ~ SQl을 저장할 대상인 sqlRegistry 오브젝트를 전달한다

이때 sqlRegistry가 구현한 인터페이스에는 리스트 7-29와 같이 등록을 위한 메소
드를제공해주면된다.


리스트 7-2fð 둥록 기능을 제공하는 SqIRegistry 메소드

interface SQIRegistry {
Sq
IReader는 읽어들인 SOL을 이 메소드를

void registerSQl(String key , String sQl);
--률 이용해 레지스트리에 저장한다

이렇게 만들어두면 불필요하게 SqlService 코드를 통해 특정 포뱃으로 변환한 SQL
정보를 주고받을 펼요 없이 SqlReader가 직접 SqlRegistry에 SQL 정보를 등록할 수
있다. JAXB를 이용한 구현에서처럼 SQL 정보를 일단 오브젝트로 변환한 후에 사용할
수도 있겠지만， 굳이 SQL을 특정 오브젝트로 변환해둘 필요가 없는 경우라면 리소스에
서 SQL 정보를 순차적으로 읽으면서 바로바로 SqlRegistry
에 등록해도 된다. 이렇게
하면 SqlReader와 SqlRegistry는 각자의 구현 방식을 독립적으로 유지하면서 꼭 필요
한관계만가지고협력해서 일을할수 있는구조가된다.

자바의 오브젝트는 데이터를 가질 수 있다. 자신이 가진 데이터를 이용해 어떻게 작
업해야 할지도 가장 잘 알고 있다. 그렇다면 오브젝트 스스로 자신의 데이터로 충실히
작업하게 만들면 되지， 쓸데없이 오브젝트 내부의 데이터
를 외부로 노출시킬 필요는
없다.

SqlReader는 내부에 갖고 있는 SQL 정보를 형식을 갖춰서 돌려주는 대신， 협력관계
에 있는 의존 오브젝트인 SqlRegistry에게 필요에 따라 등록을 요청할 때만 활용하면
된다. 그림 7-4는 SqlReader가 SqlRegistry와 의존관계를 가지고 작업을 진행하도록
만들었을 때의 구조다. 여기서 SqlReader가 사용할 SqlRegistry 오브젝트를 제공해주
는 건 SqlService의 코드가 담당한다. SqlRegistry가 일종의 콜백 오브젝트처럼 사용
된다고 생각해도 좋다. SqlReader 입장에서는 SqlRegistry 인터페이스를 구현한 오브
젝트를 런타임 시에 메소드 파라미터로 제공받!o
r서 사용하는 구조이니 일종의 묘드에
의한 수동 DI라고 볼 수도 있다. 동시에 SqlRegistry는 SqlService에게 등록된 SQL을
검색해서 돌려주는 기능을 제공하고 있기도 하므로 SqlService의 의존 오브젝트이기도
하다.

SOl을 가져오도록 요정 ,

-~I SqlReader

sqlSe펴기 • SOL
똥

; 화펴 ----">1 SqlRegistry
그림 7-4 Sq
IRegistry어| 의존하는 SqIReader 구조

7장-스프링 핵심 기솔의 응용 583



이제 SqlReader와 SqlRegistry 인터페이스를 정의해보자.

SqIRegistry 인터페이스
SQL을 제공받아 등록해뒀다가 키로 검색해서 돌려주는 기능을 담당하는 SqlRegistry
인터페이스는 리스트 7-30과 같이 정의할 수 있다.

리스트 7-30 혀IRegistry 인터페이스

package springbook.user.sqlservice;

public interface SqlRegistry (
void registerSql(String key , String sql);-SOL올키와힘께등룩한다

키로 SOL올 검색효삐 검색이String findSql(String key) throws SqlNotFoundException;-
실패하연 예외훌 던진다


SQL을 등록하고 검색하는 두 가지 기능을 메소드로 정의하고 있다. 검색의 경우 실
패할 때는 예외를 던지게 했다. 이 예외는 묘드에 버그가 있거나 설정에 문제가 있기 때
문에 발생할 수도 있으니 복구할 가능성이 적다고 판단해서 런타임 예외로 만들었다.
하지만 레지스트리를 여러 개 두는 방식을 사용한다면 한 레지스트리에서 검색이 실패
할 경우 다른 레지스트리에 검색을 시도할 수도 있다. 재시도를 통해 예외를 복구할 수
있는 여지가 있는 셈이다. 따라서 이 메소드를 사용해서 만드는 묘드가 그 기능성을 확
인할 수 있도록 런타임 예외이지만 명시적으로 메소드가 던지는 예외를 선언해두는 편
이좋다.

SqIReader 인터페이스
SqlReader 인터페이스를 정의해보자. SqlReader는 SqlRegistry 오브젝트를 메소드 따
라미터로 DI 받아서 읽어들인 SQL을 등록히는 데 사용하도록 만들어야 한다. 인터페
이스는 리스트 7-31
과 같이 정의할 수 있다.

리스트 7-31 SqIReader 인터페이스

public interface SqlReader (
SOL올 외부에서 가져와 Sq
IRegistrv어l 등록효빠 다양한 여|
void read(SqlRegistry sqlRegistry);~ 외가 발생힐 수 있겠지만 대부분 복구 불가능한 예외이므로
굳이 예외톨 선언해두지 않았다


이제 두 개의 책임에 대한 인터페이스를 모두 정의했다. 이 확장구조를 채택한
SqlService의 구현 클래스는 두 개의 인터페이스 타입 프로퍼티를 갖고 있어서 각각의
구현 오브젝트를 DI 받도록 설정해주면 된다.

7.2.5 자기참조 번으로 시작하기
다중 인터페이스 구현과 간접 참조
SqlService
의 구현 클래스는 이제 SqlReader와 SqlRegistry 두 개의 프로퍼티를 DI
받을 수 있는 구조로 만들어야 한다. 일단 기존에 만들었던 XmlSqlprovider를 이 구조
에 맞게 변경하자. 인터페이스가 총 3개이므로 그림 7-5와 같이 각 인터페이스를 구현
한 클래스 3
개를 만들어야 한다.

~---~ XmlS빼ce }--;:승

그림 7-5 SqIService 서비스의 클래스와 의존관계

XmlSqlService 클래스는 이 세 가지 관심과 책임을 구분 없이 하나의 클래스에 뭉뚱그

려서 만들어놓았던 것이다. 이제 이것을 각 책임에 따라 구분할 차례다. 그런데 그림

7-5
의 의존관계를 가만히 들여다보면 모든 클래스는 인터페이스에만 의존하고 있음을

알 수 있다. 당연히 인터페이스에만 의존하도록 만들어야 스프링의 DI를 적용할 수 있

다. 굳이 DI를 적용하지 않았더라도 자신이 사용히는 오브젝트의 클래스가 어떤 것인지

를 알지 못하게 만드는 것이 좋다. 그래야 구현 클래스를 바꾸고 의존 오브젝트를 변경

해서 자유롭게 확장할 기회를 제공해주는 것이다.

클래스의 코드는 단지 인터페이스에 대해서만 알고 있고， 인터페이스를 통해서만 의

존 오브젝트에 접근한다. 따라서 사용하는 오브젝트가 클래스로부터 만들어진 것인지

관심도 없고 알 필요도 없다. 그저 DI 받은 오브젝트를 시용하기만 하면 된다.

그렇다면 이 세 개의 인터페이스를 하나의 클래스가 모두 구현한다면 어떨까? 자바

는 extends를 이용해 다른 클래스의 구현 내용을 상속하려는 경우에는 하나의 클래스만

7장-스프링 핵심 71솔의 응용 585


상속하게 제한한다. 하지만 인터페이스의 경우는 다르다. 인터페이스는 한 개 이상을
상속하는 것이 허용된다. 잠깐만! 인터페이스는 implements를 이용해 선언하고， 인터페
이스를 구현하는 것이지 상속하는 것이 아니지 않은가? 물론 그렇다. 하지만 인터페이
스도 일종의 상속의 개념으로 생각할 수 있다. 인터페이스 구현은 타입을 상속하는 것
이다. 클래스를 상속히는 것과 마찬가지로 인터페이스를 구현하는 경우에도 구현 클래
스는 인터페이스의 타입을 그대로 물려받는다. 그 덕분에 같은 타입으로 존재하지만 다
른 구현을 가진 오브젝트를 만들 수 있다는 다형성을 활용할 수 있는 것이다. 아무튼 인
터페이스는 한 클래스에서 하나 이상을 구현할 수 있다. 하나의 클래스가 여러 개의 인
터페이스를상속해서 여러 종류의 타입으로서 존재할수 있는것이다.

그렇다면 그림 7-6과 같이 XmlSqlService 클래스 하나가 SqlService. SqlReader.
SqlRegistry
라는 세 개의 인터페이스를 구현하게 만들어도 상관없다. 어차피 기존
XmlSqlService의 코드는 세분화해서 인터페이스를 정의하지 않았을 뿐이지， 이 세 가
지 책임을 모두 갖고 있는 클래스였으니 이 세 개의 인터페이스를 구현하도록 만드는
건어렵지않을것이다.

’----------------------~----------------______ ’

1

; ------------~ XmlSqlService ~ ------------~
구현한 코드는 클래스 자신이기는 하지만
인터페이스훌 통해 접근하도록 인터떼이스
에의존적으로만든다
그림 7냉 세 개의 인터페이스롤 구현하는 XmlSqIService

이제부터 하려고 하는 작업은 책임에 따라 분리되지 않았던 XmlSqlService 클래스를
일단 세분화된 책임을 정의한 인터페이스를 구현하도록 만드는 것이다. 그래서 같은 클
래스의 코드이지만 책임이 다른 코드는 직접 접근하지 않고 인터페이스를 통해 간접적
으로 사용하는 묘드로 변경할 것이다.

인터페이스를 이용한 분리
일단 XmlSqlService는 SqlService만을 구현한 독립적인 클래스라고 생각하자. 그렇다
면 그림 7-6에서 살며본 것처럼 SqlReader와 SqlRegistry 두 개의 인터페이스 타입 오
브젝트에 의존하는 구조로 만들어야 한다.01를 통해 이 두 개의 인터페이스를 구현한
오브젝트를 주입받을 수 있도록 리스트 7-32와 같이 프로퍼티를 정의한다.


리스트 7-32 SQIService의 미 코드

public class XmlSqlService implements SqlService (
‘ private SQIReader sQIReader; 의즌 오브젝트률 g 받을 수 있도록 인터페이스 타입의
private SQIRegistry sQIRegistry; 프로머티로 선언해둔다

public void setSQIReader(SQIReader sQIReader) (
this.sQIReader =sQIReader;

public void setSQIRegistry(SQIRegistry sQIRegistry) {
this.sQIRegistry =sQIRegistry;

다음은 XmlSqlService 클래스가 SqlRegistry를 구현하도록 만들자. 리스트 7-33과
같이 기존의 HashMap을 사용히는 코드는 그대로 유지하지만 SqlRegistry
의 인터페이스
를 구현하는 메소드로 만들어놓는다. sqlMap은 이제 SqlRegistry 구현의 일부가 됐으
므로 SqlRegistry 구현 메소드가 아닌 메소드에서는 직접 사용해선 안 된다. 독립적인
오브젝트라고 생각하고 SqlRegistry
의 메소드를 통해 접근해야 한다.

리스트 7-33 SQIRegistry의 구현 부분

public class XmlSqlService implements SqlService, SQIRegistry (
private Map<String , String> sqlMap = HashMap<String , String>();

외뼈P은 혀IR뼈 구현의 일부기 된q 따라서 외부에(new ) 서 직접 접근할 수 없다 μ

public String findSql(String key) throws SqlNotFoundException (
String sQl =sQIMap.get(key);
if (sql == null) throw new SQINotFoundException(key +

·에 대한 SQL율 참을 수 없습니다");
else return sQl;

HashMapO 1"-1는 저장소를 사용하는
public void registerSQl(String key , String sQl) (
--융 구체적인 구현 방법에서 독립될 수 있

도록 인터페이스의 메소드로 접근하게

sQIMap.put(key, sQl); 해준다


다음은 XmlSqlService 클래스가 SqlReader를 구현하도록 만들 차례다. 기
존엔 초기
화 메소드인 loadSql() 메소드가 XML 파일을 읽어오는 방법과 저장 방법을 모두 알고

낀갖-스프링 핵심 기술의 응용 587


있었다. 이제 어떻게 읽어오는지는 SqlReader의 메소드 뒤로 숨기고， 어떻게 저장해둘
지는 SqlRegistry 타입 오브젝트가 알아서 처리하도록 코드를 변경해보겠다.

먼저 XmlSqlService가 SqlReader를 구현하도록 implements
에 선언해준다.
SqlReader의 구현 메소드는 리스트 7-34와 같이 작성한다. SqlReader를 구현한 묘드
에서 XmlSqlService 내의 다른 변수와 메소드를 직접 참조하거나 사용하면 안 된다. 필
요한 경우에만 적절한 인터페이스를 통해 접근하도록 한다.

리스트 7-34 Sq
l~않der의 구현 부분

public class XmlSqlService implements SqlService , SqlRegistry, SQIReader (

private String sqlmapFile;
public void setSqlmapFile(String sqlmapFile) ( sqlMa야ile은 SqIRe<잉er

구현의 일부가 된

this.sqlmapFile = sqlmapFile; 다‘ 따라서 SqIRe<영g 구현 메소드훌 통하
지 않고는 접근하연 안 된다.

αldSqI( 뻐| 있던 코드톨 SqIReacIer 메소드로 가

져온다 초기회훌 위해 무엇을 할 것인가와 잃L

public void read(SQIRegistry sQIRegistry) (
-용 을 어떻게 읽는지률 분리한다
String contextPath = Sqlmap.class.getPackage().getName();
try (

JAXBContext context =JAXBContext.newlnstance(contextPath);
Unmarshaller unmarshaller = context .createUnmarshaller();
InputStream is = UserDao.class.getResourceAsStream(sqlmapFile);
Sqlmap sqlmap =(Sqlmap)unmarshaller.unmarshal(is);
for (Sq lType sql sqlmap.getSql()) (

sQIRegistry.registerSQl(sQl.getKey(), sQl.getValue());

} catch (JAXBException e) ( SOL 저장 로직 구현에
•
독립적인 인터페이스 메소드톨
throw new RuntimeException(e);
통해 읽어들인 밍냉 키톨 전달효되

마찬가지로 SqlReader
의 구현 코드에서 SqlRegistry 구현 코드로 내부 정보에 접근
하거나 하면 안 된다. 파라미터로 전달받은 SqlRegistry 타입 오브젝트가 사실 자기 자
신이긴 하겠지만， 그래도 다른 오브젝트라고 생각하고 인터페이스에 정의된 메소드를
통해서만 사용해야 한다.

마지막으로 SqlService 인터페이스 구현을 마무리하자. @PostConstruct가 달린 빈
초기
화 메소드와 SqlService 인터페이스에 선언된 메소드
인 getFinder()
를 리
스트
7-35와 같이 sqlReader와 sqlRegistry를 이용하도록 변경한다.


리스트 7-35 SqIService 인터페이스 구현 부분

public class XmlSqlService implements SqlService, SqlRegistry, SqlReader {

öPostConstruct
public void loadSql() {
this.sQIReader.read(this.sQIRegistry);

public String getSql(String key) throws SqlRetrievalFailureException {
try (
return this.sQIRegistry.findSQl(key);

catch(SQINotFoundException e) (
throw new SQIRetrievalFailureException(e);

loadSql()
은 XmlSqlService 구현 방법에 따른 메소드이고 getSql()
은 SqlService
인터페이스의 메소드다. XmlSqlService는 SqlService와 SqlRegistry라는 두 가지
전략을 이용하도록 재구성됐으므로， 이 두 가지 오브젝트를 활용히는 방식으로 코드
를 작성하면 된다. loadSql () 초기화 메소드에서는 sqlReader에게 sqlRegistry를 전
달하면서 SQL를 읽어서 저장해두도록 요청한다. 빈의 초기회를 담당하는 메소드인
loadSql()
로서는 초기화 작업 때 이런 일을 한다는 걸 보여주는 묘드만 있으면 된다.
그것을 어떻게 할지는 DI 받는 sqlReader와 sqlRegistry 오브젝트의 몫이다. getSql()
은 내부 전략인 SqlRegistry 타입 오브젝트에게 요청해서 SQL을 가져오게 하고，
SqlRegistry에서 발생하는 예외를 SqlService 인터페이스에서 정의한 예외로 전환해
주는 기능을 구현하면 된다.

자기참조번설정
지금까지 XmlSqlService 클래스 안에 흔재되어 있던 성격이 다른 코드를 세 가지 인
터페이스를 구현하는 방법을 통해 서로 깔끔하게 분리해냈다. 언제라도 인터페이스
에 맞게 클래스를 분리해도 그만이다. 같은 클래스 안에 구현된 내용이기는 하지만
SqlService의 메소드에서 SQL을 읽을 때는 SqlReader 인터페이스를 통해
.SQL을 찾
을 때는 SqlRegistry 인터페이스를 통해 간접적으로 접근하게 했다. 이제 빈 설정을 통
해 실제 DI가 일어나도록 해야 한다. 클래스는 하나뿐이고 빈도 하나만 등록할 것이지

7장-스프링 핵심 기솔의 응용 589



만， 마치 세 개의 빈이 등록된 것처럼 SqlService 빈이 SqlRegistry와 SqlReader를 주
입받도록만들어야한다.
XML 설정을 리스트 7-36과 같이 수정해보자.

리스트 7-36 자신을 참조하는 sql용rvice 빈 설정

,

<bean id=객qlService
' class="springbook .user.sqlservice .XmlSqlService")

<p때
erty nar멘

<property name="sqlRegistry' ref='sqlService' 1) 프로머티는 자기 자신을 침조
<property name="sqlmapFile" value="sqlmap.xml" /) 할 수 있다-수정자 메소드로
</bean) 주입만
가능하연된다.

빈은 sqlService 하나만 선언했으므로 실제 빈 오브젝트도 한 개만 만들어진다. 스
프링은 프로퍼티의 ref 항목에 자기 자신을 넣는 것을 허용한다. 이를 통해. sqlService
를 구현한 메소드와 초기화 메소드는 외부에서 DI 된 오브젝트라고 생각하고 결국 자신
의 메소드에 접근한다. 인터페이스를 시용하고 DI를 이용하면 이렇게 특별한 구조까지
도 유연하게 구성할 수 있다.

이제 UserDaoTest를 수행해서 결과를 확인해보자.

자기 자신을 참조히는 빈은 사실 흔히 쓰이는 방법은 아니다. 책임이 다르다면 클래

스를 구분하고 각기 다른 오브젝트로 만들어지는 것이 자연스럽다. 다만 자기참조 빈을

만들어보는 것은， 책임과 관심사가 복잡하게 얽혀 있어서 확장이 힘들고 변경에 취약한

구조의 클래스를 유연한 구조로 만들려고 할 때 처음 시도해볼 수 있는 방법이다. 이를

통해 기존의 복잡하게 얽혀 있던 코드를 책임을 가진 단위로 구분해낼 수 있다. 당장 확

장구조를 이용해 구현을 바꿔 사용하지 않더라도 확장구조를 만들어두는 게 좋다고 생

각될 때 가장 간단히 접근할 수 있는 방법이기도 하다. 실제로 스프링이 제공하는 클래

스 중에는 비슷하게 자신의 의존 오브젝트 인터페이스를 스스로 구현하고 자신을 참조

하거나 DI 하는 코드가 제법 있다.

일단 인터페이스를 통해 책임과 역할을 구분해두고 DI를 통해 연결해췄다면 다음 단

계부터는아주쉽다.

7.2.6 디폴트 의존관계
이제 확장 가능한 인터페이스를 정의하고 인터페이스에 따라 메소드를 구분해서 DI가
가능하도록 묘드를 재구성하는 데 성공했다. 다음은 이를 완전히 분리해두고 DI로 조합
해서 사용하게 만드는 단계다.


확장가능한기반클래스
SqlRegistry와 SqlReader를 이용히는 가장 간단한 SqlService 구현 클래스를 만들
어보자. 앞에서 자기참조가 가능한 빈으로 만들었던 XmlSqlService 코드에서 의존 인
터페이스와 그 구현 코드를 제거하기만 하면 된다. 가장 기본이 되는 골격을 가진 기
본 클래스이므로 이름을 BaseSqlService로 하자. 리스트 7-37은 이렇게 만들어진
BaseSqlService 클래스다.

리스트 7-37 혀I~잃der와 Sq
IRegistry를 사용하는 SqIService 구헌 클래스

package springbook.user.sqlservice;

public class BaseSqlService implement5 SqlService (
protected SqlReader sqlReader; ~혀없 æ는 상속을 통해 짧H서 A용하기어| 적햄

뉴→-다 서브클래스에서 띨요한 경우 접근할 수 있도록 protected

protected SqlRegistry sqlRegistry; I 로 선언한다

public void setSqlReader(SqlReader sqlReader) { this.sqlReader = sqlReader; }
public void setSqlRegistry(SqlRegistry sqlRegistry) ( this.sqlRegistry =
sqlRegistry;

tlPostConstruct
public void loadSql() (
this.sqlReader .read(this .sqlRegistry);

public String getSql(String key) throws SqlRetrievalFailureException {
try ( return this.sqlRegistry.findSql(key); }
catch(SqlNotFoundException e) ( throw new SqlRetrievalFailureException(e);


BaseSqlService를 sqlService 빈으로 등록하고 SqlReader와 SqlRegistry를 구
현한 클래스 역시 빈으로 등록해서 01 해주면 된다.01를 적용했으니 언제든지
BaseSqlService의 코드에는 영향을 주지 않은 채로 SqlReader와 SqlRegistry의 구현
클래스는 자유롭게 변경해서 기능을 확장할 수 있다.

리스트 7-38은 HashMap을 이용해 SQL을 저장해두고 찾아주는 기능을 담당했던 코
드를 S띠
Registry를 구현히는 독립 클래스로 분리한 것이다.

7징-스프링 핵심 기술의 응용 591


리스트 7-38 HashMap올 이용하는 SqIRegistry 클래스

package springbook.user.sqlservice;

public class HashMapSqlRegistry implements SqlRegistry {
private Map<String , String) sqlMap = new HashMap<String , String)();

public String findSql(String key) throws SqlNotFoundException {
String sql = sqlMap.get(key);
i f (sql == null)

throw new SqlNotFoundException(key + .를 이용해서 SQL올 장을 수 없습니다");
else return sql;

public void registerSql(String key , String sql) { sqlMap.put(key, sql);}

다음은 JAXB를 이용해 XML 파일에서 SQL 정보를 읽어오는 코드를 SqlReader 인
터페이스의 구현 클래스로 독립시킬 차례다. XmlSqlService에 있던 sqlmapFile 프로퍼
티는 SqlReader에서 필요하다. 리스트 7-39와 같이 JaxbXmlSqlReader 클래스로 만들
어두자.

리스트 7-39JAXB를 사용하는 SqIReader 클래스

package springbook.user.sqlservice;
public class JaxbXmlSqlReader implements SqlReader {

private String sqlmapFile;-융 sq뼈pFile은 Sq
IRe<잉g의 특정 구현 빙법에 종속되는 프로떠티가 된다‘

public void setSqlmapFile(String sqlmapFile) { this.sqlmapFile = sqlmapFile; }
public void read(SqlRegistry sqlRegistry) {

. _ XmISqIService어|서 시용했던 JAX8
AA톨 이용해 잉L을 읽어오는 코드 생략

클래스를 분리했으니 각각의 빈 설정도 필요하다. 기존의 자신을 참조하도록 설정되
어 있던 sqlService 빈을 별도로 등록한 두 개의 빈을 참조하도록 리스트 7-40과 같이
수정한다.


리스트 7-40 혀IReader와 SqIRegistry의 독립적인 빈 설정

<bean id=갱qlService
“ class="springbook. user .sqlservice.BaseSqlService")
<property name="sqlReader" ref=“ sqlReader" /) 독립시킨 reader. registry 빈을
<:property name="sqlRegistry" ref="sqlRegistry" /) 참조하도록
ref
수정
</bean)

<be원하
id
sql
Reader"
c
lass="닝해따다때
야
찌따
싸댄
퍼없뼈바씨nl
lSq
lReader"’

an 순="닝띠
때
’ 뎌
sprin
k.user.sqlservice.laxbx삐
띠
때안

뼈
찌뻐
19φboo
Xm내
〈φp따ro때perty name="sqlmapFile" value="sqlmap.xml'’ /)
</bean>

<be원하뻐
id
찌띠
매따얀
class
sprinl띠
야씨
찌따
하
대
Hassh1삐뻐뼈며따
따얀
’

an 하='“'sqlRegistry.’. 뎌없얀="닝따
gboo
user.sqlservice
.l꺼
야
MapSqlRegis
tryγy"

피
때
때
k.l
뻐{삐빼
〈이/bean>

이제 태스트를 돌려보자.

디폴트 의존관계를 갖는 빈 만들기
BaseSqlService는 sqlReader와 sqlRegistry 프로퍼티의 DI를 통해 의존관계를 자유
롭게 변경해가면서 기능을 확장할 수 있다. 유연성을 보장하려면 이런 구조가 콕 펼요
하지만， 반대로 적어도
3
개의 빈을등록해줘야한다는점이 귀찮게 느껴지기도한다.
이렇게 확장을 고려해서 기능을 분리하고， 인터페이스와 전략 패턴을 도입하고，
DI
를 적용한다면 늘어난 클래스와 인터페이스 구현과 의존관계 설정에 대한 부담은 감
수해야 한다. 설령 한동안은 JAXB를 시용하는 SqlReader와 HashMap으로 저장해두는
SqlRegistry를 사용할 것이 분명하다고 해도 말이다. 특정 의존 오브젝트가 대부분의
환경에서 거의 디폴트라고 해도 좋을 만큼 기본적으로 시용될 기능성이 있다면， 디폴트
의존관계를 갖는 빈을 만드는 것을 고려해볼 필요가 있다.
디폴트 의존관계란 외부에서 DI 받지 않는 경우 기본적으로 자동 적용되는 의
존관계를 말한다. 리스트 7-41
은 미리 설정된 디폴트 의존 오브젝트를 갖는
DefaultSqlService 클래스다.

리스트 7-띠 생성자를 통한 디폴트 의존관계 설정


package springbook .user.sqlservice;

public class DefaultSqlService extends BaseSqlService {
public DefaultSqlService() {

7장-스프링 핵심 기술의 응용 593


setSqlReader(new JaxbXmlSqlReader());

생성지에서 디를트 의존 오브젝트를 직접

setSqlRegistry(new HashMapSqlRegistry()); 만들어서 스스로 이 해준다‘

DI 설정이 없을 경우 디폴트로 적용하고 싶은 의존 오브젝트를 생성자에서 넣어준
다.
DI
란 클라이언트 외부에서 의존 오브젝트를 주입해주는 것이지만 이렇게 자신이 사
용할 디폴트 의존 오브젝트를 스스로 DI 하는 방법도 있다. 이렇게 코드를 통해 의존관
계의 오브젝트를 직접 주입해주면 특별히 DI가 필요한 상황이 아닌 대부분의 경우에는
편리하게 사용할 수 있다.

리스트 7-40에서처럼 3개의 빈을 정의하고 프로퍼티로 연결해야 했던 설정을 리스
트 7-42와 같이 한 줄로 바꿀 수 있다.

리스트 7-42 디폴트 의존관계 빈의 설정

<bean id="sqlService" class="springbook.user.sqlservice.DefaultSqlService" />

DefaultSqlService
의 디폴트 의존관계를 그대로 사용하겠다면 이것으로 충분하다.

이제 태스트를 돌려보자. 디폴트로 생성자에서 넣어준 JaxbXmlSqlReader와
HashMapSqlRegistry를 이용해 DefaultSqlService가 멋지게 통작할 것 같지만 실은 태
스트가모두실패한다.

이유가 뭘까? 이는 DefaultSqlService 내부에서 생성하는 JaxbXmlSqlReader
의
sqlmapFile 프로퍼티가 비어 있기 때문이다. sqlmapFile
이 없으면 SQL을 읽어올 대상
을 알 수 없으므로 예외가 발생한다. 문제는 JaxbXmlSqlReader를 독립적인 빈으로 설
정했을 때와 달리 디폴트 의존 오브젝트로 직접 넣어줄 때는 프로퍼티를 외부에서 직접
지정할 수 없다는 점이다. 빈으로 등록되는 것은 DefaultSqlService뿐이다.

이 문제를 해결할 수 있는 방법이 몇 가지 있다. 하나는 sqlmapFile
을
DefaultSqlService의 프로퍼티로 정의히는 방법이다. 일단 DefaultSqlService가
sqlmapFile을 받아서 내부적으로 JaxbXmlSqlReader를 만들면서 다시 프로퍼티로 넣어
주는 것이다. 기억이 날지 모르겠지만 템플릿을 살펴볼 때 JdbcTemplate
이 펼요로 하
는 DataSource 프로퍼티를 UserDao가 대신 DI 받아서， 직접 JdbcTemplate을 만들면서
프로퍼티로 넣어췄던 방법이 있다. 클래스 내부에서 의존 오브젝트를 직접 생성히는 방
법을 쓸 때 유용하게 활용할 수 있다.


외부 클래스의 프로퍼티로 정의해서 전달받는 방법 자체는 나쁘지 않지
만 DefaultSqlService
에 적용하기에는 적절치 않다. 그 이유는 이
름 그대로
JaxbXmlSqlReader는 디폴트 의존 오브젝트에 불과하기 때문이다. 디폴트라는 건 다른
명시적인 설정이 없는 경우에 기본적으로 λF용하겠다는 의미다. 반면에 설정이 있다면
디폴트는 무시된다. DefaultSqlService는 JaxbXmlSqlReader를 디폴트 의존 오브젝트
로 갖고 있을 뿐이기 때문에 이를 사용할 수도 있고 안 할 수도 있다. 따라서 반드시 펼
요하지도 않은 sqlmapFile을 프로퍼티로 등록해두는 건 바람직하지 못하다.

그렇다면， 이런 방법은 어떨까? JaxbXmlSqlReader
는 DefaultSqlService
의
sqlReader로서 대부분의 경우 그대로 사용해도 좋을 구현이기 때문에 디폴트 의존 오
브젝트로 만든 것이다. 마찬가지로 sqlmapFile의 경우도 JaxbXmlSqlReader에 의해 기
본적으로 사용될 만한 디폴트 값을 가질 수 있지 않을까? SQL 파일 이름을 매번 바꿔
야 할 필요도 없고， 관례적으로 사용할 만한 이름을 정해서 디폴트로 넣어주면 어떨까?
그렇게 하면 DefaultSqlService의 디폴트 의존 오브젝트가 되는 JaxbXmlSqlReader는
디폴트 sqlmapFile 이름도 갖고 있게 되므로 별다른 설
정 없이 그대로 사용 가능하다.
sqlmapFile 프로퍼티에 디폴트 값을 주면 JaxbXmlSqlReader를 직접 빈으로 등록해서
사용할 때도 유용할 것이다.

리스트 7-43과 같이 JaxbXm
lSqlReader의 sqlmapFile에 디폴트 파일 이름을 넣어주자.

리스트 7-43 디롤트 값올 갖는 JaxbXmlSqIReader

public class JaxbXmlSqlReader implements SqlReader (
private static final String DEFAULT_SQLMAP_FILE = .sqlmap.xml";~

굳이 상수로 만들지 않고 바로

pri vate String sqlmapFi le =DEFAULT_SQLMAPJILE; sqlmapFile의 값으로 넣어도
상관없지만 이렇게 해주연 의

r률
sqlmapFile 프로떠티를 지정히연 지정된 따일
도돼가 코또꽤드돼돼에| 분
| L옆짧調영얽웹히
드려댁러레나t

이 사용되고， 아니리연 디를트로 넣은 따일이
코드도톰이난다

사용된
다

public void setSqlmapFile(String sqlmapFile) { this.sqlmapFile = sqlmapFile; }


이제 테스트를돌려보자. 드디어 성공이다.

DI를 사용한다고 해서 항상 모든 프로퍼티 값을 설정에 넣고， 모든 의존 오브젝트
를 빈으로 일일이 지정할 펼요는 없다. 먼저 BaseSqlService와 같이 의존 오브젝트를
DI 해줌으로써 기능의 일부를 자유롭게 확장해줄 수 있는 기반을 만들어둬야 하지만，
DefaultSqlService
처럼 지주 사용되는 의존 오브젝트는 미리 지정한 디폴트 의존 오브
젝트를 설정 없이도 사용할 수 있게 만드는 것도 좋은 방법이다.

F당-스프링 핵심 기술의 응용 595


DefaultSqlService는 SqlService를 바로 구현한 것이 아니라 BaseSqlService를
상속했다는 점이 중요하다. DefaultSqlService는 BaseSqlService의 sqlReader와
sqlRegistry 프로퍼티를 그대로 갖고 있고， 이를 이용해서 원한다면 언제든지 일부 또
는 모든 프로퍼티를 변경할 수 있다. 디폴트 의존 오브젝트 대신 사용하고 싶은 구현 오
브젝트가 있다면 리스트 7-44와 같이 설정에 프로퍼티를 추가해주면 된다. 설정하지
않은 부분은 디폴트가 사용된다.

리스트 7-44 디풀트 의존 오브젝트 대신 사용할 빈 선언

<bean id=닝qlService" class=“ springbook .user .sqlservice .DefaultSqlService" >
(property name="sqlRegistry" ref="ultraSuperFastSqlRegistry. />

</bean>

그런데 디폴트 의존 오브젝트를 사용하는 방법에는 단점이 한 가지 있다. 설정을 통
해 다른 구현 오브젝트를 사용하게 해도 DefaultSqlService는 생성자에서 일단 디
폴트 의존 오브젝트를 다 만들어버린다는 점이다. 리스트 7-44처럼 설정했다고 해
도 DefaultSqlService
의 생성자에서 HashMapSqlRegistry 오브젝트가 만들어진다.
물론 프로떠티로 설정한 빈 오브젝트로 바로 대체되긴 하겠지만 사용되지 않는 오브
젝트가 만들어진다는 점이 조금 꺼림칙하긴 하다. 하지만 디폴트 의존 오브젝트를 갖
게 했을 때의 장점이 크기 때문에 오브젝트가 하나쯤 더 만들어지는 부담은 무시할 수
도 있다. 그러나 디폴트로 만드는 오브젝트가 매우 복잡하고 많은 리소스를 소모한다
면 디폴트 의존 오브젝트가 。뼈 만들어지지 않게 하는 방법을 쓸 수 있다. 예를 들어
@PostConstruct 초기화 메소드를 이용해 프로퍼티가 설정됐는지 확인하고 없는 경우에
만 디폴트 오브젝트를 만드는 방법을 시용하면 된다.

아무튼 이렇게 해서 디폴트 의존 오브젝트와 값을 이용해 설정을 간단하게 해주고
미리 준비된 기능을 손쉽게 사용할 수 있으면서도 펼요한 부분은 언제든지 확장 가능
한 구조를 갖는 빈으로 만들었다.


[ [18] 서비스추상화적용 챈
l

JaxbXmlSqlReader는 좀 더 개선하고 발전시킬 부분이 있다. 크게 다음 두 가지 과제를

생각해볼수있다.

• 자바에는 JAXB 외에도 다%탤 XML과 자바오브젝트를 매핑하는 기술이 있다. 필요에 따
라 다른 기술로 손쉽게 바꿔서 사용할 수 있게 해야 한다 .
• XML 파일을 좀 더 다양한 소스에서 가져올 수 있게 만든다. 현재는 UserDao 클래스와 같
은 클래스패스 안에서만 XML을 읽어올 수 있다. 이것을 임의의 클래스패스나 파일 시스템
상의 절대위치 또는 HTTP 프로토콜을 통해 원격에서 가져오도록 확장할 수는 없는가 하는
점이다.
7.3.1 OXM 서비스 추상화
JAXB가 비록 JavaSE와 JavaEE 표준에 포함되어 있긴 하지만 JAXB 외에도 실전에서
자주 사용되는 XML과 자바오브젝트 매핑 기술이 있다. 대표적으로 다음 네 가지를 들
수있다.

• Castor XML: 설정파일이 필요 없는 인트로스펙션 모드를 지원하기도 하는 매우 간결하고
가벼운 바인딩 프레임워크다.
• JiBX: 뛰어난 퍼포먼스를 자랑하는 XML 바인딩 기술이다.
• Xml8eans: 아파치 XML 프로젝트의 하나다.XML의 정보셋을 효과적으로 제공해준다.
• Xstream: 관례를 이용해서 설정이 없는 바인딩을 지원하는 XML 바인딩 기술의 하나다.
JAXB뿐 아니라 이 네 가지 XML/자바오브젝트 바인딩 기술도 독자적으로 발전해

왔고 다양한 프로젝트와 기업에서 많이 시용되고 있다. 이렇게 XML과 자바오브젝트를
매핑해서 상호 변환해주는 기술을 간단히 OXMObject-XML Mapping이라고도 한다.

OXM 프레임워크와 기술들은 기능 변에서 상호 호환성이 있다. JAXB를 포함해서
다섯 가지 기술 모두 시용 목적이 동일하기 때문에 유사한 기능과 API를 제공한다. 기
능이 같은 여러 가지 기술이 존재한다는 이야기가 나오면 떠오르는 게 있다. 바로 서

비스 추상화다. 로우레벨의 구체적인 기술과 API
에 종속되지 않고 추상화된 레이어와

API를 제공해서 구현 기술에 대해 독립적인 코드를 작성할 수 있게 해주는 서 비스 추상

화가필요하다.

스프링은 트랜잭션， 메일 전송뿐 아니라 OXM
에 대해서도 서비스 추상화 기능을 제

7징-스프링 핵심 기술의 응용 597


공한다. 스프링이 제공하는 OXM 추상 계층의 API를 이용해 XML 문서와 오브젝트
사이의 변환을 처리하게 하면， 코드 수정 없이도 OXM 기술을 자유롭게 바꿔서 적용할
수 있다. 추상 인터페이스를 제공하기 때문에 태스트를 작성하기도 편리하다.

OXM 서비스 인터페이스
스프링이 제공하는 OXM 추상화 서비스 인터페이스에는 자바오브젝트를 XML로 변환
하는 Marshaller와， 반대로 XML을 자바오브젝트로 변환히는 Unmarshaller가 었다.

SqlReader는 이 중에서 Unmarshaller를 이용하면 된다.
리스트 7-45
의 Unmarshaller 인터페이스를 살펴보자.

리스트 7-45 Unmarshaller 인터페이스

package org. springframework .oxm; _ sprir빙-{)xm 모율 안에 정의되어 있다
import javax.xml.transform.Source;

-해당 클래스로 언마실이 가능한지 확인해준다

public inte떠ce Unmarshaller ( ~률 별로 A땅할 일은 없다
boolean supports(Class(?> clazz);
「매밍 실때 시 추상회된 예외를 던진다

서브클래스에 좀 더 세분화되어 있다

Object unmarshal(Source source) throws IOException , XmlMappingException;

~~::e를 통해 제공받은 XML을 자비오브젝트

트리로 변환해서 그 루트 오브젝트를 돌려준다

Unmarshaller 인터페이스는 아주 간단하다.XML 파일에 대한 정보를 담은 Source

타입의 오브젝트를 주면， 설정에서 지정한 OXM 기술을 이용해 자바오브젝트 트리로

변환하고， 루트 오브젝트를 돌려준다.

OXM 기술에 따라 Unmarshaller 인터페이스를 구현한 다섯 가지 클래스가 있다. 각
클래스는 해당 기술에서 필요로 하는 추가 정보를 빈 프로퍼티로 지정할 수 있게 되어
있다.

JAXB
구현 테스트
앞에서 만들었던 학습 태스트인 JaxbTest를 스프링의 OXM 서비스 추상화 인터페이스
를이용하도록만들어보자.
JAXB를 이용하도록 만들어진 Unmarshaller 구현 클래스는 Jaxb2Marshaller다. 그
런데 지금 펼요한 건 언마살러인데 왜 Marshaller라는 이름을 가진 클래스를 사용할
까? Jaxb2Marshaller 클래스는 Unmarshaller 인터페이스와 Marshaller 인터페이스를


모두 구현하고 있기 때문이다. 이름은 대표적으로 Marshaller라고 했지만 언마살러로
도 사용할 수 있다. Jaxb2Marshaller 클래스를 빈으로 등록하고 바인딩 클래스의 패키
지 이름을 지정하는 프로퍼티인 contextPath만 넣어주면 된다.

OxmTest-context.xml 따일을 만들고 리스트 7-46과 같이 JAXB 언마살러를 등록
한 빈 설정을 만들어주자.

리스트 7-46JAXB용 Unmarshaller 빈 설정

<?xml version="1.0" encoding="UTF-8"?)

<beans xmlns=‘’ http://www.spr ingframework .org/schema/beans''
xmlns:xsi=“ http://www.w3.org/2001/XMLSchema-instance ''
xs i :schemaLocation=''http://www.springframework.org/schema/beans
http ://www .springframework .org/schema/beans/spring-beans-3.0.xsd")

<bea히n 피
nars
a
11er"‘. ’
매띠
하삐맨|매애
자
없
재
야h념
’"

id=피nm뻐
야h념따
c1ass="org.sprin1gframework.oxxmι.jaxb.Jaxb2Mars
a11er"
φroφp야erty name="contextPath'’ value=‘ springbook.user.sQlservice.jaxb" />
</bean>
</beans)

unmarshaller 빈은 Unmarshaller 타입이다. 따라서 스프링 컨텍스트 테
스트의
@Autowired를 이용해 Unmarshaller 타입의 인스턴스 변수를 선언해주면 빈을 가져올
수 있다. 스프링의 서비스 추상화가 적용됐으므로 JaxbTest에서처럼 로우레벨의 JAXB
API를 사용해서 컨텍스트를 만들어 언미잘러를 생성하는 등의 복잡한 코드를 작성할
펼요가 없다. 추상 인터페이스인 Unmarshaller
의 unmarshal() 메소드를 한 번 호출해
주기만 하면 모든 번거로운 작업은 Jaxb2Marshaller 빈이 알아서 진행해줄 것이다.

리스트 7-47에 나와 있는 태스트 코드를 한번 살펴보자. 태스트 내용은 JaxbTest와
마찬가지로 미리 준비한 간단한 sqlmap.xml 파일을 읽어와 내용을 확인하는 것이다.
다만 OXM 추상화 API를 사용했으므로 XML을 읽어서 오브젝트로 변환하는 것은 단
두 줄이면 충분하다. Source 타입으로 가져올 파일을 지정하는 것 하나와 Unmarshaller
오브젝트의 unmarshal( ) 메소드를 호출하는 것이 전부다. 보기 좋게 두 줄로 했을 뿐이
지 변수 선언을 없애고 한 줄로 만들 수도 있다.

JaxbTest에서 사용했던 태스트용 sqlmap.xml 파일을 같은 패키지에 복사하고 테스
트를실행해보자.


낀~-스프링 핵심 기술의 응용 599


리스트 7-470XM 언마살링 테스트 코드

package springbook .learningtest.spring .oxm;

import org
.
springframework
.
oxm
.
Unmarshaller;~
~~ 애 용에서 사용하는 언마살러와 클래스 이륨이

같으므로 임포트힐 때 주의해야 흔κf

import javax.xml.transform.stream.StreamSource;

@R unWith(SpringJUnit4ClassRunner .class)
1πt
e
x
tConfiguration
클래스 이름 + ’-conte에.xml" 따일율 A사t용용a하}는는 애울리케이션

@(
on따댄야
컨텍스트로 E똘어서 테스트가 사용할 수 있게 해훈다

public class OxmTest (
@Autowired Unmarshaller unmarshaller;

스프링 테스트가 테스트용 애을리케이선 컨돼스트에서 Unmars떠
ller 인터페이스

@Test 타입의 빈올 찾아서 테스트가 * 시작되기 전에 이 번수에 넣어준다
public void unmarshallSqlMap() throws XmlMappingException , IOException (
Source xmlSource = new StreamSource(

getCla
ss
(
).
getResourceA
s
Stream(
갱
qlmap
.x
ml"));

L을 InαrtSt
rearη을 이용하는 Soun∞ 타입의 St
n않마ìouræ훌 만든다

SQlmap sQlmap = (SQlmap) this.unmarshaller.unmarshal(xmlSource);

L. 어떤 OXM 기술이든 언D냉은
List<SqlType> sqlList = sqlmap.getSql(); 이한줄이연끝이다‘
assertThat
(s
qlLi
s
t
.
size
()~ is(3)) ;

assertThat( sqlList .get(8). getKey() , is ( "add ")) ;

assertThat( sqlList .get(2 ). getValue (), is ("delete'’ ));

JaxbTest외 동일하게 sqlmap.xml 따일의 내용올

정확히 가져왔는지 검사한다

".후7~휠 라이브러리
org.spri때Ira
meWOl1<.oxm-3.0.7.R타5엉E.원r

태스트를 마쳤다면 OxmTest 코드를 다시 한번 살펴보자. 이 태스트 코드 어디에도
JAXB라는 구체적인 기술에 의존하는 부분은 없다.OXM 추상화 계층을 이용했으니

당연한 일이다. 따라서 OXM 기술을 JAXB가 아닌 다른 것으로 바꿔도 태스트 묘드는
전혀 수정할 게 없다.
XML의 빈 설정만 변경해주연 된다.

Castor 구현 테스트
이번엔 Castor로 OXM 기술을 바꿔보자. Castor에서 펼요한 매핑정보가 준비됐다면
unmarshaller 빈 설정만 바꿔주면 된다.


Castor는 여러 가지 XM
L!오브젝트 변환 방법을 지원히는데， 그중에서 간단하게
정의해서 사용할 수 있는 XML 매핑파일을 이용해보자. 매핑정보만 적절히 만들어
주변 어떤 클래스와 필드로도 매핑이 가능하기 때문에 JAXB 컴파일러가 만들어췄던
Sqlmap. Sq lType 클래스를 Castor 매핑용으로 사용해도 된다.

리스트 7-48은 Castor에서 사용할 매핑정보를 담은 XML을 만들어본 것이다.
mapping.xml이라는 이름으로 저장해두자.

리스트 7-48 Castor용 매핑정보

<?xm1 version="1.0"?>
<!DOCTYPE mapping PUBLIC "-//EXOLAB/Castor Mapping DTD Version 1.0//EN"
''http://castor.org/mapping.dtd''>
<mapping>

<class name=갱pringbook
.
sq1service
.
jaxb.Sq1map">
<map-to xm1=재q1map" />
<fie1d name="sq1" type="springbook. sq1service. j axb. SqlType"

required='’true" co띠llection=녀rray싸list'’"
<bin때d-xmnil 매
sq
node=갯
1ement"

1띠
지째삐띠
n
am
e=딛”닝쩍띠1" />

</fie1d>
</class>
<class name="springbook.sq1service.jaxb.Sq1Type'’>

<map-to xm1="sq1" />
<fie1d name="key" type=깨
trηg" required=“ true">

<bind-xm1 name="key" node=녀
ttribute" />
</fie1d>
<fie1d name="value" type="string' requ띠Jired=냥’'true
‘

1띠
씨따
de="text" >

<bin때d-xxm떼nil no여
/>
</fie1d>
</class>
</mapping>


다음은 설정파일의 unmarshaller 빈의 클래스를 Castor용 구현 클래스로 변경한다.
mappingLocation 프로퍼티에는 준비된 Castor용 매핑따일의 위치를 지정해준다.

리스트 7-49
C뚱tor 기술을 사용히는 언마살러 설정

<bean id="unmarsha11er" Unmars떠l
ler 인터페이스훌 Caslα API를 이용해서 구현한 클래스

4

class=
“
org
.
springframework
.
oxm
.
castor.CastorMars야h념aller'’”’

〈따때
name='mappingLocation'

φp
ro
perty

value='springbook/learningtest/spring/oxm/mapping.xml' />

</bean>

7장-스프링 핵심 기술의 응용 601


*후7t할라이브러리
com.spnng없Jræ.α9.castα.-1.2.
0.jar

태스트를 실행해보자. 테스트 내의 언마살러를 이용하는 묘드는 전혀 바뀌지 않았지
만 XML 파일을 읽어서 변환하는 기술은 Castor로 완벽하게 전환됐다. 서비스 추상화
는 이렇게 로우레벨의 기술을 필요에 따라 변경해서 사용하더라도 일관된 애플리케이
션 코드를 유지할 수 있게 해준다.

또한 스태틱 메소드나 팩토리 메소드를 샤용하는 JAXB나 Castor API와 달리 인터
페이스와 DI를 통해 언마살러를 이용하기 때문에 손쉽게 태스트용 Unmarshaller로 대
체할 수도 있다. SqlService를 이용하는 DAO를 테스트하고 싶긴 한데 아직 매핑따일
이 준비되어 있지 않았다거나 어떤 OXM 기술을 λF용할지 결정하지 못했을 수도 있다.
이런 경우엔 일단 테스트용으로 Unmarshaller 인터페이스를 구현해서 미리 준비된 오
브젝트를 돌려주게 할 수도 있다. 테스트용 클래스를 만들 것도 없이 Mockito로 목 오
브젝트를 만들어 사용해도 좋을 것이다.

7.3.2 OXM 서비스 추상화 적용
이제 스프링의 OXM 추상화 기능을 이용하는 SqlService를 만들어보자. 이름은
OxmSqlService라고 하고 SqlRegistry는 DI 받을 수 있게 만들지만 SqlReader는 스프
링의 OXM 언미잘러를 이용하도록 OxmSqlService 내에 고정시켜야 한다.SQL을 읽는
방법을 OXM으로 제한해서 사용성을 극대화하는 게 목적이다.
SQL
을 가져오는 방법이 스프링의 OXM 추상화 방식으로 고정된다면
OxmSqlService 클래스 내에 OXM 코드를 직접 넣어도 될까? 물론 그럴 수도 있다. 하
지만 OxmSqlService가 OXM 기술에 의존적이라고 해서 꼭 OXM 코드를 직접 갖고 있
을 필요는 없다. 이미 S띠
Reader와 SqlRegistry라는 두 개의 전략을 활용히는 구조를
적용해봤으므로， 이를 그대로 유지하되 SqlReader 구현 오브젝트에 대한 의존관계를
고정시켜버리는 방법을 생각해볼 수 있다. 이왕이면 구현 클래스를 OxmSqlService가
내장하게 히는 것도 좋겠다.

멤버 클래스를 참조하는 통합 클래스
OxmSqlService는 BaseSqlService와 유사하게 SqlReader 타입의 의존 오브젝트를 사
용하되 이를 스태틱 뱀버 클래스로 내장하고 자신만이 사용할 수 있도록 만들어보


'---------->1
•
--각 인터페이스의 구현 클래스훌 빈으로
등록하고 OxmSql'---------->1
•
--각 인터페이스의 구현 클래스훌 빈으로
등록하고 OxmSql
자. 의존 오브젝트를 자신만이 시용하도록 독점하는 구조로 만드는 방법이다. 내장된
SqlReader 구현을 외부에서 사용하지 못하도록 제한하고 스스로 최적화된 구조로 만들
어두는 것이다. 밖에서 볼 때는 하나의 오브젝트로 보이지만 내부에서는 의존관계를 가
진 두 개의 오브젝트가 깔끔하게 결합돼서 사용된다. 유연성은 조금 손해를 보더라도
내부적으로 낮은 결합도를 유지한 채로 응집도가 높은 구현을 만들 때 유용하게 쓸 수
있는방법이다.

그림 7-7은 SqlReader 구현을 내장하고 있는 OxmSqlService의 구조를 보여준다.

않Nlce가 므로떠티로

침조하게한다‘

그림 7-7 Oxm
Sq
IReader를 앨버로 강는 OxmSqISeNice 클래스 구조

언마살러 빈은 스프링이 제공해주니 구현할 필요는 없다. SqlRegistry는 일단 가장 단
순한 HashMapSqlRegistry를 디폴트 의존 오브젝트로 등록해둔다. 단순한 오브젝트이
므로 디폴트로 만들어두고 필요하면 프로퍼티로 DI 해서 바꿔서 사용하면 된다.

OxmSqlService와 OxmSqlReader는 구조적으로는 강하게 결합되어 있지만 논리적으
로 명확하게 분리되는 구조다. 자바의 스태틱 뱀버 클래스는 이런 용도로 쓰기에 적합
하다.

클래스의 기본 구조는 리스트 7-50에서 볼 수 있다.

리스트 7-50 OxmSql않M∞ 71본 구조


package springbook.user .sQlservice;

public class OxmSQlService implements SQlService (
private final OxmSQIReader oxmSQlReader = new OxmSQIReader();

나 !뻐l이므로 변경 물7념하Cf. Oxm혀빼g와 OxmSq
lR짧er는 행}거|

결합돼서 하나의 빈으로 등록되고 한 번에 설정할 수 있다

pr뻐te class OxmSQIReader implements SQIReader {--.

αivate 엉
버 클래스로 정의한다. 툴레빌 클래스인
OxmSqlService만
01 사용할 수 있다

낀~-스프링 핵심 기술의 응용 603


OxmSqlReader는 private 멤버 클래스이므로 외부에서 접근하거나 사용할 수 없
다. 또한 OxmSqlService는 이를 final로 선언하고 직접 오브젝트를 생성하기 때문에
OxmSqlReader를 DI 하거나 변경할 수 없다. 이렇게 두 개의 클래스를 강하게 결합하고
더 이상의 확장이나 변경을 제한해두는 이유는 무엇일까? 그것은 OXM을 이용하는 서
비스 구조로 최적화하기 위해서다. 하나의 클래스로 만들어두기 때문에 빈의 등록과 설
정은 단순해지고 쉽게 사용할 수 있다.

스프링의 OXM 서비스 추상화를 사용하면 언마살러를 빈으로 등록해야 한다.
SqlService를 위해 등록할 빈은 자꾸 늘어난다. 편리한 확장과 유연한 변경을 위해서
클래스를 분리하고 빈을 따로 등록해 DI 할 수 있도록 기본 구조를 가져간 것은 좋지
만， 자꾸 늘어나는 빈의 개수와 반복되는 비슷한 DI 구조가 불편하게 느껴질 수도 있다.
SqlService를 설계하고 개발하고 발전시켜야 히는 입조에서는 가능한 한 분리하고 유

연하게 확장할 수 있게 만드는 것이 중요하지만 실제로 이를 적용해 DAO를 개발히는
애플리케이션 개발자 입장에서는 SqlService를 시용하기 위해 많은 빈을 등록하는 게

부담이될수있다.
빈의 개수를 줄이고 설정을 단순하게 하는 방법에는 BaseSqlService를 확장해서 디
폴트 설정을 두는 방법도 있다. 하지만 이 디폴트 의존 오브젝트를 만들어주는 방식

의 한계는 디폴트로 내부에서 만드는 오브젝트의 프로퍼티를 외부에서 지정해주기가

힘들다는 점이다. 그래서 DefaultSqlService
의 경우에는 내부에서 디폴트로 만드는
JaxbXmlSqlReader도 디폴트 값만을 갖도록 만들었다. 반면에 OXM을 적용히는 경우
는 언마살러를 비롯해서 설정을 통해 DI 해줄 게 많기 때문에 SqlReader 클래스를 단순
한 디폴트 오브젝트 방식으로는 제공해줄 수 없다.

이런 경우에는 하나의 빈 설정만으로 SqlService와 SqlReader의 펼요한 프로퍼티

설정이 모두 가능하도록 만들 필요가 있다. 그래서 SqlService의 구현이 SqlReader의

구체적인 구현 클래스가 무엇인지도 알고 자신의 프로퍼티를 통해 펼요한 설정정보도

넘겨주고， 심지어 멤버 클래스로 소유도 하고 있는 강한 결합 구조를 만드는 방법을 사
용하는것이다.

그림 7-8은 하나의 빈 설정으로 두 개의 오브젝트를 설정하는 구조를 보여준다.
OxmSqlService로 등록한 빈의 프로퍼티 일부는 OxmSqlService 내부의 OxmSqlReader
프로퍼티를 설정해주기 위한 창구 역할을 한다.


여
칩조빈

。x
mSqlService


생성，
DI DI 설정 값
DI


맴버 짐조 통합 클래스 단얼화된 설정 인
터페이스
그림 7-8 멤버 클래스톨 참조하는 통합 클래스

OxmSqlReader는 외부에 노출되지 않기 때문에 OxmSqlService에 의해서만 만들어지고，
스스로 빈으로 등록될 수 없다. 따라서 자신이 DI를 통해 제공받이야 히는 프로퍼티가
있다면 이를 OxmSqlService의 공개된 프로퍼티를 통해 간접적으로 DI 밭F아야 한다.

리스트 7-51은 OxmSql
Service의 프로퍼티를 통해 내장된 뱀버 클래스의 프로퍼티
를 설정해주는 코드다. OxmSqlReader는 OXM을 사용하므로 Unmarshaller가 펼요하
다. 또한 매핑파일도 외부에서 지정할 수 있게 해줘야 한다. 이 두 개의 펼요한 정보를
OxmSql
Service의 프로퍼티로 정의해두고 이를 통해 전달받게 만든 것이다.

리스트 7냉1 내부 오브젝트의 프로퍼티룰 전달해주는 코드

public class OxmSqlService implements SqlService (
private final OxmSqlReader oxmSqlReader = new OxmSqlReader();

public void setUnmarshaller(Unmarshaller unmarshaller) (
this.oxmSQlReader.setUnmarshaller(unmarshaller);

public void setSQlmapFile(String sQlmapFile) (
this .oxmSQlReader .setSQlmapFile(sQlmapFile) ;

뚫IR
짧로전달만
할뿐
I
Cf

private class OxmSqlReader implements SqlReader {
private Unmarshaller unmarshaller;
private String sQlmapFile;
11 setter 메소드 생략

OxmS이Service의 공개된 프
로떠티훌 통해 미 받은 것을

내 그대로 엠버 클래스의 오브
젝트에 전딜한다 이 setter
들은 딘일 빈 설징구조률 위
한칭구역할을
할
뿐이다


7장-스프링 핵심 기술의 응용 605


이 방법은 앞서 UserDaoJdbc 안에서 JdbcTemplate을 직접 만들어 시용할 때 적용했
던 것과 비슷하다. UserDaoJdbc는 스스로 DataSource 프로퍼
티가 펼요하지 않지만 자
신의 프로퍼티로 DataSource를 등록해두고 이를 DI 받아서 JdbcTemplate을 생성하면
서 전달해준다. OxmSqlService가 UserDaoJdbc와 다른 점은 JdbcTemplate은 한 개의
프로퍼티만 있으면 되기 때문에 setDataSource() 메소드에서 JdbcTemplate 오브젝트
를 생성하고 DataSource를 전달히는 작업을 한 번에 진행했다는 것이다. OxmSqlReader
의 경우 두 개의 프로퍼티가 필요하기 때문에 어느 수정자 메소드에서 오브젝트를 생성
해야 할지 모른다. 스프링이 어떤 순서로 프로퍼티를 설정해줄지 알 수 없기 때문이다.
그래서 미리 오브젝트를 만들어두고 각 수정자 메소드에서는 DI 받은 값을 넘겨주기만
한다.

또한 JdbcTemplate은 그 자체로 독립적으로 빈으로 만들 수도 있고 여러 DAO에서
사용 가능한 최상위 레벨 클래스이지만 OxmSqlReader는 OxmSqlService에서만 시용하도
록 제한한 뱀벼 클래스라는 점에서 차이가 있다.

리스트 7-52는 완성된 OxmSqlService 클래스다
. SqlService를 구현한 부분은 앞
에서 SqlReader와 SqlRegistry를 이용하도록 만든 BaseSqlService와 다를 바 없다.
SqlReader를 DI 받을 수 없게 내부에 고정시켜두긴 했지만 SqlReader 인터페이스를 이
용한다는 면에서는 바뀐 게 없기 때문이다.

리스트 7냉2 완성된 OxmSqIServi∞ 클래스

public class OxmSqlService implements SqlService {
private final OxmSqlReader oxmSqlReader = new OxmSqlReader();

oxrnSqlReader
와 달리 단지 디올트 오브젝트로 만들어진
「
τr 프로떠티다‘ 따라서 필요에 따라 DI훌 통해 교치| 가능하다
private SqlRegistry sqlRegistry = new Hash
삐
apSqlRegistry();

public void setSqlRegistry(SqlRegistry sqlRegistry) { this.sqlRegistry =
sqlRegistry; }

public void setUnmarshaller(Unmarshaller unmarshaller) { ... }
public void setSqlmapFile(String sqlmapFile) { ... }

「... SqIService 인터페이스에 대한 구현 코드는 BaseSqIService와 같다‘
lIPostConstruct
public void loadSql() { this.oxmSqlReader.read(this.sqlRegistry); }

public String getSql(String key) throws SqlRetrievalFailureException {
try { return this.sqlRegistry.findSql(key); }
catch(SqlNotFoundException e) { throw new SqlRetrievalFailureException(e); }


private class OxmSqlReader implements SqlReader (
private Unmarshaller unmarshaller;
private final static String DEFAULT_SQLMAP_FILE = 닝
qlmap.xml";
private String sqlmapFile =DEFAULT_SQLMAP_FILE;

public void setUnmarshaller(Unmarshaller unmarshaller) (
this.unmarshaller = unmarshaller;

public void setSqlmapFile(String sqlmapFile) { this .sqlmapFile =
sqlmapFile; }

public void read(SQIRegistry sQIRegistry) {
try (
Source source =new StreamSource(
UserDao.class.getResourceAsStream(this.sQlmapFile));
SQlmap sQlmap = (SQlmap)this.unmarshaller.unmarshal(source);

4~X~~"'-~를 통해 전달받은 0)애 인터페이스 구현
오브젝트률 가지고 언마실링 직범 수행

for(SQlType sQl : sQlmap.getSQl()) (
sQIRegistry.registerSQl(sQl.getKey() , sQl.getValue());

} catch (IOException e) (
throw new IllegalArgumentException(this.sQlmapFile +

·올 가져올 수 없습니다.， e); I 언마살
ξ엉중
m
에러가났다연설정을통해제공
| 받은 XML 따일 이름이나 정보가 잘못됐을 가능성
L‘ 이 제일 높다 이런 경우에 가장 적합한 런타임 예
외 중 하나인 Il
lega
lArgurrent당∞αion9.로 포징해
서던진다


이제 OXM을 적용했음에도 빈 설정은 여전히 단순하게 유지할 수 있게 됐다. 어차
피 OXM 기술을 지정하고 그에 따른 설정이 필요한 언마살러 빈은 따로 필요한 것이
고， 그 외의 SqlService와 OXM 언마살러를 사용히는 SqlReader 그리고 SqlRegistry
는 하나의 빈을 등록하는 것으로 충분하기 때문이다. SqlRegistry는 필요에 따라 다른
구현으로 교체할 수도 있다.

OxmSqlService를 빈으로 등록하고 JAXB 언마살러를 사용하도록 설정해보면 리
스트 7-53과 같이 두 개의 빈으로 충분할 것이다. OxmSqlService의 프로퍼티 중
unmarshaller와 sqlmapFile은 내부의 OxmSqlReader가 사용할 것이다. 이 중에서
sqlmapFile은 지정하지 않았다. OxmSqlReader의 디폴트 값을 사용해도 되기 때문이다.
파일 이름이 다른 경우만 지정해주면 된다.

얻~ 스프링 핵심 기솔의 응용 607


리스트 7-53
0XM올 적용한 SqIService 설정

<bean id=깨qlService" class=닝
pringbook
.
user.sqlservice
.
OxmSqlService’‘〉
<property name="unmarshaller" ref="unmarshaller" />

</bean>

<bean id="unmarshaller" class="org. springframework .oxm. jaxb. Jaxb2Marshaller'>
<property name="contextPath" value='springbook.user.sqlservice. jaxb" />

</bean>

추상화된 OXM 적용이라는 큰 기술적 변화가 있었지만 설정은 여전히 깔끔하고 이
해하기도좋다.

테스트를 돌려보고 이상이 없는지 확인해보자.

위임을 이용한 BaseSq
IService의 재사용
OxmSqlService는 SqlReader를 스태틱 멤버 클래스로 고정시켜서 OXM
에 특화된 형태
로 재구성했기 때문에 설정은 간결해지고 의도되지 않은 방식으로 확장될 위험이 없다.
그런데 한 가지 좀 꺼림칙한 부분이 있다. loadSql ()과 getSql()
이라는 SqlService
의 핵심 메소드구현코드가
BaseSqlService와동일하다는점이다. 프로퍼티 설정을통
한 초기화 작업을 제외하면 두 가지 작업의 묘드는 BaseSqlService와 OxmSqlService
양쪽에 중복된다. 워닥 간단한 내용이니 이 정도의 중복은 무시할 수도 있을 것이다. 만
약 BaseSqlService 코드를 재사용한답시고 이를 상속해서 OxmSqlService를 만들면 멤
버 클래스로 통합시킨 OxmSqlReader를 생성하는 묘드를 넣기가 애매하다. 또는 중복을
제거하기 위해 loadSql()
과 getSql() 메소드를 추출해서 슈퍼클래스로 분리하는 방법
도 있겠지만， 이 정도 코드로는 복잡한 계층구조로 만들기도 부담스럽다.
그래서 이런 경우에는 그냥 간단한 코드의 중복쯤은 허용하고 BaseSqlService와는
독립적으로 OxmSqlService를 관리해나가도 크게 문제 될 것은 없어 보인다.
그런데 이 두 개의 중복되는코드를 가진 loadSql()
과
getSql() 메소드의 작업이 꽤
나 복잡하다면 어떨까? 그래서 코드의 양도 많고 변경도 자주 일어난다면? 그렇다면 코
드의 중복은 심각한 문제가 될 수도 있다. loadSql ()과 getSql ()의 수정이 펼요할 때마
다 양쪽을 함께 변경해야 하니 부담도 되고 실수할 가능성도 높아진다.
물론 아직은 그런 수준은 아니지만 그래도 미래를 대비한다는 의미에서 중복된 코
드를 제거할 방법을 생각해보자. 이런 경우에는 위임 구조를 이용해 코드의 중복을
제거할 수도 있다. loadSql ()과 getSql()
의 구현 로직은 BaseSqlService에만 두고，


OxmSqlService는 일종의 설정과 기본 구성을 변경해주기 위한 어랩터 같은 개념으로
BaseSqlService의 앞에 두는 설계가 기능하다.
OxmSqlService
의 외형적인 틀은 유지한 채로 SqlService
의 기능 구현은
BaseSqlService로 위임히는 것이다.

위입구조라면 프록시를 만들 때 사용해봤다. 위임을 위해서는 두 개의 빈을 등록하
고 클라이언트의 요청을 직접 받는 빈이 주요한 내용은 뒤의 빈에게 전달해주는 구조
로 만들어야 한다. 하지만 OxmSqlService와 BaseSqlService를 위임구조로 만들기 위
해 두 개의 빈을 등록히는 것은 불편한 일이다. 부가기능 프록시처럼 많은 타깃에 적용
할 것도 아니고， 특화된 서비스를 위해 한 번만 사용할 것이므로 유연한 DI 방식은 포기
하고 OxmSqlService와 BaseSqlService를 한 클래스로 묶는 방법을 생각해보자. 마치
OxmSqlReader를 OxmSqlService
에 내장하고 있는 것과 마찬가지 방법을 사용하면 된다.

그림 7-9는 이렇게 만들어진 위입구조다. 의존관계가 조금 복잡해 보일지 모르겠지
만 OxmSqlService 자체는 OXM
에 최적화된 빈 클래스를 만들기 위한 틀이라고 생각하 면 이해하기 쉬울 것이다.

,_____ ________________L _______________________ _

작업 위임 ‘ ’ ‘ (-)

i

i

그림 7-9 위임을 통한 BaseSq
IService의 재사용

OxmSqlService는 OXM 기술에 특화된 SqlReader를 멤버로 내장하고 있고， 그에 필
요한 설정을 한 번에 지정할 수 있는 확장구조만을 갖고 있다. 실제 SqlReader와
SqlService를 이용해 SqlService의 기능을 구현히는 일은 내부에 BaseSqlService를
만들어서 위임할 것이다.

BaseSqlService
에 대한 위임 방식으로 OxmSqlService를 수정한 코드는 리스트
7-54와같다.

얻it 스프링 핵심 기술의 응용 609

초

써

서

짧

활 ￡。

總

뼈

ι@

E

다

때핸책미

α 기

동


리스트 7-54 BaseSq
l않rvice.로의 위임을 적용한 OxmSqI용rvl∞

public class OxmSqlService implements SqlService (
private final BaseSqlService baseSqlService =new BaseSqlService();
L융 혀ßervi않의 실제 구현 쁨을 위입할 대상인 없seSq
I않rv옳
인스턴스 변수로 정의해둔다

@PostConstruct

public void loadSql( ) (
this.baseSqlService.setSqlReader(this.oxmSqlReader);
this.baseSqlServlce.setSqlRegistry(thiS.sqlRegistry);

OxmSq
lSeαice의 프로퍼티률 통해서 초기화된
this.baseSqlService.loadSql(); 혀Reader와 혀IRegist
r;를 실제 작업을 위입
나 SQl을 둥록핸 초기화 직엽을
할 대상인 αlSeSq앓VI∞어| 주입한다

αlSeSq
I않이
g어| 위임효다

public String getSql(String key) throws SqlRetrievalFailureException (
return this.baseSqlService.getSql(key);

4
SOL을 찾아오는 작업도 벼seSq
l않rvice에 위임한다

이렇게 위임구조를 이용하면 OxmSqlService
에 있던 중복 코드를 깔끔하

게 제거할 수 있다. SqlReader와 SqlRegistry를 활용해 SqlService를 제공하

는 코드는 BaseSqlService
에만 유일하게 존재한다. 이와 관련된 로직이 변경되면

BaseSqlService만 수정해주면 된다.

이제 테스트를 돌려보고 기능이 정상적으로 동작하는지 검증해보자. 성공한다면

OXM 추상화를 도입히는 첫 단계는 마무리한 것이다. 아직은 끝이 아니다.

7.3.3 리소스 추상화
지금까지 만든 OxmSqlReader나 XmlSqlReader에는 공통적인 문제점이 있다.SQL 매핑
정보가 담긴 XML 파일 이름을 프로퍼티로 외부에서 지정할 수는 있지만 UserDao 클래
스와 같은 클래스패스에 존재히는 파일로 제한된다는 점이다. 예를 들어 클래스패스 루
트 등에 있는 XML 파일을 읽으려면 어떻게 해야 할까? 또는 상대적인 클래스패스가
아니라서버나 개발시
스뱀의 특정 폴더에 있는파일을 읽을수는 없을까? 더 나아가서
서블릿 컨텍스트의 상대적인 폴더나 http, ftp 프로토콜로 접근할 수 있는 웹상의 리소
스 파일을 가져올 수는 없을까? 어차피 XM,L 포뱃의 문서이면 되는데 특정 클래스패스
로제한할이유는없다.
안타깝게도 자바에는 이렇게 다OJ=한 위치에 존재하는 리소스에 대해 단일화된 접근
인터페이스를 제공해주는 클래스가 없다. 그나마 URL을 이용해 웹상의 리소스에 접근


할 때 사용할 수 있는 java.net.URL 클래스가 있을 뿐이다. 이 URL 클래스는 http. ftp.
file과 같은 접두어
prefix를 지정할 수 있어서 다양한 원격 리소스에 접근이 가능하다는
장점이 있다. 하지만 자바의 클래스패스 안에 존재하는 리소스나 서블릿 컨텍스트의 리
소스 또는 임의의 스트림으로 가져올 수 있는 리소스를 지정하는 방법이 없다는 점과
리소스 파일의 존재 여부를 미리 확인할 수 있는 기능이 없다는 단점이 있다.

기존 OxmSqlReader는 클래스패스로부터 리소스를 가져오기 위해 ClassLoader 클
래스의 getResourceAsStream() 메소드를 사용했다. 이를 파일 시스템이나 웹상
의 HTTP를 통해 접근 가능한 파일로 바꾸려면 URL 클래스를 사용하도록 묘드를
변경해야 한다. 또한 서블릿 컨텍스트 내의 리소스를 가져오려면 ServletContext
의 getResourceAsStream()
을 사용해야 한다. 사실 리소스를 가져오면 최종적으로
InputStream 형태로 변환해서 사용하겠지만 리소스의 위치와 종류에 따라서 다른 클
래스와 메소드를 사용해야 한다는 점이 불편하다.

이것도 역시 목적은 동일하지만 사용법이 각기 다른 여러 가지 기술이 존재하는 것
이라고 생각할 수 있다. 그렇다면 OXM과 마찬가지로 서비스 추상화를 적용할 수 있지
않을까? 여러 가지 종류의 리소스를 어떻게 단일 인터페이스와 메소드로 추상화할지
는 고민해봐야겠지만， 아무튼 리소스에 접근할 수 있는 통일된 방법이 있다면 좋을 것
이다. 이를 이용해 OxmSqlReader가 sqlmapFile을 읽어오는 묘드를 작성해두면， 묘드의
변경 없이도 다양한 소스로부터 SQL 뱀 파일을 가져오게 할 수 있다.

리소스
스프링은 자바에 존재하는 일관성 없는 리소스 접근 API를 추상화해서 Resource라는
추상화 인터페이스를 정의했다. 일단 리스트 7-55
에 나와 있는 Resource 인터페이스
를살펴보자.

리스트 7-55 R않αJrce 인터페이스


package org .springframework .core.io;
public interface Resource extends InputStreamSource (

boolean exists();

리소스의 존재나 읽기 가능한지 여부를 확인할 수 있다 또 현재

boolean isReadable();
리소스에 대한 입력 스트림이 열려 있는지도 확인 가능하다

boolean isOpen();

얻*-스프링 핵심 기술의 응용 611


URL getURL() throws IOException;
_
JDK의 URL URI. File 형태로 전환 가능한URI getURI() throws IOException; 리소스에
사용된다
File getFile() throws IOException;

Resource createRelative(String relativePath) throws IOException;

long lastModified() throws IOException;

리소스에 대한 이름과 부가적인 정보훌String getFilename(); 제공한다
String getDescription();

public interface InputStreamSource (
InputStream getlnputStream() throws IOException; --률 모든 리소스는 InpulSlream

형태로기져올수있다

애플리케이션 컨텍스트가 사용할 설정정보 파일을 지정히는 것부터 시작해서 스프
링의 거의 모든 API는 외부의 리소스 정보가 펼요할 때는 항상 이 Resource 추상화를
이용한다.

그렇다면 어떻게 임의의 리소스를 Resource 인터페이스 타입의 오브젝트로 가져올
수 있을까? 리소스를 사용하려면 매번 빈으로 등록해야 할까? 물론 그렇지 않다. 다른
서비스 추상화의 오브젝트외는 달리 Resource는 스프링에서 빈이 아니라 값으로 취급
된다. 리소스는 OXM이나 트랜잭션처럼 서비스를 제공해주는 것이 아니라 단순한 정
보를 가진 값으로 지정된다.

그래서 추상회를 적용하는 방법이 문제다. 빈으로 등록한다면 리소스의 타입에 따라
서 각기 다른 Resource 인터페이스의 구현 클래스를 지정해주면 된다. HTTP로 가져올
리소스라면 HttpResource 같은 클래스가 만들어져서 이를 빈의 클래스로 지정하는 것
이다. 하지만 Resource는 빈으로 등록하지 않는다고 했으니 기껏 외부에서 지정한다고
해봐야 (property>의 value 애트리뷰트에 넣는 방법밖에 없다. 하지만 value 애트리뷰
트에 넣을 수 있는 건 단순한 문자열뿐이다.

리소스로더
그래서 스프링에는 URL 클래스와 유사하게 접두어를 이용해 Resource 오브젝트를 선
언하는 방법이 있다. 문자열 안에 리소스의 종류와 리소스의 위치를 함께 표현하게 해
주는 것이다. 그리고 이렇게 문자열로 정의된 리소스를 실제 Resource 타입 오브젝트로


변환해주는 ResourceLoader를 제공한다. ResourceLoader도 구현이 다oð할 수 있으므
로 리스트 7-56과 같은 인터페이스로 정의해뒀다.

리스트 7-56 R，앉;ou
rceLoader 인터페이스

package org.springframework.core .io;
public interface ResourceLoader {

IocatKJn에 담긴 스트링 정보훌 바탕으로

Resource getResource (String location);
--을
그에 적절한 Resource로 변환해준다

표 7-1은 ResourceLoader가 인식하는 접두어와 이를 이용해 리소스를 표현한 예를
보여준다. 접두어가 없는 경우에는 리소스 로더의 구현 방식에 따라 리소스를 가져오는
방식이 달라진다. 하지만 접두어를 붙여주면 리소스 로더의 종류와 상관없이 접두어가
의미히는 위치와 방법을 이용해 리소스를 읽어온다.

표 7-1 ResourceL∞der가 처리하는 접두어의 예

| 접두어 예 | 설명

1 1

file: file:/C
끼emp/file.txt 파일 시스템의 C:!temp 폴더에 있는 file.txt를 리소
스로만들어준다.
classpath: classpath:file.txt 클래스때스의 루트에 존재하는 file.txt 리소스에 접
근하게해준다.
。aA4sIa그 WEB-INF/test.dat 접두어가 없는 경우에는 ResourceLoader
구현에 따라 리소스의 위치가 결정된다
.
Se
rvletResourceLoader
라면 서블릿 컨텍스트의 루
트를 기준으로 해석한다.
hllp: h미얘1끼111φpα:끼끼/ν/www.myserver.
com/test.dat HTIP 프로토콜올 사용해 접근할 수 있는 웹상의 리
소스를 지정한다. ftp:
도 사용할 수 있다


ResourceLoader
의 대표적인 예는 바로 스프링의 애플리케이션 컨텍스트다. 애
플리케이션 컨텍스트가 구현해야 하는 인터페이
스
인 ApplicationContext
는
ResourceLoader 인터페이
스를 상속하고 있다. 따라서 모든 애플리케이션 컨텍스트는
리소스로더이기도하다.

스프링 컨테이너는 리소스 로더를 다양한 목적으로 시용하고 있기 때문이다. 예
를 들어 애플리케이션 컨텍스트가 사용할 스프링 설정정보가 담긴 XML 파일도 리소
스 로더를 이용해 Resource 형태로 읽어온다. 그 밖에도 애플리케이션 컨텍스트가 외

F앙-스프링 핵심 기술의 응용 613


부에서 읽어오는 모든 정보는 리소스 로더를 시용하게 되어 있다. 또한 빈의 프로퍼티
값을 변환할 때도 리소스 로더가 자주 사용된다. 스프링이 제공히는 빈으로 등록 기능
한 클래스에 파일을 지정해주는 프로퍼티가 존재한다면 거의 모두 Resource 타입이다.
Resource 타입은 빈으로 등록하지 않고 <property) 태그의 value를 사용해 문자열로
값을 넣는데， 이 문자열로 된 리소스 정보를 Resource 오브젝트로 변환해서 프로퍼티에
주입할 때도 애플리케이션 컨텍스트 자신이 리소스 로더로서 변환과 로딩 기능을 담당

한다.

만약 myFile이라는 이름의 프로퍼티가 Resource 타입이라고 하면， 다음과 같은 식으
로 접두어가 붙은 리소스 문자열을 사용할 수 있다는 뭇이다. 각각 클래스패스와 따일
시스랩， 웹 서버의 리소스를 지정히는 것이다.

<property name="myFile" va lue=“ classpath:com/epril/myproject/myfile .txt" />

<property name="myFile" va lue="file:/data/myfi le .t xt" />

<property name="myFile'’ value=.. http://www.myserver.com/test.dat .. />

myFile 프로퍼티 입장에서는 추상화된 Resource 타입의 오브젝트로 전달받기 때문
에 리소스가 실제로 어디에 존재히는 어떤 종류인지 상관없이 동일한 방법으로 리소스
의 내용을 읽어올 수 있다.

Resource를 이용해 XML 파일 가져오기

이제 OxmSqlService에 Resource를 적용해서 SQL 매핑정보가 담긴 파일을 다OJ=한 위

치에서 가져올 수 있게 만들어보자.

일단 스트링으로 되어 있던 sqlmapFile 프로퍼티를 모두 Resource 타입으로 바문다.
그리고 이름도 sqlmap으로 변경한다. 목 파일에서 읽어오는 것은 아닐 수도 있기 때문
이다. Resource 타입은 실제 소스가 어떤 것이든 상관없이 getlnputStream( ) 메소드를
이용해 스트림으로 가져올 수 있다. 이를 StreamSource 클래스를 이용해서 OXM 언마
살러가 필요로 히는 Source 타입으로 만들어주면 된다.

리스트 7-57은 Resource를 적용한 OxmSqlService 코드다.

리스트 7-'57 Re:

없Jrce 적용

public class OxmSqlService implements SqlService {

public void setSQlmap(Resource sQlmap) (
이릉과 타입을 모두 변경한다 큰 변화긴
this.oxmSQlReader.setSQlmap(sQlmap); 하지만 그만큼 기능올 확~하고 유연성
올 얻는 것이니 과감하게 변경한다


private class OxmSqlReader implements SqlReader (
private Resource sqlmap = new ClassPathResource("sqlmap.xml" ,
UserDao.class); 니 디폴트 따일은 기존과 같지만 뼈|는 Resource

! 클래스인 C
IassPathResoun∞률 이용한다
SOL 매핑정보 소스의 타입올

Re없Jr∞로 변경한디

public void setSqlmap(Resource sqlmap) (
this.sqlmap = sqlmap;

public void read(SqlRegistry sqlRegistry) {
try (
Source source = new StreamSource(sqlmap.getlnputStream());

4 리소
스의 종류에 상관없이
} catch (IOException e) ( 스트림으로 가져올 수 있다

throw new IllegalArgumentException(this.sqlmap.getFilename()

+ "올 가져올 수 없습니다"， e);
Resource를 사용할 때는 Resource 오브젝트가 실제 리소스는 아니라는 점을 주의해
야 한다. Resource는 단지 리소스에 접근할 수 있는 추상화된 핸들러일 뿐이다. 따라서
Resource 타입의 오브젝트가 만들어졌다고 해도 실제로 리소스가 존재하지 않을 수 있다.

기존의 sqlmapFile과 마찬가지로 sqlmap 리소스도 디폴트를 설정해준다. UserDao와
같은 클래스패스 안의 sqlmap.xml 파일을 클래스패스 리소스로 지정해주면 된다. 코드
에서 클래스패스 리소스를 바로 지정하고 싶다면 ClassPathResource를 사용해 오브젝
트를만들면된다.

반면에 문자열로 지정할 때는 리소스 로더가 인식할 수 있는 문자열로 표현해주변
된다. 예를 들면 리스트 7-58과 classpath : 접두어를 사용해 클래스패스의 리소스를
표현할수있다.

리스트 7-58 classpath: 접두어톨 이용해 지정한 리소스


<bean id="sqlService" class=견
pringbook
.
user.sqlservice.OxmSqlService")
<property name="unmarshaller" ref="unmarshaller" /)
<property name="sqlmap" value="classpath :springbook/user/dao/sqlmap.xml" 1)

</bean) C않S떠h
는 디롤트이뾰 생략 캠하다 클래스때스 위치훌
」→-지정할 때는 클래스때스 루트부터 절대위치훌 적어야 한다.

7징-스프링 핵심 기슐의 응용 615


클래스패스 대신 파일 시스템의 특정 위치에 있는 파일을 읽어오고 싶다면 리스트
7-59와 같이 변경해주변 된다. classpath:
를 사용했을 때는 클래스패스 루트로부터
상대적인 위치지만 file
:
을 시용하면 따일 시스렘의 루트 디렉토리로부터 시작하는 파
일위치를나타낸다.

리스트 7• 59 file: 접두어훌 이용해 지정한 리소스

<bean id="sqlService" class="springbook . user .sqlservice.OxmSqlService")
<property name=’ unmarshaller" ref="unmarshaller ‘ /)
(property name=‘ sqlmap" value="file:/opt/resources/sqlmap.xml" 1)

</bean)

또는 리스트 7-60과 같이 HTTP 프로토콜로 접근 가능한 웹 리소스를 가져올 수도
있다.

리스트 7• 30 따TP로 접근 가능한 리소스

<bean id=닝qlService" class=갱pringbook.user.sqlservice.OxmSqlService")
<property name="unmarshaller' ref="unmarshaller" /)
φroperty name="sqlmap" value="http ://www.epril.com/resources/sqlmap.xml.’ 1>

</bean)

공개적인 웹 서버에서 SQL 정보를 가져올 일이야 아마도 없겠지만， 기업의 DB 관
련 정보를 관리히는 내부 서벼가 있다면 SQL 정보를 HπP 프로토콜로 가져올 수 있
게 하는 건 좋은 방법이다.

이렇게 스프링의 리소스 추상화를 이용하면 리소스의 위치와 접근 방법에 독립적인
코드를 쉽게 만들 수 었다. 스프링 애플리케이션에서 파일을 읽거나 참조하는 기능을
만들 때는 Resource 타입의 추상화 기능을 사용하자.

IrÆ~ 인터페이스 상속을 통한 안전한 기능확장 •

원칙적으로 권장되진 않지만 때로는 서버가 운영 중인 상태에서 서버를 재시작하지 않
고 긴급하게 애플리케이션이 사용 중인 SQL을 변경해야 할 수도 있다. 운영시간 중에
예상하지 못한 SQL의 오류를 발견했다거나， 아니면 특별한 이유로 SQL 조건이나 참
조 태이블을 급하게 변경할 수도 있다.

616


지금까지 만든 SqlService 구현 클래스들은 초기에 리소스로부터 SQL 정보를 읽어
오면 이를 메모리에 두고 그대로 사용한다. SQL 매핑정보 파일을 변경했다고 해서 메
모리상의 SQL 정보가 갱신되진 않는다. 굳이 방법이 있다면 서버를 재시작하거나 웹
애플리케이션을 리로딩해서 다시 SqlService 구현 빈을 초기화히는 것이다.

애플리케이션을 새로 시작하지 않고 특정 SQL의 내용만을 변경하고 싶다면 어떻게
해야 할지 생각해보자.SQL 정보의 실시간 변경이라는 기능을 추가하려면 지금까지 만
들고 다듬어왔던 SqlService 구현 클래스는 물론이고 핵심 인터페이스까지 뜸어고쳐야
할지도 모르겠다. 기능의 변경 또는 추가에 대응하는 방법은 상황어나 조건에 따라 달
라질 수 있다. 여기서는 기존에 설계하고 개발했던 기능이 발전돼야 할 경우에 스프링
답게 접근하는 방법이 무엇인지를 살펴볼 것이다.

7.4.1 미와기능의확장
지금까지 적용해왔던 DI는 특별한 기술이라기보다는 일종의 디자인 패턴 또는 프로그
래밍 모델이라는 관점에서 이해하는 것이 더 자연스럽다. 그래서 단지 스프링과 같은
DI 프레임워크를 적용하고 빈 설정파일을 이용해 애플리케이션을 구성했다고 해서 DI
를 바르게 활용하고 있다고 볼 수는 없다.DI의 가치를 제대로 얻으려면 먼저 DI에 적
합한 오브젝트 설계가 필요하다.

미를의식하는설계
모든 기능을 클래스 하나 안에 마구 섞어서 SqlService 구현 클래스를 만들었다면， 지
금까지 진행했던 다양한 기능의 확장이 기능했을까? 새로운 기술을 적용하고， 추가된
요구사항을 만족시키고， 설정이 좀 더 편리하게 만들려고 할 때마다 클래스 전부를 이
리저리 묻어고쳐야 히는 매우 비효율적이고 골치 아픈 작업에 시달려야 했을 것이다.
하지만 초기부터 SqlService의 내부 기능을 적절한 책임과 역할에 따라 분리하고，
인터페이스를 정의해 느슨하게 연결해주고 DI를 통해 유연하게 의존관계를 지정하도
록 설계해뒀기 때문에 그 뒤의 작업은 매우 쉬워졌다. 오브젝트들이 서로의 세부적인
구현에 얽매이지 않고 유연한 방식으로 의존관계를 맺으며 독립적으로 발전할 수 있게
해주는 DI 덕분이다. 결국 유연하고 확장 가능한 좋은 오브젝트 설계와 DI 프로그래밍
모댈은 서로 상승작용을 한다.
스프링을 이용해 DI를 적용하는 건 어떻게 생각하면 매우 간단한 일이다. 시용할 오
브젝트를 직접 만드는 대신 프로퍼티로 정의하고 XML 빈 설정을 이용해 주입받도록

7징-스프링핵심
71술의응용 617


설정히는 방법을 배우는 데는 몇 시간이면 충분하다. 스프링 컨테이너를 띄우고 XML
설정파일을 사용하게 만들고자 할 때， 복잡한 API를 시용해야 한다거나 어려운 기술이
필요하지 않다. 오브젝트 주입을 위한 수정자 메소드를 만드는 일은 자바 개발자라면
누구나 할 줄 안다.XML 설정을 만들 때 사용할 태그도 몇 개 되지 않는다. 그래서 01
는알고보니 별것아니라고생각할수있다.

하지만 01의 가치를 제대로 누리기가 쉽진 않다.01에 필요한 유연하고 확장성이 뛰
어난 오브젝트 설계를 하려면 많은 고민과 학습， 훈련， 경험이 펼요하다. 객체지향 설계
를 잘히는 방법은 다%봐겠지만， 그중에서 추천하고 싶은 한 가지가 있다면 바로 01를
의식하면서 설계하는 방식이다.
01를 적용하려면 커다란 오브젝트 하나만 존재해서는
안 된다. 최소한 두 개 이상의， 의존관계를 가지고 서로 협력해서 일하는 오브젝트가 펼
요하다. 그래서 적절한 책임에 따라 오브젝트를 분리해줘야 한다. 그리고 항상 의존 오
브젝트는 자유롭게 확장될 수 있다는 점을 염두에 둬야 한다.
01는 런타임 시에 의존 오
브젝트를 다이내믹하게 연결해줘서 유연한 확장을 꾀하는 게 목적이기 때문에 항상 확
장을 염두에 두고 오브젝트 사이의 관계를 생각해야 한다. 이렇게 01를 잘 활용할 수 있
는 방법을 생각하면서 오브젝트를 설계한다면 객체지향 기술이 약속하는 유연한 확장
과 재시용이 가능한 설계를 만드는 데 많은 도움이 될 것이다.

확장은 항상 미래에 일어나는 일이다. 지금 당장 기능이 동작히는 데 아무런 문제가
없으면 된다고 생각하면 오늘을 위한 설계밖에 나오지 않는다.01는 확장을 위해 필요
한 것이므로 항상 미래에 일어날 변화를 예상하고 고민해야 적합한 설계가 가능해진다.
01란 결국 미래를 프로그래밍하는 것이다.

01와 인터페이스 프로그래밍
01를 적용할 때는 가능한 한 인터페이
스를 사용하게 해야 한다. 물론 인터페이스를 사
용하지 않고도 01는 가능하다. 의존 오브젝트가 생성자나 수정자 등을 통해 주입만 가
능하면 되기 때문에 의존 오브젝트의 클래스 타입을 클라이언트가 직접 시용해도 문제
는 발생하지 않는다. 하지만 01를 01답게 만들려면 두 개의 오브젝트가 인터페이스를
통해 느슨하게 연결돼야 한다.
인터페이스를 시용히는 첫 번째 이유는 다형성을 얻기 위해서다. 하나의 인터페이스
를 통해 여러 개의 구현을 바꿔가면서 사용할 수 있게 하는 것이 01가 추구히는 첫 번
째 목적이다. 물론 지금까지 여러 가지 01 적용 예를 살펴봤듯이 의존 오브젝트가 가진
핵심 로직을 바꿔서 적용히는 것 외에도 프록시， 데코레이터， 어랩터， 테스트 대역 등의
다양한 목적을 위해 인터페이스를 통한 다형성이 활용된다.


하지만 단지 DI의 목적이 다형성을 편리하게 적용하는 것 때문만이라면 제약이 많고
불편한 점이 있다고 해도 클래스를 사용할 수도 있다. 상속이 불가능한 final 클래스만
아니라면 상속을 통해서도 여러 가지 방식으로 구현을 확장할 수 있기 때문이다. 1
장에
서 살펴본 랩플릿 메소드 패턴이 그런 대표적인 방법이다.

그럼에도 인터페이스를 시용해야 송}는 이유가 또 있다면 그것은 인터페이스 분리 원
칙을 통해 클라이언트와 의존 오브젝트 사이의 관계를 명확하게 해줄 수 있기 때문이
다.A 오브젝트가 B 오브젝트를 사용한다고 했을 때 A를 사용하는 입장이니까 클라이
언트，
8를 사용되는 의존관계에 있으니까 의존 오브젝트라고 부르자.A와 B가 인터페
이스로 연결되어 있다는 의미는 다르게 해석하면 A가 B를 바라볼 때 해당 인터페이스
라는 창을 통해서만 본다는 뭇이다. 만약 81
이라는 인터페이스를 B가 구현하고 있고
A는 81 인터페이스를 통해서만 B를 사용한다면 그래서 DI 받을 때도 81 인터페이스
를통해 받는다면 A에게 B는
81
이라는관심사를구현한 임의의 오브젝트에 불과하다.
그래서 같은 Bl이라는 인터페이스를 구현했다면 B가 아니라 C, 0 클래스로 만들어진
오브젝트이더라도 A에게 DI가 가능해진다.

그런데 B 오브젝트는 81
이 아니라 82
라는 다른 인터페이스를 구현하고 있을 수도
있다. 자바의 클래스는 하나 이상의 인터페이스를 구현할 수 있다. 그렇다면 B는 왜 또
82라는 다른 인터페이스를 구현하고 있을까? 그 이유는 82라는 인터페이스가 그려주
는창으로
B를바라보는다른종류의 클라이언트가존재하기 때문이다.

즉 인터페이스는 하나의 오브젝트가 여러 개를 구현할 수 있으므로， 하나의 오브젝
트를바라보는창이 여러 가지일수있다는뭇이다. 각기 다른관심과목적을가지고어
떤 오브젝트에 의존하고 있을 수 있다는 의미다. 굳이 82
라는 인터페이스에 정의된 내
용에는 아무런 관심이 없는 A 오브젝트가 82 인터페이스의 메소드까지 모두 노출되어
있는 B라는 클래스에 직접 의존할 이유가 없다. 게다가 82 인터페이스의 메소드에 변
화가 발생하면 그에는 관심도 없는 A 오브젝트의 코드에 영향을 줄 수도 있다. 인터페
이스를 이렇게 클라이언트의 종류에 따라 적절하게 분리해서 오브젝트가 구현하게 하
면매우유용하다.

오브젝트가 그 자체로 충분히 응집도가 높은 작은 단위로 설계됐더라도， 목적과 관
심이 각기 다른 클라이언트가 있다면 인터페이스를 통해 이를 적절하게 분리해줄 필요
가 있고， 이를 객체지향 설계 원칙에서는 인터페이스 분리 원칙
Inle꺼ace Segregalion Princi미e이

라고 부른다. 인터페이스를 사용하지 않고 클래스를 직접 참조하는 방식으로 DI를 했다
면， 인터페이스 분리 원칙과 같은 클라이언트에 특화된 의존관계를 만들어낼 방법 자체
가없는것이다.

7징-스프링 핵심 기술의 응용 619


다형성은 물론이고 클라이언트별 다중 인터페이스 구현과 같은 유연하고 확장성 높
은 설계가 가능함에도 인터페이스를 피할 이유는 없다.DI는 특별한 이유가 없는 한 항
상 인터페이스를 사용한다고 기억해두자. 굳이 인터페이스를 써야 하냐고 주장히는 사
람을 만났는데 논리적으로 설득할 자신이 없거든 DI는 원래 인터페이스를 쓰게 돼 있다
고 우겨도 좋다. 분명한 이유가 있어서 인터페이스를 사용하지 않는 경우가 없지는 않
겠지만， 단지 인터페이스를 추가하기가 귀찮아서 약간의 게으름을 부리고자 인터페이
스를 생략한다면 이후의 개발， 디버깅， 태스트， 기능의 추가， 변화 등에서 적지 않은 부
담을안게될것이다.

7.4.2 인터페이스 상속
하나의 오브젝트가 구현하는 인터페이스를 여러 개 만들어서 구분하는 이유 중의 하나

는 오브젝트의 기능이 발전히는 과정에서 다른 종류의 클라이언트가 등장하기 때문이

다. 때로는 인터페이스를 여러 개 만드는 대신 기존 인터페이스를 상속을 통해 확장하

는방법도사용된다.

인터페이스 분리 원칙이 주는 장점은 모든 클라이언트가 자신의 관심에 따른 접근

방식을 불필요한 간섭 없이 유지할 수 있다는 점이다. 그래서 기존 클라이언트에 영향

을 주지 않은 채로 오브젝트의 기능을 확장하거나 수정할 수 있다. 기존 클라이언트는

자신이 시용하던 인터페이스를 통해 동일한 방식으로 접근할 수만 있다면 오브젝트의

변경에 영향받지 않는다. 오브젝트가 완전히 새로운 인터페이스를 추가로 구현히는 경

우뿐 아니라 기존 인터페이스를상속해서 기능을확장하는 경우에도 마찬가지다.

SqlService
의 기본 구현인 BaseSqlService 클래스의 설계구조를 살펴보자.
BaseSqlService와 그 서브클래스는 SqlReader와 SqlRegistry라는 두 개의 인터페이스
를 통해 의존 오브젝트들을 DI 하도록 되어 있다. 그림 7-10은 인터페이스와 DI가 적
용된 전형적인 구조를 보여준다. BaseSqlService는 SqlRegistry라는 인터페이스를 통
해 MySqlRegistry 클래스의 오브젝트에 접근하기 때문에 MySqlRegistry
의 구현 내용
이 변경을 통해 SQL 등록 기능은 확장될지라도 BaseSqlService 클래스는 변경 없이
유지될 수 있다. 일단 여기까지는 DI가 적용된 전형적인 오브젝트 관계와 그 특정이다.


BaseSqlService

---1

My없IReg성이는 앉3SeSq
1않rvice어| BaseSq
lService기 접근하는 데 필요한
영호탤 주지 않으연서 독자적으로 SqlRegislry 인터페이스를 제공하는 한
확장될수있다， MySqIRegistry는 자유롭게 변경 또는 확징
이가능하디


그림 7-10 인터페이스와 DI톨 룡한 유연한 확장구조

인터페이스를 사용해 미 관계를 만들었기 때문에 얻을 수 있는 또 다른 장점은
SqlRegistry
의 구현 클래스인 MySqlRegistry
의 오브젝트가 또 다른 제3
의 클라이언트
를 위한 인터페이스를 가질 수 있다는 점이다. 현재 MySqlRegistry는 BaseSqlService
가 유일한 클라이언트다. 그런데 MySqlRegistry
의 기본 기능이 확장되면서 새로운 클
라이언트가 나타날 수도 있다는 뭇이다. 물론 이를 위해 SqlRegistry와는 다른 인터
페이스가 필요해진다. 새로운 클라이언트를 위한 새로운 인터페이스가 필요하지만 꼭
SqlRegistry와 별개의 인터페이스를 만들어야 하는 것은 아니다. 새로운 클라이언트의
성격에 따라서 기존 SqlRegistry를 확장한 인터페이스를 이용할 수도 있다.

현재 SqlRegistry 인터페이스는 리스트 7-61에서 볼 수 있듯이 초기에 새로운
SQL을 등록히는 기능과 이렇게 등록된 SQL을 다시 검색해오는 두 가지 메소드를 갖
고있다.

리스트 7-원 SqIRegistry 인터페이스

public interface SQIRegistry (
void registerSQl(String key , String sQl );

String findSQl (String key) throws SQINotFoundException;


BaseSqlService는 이 SqlRegistry 인터페이스를 구현하는 오브젝트에 의존하고
있다. 그림 7-10의 경우라면 MySqlRegistry 오브젝트다. 그런데 여기에 이미 등록된
SQL을 변경할 수 있는 기능을 넣어서 확장하고 싶다고 생각해보자.

이때는 이미 SqlRegistry 인터페이스를 이용해 접근하는 클라이언트인
BaseSqlService 클래스와 그 서브클래스가 존재하기 때문에 SqlRegistry 인터페이스
자체를 수정히는 건 바람직한 방법이 아니다. BaseSqlService 오브젝트는 SqlRegistry

낀~-스프링 핵심 기술의 응용 621


인터페이스가 제공히는 기능이면 충분하기 때문이다. DAO를 위한 SQL 조회 서비스
인 BaseSqlService 입징에서 SQL을 업데이트하는 기능을 이용히는 클라이언트가 될
이유가 없다. 따라서 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공한다는
인터페이스 분리 원칙을 지키기 위해서라도 이미 적용한 SqlRegistry는 건드리면 안
된다.

대신 새롭게 추가할 기능을 사용하는 클라이언트를 위해 새로운 인터페이스를 정의
하거나 기존 인터페이스를 확장하는 게 바람직하다. SQL 저장소에 담긴 SQL 정보를
변경히는 기능을 추가하기로 했다는 건， 그런 기능을 사용할 클라이언트가 존재해야 한
다는 의미이기도 하다. 아마도 관리자가 사용할 SQL 관리 기능을 맡은 오브젝트가 새
로운 클라이언트가 될 것이다. 새로운 클라이언트가 필요로 하는 인터페이스는 SQL에
대한 수정을 요청할 수 있는 메소드를 갖고 있어야 한다.SQL 관리 기능이라고 하면 단
순히 업데이트뿐 아니라 SQL 등록이나 검색 같은 기본적인 기능도 필요할 태니 기존
SqlRegistry 인터페이스에 정의된 메소드도 시용할 필요가 있다. 그렇다면 새로운 클
라이언트를 위한 인터페이스는 SqlRegistry 인터페이스의 기능과 함께 새로운 SQL 수
정 기능도 갖고 있어야 한다. 그러기 위해서는 기존의 SqlRegistry 인터페이스를 상속
하고 메소드를 추가해서 리스트 7-62와 같이 새로운 인터페이스로 정의돼야 한다.

리스트 7냉2SQL 수정 기능을 가진 확장 인터페이스

package springbook.issuetracker.sqlservice;

public interface UpdatableSqlRegistry extends SqlRegistry (
public void updateSql(String key , String sql) throws SqlUpdateFailureException;
public void updateSql(Map(String, String) sqlmap) throws SqlU띠ateFailureException;

이름으로도 예상할 수 있듯이 UpdatableSqlRegistry 인터페이스는 SqlRegistry
의
서브인터페이스다. SQL의 등록과 조회만 가능한 SqlRegistry에 SQL 업데이트를 위
한기능이추가됐다.

그런데 이렇게 SQL 업데이트 기능을 가진 새로운 인터페이스를 만들었으니
BaseSqlService도 새로 만든 UpdatableSqlRegistry 인터페이스를 이용하게 해야 할
까? 그렇지 않다. BaseSqlService는 초기화를 통한 SQL 등록과 조회만을 목적으로
SQL 레지스트리 오브젝트를 사용할 것이므로， 기존의 SqlRegistry 인터페이스를 통해


접근하면 충분하다. 반면에 SQL 업데이트 작업이 필요한 새로운 클라이언트 오브젝트
는 UpdatableSqlRegistry 인터페이스를 통해 SQL 레지스트리 오브젝트에 접근하도록
만들어야한다.

SQL 변경에 대한 요청은 웹이나 원격 호출 또는 웹 서비스， 이벤트 등의 다OJ=한 방
법을 통해 일어날 수 있다. 이런 경로로 들어옹 SQL 변경 요청을 담당하는 SQL 관
리용 오브젝트가 있다고 하고， 클래스 이름을 SqlAdminService라고 하자. 그렇다면
SqlAdminService는 UpdatableSqlRegistry
라는 인터페이스를 통해 SQL 레지스트리
오브젝트에 접근해야 한다.

새로운 SQL 업데이트 기능까지 구현한 SQL 레지스트리 클래스를
MyUpdatableSqlRegistry
라고 하면 그림 7-11
과 같은 의존관계가 만들어진다.

BaseSqlService
‘ 각각 자신의 필요에 맞는


~

<-~-J검AdminService
그림 7-11 인터페이스 상속율 이용한 확장구조

실제 오브젝트 사이에 일어나는 DI
의 결과만 보자면 BaseSqlService
와
SqlAdminService 오브젝트는 동일한 MyUpdatableSqlRegistry 오브젝트를 DI 받F아서
시용한다.XML 설정을 보자면 리스트 7-63과 같이 동일한 빈을 참조하도록 설정된다.

리스트 7•)3 MyUpdatableSq
lRegistry의 의존관계


<bean id=당qlService" class="springbook.user.sqlservice .BaseSqlService" )

<property name="sqlRegistry" ref=' sqlRegistry" /)
</bean) •

<bean id='sqlRegistry" class=’ springbook.user.sqlservice.MyUpdatableSqlRegistry"/>
<bean id="sqlAdminService" class=갱
pringbook.user.sqlservice.SqlAdminService"")
<propery name=‘ updatableSqlRegistry" ref="sqlRegistry" /)
</bean)

7장-스프링 핵심 기술의 응용 623


오브젝트의 의존관계를 보자면 DI를 통해 동일한 오브젝트에 의존하고 있지만 설계
와 묘드에서는 각각 SqlRegistry와 UpdatableSqlRegistry라는 인터페이스에 의존하
고 있을 뿐이다. SqlAdminService의 코드는 리스트 7-64와 같이 만들어진다.

리스트 7•)4 SqlAd
min용rvice 클래스

public class SqlAdminService implements AdminEventListener {
private UpdatableSqlRegistry updatableSqlRegistry;

public void setUpdatableSqlRegistry(UpdatableSqlRegistry
updatableSqlRegistry) {
this .updatableSqlRegistry =updatableSqlRegistry;

public void updateEventListener(UpdateEvent event) {
this.updateSqlRegistrY .updateSql(event.get(KEY_ID) , event .get(SQL_ID));

BaseSqlService와 SqlAdminService는 동일한 오브젝트에 의존하고 있지만 각자의
관심과 펼요에 따라서 다른 인터페이스를 통해 접근한다. 인터페이스를 사용하는 DI
이
기 때문에 가능한 일이다. 이렇게 인터페이스를 추가하거나 상속을 통해 확장하는 방식
을 잘 활용하면 이미 기존의 인터페이스를 사용히는 클라이언트가 있는 경우에도 유연
한 확장이 가능해진다. 만약 SQL 수정 기능만을 처리하는 클라이언트가 필요했다면 기
존 SqlRegistry 인터페이스를 상속하지 않고 새로운 인터페이스를 추가했을 수도 있
다. 오브젝트 사이의 의존관계와 목적에 따라 적절한 방식을 택하면 된다. 중요한 것은
클라이언트가 정말 펼요한 기능을 가진 인터페이스를 통해 오브젝트에 접근하도록 만
들었는가이다.

잘 적용된 DI는 결국 잘 설계된 오브젝트 의존관계에 달려 있다. 인터페이스를 적절
하게 분리하고 확장하는 방법을 통해 오브젝트 사이의 의존관계를 명확하게 해주고， 기
존 의존관계에 영향을 주지 않으면서 유연한 확장성을 얻는 방법이 무엇인지 항상 고민
해야 한다. 다시 말하지만，
DI와 객체지향 설계는 서로 밀접한 관계를 맺고 있다.


r 7.5 미를 이용해 다양한 구현 방법 적용하기 쩔|

인터페이스 상속을 통한 확장과 클라이언트에 따른 인터페이스 분리 원칙을 잘 지키는
구조를 만들었으니 이제는 실제 구현을 해볼 차례다. 운영 중인 시스템에서 사용하는
정보를 실시간으로 변경하는 작업을 만들 때 가장 먼저 고려해야 할 사항은 동시성 문
제다. 한 번 초기화하고 그 뒤에는 읽기전용으로 동작하는 기존의 SqlRegistry의 방식
에서는 여러 스레드가 함께 접근할 때 발생히는 동시성 문제가 발생할 일이 없다.

하지만 수정은 다르다. 동시 접속자가 많은 대형 시스램의 DAO라면 수시로 접근하
는 SQL 레지스트리 정보를 잘못 수정하다가 어느 순간 깨진 SQL이 나타날 수도 있다.
자바 엔터프라이즈 시스랩에서 발생하는 복잡한 동시성 문제는 이 책에서 다룰 내용은
아니니 더 갚이 다루지는 않는다. 대신 자바에서 제공되는 주요 기술을 이용해 간단한
방식으로 어느 정도 안전한 업데이트가 가능한 SQL 레지스트리를 구현해보겠다.

이미 UpdatableSqlRegistry
라는 인터페이스를 정의해서 수정 가능한 SQL 레지스
트리 구현을 다
O.{하게 DI로 적용할 수 있게 만들어뒀으니， 이를 활용해 여러 가지 구현
을만들어적용해보자.

7.5.1 ConcurrentHashMap을 이용한 수정 가능 SQL 레지스트리
지금까지 디폴트로 써왔던 HashMapRegistry는 JDK의 HashMap을 사용한다. 하지만
HashMap으로는 멀티스레드 환경에서 동시에 수정을 시도하거나 수정과 동시에 요청하
는 경우 예상하지 못한 결과가 발생할 수 있다. 멀티스레드 환경에서 안전하게 HashMap
을 조작하려 면 Collections .synchronizedMap() 등을 이용해 외부에서 동기화해줘야
한다. 하지만 이렇게 HashMap에 대한 전 작업을 동기화하면 SqlService처럼 DAO의 요
청이 많은 고성능 서비스에서는 성능에 문제가 생긴다.
그래서 동기화된 해시 데이터 조직에 최적화되도록 만들어진 ConcurrentHashMap을 사
용하는 방법이 일반적으로 권장된다. ConcurrentHashMap은 데이터 조작 시 전체 데이터에
대해 락을 걸지 않고 조회는 락을 이에 사용하지 않는다. 그래서 어느 정도 안전하면서 성능
이 보장되는동기화된 HashMap으로 이용하기에 적딩하다.

수정 가능 SOL 레지스트리 테스트
일단 ConcurrentHashMap을 이용해 UpdatableSqlRegistry를 구현해보자. SQL을 변경
하는 기능을 검증히는 건 기존에 사용해온 UserDaoTest로는 불가능하다. 그래서 이번

낀!l: 스프링 핵심 기슐의 응용 625



에는 단위 태스트를 별도로 만들어서 SQL의 등록과 조회
， 수정
이 모두 잘 일어나는지
를
확인하겠다.

태스트로 검증해야 할 사항을 꼽아보자. 먼저 SQL 등록한 것이 잘 조회되는지 확인
해야 하고， 이를 수정한 후에 수정된 SQL
이 바르게 적용됐는지 확인해봐야 한다. 또 존
재하지 않는 SQL에 대해 수정을 시도했을 때 적절한 예외가 발생히는지도 검증해보자.

리스트 7-65와 같이 기능을 검증할 만한 단위 테스트를 먼저 만들어보자.

리스트 7-65 ConcurrentHashMap올 이용한 SQL 레지스트리 테스트

public class ConcurrentHashMapSqlRegistryTest (
UpdatableSqlRegistry sqlRegistry;

OOefore

public void setUp() (
sqlRegistry = new ConcurrentHashMapSqlRegistry () ;
sqlRegistry , registerSql (" KEY1 ", ' SQL1 ") ;

sqlRegistry , registerSql( "KEY2" , "SQL2 ") ; 각 테스트 에소드에서 사용할 초기
sqlRegistry,registerSql (" KEY3 “, "SQL3" );
SOL 정보훌 미리 둥룩해둔다

@Test
public void find() (
checkFindResult ("SQLl “ , "SQL2" , 잉QL3
"
);

r


반복적으로 검증핸 쁜은 열도의 메소드로

분리해두연 테스트 코드가 깔끔해진다

private void checkFindResult (String expectedl , String expected2 , String

expected3) (
assertThat(sqlRegistry , findSql (" KEY1" ), is(expectedl ));
assertThat (sqlRegistry , findSql ("KEY2"), is(expected2)) ;
assertThat (sqlRegi stry , findSql("KEY3 “) , is(expected3 ));

@Test(expected= SqlNotFoundException , class)

주어진 키에 해당하는 SOL을 찾을 수 없을 때

public void unknownKey () {

예외가 발생하는지톨 확인한다 예외상횡에 대한

sqlRegistry , findSql ("SQL9999 !@#$"); 테스트는 빼먹기가 쉽기 때문에 향상 의식적으
로 넣으려고 노력해야 한다

@Test

public void updateSingle () (
하나의 SOL올 변경하는 기능에 대한 테sqlRegistry , updateSql (" KEY2" , "Modified2");
스트다 검중할 때는 변경된 SQL 외의
checkFindRe
s
ult(
잉QLl “/ “Modified2" , "SQL3‘); 나머지 밍L은 그대로인지도 확인해주는

게출다


@Test

public void updateMulti() ( --을 한 번에 여러 개의 SOL을 수정하는 기능을 검증한다
Map(String, String) sqlmap = new HashMap(String , String)();
sqlmap .put("KEY1" , "Modifiedl");
sqlmap. put( "KEY3" , "Modi fied3");

sqlRegistrY.updateSql(sqlmap) ;
checkFindResult( “Modi fiedl ", “SQL2" , "Modi fied3");

존재하지 않는 키의 SOL을 연겸하려고 시

@Test(expected=SqlUpdateFailureException.class)~ 도할 때 예외가 발생하는 것을 검증한다

public void updateWithNotExistingKey( ) (
sqlRegistrY
.
updateSql("SQL9999!
빼$"
， "Modified2" );

동시성에 대한 부분도 테스트할 수 있다면 좋겠지만 이는 간단하지 않다. 아쉽지만
그 부분은 제외하고 일단 수정 기능을 검증히는 것으로 만족하자.

태스트를 만들어놨으니 이제 태
스트 조건을 모두 충족히는 ConcurrentHashMap
을 작성한다. 굳이 모든 태
스트를 작성한 후에 묘드를 만들 필요는 없다. 만들어야
할 기능에 대해 태스트 메소드를 하나씩 추가하면서 이 테스트를 성공시킬 수 있는
ConcurrentHashMap을 만들어나가도 좋고， 태스트를 먼저 만드는 게 불편하다면 일단 코
드를 먼저 만들고 그에 대한 테스트를 바로 추가해서 확인해보는 방법도 나쁘지 않다.
중요한 건 코드를 작성한 다음 태스트를 만들어 검증히는 그 씨의 간격을 가능한 한
짧게 하고， 예외상황을 포함한 기능을 세세하게 검증하도록 테스트를 만드는 것이다
.

SqlService나 그 부속 기능인 SqlRegistry의 구현 클래스 등은 UI 조작을 통해 어
느 정도 태스트 기능한 애플리케이션의 코드와 달리 수동으로는 손쉽게 태스트하기 힘
들다. 또한 구현 방법과 적용 기술이 바뀔 수 있고 내부 구조가 변경될 수 있으면서도
인터페이스 메소드는 일정하게 유지해야 동}는 부담도 있다. 따라서 이런 코드는 설계도
중요하지만 태스트를 철저하게 만들어서 기능을 검증하고 구현 방식이 변경될 때마다
태스트를 실행해서 기능에 영향을 주는지 확인하는 일이 매우 중요하다.

수정 가능 SQL 레지스트리 구현
이제 태스트를 모두 성공시키도록 만들어진 ConcurrentHashMap 코드를 만들어보
면 리스트 7-66과 같이 만들 수 있다. 기존 HashMapSqlRegistry에서 HashMap을

견~-스프링 핵심 기술의 응용 627



ConcurrentHashMap으로 변경하고 UpdatableSqlRegistry
에 추가된 메소드를 그에 맞
게구현해췄다.

리스트 7-66 ConcurrentHashMap올 사용하는 SOL 러|지스트리

public class ConcurrentHashMapSqlRegistry implements UpdatableSqlRegistry (
private Map<String , String> sqlMap = new ConcurrentHashMap<String , String>();

public String findSql(String key) throws SqlNotFoundException (
String sql =sqlMap.get(key);
if (sql == null) throw new SqlNotFoundException(key +

"를 이용해서 SQL을 참을 수 없습니다");

else return sql;

public void registerSql(String key , String sql) ( sqlMap.put(keι sql);}

public void updateSql(String key , String sql) throws
SqlUpdateFailureException (
if (sqlMap.get(key) == null) (
throw new SqlUpdateFailureException(key +

·에 해당하는 SQL을 참울 수 없습니다");
sqlMap.put(key , sql);

public void updateSql(Map<String , String> sqlmap) throws
SqlUpdateFailureException (
for(Map.Entry<String , String> entry sqlmap.entrySet()) (
updateSql(entry.getKey() , entry.getValue());

수정 기능을 가진 SQL 레지스트리를 적용하기 전에 먼저 태스트를 이용해 모든 수
정 기능이 완벽하게 동작히는지 검증하는 것을 잊지 말자.

OxmSqlService는 sqlRegistry 프로떠티를 지정하지 않으면 디폴트로 설정된 단순
한 HashMapSqlRegistry를 시용하게 되어 있다. 그래서 설정을 통해 디폴트 대신 새로
만든 ConcurrentHashMapSqlRegistry 빈을 사용하도록 리스트 7-67과 같이 빈 설정을
수정하자.


리스트 7-fJ1 ConcurrentHashMapSq
lRegistry톨 적용한 설정

(bean id=꺼qlService" class=닝pringbook.user.sqlservice
.
OxmSqlService">
(property name="unmarshaller" ref="unmarshaller" />
(property name='sqlRegistry' ref='sqlRegistry ' />

(/bean> 나 디폴트로 준비된 Hash뼈뼈11<영뼈 대신 외부에 따로 정의한 SOL

레지스트리를 사용히도록 프로떠티를 영시적으로 지정한다

(bean id='sqlRegistry'

c1
ass=갱pringbook.user.sqlservice.updatable.ConcurrentHashMapSqlRegistry
'
>

</bean>

이 렇게 스프링 XML 설정을 변경한 뒤에 UserDaoTest를 실행해보면 새로 적용한
ConcurrentHashMapSqlRegistry가 OxmSqlService와 협력해서 기본적인 SqlService 기
능을 제공하는 데 이상이 없는지를 확인할 수 있다. ConcurrentHashMapSqlRegistry 구
현 클래스에 대한 단위 태스트를 만들어서 새로운 기능을 검증하긴 했지만 여타 오브젝
트와 협력해서 작업할 때 고려해야 할 부분을 빼먹었을 수도 있으니， 이렇게 통합 태스
트를 이용해서 새로 만든 클래스의 빈이 다른 빈 오브젝트와 함께 시용될 때도 문제없
이 동작히는지 반드시 확인해야 한다.

7.5.2 내짙병 데이터베이스를 이용한 SQL 레지스트리 만들기
이번엔 ConcurrentHashMap 대신 내장형 DBembedded DB를 이용해 SQL을 저장하고 수
정하도록 만들어보겠다. ConcurrentHashMap이 멀티스레드 환경에서 최소한의 동시성
을 보장해주고 성능도 그리 나쁜 펀은 아니지만 저장되는 데이터의 양이 많아지고 잦
은 조회와 변경이 일어나는 환경이라면 한계가 있다.

인텍스를 이용한 최적화된 검색을 지원하고 동시에 많은 요청을 처리하면서 안정적

인 변경 작업이 가능한 기술은 바로 데이터베이
스다. 그래서 이번에는 SQL 레지
스트리

를 DB를 이용해 만들어보려고 한다.

그렇다고 기껏 DAO가 시용할 SQL을 저장해두고 관리할 목적으로 별도의 DB를 구

성하면 배보다 배꼽이 더 큰 일이 될 수도 있다. 그래서 이런 경우라면， DB의 장점과

특징은 그대로 갖고 있으면서도 애플리케이션 외부에 별도로 설치하고 셋업하는 번거

로움은 없는 내장형 DB를 사용하는 것이 적당하다.

내장형 DB는 애플리케이션에 내장돼서 애플리케이션과 함께 시작되고 종료되는

DB를 밀한다. 데이터는 메모리에 저장되기 때문에 10로 인해 발생히는 부하가 적어서

성능이 뒤어나다. 동시에 Map과 같은 컬렉션이
나 오브젝트를 이용해 메모리에 데이터를

7징-스프링 핵심 기술의 응용 629



저장해두는 방법에 비해 매우 효과적이고 안정적인 방법으로 등록， 수정， 검색이 기능
하다. 최적화된 락킹， 격리수준， 트랜잭션을 적용할수도 있다.

메모리로 읽어들인 데이터를 여러 가지 조건으로 검색하거나 통계를 내야 하고 필요
에 따라 데이터를 조작해가면서 복잡한 로직을 처리해야 하는 경우를 생각해보자. 데이
터를 List나 Map 같은 컬렉션 또는 데이터 흘더 역할을 히는 자바빈 오브젝트 등에 담
아서 사용한다면， 조건이 복잡한 검색 하나를 위해서도 꽤나 복잡한 자바 코드가 펼요
할 것이다. 루프와 if 문이 점철된 코드가 만들어질 것이고 테스트하기도 까다롭다.

하지만 애플리케이션에 내장된 DB를 이용하면 이런 작업을 매우 편리하게 진행할

수 있다. 데이터를 내장형 DB
의 테이블에 분산해서 넣은 후 SQL 문을 이용해 검색하

고 조작하는 편이 훨씬 묘드도 깔끔하고 활용하기도 편리하다. 복잡한 데이터를 효과적
으로 분석하고 조작하는 데는 관계형 DB와 SQL만 한 것이 없다. 물론 단순한 자바오
브젝트와 컬렉션， 배열 등을 사용할 때보다는 애플리케이션에 부담을 줄 수 있겠지만，
메모리 안에서 동작하도록 최적화된 내장형 DB
라면 대개 별문제가 되지 않을 것이다.

스프링의 내ε병 DB 지원 기능
자바에서 많이 사용되는 내장형 데이터베이스는 Derby, HSQL, H2를 꼽을 수가 있다.

모두 JDBC 드라이버를 제공하고 표준 DB와 호환되는 기능을 제공하기 때문에 JDBC

프로그래밍 모델을 그대로 따라서 사용할 수 있다.

JDBC 방식의 접근이라고 해서 기존의 DataSource와 DAO를 사용히는 모댈을 그
대로 사용히는 건 좋은 방법은 아니다. 애플리케이션과 그 생명주기를 같이하는 내장형
메모리 DB는 외부에서 DB를 생성하고 테이블을 만들고 초기화하는 작업을 하는 것이

아니라， 애플리케이션 내에서 DB를 기동시키고 초기화 SQL 스크립트 등을 실행시키

는 등의 초기화 작업이 별도로 필요하기 때문이다. 일단 DB를 초기화하는 작업을 하고

나면 그 후에는 내장형 DB용 JDBC 드라이버를 이용해서 일반 DB와 마찬가지로 접속

하고사용할수있다.

스프링은 내장형 DB를 손쉽게 이용할 수 있도록 내장형 DB 지원 기능을 제공하고

있다. 일종의 내장형 DB를 위한 서비스 추상화 기능이다. 하지만 다른 서비스 추상화
처럼 별도의 레이어와 인터페이스를 제공하지는 않는다. 어차피 DB를 액세스할 때는
JDBC와 DataSource를 이용하면 되고 필요할 경우 스프링이 제공하는 JDBC 지원 댐
플릿 등을 활용하면 충분하기 때문이다.


대신 스프링은 내장형 DB를 초기화하는 작업을 지원하는 편리한 내장형 DB 벌더를
제공한다. 내장형 DB 인스턴스는 보통 고유한 JDBC 접속 URL을 통해 연결을 시도하
면 JDBC 드라이버 내에서 이를 생성해준다. 스프링의 내장형 DB 빌더에는 대표적인
세 가지 내장형 DB를 사용할 때 펼요한 URL과 드라이버 등을 초기화해주는 기능이 있
다. 또한 데이터 초기화를 위해 테이블 등을 생성하거나 초기 데이터를 삽입하는 SQL
을 실행해주기도 한다. 모든 준비가 끝나면 내장형 DB
에 대한 DataSource 오브젝트를
돌려준다. 이후로는 DataSource 오브젝트를 이용해 일반적인 DB
처 럼 사용할 수 있다.

다만 내장형 DB는 애플리케이션 안에서 직접 DB 종료를 요청할 수도 있어야 한다.
이를 위해 스프링은 DataSource 인터페이스를 상속해서 shutdown()
이라는 내장형 DB
용 메소드를 추가한 EmbeddedDatabase 인터페이스를 제공한다. 앞에서 살펴본 인터페
이스상속을통한확장방법의좋은예다.

LH질병 DB 빌더 학습 테스트
스프링의 내장형 DB 지원 기능이 어떻게 동작하는지 살펴보기 위해 학습 태스트를 하
나만들어보자.
먼저 테이블을 생성하는 데 사용할 SQL을 다음과 같이 준비한다. 내장형 DB는 애
플리케이션을 통해 DB가 시작될 때마다 매번 테이블을 새롭게 생성한다. 따라서 지속
적으로 사용 기능한 테이블 생성 SQL 스크립트를 준비해둬야 한다. 나중에 내장형 DB
를 이용한 SQL 레지스트리에 사용할 용도로도 활용하도록 거와 SQL 문장을 저장할
필드를 가진 SQLMAP이라는 이름의 태이블을 리스트 7-68과 같이 작성해서 schema.sql
이라는 이름으로 저장해둔다.

리스트 7-68 테이블 생성 SOL


CREATE TABLE SQLMAP (
KEY_ VARCHAR(188) PRIMARY KEY ,
SQL_ VARCHAR(188) NOT NULL

KEY와 SOL 모두 일반적으로 DB에서 키워드로 사용되기 때문에 그대로
.. 필드 이름으로 을 수 없다 번거롭게 앞뒤에 ”를 붙여서 사용하는 것올 피
하기 위해 뒤에 -룰 추가했다

애플리케이션에서 펼요로 하는 초기 데이터가 있다면 이것도 SQL로 미리 준비해뒀
다가
DB가시작될 때 실행되게 해야한다. 초기 데이터를위한
SQL을담은
data.sql을
리스트 7-69와 같이 준비한다. 학습 테스트에서 사용할 용도로 두 개의 SQLMAP 정보를
삽입한다.

7장」 스프링 핵심 기술의 응용 631


리스트 7-f.영 초기 데이터 등록 SQL

INSERT INTO SQLMAP(KEY_, SQL_) values('KEY1 ’/ ’ SQL1' );
INSERT INTO SQLMAP(KEY_, SQL_) values( ’KEY2 ’/ ’SQL2 ’);

이제 내장형 DB가 시작될 때 준비해둔 두 개의 스크립트가 실행돼야 한다. 내장형
DB 벌더는 DB 엔진을 생성하고 초기화 스크립트를 실행해서 태이블과 초기 데이터를
준비한 뒤에 DB
에 접근할 수 있는 Connection을 생성해주는 DataSource 오브젝트를
돌려주게 된다. 정확히는 DB 섯다운 기능을 가진 EmbeddedDatabase 타입 오브젝트다.

태스트에서는 내장형 DB 빌더를 시용해 DB를 초기화하고 EmbeddedDatabase를 가
져오게 하고， 스프링의 JDBC용 템플릿을 이용해 초기 데이터를 가져오는 것과 데이터

를 추가로 등록히는 것을 검증해보겠다.
스프링이 제공하는 내장형 DB 빌더는 EmbeddedDatabaseBuilder
다. 다음은
EmbeddedDatabaseBuilder를 시용하는 전형적 인 방법을 보여준다.

new EmbeddedDatabaseBuilder()--용 빌더 오브젝트 생성
.se
tT
ype(
내장횡'DB흥투)_Em때d잉Data∞seTy∞의 HSOL 마RBY. H2 중에서 하나률 선택효백

.
addScript(초기화에 사용할 DB 스크릅l트의 ë!.l쇼스)

l 테이볼 생성과 데이터 초꽤내톨 위해 사용할 SOl 문장을 담은 SOl 스크립트의 위치률
.buildO; 지정효봐 SOL
스크링트는하나이상을지정할수있다

4. 주어친 조건에 맞는 내장형 D8훌 준비
õf고 초기화 스크립트톨 모두
실행한 뒤에 이에 접근할 수 있는 타nbE영아~Da녕base를 돌려준다

EmbeddedDatabaseBuilder 빌더가 최종적으로 만들어주는 오브젝트는 DataSource
인터페이스를 상속한 EmbeddedDatabase 타입이다. 따라서 DataSource의 일반적인 사
용 방법을 그대로 적용할 수 있다. 예를 들어 DataSource를 DI 받는 JdbcTemplate을 사

용할수도있다.

이제 리스트 7-70에 나와 있는 EmbeddedDatabaseBuilder를 이용한 내장형 DB 사
용 방법의 학습 태스트를 살펴보자.

리스트 7-70 내E뱅 DB 학습 테스트

package springbook.learningtest .spring .embeddeddb;
import static
org .springframework.idbc.datasource.embedded .EmbeddedDatabaseType.HSQL;

public class EmbeddedDbTest {

EmbeddedDatabase db;

SimpleJdbcTemplate template;
--을
Jdbc Templale올 더 펀리하게 사용할 수 있게 확장한 템플릿


OOefore HSOL. DERBY. H2 서| 가지 중 하나률 선택할 수 있다 초기화
public void setUp() ( SOLOI 호환만 된다면 DB 종류는 언제든지 바꿀 수 있다‘
db = new EmbeddedDatabaseBuilder()
.setType(HSQL) T

.addScript("classpath :/springbook!learningtest/spring/embeddeddb/
schema .sql ")

.addScript( “ classpath :/springbook/learningtest/spring/embeddeddb/
data .sql")
.build(); L. 테이블생성과초
71
데이터툴넣
71
위한스크링트지정

EmbeddedDatabase는 DataSource
의 서브

template = new SimpleJdbcTemplate(db)
;~ 인터페이스이므로 DataSource를 필요로 하는
Simple.kJbcTemp녕te을 만들 때 사용할 수 있다

@Af ter
매 테스트를 진행한 뒤에 DB를 종료한다 내ε꺼엉 메모리 DB는 따로
public void tearDown() (
--률 저행t지 않는 한 애를리케이션과 힘께 매번 새롭게 DB가 만들어지
db .shutdown(); 고 제거되는 생영주기를 갖는다‘

@Test
public void initData() (
--용 초기회 스크립트를 통해 둥록된 데이터률 검중하는 테스트다
assertThat(template .queryForlnt("select count(*) frαn sqlmap" ), is(2));

List<Map<String ,Object>> list = template .queryForList("select * from
sqlmap order by key-");;

asserπtT까h념
“
매9
ge
t(애이)
.
ge
t('개e
y-")， “‘

at(
(Strin1밍이)
list
.
얀
0
얀
is('
KEY1"η))
;

asserπtT까깨벼at(
(Strin1빙이)list.ge
t(애
s
q
is('γ‘
마L1
") );;

h1념
“
매9
얀
0).get("갱’찌띠C'
)， ’”
SQ


assertThat((String)list.get(l ).get("key_"), is("KEY2")) ;

assertThat( (String)list .get( 1).get( "sqC') , is( "SQL2")) ;

@Test
public void insert() (
--을 새로운 데이
터를 추가하고 이를 확인해본다
template .update("insert into sqlmap(key_, sql_) values(? , ?)" , "KEY3" ,
.’ SQL3");

assertThat (template.queryForlnt("select count(*) frαn sqlmap") , is(3 )) ;


"，추가할라이브러리
COITl.sprir갱없Jrce.α'g.뼈q애눈1.8.0.9.jar

7징-스프링 핵심 기술의 응용 633


초기화 부분을 제외하면 JdbcTemplate을 이용한 간단한 DB 테스트다. 테이블만 정
상적으로 만들어지고 JDBC를 통해 시용할 수 있는 DB라면 문제없이 모든 테스트를
통과할 것이다. 비록 애플리케이션이 시작된 뒤에 메모리에만 만들어졌다가 사라지는
DB
이지만 DataSource를 통해 DB 커넥션을 가져오는 것부터 JdbcTemplate을 활용하
는 것까지 사용 방법은 일반 DB와 거의 동일하다.

내짙병 DB를 이용한 SqIRegistry 만들기
스프링에서 간단히 내장형 DB
를 이용하려면 학습 테스트로 확인해본 것처럼
EmbeddedDatabaseBuilder를 사용하면 된다. 그런데 EmbeddedDatabaseBuilder는 직
접 빈으로 등록한다고 바로 사용할 수 있는 게 아니다. 적절한 메소드를 호출해주는 초
기화 묘드가 필요하다. 초기화 코드가 필요하다면 팩토리 빈으로 만드는 것이 좋다.
EmbeddedDatabaseBuilder 오브젝트는 한 번 초기화를 거쳐서 내장형 DB를 기동하고
이에 접근할 수 있는 EmbeddedDatabase를 만들어주면 그 이후로는 사용할 일은 없다.
따라서 EmbeddedDatabaseBuilder를 활용해서 EmbeddedDatabase 타입의 오브젝트를
생성해주는팩토리 빈을만들어야한다.
다행히 스프링에는 팩토리 빈을 만드는 번거로운 작업을 대신해주는 전용 태그가 있
다. 내장형 DB와 관련된 빈을 설정하고 등록해주는 기능이 있는 태그들은 jdbc 스카마
에 정의되어 있다. jdbc 네임스페이스를 선언해두고 간단한 전용 태그로 빈을 정의해주
변 내장형 DB를 손쉽게 시용할 수 있다. 만약 HSQL을 사용하고 schema.sql이라는 테
이블 생성용 초기화 스크립트를 이용히는 내장형 DB라면 리스트 7-71과 같이 정의해
주면된다.

리스트 7-71 HSQL 내ε병 DB 실정 예

(jdbc:embedded-database id="embeddedDatabase" type='HSQL'>
(jdbc:script location='classpath :schema.sQl'/>
(/jdbc:embedded-database>

이렇게 설정하면 embeddedDatabase 아이디를 가진 빈이 등록되며， 빈의 타입은
EmbeddedDatabase
다. 내장형 DB를 시작하고 초기화를 마쳤으니 EmbeddedDatabase 타
입 빈 오브젝트를 이용해 내장형 DB를 자유롭게 사용할 수 있다.

이제 남은 건 등록된 내장형 DB
의 DataSource를 DI 받아서 UpdatableSqlRegistry
를 구현하는 부분이다. 리스트 7-72는 이렇게 만들어진 클래스 묘드다.


리스트 7-72 내장형 DB률 사용하는 SOL 레지스트리

package springbook.issuetracker.sqlservice.updatable;

public class EmbeddedDbSqlRegistry implements UpdatableSqlRegistry (
SimpleJdbcTemplate jdbc;

public void setDataSource (DataSource dataSource) ( DataSource률 DI 받아서

jdbc = new SimpleJdbcTemplate(dataSource
);---을 Simpl허dbcTemplate 형태
로저장해두고시용한다

public void registerSql(String key , String sql) (
jdbc. update("insert into sqlmap(keL, sql_) values(7, 7)" , key , sql);

public String findSql (String key) throws SqlNotFoundException {
try (
return jdbc
.
queryForObje
c
t
(
갱
elect sql_ from sqlmap where key_ =

7" , String .class , key
~
);
~빼orObj때는 쿼
리
의 결과가 없으면
이예외를
발생시킨다

catch(EmptyResultDataAccessException e) (
throw new SqlNotFoundException(key +
“에 해당하는 SQL을 찾올 수 없습니다"
， e);

} ‘ u여at허 }는 SOL 실행 결과로 영향을 받은 레코드의 개수훌 리턴한다 이를 이용하면

| 주어진 키(key}률 가진 SOL이 존재했는지흘 간딘히 확인할 수 있다
I public void updateSql (String key , String sql ) throws
SqlUpdateFailureException (
~
int affected = jdbc.update("update sqlmap set sql_ = 7 where key_ =
7" , sql , key) ;
if (affected == 0) (
throw new SqlUpdateFailureException(key +

”에 해당하는 SQL을 장을 수 없습니다")
;

public void updateSql (Map<String , String) sqlmap ) throws
SqlUpdateFailureException (
for (Map .Entry<String , String) entry sqlmap.entrySet()) (
updateSql (entry .getKey() , entry .getValue()) ;


견~ 스프링 핵심 기솔의 응용 635


JdbcTemplate을 이용한 전형적인 JDBC 입력， 조회， 수정 작업이므로 특별한 설명
은 필요 없을 것이다. 다만 내장형 DB를 λF용하기 위해 DataSource 타입의 오브젝트
를 주입받도록 수정자를 만든 부분에 주목해보자. jdbc 스키마의 태그를 이용해 내장형
DB로 정의한 빈의 타입은 DataSource의 서브인터페이스인 EmbeddedDatabase 타입이
라고 했다. 그런데 왜 여기서는 그냥 DataSource 타입으로 DI를 받도록 했을까? 그 이
유는 인터페이스 분리 원칙을 지키기 위해서다. 물론 DataSource와 EmbeddedDatabase
는 다른 인터페이스는 아니고， 단지 상속관계에 있을 뿐이다. 그럼에도 중요한 것은 클
라이언트는 자신이 펼요로 히는 기능을 가진 인터페이스를 통해 의존 오브젝트를 DI 해
야 한다는 사실이다.SQL 레지스트리는 JDBC를 이용해 DBoJj 접근할 수만 있으면 된
다. 따라서 DataSource 인터페이스가 가장 적합하다. 따라서 사용하지도 않을 DB 종료
기능을 가진 EmbeddedDatabase 대신 DataSource 인터페이스를 시용한 것이다.

U때atableSq
IRegistry 테스트 코드의 재사용
EmbeddedDbSqlRegistry도 간단한 구현이 아니므로 테스트를 만들어 검증해야 한
다. 예외상황도 검증할 펼요가 있으므로， 정상적인 DAO 기능에 충실한 테스트인
UserDaoTest로 통합 태스트를 하기보다는 ConcurrentHashMapSqlRegistryTest와 비슷
하게 단위 태스트를 만드는 것이 좋겠다.
그런데 ConcurrentHashMapSqlRegistry
와 EmbeddedDbSqlRegistry 둘 다
UpdatableSqlRegistry 인터페이스를 구현하고 있기 때문에 테스트 내용이 중복될 가
능성이 높다. 일반적으로는 인터페이스가 같은 클래스라고 하더라고 구현 방식에 따라
검증 내용이나 테스트 방법이 달라질 수도 있고， 의존 오브젝트의 구성에 따라 목이나
스럽을 시용하기도 한다. 하지만 ConcurrentHashMapSqlRegistry는 의존 오브젝트가
아예 없고 EmbeddedDbSqlRegistry
의 경우에도 내장형 DB
의 DataSource 빈을 의존하
고 있기는 하지만 이를 테스트 대역으로 대체하긴 어렵다.DAO 태스트를 단위 테스트
로 만든다고 DataSource를 대체하기는 매우 힘들다. 따라서 DAO는 DB까지 연동하는
태스트를 히는 편이 더 효과적이다. 마찬가지로 EmbeddedDbSqlRegistry도 뒤의 내장형
DB까지 연동돼서 테스트되는 게 훨씬 간편하다. 결국 ConcurrentHashMapSqlRegistry
와 EmbeddedDbSqlRegistry
의 태스트 방법은 특별히 차이 날 것이 없다.
그렇다면 기존에 만들었던 ConcurrentHashMapSqlRegistryTest
의 태스트 코드를
EmbeddedDbSqlRegistry를 위한 태스트가 공유히는 방법을 찾으면 좋을 것이다. 구현된
코드를 공유히는 가장 쉬운 방법은 상속이다. JUnit4.x를 사용하는 태스트 클래스는 간
단히 상속구조로 만들 수 있다.


ConcurentHashMapSqlRegistryTest
의 코드 중에서 테스트 대상 클래스인
ConcurrentHashMapSqlRegistry
에 직접 의존하는 코드는 리스트 7-73
에 나온 것처럼
딱 한 줄뿐이다. 나머지 테스트 코드는 ConcurrentHashMapSqlRegistry가 구현하고 있
는 UpdatableSqlRegistry 인터페이스에만 의존하고 있다.

리스트 7-73 테스트 코드에서 ConcurrentHashMa며qlRegistry어| 의존하는 부분

public class (oncurrentHashMapSqlRegistryTest (

UpdatableSqlRegistry sqlRegistry; -•-테스트에서 사용할 픽스처는 인터페이스로
정의해두길잘했다，

OOefore
오직 이 문ε반 Concu
rre미벼shMapSq
lRegistry라는

public void setUp( ) ( ~ 특정 클래스에 의존하고 있다
sQIRegistry =new ConcurrentHashMapSQlRegistry();

결국 UpdatableSqlRegistry 구현 클래스의 오브젝트를 생성하는 부분
만 분리한다면， 나머지 테스트 코드는 모두 공유 가능하다. 리스트 7-73
과 같
이 바뀌는 부분을 별도의 메소드로 분리하고 아예 추상 메소드로 전환한
다. 이제 ConcurrentHashMapSqlRegistry
에 직접 의존하는 코드는 남아 있
지 않으니 리스트 7-74와 같이 클래스를 아예 추상 클래스로 바꾸고 이름도
AbstractUpdatableSqlRegistryTest로 변경할 수 있다.

리스트 7-74 U여atabl엇qlRegistry어| 대한 테스트 추상 클래스

public abstract class AbstractUpdatableSQlRegistryTest (
UpdatableSqlRegistry sqlRegistry; UpdatableSqIRegistry 인터페이스를 구현한

L녁i 모든 클래스에 대한 테스트를 만들 때 사용할
수 있는 추상 테스트 클래스다

OOefore
public void setUp() (
sQIRegistry =createUpdatableSQlRegistry();

테스트 픽스처를 생성하는 부분만 추상 메소드로 민들어

[ 두고 서브클래스에서 이률 구현하도록 만든다

abstract protected UpdatableSQlRegistry createUpdatableSQlRegistry();

서브클래스에 테스트를 추가한다연 필요할 수 있다 따라서

「률 서브클래스뻐 접근이 캠하도록 뼈總로 변경한다

protected void checkFind(String expected1 , String expected2 , String
expected3) {


7장-스프링 핵심 기술의 응용 637


@Test
public void find() {

// 나머지 테스트 메소드 모두 생략

기존의 ConcurrentHashMapSqlRegistryTest는 AbstractUpdatableSqlRegistry를
상속해서 추상 메소드인 createUpdatableSqlRegistry()
를 리스트 7-75와 같이 구현하
도록하면된다.

리스트 7-75 변경된 ConcurrentHashMa마찍IRegistryTest

public class ConcurrentHashMapSqlRegistryTest extends AbstractUpdatableSqlRegistry
Test {
protected UpdatableSqlRegistry createUpdatableSqlRegistry() (
return new (oncurrentHashMapSqlRegistry();

ConcurrentHashMapSqlRegistryTest 클래스 안에는 @Test
가 붙은 메소드
가 하나도 보이지 않지만 슈퍼클래스인 AbstractUpdatableSqlRegistryTest
의
@Test 태스트 메소드를 모두 상속받아서 자신의 태스트로 활용하게 된다. 태스트
를 실행하면 createUpdatableSqlRegistry() 메소드에서 생성한 오브젝트에 대해
AbstractUpdatableSqlRegistryTest
에서 정의한 5
개의 태스트가 진행될 것이다. 테스
트가 성공한다면 테스트 코드 공유를 위한 리팩토링 작업이 잘된 것이라고 생각하고 다
음으로넘어가자.

다음은 같은 방법으로 EmbeddedDbSqlRegistry에 대한 태스트를 만들어보자. 테스트
내용은 동일하지만 준비 과정에서 할 일이 많고 정리 작업도 필요하다. 추상 메소드인
createUpdatableSqlRegistry()
에서 생성해줄 EmbeddedDbSqlRegistry 오브젝트를 위
해서 먼저 내장형 DB를 만들고 초기화해야 하기 때문이다. 또， 테스트가 끝날 때마다
내장형 DB를 닫아주는 작업도 필요하다.

SQLMAP 테이블을 생성하는 SQL 스크립트는 sqlRegistrySchema. sql 파일에 저


장해두고 내장형 DB 벌더가 사용할 수 있게 해준다. 초기화 작업 중에 생성된
EmbeddedDatabase는 인스턴스 변수에 저장했다가 @After 메소드에서 DB를 중지시킬
때 사용한다. 리스트 7-76은 이렇게 만들어진 EmbeddedDbSqlRegistryTest 클래스다.

리스트 7-76 Em뾰ddedD~써
IRegistry어| 대한 테스트 클래스

package springbook.user.sqlservice.updatable;

public class EmbeddedDbSqlRegistryTest extends AbstractUpdatableSqlRegistryTest (
EmbeddedDatabase db;

protected UpdatableSqlRegistry createUpdatableSqlRegistry() (

db =new EmbeddedDatabaseBuilder()
.setType(HSQL).addScript(
"classpath:springbook/user/sqlservice/updatable/sqlRegistrySchema.sql")
.build();

EmbeddedDbSqlRegistry embeddedDbSqlRegistry = new
EmbeddedDbSqlRegistry();
embeddedDbSqlRegistry.setDataSource(db);

return embeddedDbSqlRegistry;

öAfter
public void tearDown() (
db.shutdown() ;


테스트를 실행해서 EmbeddedDbSqlRegistry의 모든 기능이 잘 동작하는지 예외상
황에서는 적절한 예외를 던지는지 모두 확인해본다. 태스트가 모두 성공했다면， 이제
SqlService에 본격적으로 적용해보자.

XML 설정을 통한 내짙뺑 DB의 생성과 적용
SqlService에 새롭게 만든 EmbeddedDbSqlRegistry를 적용해보자. 내장형 DB를 등록
하는 방법은 학습 태스트를 만들어서 살펴봤듯이 jdbc 스키마의 전용 태그를 사용하는
것이 편하다. 먼저 리스트 7-77과 같이 jdbc 네임스페이스와 스키마 위치 선언을 해
준다.

낀l_ 스프링 핵심 기술의 응용 639


리스트 7-77 jdbc 네임스페이스 선언

<beans xmlns=‘ http://www .springframework .org/schema/beans''

xmlns:jdbc="http://www.sprin때
해빼’
뼈따

19framework.org/schema/jdbc
"

xsi:schemaLocation=''http://www.springframework.org/schema/tx/spring-tx-3.9.xsd
http://www.springframework.org/schema/jdbc

,,")

그리고 리스트 7-78과 같이 <idbc:embedded-database> 태그를 이용해 내장
형 DB를 등록한다. 초기화 중에 태이블을 생성하는 데 펼요한 SQL 스크립트를
<idbc:script>로 지정해줘야한다.

리스트 7-78 내장형 DB 둥록

<idbc:embedded-database id=갱mbeddedDatabase" type="HSQL")
<idbc:script location=
"classpath:springbook/user/sqlservice/updatable/sqlRegistrySchema.sql ’/)
</idbc:embedded-database)

DB
의 종류는 스프링이 지원히는 세 가지 내장형 DB 중에서 하나를 선택하면 된
다. 설정과 함께 관련된 라이브러리 파일은 추가해줘야 한다. EmbeddedDbSqlRegistry
에서는 표준 SQL만 사용하므로 코드의 수정 없이도 간단히 다른 내장형 DB로 비꿀
수있다.

마지막으로 리스트 7-79와 같이 embeddedDatabase 빈을 dataSource 프로퍼티로 참
조히는 EmbeddedDbSqlRegistry 타입의 sqlRegistry 빈을 정의해주면 된다.

리스트 7-79 Em아져dedDb얼IRegistry 률래스톨 이용한 빈 등록

<bean id=닝qlService" class=닝
pringbook.user
.
sqlservice.OxmSqlService")
<property name="unmarshaller" ref="unmarshaller" /)
<property name=년qlRegistry" ref="sqlRegistry" /)

</bean)

<bean id="sqlRegistry ’·
class="springbook.user.sQlservice.updatable.EmbeddedDbSQlRegistry")
(property name="dataSource" ref="embeddedDatabase" 1>
</bean)


<idbc:embedded-database> 태그에 의해 만들어지는 EmbeddedDatabase 타입 빈은
스프링 컨테이너가 종료될 때 자동으로 shutdown() 메소드가 호출되도록 설정되어 있
다. 따라서 내장형 DB를 종료시키기 위한 별도의 코드나 설정은 필요하지 않다.

이제 모든 적용이 완료됐으니 UserDaoTest를 실행해서 내장형 DB를 사용하는
SqlService의 기능이 이상 없이 동작하는지 확인해보자.

7.5.3 트랜잭션 적용
EmbeddedSqlRegistry는 내장형 DB를 사용하기 때문에 조회가 빈번하게 일어나는 중
에도 데이터가 깨지는 일 없이 안전하게 SQL을 수정하도록 보장해준다. 하나의 SQL
을 수정할 때는 문제가 없다. 하지만 하나 이상의 SQL을 랩으로 전달받아 한 번에 수
정해야 히는 경우에는 자칫 심각한 문제가 발생할 수 있다. 뱀으로 SQL과 키의 쌍
을 전달받는 updateSql ( ) 메소드는 한 번에 한 개의 SQL을 수정해주는 같은 이름의
updateSql() 메소드를랩 안에 있는
SQL
의 개수만큼반복해서 호출하도록되어 있다.
그런데 여러 개의 SQL을 변경하는 작업을 진행하는 중에 존재하지 않는 키가 발견
되면 어떻게 될까? 이런 경우에는 예외가 발생하도록 되어 있으니 작업이 중단될 것이
다. 문제는 updat eSql() 메소드는 단순히 SimpleJdbcTemplate을 사용해 SQL을 실행
하고 있으므로 트랜잭션이 적용되어 있지 않다는 점이다. 따라서 여러 개의 SQL을 수
정하다가 중간에 예외가 발생하면 이미 수정한 SQL은 DB
에 그대로 반영되고 예외가
발생한 SQL부터 그 이후는 적용되지 않은 채로 작업을 마치게 된다.
운영 중인 시스뱀에서 한 번에 한 개 이상의 SQL을 동시에 수정하는 이유는 무엇일
까? 아마도 SQL들이 서로 관련이 있기 때문이 아닐까 싶다. 비즈니스 로직이 급하게
변경됐다면， 그에 영향을 받는 SQL이 모두 변경돼야 하기 때문이다. 그런데 일부는 새
로운 SQL이 적용되고 일부는 예외가 발생한 이후에 있는 SQL이어서 반영되지 않은
상태로 남는다면， 매우 위험한 결괴를 초래할 수 있다. 따라서 여러 개의 SQL을 수정하
는 작업은 반드시 트랜잭션 안에서 일어나야 한다.
기본적으로 HashMap과 같은 컬렉션은 트랜잭션 개념을 적용하기가 매우 힘들다. 엘
리먼트 하나를 수정하는 정도는 간단한 락킹을 이용해 안전성을 보장해줄 수 있다고 해
도， 여러 개의 엘리먼트를트랜잭션과같은 원자성이 보장된 상태에서 변경하려면 매우
복잡한 과정이 펼요하기 때문이다.
반면에 내장형 DB를 시용히는 경우에는 트랜잭션 적용이 상대적으로 쉽다. DB 자
체가 기본적으로 트랜잭션 기반의 작업에 충실하게 설계됐기 때문이다. 조금 번거로운

7장-스프링 핵심 기슐의 응용 641


설정이 뒤따름에도 내장형 DB를 도입한 이유는 바로 이런 트랜잭션과 같은 안전한 수

정 작업이 가능하기 때문이다.

스프링
에서 트랜잭션을 적용할 때 트랜잭션 경계가 DAO 밖에 있고 범위가 넓은 경
우라면 AOP를 이용하는 것이 편리하다. 하지만 SQL 레지스트리라는 제한된 오브젝트
내에서 서비스에 특화된 간단한 트랜잭션이 필요한 경우라면 AOP와 같이 거창한 방법
보다는 간단히 트랜잭션 추상화 API를 직접 사용하는 게 편리할 것이다.

다중 SQL 수정에 대한 트랜잭션 테스트
가장 먼저 할 일은 태스트를 만드는 것이다. 앞에서 이미 살펴봤지만 트랜잭션의 적
용은 수동 태스트 따위로 검증하기는 매우 어렵다. 특별한 예외상황이 아니라면 트
랜잭션의 적용 여부가 결과에 별 영향을 주지 않기 때문이다. 그러므로 먼저 트
랜잭션이 적용되면 성공하고 아니라면 실패하는 태스트를 만들자. 그래서 현재의
EmbeddedDbSqlRegistry 묘드가 테스트의 조건을 만족시키지 못하고 실패하게 만들어
야 한다. 그러고 나서 이 태스트가 성공할 수 있도록 EmbeddedDbSqlRegistry
에 트랜잭

션 기능을 추가하면 된다.

트랜잭션 기능을 점검하는 새로운 테스트 메소드를 EmbeddedDbSqlRegistryTest 클
래스에 추가하자. 새로운 태스트 메소드는 슈퍼클래스에 정의되어 있는 5
개의 공통 태
스트와 함께 6번째 태스트로 실행될 것이다. 리스트 7-80은 트랜잭션 기능을 점검하기
위해 추가한 태스트 코드를 보여준다.

리스트 7-80 다종 SQL 수정에 대한 트랜잭션 테스트

public class EmbeddedDbSqlRegistryTest extends AbstractUpdatableSqlRegistryTest (

OTest
public void transactionalUpdate() { 초기 상태룰 확인효
t
Cf. 이미 슈퍼클래스의 다른 테스트 메

소드에서 확인하긴 했지만 트랜잭션 훌백 후의 결과와 비

checkFind("SQL1" , "SQL2" , .SQL3");~ 교돼서 이 테스트의 목적인 훌빽 후의 상태는 처음과 동일
하다는 것을 비교해서 보여주려고 넣었다

Map<String , String) sqlmap =new HashMap<String , String)();

sqlmap.put("KEY1 ", "Modifiedl"); 두 번째 SQL의 키훌 존재하지 않는 것으로 지
sqlmap.put("KEY9999!
뼈S"， "Modified9999");--용정효떼 이 때문에 테스트는 실때할 것이고 그
때 과연 훌백이 일어니는지 확인한다

try {
sqlRegistry.updateSql(sqlmap);

failO; • 예외가 발생해서 catch 블록으로 넘어가지 않으면 뭔가 잘못된 것이다 그때는 테스트룰
깅제로 실패하게 만돌고 기대외 다르게 동직한 원인을 찾도록 해야 한다，

catch(SqlUpdateFailureException e) {}


~heckFind('SQL1'， 'SQL2" , “SQL3 “);
니 첫 번째 밍L은 정상적으로 수정했지만 트랜잭션이 롤백되
71 때문어| 디).1 변경 이전 상태로

돌아와야 한다 트랜잭션이 적용되지 않는다연 변경된 채로 남아서 테스트는 실때할 것이디

일단 transactionalUpdate() 테스트는 실패를 확인히는 것이 목적이다. 아직 다중
SQL 수정 묘드에 트래잭션 기능을 추가하지 않았기 때문이다. 이 테스트가 예상대로
실패하면， 그때부터 트랜잭션이 적용되도록 코드를 수정하고 최종적으로 이 태스트가
성공히는 것을 확인하면 된다. 태스트가 없었다면 도대체 이런 것은 어떻게 검증할 수
있을까?

테스트를 실행해보면 기존의 다섯 가지 태스트는 성공하지만 트랜잭션을 검증하는
transactionalUpdate() 태스트는 실패할 것이다. 예상했던 것처럼 Map에 담긴 첫 번째
SQL은 수정됐고， 두 번째 것은 존재하지 않는 키이기 때문에 수정하지 못하고 실패했
을 것이다. 트랜잭션 개념이 없으니 첫 번째 것이 그대로 남아 있을 것이고 마지막 검증
과정에서실패한다.

코드를 이용한 트랜잭션 적용
태스트도 준비됐으니 본격적으로 EmbeddedDbSqlRegistry
의 updateSql(Map
sqlmap) 메소드에 트랜잭션 기능을 추가해보자. SimpleJdbcTemplate을 통해
JDBC 처리를 하고 있으므로 스프링의 트랜잭션 추상화 서비스를 적용할 수 있
다. PlatformTransactionManager를 직접 사용해서 트랜잭션 처리 코드를 만들어
도 되지만 그보다는 간결하게 트랜잭션 적용 코드에 템플릿/콜백 패턴을 적용한
TransasctionTemplate을 쓰는 편이 낫다.
EmbeddedDbSqlRegistry가 DataSource를 DI 받아서 트랜잭션 매니저와 템플릿
을 만들게 한다. 일반적으로는 트랜잭션 매니저를 싱
글톤 빈으로 등록해서 사용하
는데， 그 이유는 여러 개의 AOP를 통해 만들어지는 트랜잭션 프록시가 같은 트랜잭
션 매니저를 공유해야 하기 때문이다. 반면에 EmbeddedDbSqlRegistry가 λ}용할 내
장형 DB
에 대한 트랜잭션 매니저는 공유할 필요가 없다. 따라서 번거롭게 빈으로 등
록하는 대신 EmbeddedDbSqlRegistry 내부에서 직접 만들어 사용하는 게 낫다. 사실
PlatformTransactionManager 오브젝트가 아니라 TransactionTemplate을 이용해 트랜
잭션 기능을 사용할 것이므로 트랜잭션 매니저 오브젝트는 트랜잭션 템플릿을 만들기
위해서만 사용하고， 따로 저장해두지 않아도 상관없다. TransactionTemplate은 멀티스

낀~-스프링 핵심 기솔의 응용 643



레드 환경에서 공유해도 안전하도록 만들어져 있으니 처음 만들 때 인스턴스 변수에 저
장해두고사용한다.
리
스트 7 -81
은 트랜잭션 랩플릿
을 이용해서 트랜잭션 기능을 적용한
EmbeddedDbSqlRegistry 클래스 코드다.

리스트 7---81 트랜잭션 기능율 가진 EmbeddedDbSqlRegistry

public class EmbeddedDbSqlRegistry implements UpdatableSqlRegistry {

SimpleJdbcTemplate jdbc;
JdbcTem때녕te과 트랜잭션을 동기회해주는 트랜잭션
TransactionTemplate transactionTemplate;
-경-댐률릿이다 멀티스레드 환경에서 공유 가능하다‘

public void setDataSource(DataSource dataSource) {
jdbc =new SimpleJdbcTemplate(dataSource);
transactionTemplate =new TransactionTemplate(

new DataSourceTransactionManager(dataSource));

L.없뼈Jr'∞로 Transaction뼈때er를 민들고 이를 이용해
TransactionTemptate올 생성한다

익영 내부 클래스로 인들어지는 콜백 오브젝트 안에서

r
^용되는 것이
라 ’
1때로 선언해줘야 한다

public void updateSql (final Map<String , String> sqlmap ) throws
SqlUpdateFailureException {
transactionTemplate.execute(new TransactionCallbackWithoutResult() {
protected void dolnTransactionWithoutResult(TransactionStatus status) {
for(Map.Entry<String , String> entry sqlmap.entrySet ()) { I
updateSql(entrY .getKey() , entrY.getValue() );

}); 트랜잭션 템플릿이 만드는 트랜잭션 경계 안에서 ’ 동작
할 코드률 콜백 형태로 만들고 TransactionTer뼈ate의
ex∞뼈) 메소드에 전달효삐

수정을 마쳤으면 트랜잭션이 제대로 적용됐는지 확인하기 위해 앞에서 실패했던
EmbeddedDbSqlRegistryTest를 실행해보자. 태스트가 성공한다면 트랜잭션이 바르게
적용됐음을알수있다.

더 이상 쪼개지면 안 되는 작업의 최소 단위인 트랜잭션은 이 정도의 태스트라면 충
분히 확인 가능하다. 하지만 매우 분주하게 동작하는 서버환경이라면 트랜잭션 작업의
격리수준jsolation level에도 신경 써야 한다.


뿔 내짧 DB의 트랜잭션 격리쯤 지월
스프링이 지원하는 내장형 DB의 하나인 HSQL의 경우는 1.8 이하의 버전에서는 일반적인 DB
와는 다르게 트랜잭션 격리수준이 READ_UNCOMMITTED라고 보통 불리는 레벨 0만을 지원한
다. READ_UNCOMMITTED 트랜잭션 격리수준의 문제접은 한 트랜잭션이 종료되기 전의 작업

내용을 다른 트랜잭션이 읽을 위험성이 있다는 것이다. 만악 다른 트랜잭션이 몰나기 전에 변경
한 정보훌 읽어버혔는데 해당 트랜잭션이 훌백돼버리면 실제로는 DB에 반영되지 않은 유효하
지 않은 데이터를 사용하는 문제가 발생한다.

성능을 극대화하기 위해 약간의 위험성을 감수하고라도 일부러 낮은 격리수준을 적용하는 경
우가 있긴 하지만. SQL의 변경 작업 같은 중요한 작업에는 권장할 수 없다.
낮은 격리수준의 위험성을 피하려면 READ_COMMITTED 격리수준을 지원하는 HSQL 1.901
상을 사용하거나 H2. 또는 Derby롤 사용해야 한다.

m 꽃릴 311으Dl 洲|


스프링 프레임워크가 나온 지 8
년이 지났다. 그 사이 자바 언어와 자바 엔터프라이즈
표준 기술에 상당한 변화가 있었다. 스프링이 처음 등장했을 즈음에는 오픈소스 기술은
안전하지 않은데다 완성도도 떨어져서 엔터프라이즈 애플리케이션 개발에 적합하지 않
다고 보는 사람이 많았으나 점차 오픈소스 기술의 위상이 높아졌고 지금은 오픈소스 제
품이나 기술 없이 자바 서버 애플리케이션을 개발한다는 건 상상할 수 없는 수준에 다
다랐다. 다OJ=한 언어와 새로운 패턴의 프레임워크가 등장해서 높은 인기를 꿀기도 했
고， 모바일과 클라우드가 새로운 주류 플랫폼으로 떠오르기도 했다. 이런 변화는 자바
프로그래밍 스타일이나 표준 기술과 오픈소스 제품에도 많은 영향을 줬다. 자바 언어와
관련 기술이 다양한 변화를 겪는 동안 스프링도 꾸준히 발전하고 변신해왔다.

스프링이 처음 등장한 이후 많은 변화를 겪은 것은 사실이지만 스프링이 근본적으로
지지하는 객체지향 언어인 자바의 특정과 장점을 극대화하는 프로그래밍 스타일과 이
를 지원하는 도구로서의 스프링 정체성은 변하지 않았다. 놀랍게도 스프링은 1
.
0부터

3.1까지 거의 완벽에 가끼울 만큼 구 버전 호환성을 유지하고 있다. 그 덕분에 구 버전
스프링을 이용해 개발했던 묘드와 설정파일을 최신 스프령 3.1 에서도 수정 없이 그대로
사용할 수 있다. 벼전이 올라가면서 꾸준히 새로운 기능이 추가되고， 점점 더 많은 기술
을 지원하게 되었음에도 스프링의 근본이 변하지 않은 덕이다.
많은 변화 속에서 스프링이 꾸준히 호환성을 지키고 안정된 기술을 유지해올 수 있

견앙-스프링 핵심 기술의 응용 645



었던 것은 스프링이 지지하고 지원하는 객체지향적인 코드의 장점인 유연성과 확장성
을 스프링 스스로가 충실하게 지켜왔기 때문이다. 스프링을 이용해서 만들어지는 애플
리케이션 코드가
DI 패턴을 이용해서 안전하게 발전하고확장할수 있는것처럼 스프링
프레임워크 자체도 DI 원칙을 충실하게 따라서 만들어졌기 때문에 기존 설계와 코드에
영향을 주지 않고도 꾸준히 새로운 기능을 추가하고 확장해나가는 일이 가능했다.

자바 언어의 변화와 스프링
스프링이 제공하는 모든 기술의 기초가 되는 DI의 원리는 변하지 않았지만 DI가 적용
된 묘드를 작성할 때 사용하는 핵심 도구인 자바 언어에는 그간 적지 않은 변화가 있었
다. 이런 변회들이 DI 프레임워크로서 스프링의 사용 방식에도 여러 가지 영향을 췄다.
대표적인두가지 변회를살펴보자.

• 애노테이션의 메타정보 활용
첫째는 자바 코드의 메타정보를 이용한 프로그래밍 방식이다. 자바는 소스코드가 컴
파일된 후 클래스 파일에 저장됐다가，
NM에 의해 메모리로 로딩되어 실행된다. 그
런데 때로는 자바 묘드가 실행되는 것이 목적이 아니라 다른 자바 코드에 의해 데이
터처럼 취급되기도 한다. 자바 코드의 일부를 리플렉션 API 등을 이용해 어떻게 만
들었는지 살펴보고 그에 따라 동작히는 기능이 점점 많이 시용되고 있다.
이런 스타일의 프로그래밍 방식은 자바 5와 JavaEE5가 등장한 시점부터 급격하
게 확산되기 시작했다. 자바 클래스나 인터페이스， 필드 메소드 등의 메타정보를 살
펴보거나 조작하기 위해 java. lang 패키지 아래에 있는 리플렉션 API를 사용히는
방식은 자바 초기 버전부터 존재해왔다. 원래 리플렉션 API는 자바 묘드나 컴포넌트
를 작성하는 데 사용되는 툴을 개발할 때 이용하도록 만들어졌는데， 언제부턴가 본
래 목적보다는 자바 코드의 메타정보를 데이터로 활용히는 스타일의 프로그래밍 방
식에 더 많이 활용되고 있다.

이런 프로그래밍 방식의 절정은자바
5
에서 등장한애노태이션일 것이다. 자바클
래스나 인터페이스， 필드， 메소드 등은 그 자체로 실행 가능하고， 상속하거나 참조하
거나 호출히는 방식 등으로 직접 이용할 수 있다. 반면에 애노태이션은 기존의 자바
프로그래밍 방식으로는 활용할 수가 없다. 애노테이션은 옵션에 따라 컴파일된 클래
스에 존재하거나 애플리케이션이 동작할 때 메모리에 로딩되기도 하지만 자바 코드
가 실행되는 데 직접 참여하지 못한다. 인터페이스처럼 오브젝트에 타입을 부여하는
것도 아니고， 그 자체로 상속이나 오버라이딩이 가능하지도 않다. 동작하는 코드를


넣을 수 없는 것은 물론이고 코드에서 간단히 참조하거나 활용할 수가 없다. 복잡한
리플렉션 API를 이용해 애노태이션의 메타정보를 조회하고， 애노태에션 내에 설정
된 값을 가져와 참고하는 방법이 전부다. 애노태이션 자체가 클래스의 타입에 영향
을 주지도 못하고， 일반 코드에서 활용되지도 못하기 때문에 일반적인 객체지향 프
로그래밍 스타일의 묘드나 패턴 등에 적용할 수도 없다. 그럼에도 애노태이션을 이
용히는 표준 기술과 프레임워크는 빠르게 증가했다. 스프링 또한 애노태이션의 적극
적인활용에앞장서왔다.

이렇게 애노테이션의 활용이 늘어난 이유는 무엇일까? 애노테이션은 애플리케이
션을 핵심 로직을 담은 자바 코드와 이를 지원하는 loC 방식의 프레임워크， 그리고
프레임워크가 참조하는 메타정보라는 세 가지로 구성하는 방식에 잘 어울리기 때문
일 것이다. 애노테이션은 프레임워크가 참조하는 메타정보로 사용되기에 여러 가지
유리한점이많다.

DI
의 기본 원리를 소개했던 l
장의 내용을 다시 생각해보자. 단순하게 작성됐던
UserDao에 객체지향 프로그래밍의 특정을 최대한 적용해서 유연하게 확장 가능한 깔
끔한코드로꾸준히 다듬어 보니 1
.4절에 나온것처럼 책임에 따라서로영향을주지
않고 확장 가능하도록 만들어진 핵심 로직 코드ωserDao. ConnectionMaker. DConnection)와
핵심 묘드가 런타임 시 동적으로 관계를 맺고 동작하도록 만들어주는 DaoFactory.
그리고 DaoFactory를 활용해 핵심 로직 묘드가 서로 관계를 맺고 동작히는 모든 과
정을 제어하는 클라이언트 코드(UserDaoTes t) 세 가지로 구분할 수 있었다. 핵심 로직
을 담은 오브젝트가 클라이언트에 의해 생성되고， 관계를 맺고 제어되는 구조다. 따
라서 이때의 클라이언트는 일종의 IoC 프레임워크로 볼 수 있다. 또한 DaoFactory는
IoC 프레임워크가 참고하는 일종의 메타정보로서 의미가 있다.

런타임 의존관계 정보를 담고 있는 DaoFactory는 처음엔 평범한 자바 코드로 작
성됐다. 객체지향 원칙에 따라 여러 책임이 얽혀 있는 코드를 적절히 분리해서 만들
어졌기 때문에 당연히 평범한 자바 코드로 만들어도 충분하다. 그런데 UserDao 한 가
지가 아니라 애플리케이션을 구성히는 많은 오브젝트의 관계를 IoC
/DI를 이용해서
프레임워크와 메타정보를 활용하는 방식으로 작성하도록 발전시키려면 DaoFactory
와 같은 단순한 자바 묘드로 만들어진 관계 설정 책임을 담은 묘드는 불편하다. 그래
서 1.8절에서는 DaoFactory의 내용을 XML로 전환해서 좀 더 간결한 형태로 전환
했다. 어차피 DaoFactory는 애플리케이션의 로직을 담은 코드에서 사용될 일이 없
기 때문에 형태가 어떻든지 상관없다.XML이라면 DaoFactory 같은 자바 코드를 이

7장-스프링 핵심 기술의 응용 647


용할때보다프레임워크가할 일이 좀 더 많아지긴 하지만 작성하기 면하고 빌드과
정이 펼요 없으며. AOP를 위해 빈 생성과 관계 설정을 재구성히는 경우를 고려하면
X빠 묘드보다 유리했기 때문에 스프링 초창기부터 XML이 프레입워크가 사용하는
오브젝트 관계 설정용 DI 메타정보로 적극 활용돼왔다.

초창기 자바 엔터프라이즈 버전에서 시용됐던 XML에 대한 안 좋은 기억 때문인
지 스프링이 XML을 시용한다는 것 자체에 거부감을 느끼는 개발자도 있다. 쓸데없
이 장황한 정보를 억지로 작성하게 만든다고 생각하기 때문이다. 하지만 그건 잘못
된 생각이다. 스프링 XML에 담긴 정보는 군더더기나 무의미하게 만들어야 하는 잉
여 정보가 아니다. 어쨌든 프레임워크의 도움이 없었다면 더 많은 양의 자바 코드를

이용해서 작성해야 했던 내용이다. 게다가 스프링은 꾸준히 XML을 좀 더 간결하고
효율적으로 작성히는 방법을 제공해왔다.
그런데 애노테이션이 등장하면서 상황어 달라졌다. 애노테이션은 XML이나 여타

외부 파일과 달리 자바 코드의 일부로 사용된다. 코드의 통작에 직접 영향을 주지는
못하지만 메타정보로서 활용되는 데는 XML에 비해 유리한 점이 많다. 다음과 같이

간단한 애노태이션이 사용된 코드를 살펴보자.

package com.mycompany.myproject;

@S pecial
public class MyClass {

@Specia
l
이라는 간단한 애노태이션 하나를 클래스 선언 위에 넣었을 뿐이다. 그
런데 이렇게 하는 것만으로도 여러 가지 정보를 추가로 얻을 수 있다. 가장 먼저
@Special 애노테이션이 타입 레벨 즉 클래스에 부여됐다는 사실을 알 수 있다. 애노
테이션은 정의하기에 따라서 타입， 필드， 메소드， 파라미터， 생성자， 로컬 변수의 한
군데 이상 적용 가능하다. 만약 @Special 애노테이션이 여러 위치에 적용 가능하도
록 정의되어 있다면 위의 코드에선 클래스 레벨에 적용한다는 정보를 얻을 수 있다.
애노테이션이 위치한 My Cl ass 클래스의 메타정보도 얻을 수 있다. @Speical 애노태
이션이 부여된 클래스의 패키지， 클래스 이름 접근 제한자， 상속한 클래스나 구현
인터페이스가 무엇인지 알 수 있다. 원한다면 클래스의 필드나 메소드 구성도 확인
할 수 있다. 단순한 애노태이션 하나를 자바 코드에 넣는 것만으로도， 애노테이션을

참고히는 코드에서는 이렇게 다양한 부가 정보를 얻어낼 수 있다.


반면에 통일한 정보를 XML로 표현하려면 모든 내용을 명시적으로 나타내야 한
다. 간단히 클래스가 무엇인지만 지정하려고 해도 다음과 같이 작성해야 한다.

<x:special target="type" class="com.mycompany.myproject.MyClass “ />

애노테이션 하나를 자바 코드에 넣는 것에 비해 작성할 정보의 양이 많다. 또

한 텍스트 정보이기 때문에 오타가 발생하기 쉽다. 물론 뛰어난 지원 툴을 만들면
XML 작성 중에 클래스의 존재 여부 정도는 확인할 수 있겠지만， 그래도 최신 IDE
에 내장된 자바 에디터의 장점을 최대한 활용할 수 있는 애노테이션보다 불편한 건
사실이다.

리팩토링에서도 많은 차이점이 드러난다. 만약 리팩토링 중에 My
Cl
ass
의 패키지
를 변경하거나 클래스 이름을 바꿨다고 해보자. ID
E를 활용하면 이름이나 위치 정도
를 바꾸는 리팩토령은 간단한 일이다. MyClass를 참조하는 코드도 자동으로 바꿔준
다. 반면에 XML은 패키지나 클래스 정보 등이 단순 텍스트로 작성되어 있어서 리팩
토링을 할 때 번거롭고 안전하지 못하다.

물론 애노테이션에도 단점이 있다.XML은 어느 환경에서나 손쉽게 편집이 기능
하고， 내용을 변경하더라도 다시 빌드를 거칠 필요가 없다. 반면에 애노태이션은 자
바 코드에 존재하므로 변경할 때마다 매번 클래스를 새로 컴파일해줘야 한다. 편리
한 벌드 툴이 많이 나와 있고， 빌드된 패키지의 배포도 자동화된 경우가 많아서 소
스코드의 변경이 예전보다는용이하긴 하지만， 단순한
XML 파일 수정에 비하면 번
거롭다. 고객에게 코드를 납품하거나 외부에 제공하는 경우 설정정보의 변경을 위해
소스코드를 제공해야 한다는 불편도 있다.

자바 개발의 흐름은 점차 XML 같은 텍스트 형태의 메타정보 활용을 자바 코드에
내장된 애노테이션으로 대체하는 쪽으로 가고 있다. JavaEE 내의 다양한 엔터프라
이즈 표준 기술은 물론이고 JavaSE에도 애노테이션이 폭넓게 적용되고 있다. 오푼
소스프레임워크에서도마찬가지다.

스프링은 2.5 벼전에서 DI와 웹 기능 일부에 애노태이션을 적용하기 시작했고
스프링 3.0에서는 다OJ=한 영역으로 애노테이션의 활용범위를 넓혔다. 애노테이션이
도입되기는 했지만 XML이 여전히 DI 메타정보 작성의 중심이었다. 스프링 3.0까지
는 XML을 완전히 배제하기는 불기능했다. 그런데 스프링 3.1 에서는 애노테이션을
이용한 메타정보 작성 방식이 거의 모든 영역으로 확대돼서， 원한다면 스프링 애플
리케이션을
XML 없이도작성할수 있게 됐다.

객체지향 언어의 기본에 충실하게 작성된 자바 코드 형태로 시작됐던 DI 패턴은

7갚 스프링 핵심 기솔의 응용 649


프레임워크의 발전과 함께 자바 코드와 프레임워크. XML 메타정보의 형태로 진행
되다가 스프링 3.1 에 이르러서는 핵심 로직을 담은 자바 코드와 DI 프레임워크， 그
리고 DI를 위한 메타데이터로서의 자바 코드로 재구성되고 었다.

정책과 관례를 이용한 프로그래밍

애노테이션 같은 메타정보를 활용하는 프로그래밍 방식은 코드를 이용해 명시적으
로 동작 내용을 기술하는 대신 코드 없이도 미리 약속한 규칙 또는 관례를 따라서 프
로그램이 동작하도록 만드는 프로그래밍 스타일을 적극적으로 포용하게 만들어왔다.
DaoFactory 같은 자바 묘드를 대체한 스프링의 XML도 미리 정의한 정책을 이용해
서 특정 기능이 동작하게 만든 것이라고 볼 수 있다. <bean) 태그를 작성해두면 그에
따라 하나의 오브젝트가 만들어진다. new 키워드를 이용한 인스턴스 생성 묘드가 통
작하는 셈이다. <property)는 프로퍼티 주입을 통해 오브젝트 의존관계가 설정되는
코드가 동작하게 된다. 미리 정의한 규칙을 따라서 프레임워크가 작업을 수행한다.
이런 스타일의 프로그래밍 방식은 자바 코드로 모든 작업 과정을 직접 표현했을 때

에 비해서 작성해야 할 내용이 줄어든다는 장점이 있다. 좀 더 지능적으로， 자주 반
복되는 부분을 관례화하면 더 많은 내용을 생략할 수도 있다.

반면에 프로그래밍 언어나 API 사용법 외에 미리 정의된 많은 규칙과 관례를 기
억해야 하고， 메타정보를 보고 프로그램이 어떻게 동작할지 이해해야 하는 부담을
주기도 한다. 익숙해지면 편하겠지만， 그때까지 적지 않은 학습 비용이 들고， 자칫
잘못 이해하고 있을 경우 찾기 힘든 버그를 만들어내기도 한다.

루비 언어를 기반으로 한 RoR 프레임워크의 폭발적인 인기에 영향을 받아 이
런 스타일의 프로그래밍 방식은 자바 기술과 스프링에도 많은 영향을 주었다. 같은

XML을 작성하더라도 미리 정해진 규칙이나 관례를 이용해서 작성해야 할 메타정보

의 양을 최소화하게 했다. 애노태이션을 이용하는 방식도 마찬가지다. 애노태이션은
작성하는 묘드의 양에 비해 부가적으로 얻을 수 있는 정보가 많기 때문에 일정한 패
턴을 따르는 경우 관례를 부여해 명시적인 설정을 최대한 배제하면 애플리케이션의
코드가 매우 간략해진다.

코드로 직접 모든 내용을 작성하는 것보다 간결하고 빠른 개발이 가능하기 때

문에 이런 스타일의 프로그래밍 방식은 지속적으로 인기를 꿀고 있다. 스프링에서

도 점차 이런 스타일이 늘고 있다. 6.7절에서 살펴봤던 @Transactional의 대체 정

책을 생각해보자. @Transactional은 클래스와 인터페이스， 그리고 각각의 메소드

를 포함해 네 가지 위치에 적용이 가능하다. 만약 한 오브젝트가 이 네 가지 종류


의 @Transactional을 모두 갖고 있다면 트랙잭션 속성이 최종적으로 어떻게 적용
될까? @Transactional로부터 트랜잭션 속성을 가져와 선택히는 코드를 직접 만들
것도 아니니 코드를 들여다봐도 답이 나오지 않는다. 번거롭지만 명확하게 하려면
@Transactional
에 중첩된 설정이 있는 경우에는 적용 우선순위를 직접 지정하도록
만들 수 있다， @Transactional(order=l)과 같은 식이 될 것이고， order가 높은 쪽의
설정이 우선적으로 적용되게 만들면 된다. 우선순위에 충돌이 일어나는 경우엔 에러
를 내면 될 태고. 하지만 스프링은 그 대신 미리 4단계의 우선순위를 가진 대체 정책
을 정해놨다， @Transactional을 제대로 활용하려면 관례화된 이 정책을 기억하고 코
드를 작성해야 한다. 미리 만들어진 묘드를 읽고 어떻게 동작하는지 이해해야 할 때
도 마찬가지다. 대체 정책은 코드에선 그 내용을 찾을 수가 없다. 애노태에션을 메타
정보로 이용하면서도 명시적으로 정보를 넣도록 하지 않았다. 그 덕분에 묘드는 간
결해진다. 하지만 정책을 기억 못하거나 잘못 알고 있을 경우 의도한 대로 동작하지
않는 묘드가 만들어질 수 있다. 트랜잭션 속성의 문제 같은 경우는 디버깅도 매우 어
렵다.

애플리케이션이 동작히는 방식과 기능을 코드에 직접 담는 것이 좋을 수도 있고，
XML과 같은 메타정보로 작성해두고 프레임워크에 의해 동작하도록 만드는 편이 나
을 수도 있다. 텍스트 형태의 XML을 이휩l는 방법이 좋은 개발자도 있고， 자바 코
드와 함께 작성하는 애노테이션을 선호히는 개발자도 있을 것이다. 가능한 한 명시
적으로 메타정보를 작성하는 것이 안전하고 쉽다고 보는 사람도 있고， 최대한 관례
와 지능적인 디폴트 등을 이용해서 작성할 코드와 메타정보를 최소화하는 방법에 매
력을느끼기도한다.

어쨌든 스프링은 점차 애노테이션으로 메타정보를 작성하고， 미리 정해진 정책과
관례를 활용해서 간결한 코드에 많은 내용을 담을 수 있는 방식을 적극 도입하고 있
다. 스프링 3，
1은 그런 면에서 완성도가 상당히 높다. 스프링 하면 제일 먼저 떠오르
는 것 중의 하나였던 XML을 전혀 사용하지 않고도 스프링 애플리케이션을 만들 수
있다는 점은 스프링이 공개된 이후로 가장 큰 변화일 것이다.

이 절에서는 I
장부터 지금까지 발전시켜왔던 λF용자 DAO와 서비스 기능의 예제 코
드를 스프링 3,1의 최신 DI 스타일로 바꾸는 과정을 보여주고 설명할 것이다. 스프링
3，0과 3，
1의 다OJ=한 DI 코드 작성 방식은 V이
2에서 자세히 설명한다. 이 절에서는 지
금까지 스프링의 핵심 원리를 설명하기 위해 단계적으로 설명하고 작성했던 것이 스프
링 3，
1
의 최신 스타일을 적용하면 어떻게 달라지는지， 어떤 장점이 있는지만 간략히 살

7징-스프링 핵심 기술의 응용 651


펴보겠다. 스프링이 DI
의 원리와 다잉댁f 패턴을 빈과 DI 설정정보를 담은 자바 코드와

애노테이션 등에 어떻게 적용했는지도 눈여겨보자.

시용자 관리를 위해 지금까지 만들었던 애플리케이션 로직이나 관련 테스트에 새로

운 기능을 추가하거나 변경히는 일은 없을 것이다. 기능의 변경 없이 구조만 개선하는

작업이므로 일종의 리팩토링이다. 리팩토링을 진행할 때 중요한 것은 태스트를 준비하

는 일이다. 리팩토링 과정에서 코드나 설정정보를 수정하게 되므로 자칫 실수하면 기존

에 잘 동작하던 기능이 바르게 동작하지 않을 수도 있다. 다행히 지금부터 리팩토링을

진행할 Vol.l
의 예제 코드는 처음부터 테스트를 충실하게 만들어왔으니 안심이다. 매

단계를 진행할 때마다 태스트를 모두 실행해서 문제가 발생하지 않는지 확인해보자. 혹

시 테스트가 실패하면 더 문제를 확인해서 태스트가 모두 성공하도록 만든 뒤 디음 단

계로진행해야한다.

스프링 3.1
의 DI 스타일로 변경하는 리팩토링은 총 6단계로 진행할 계획이다. 지금

까지 그랬던 것처럼， 급하게 최종 결과 묘드를 뽑아내기보다는 각 작업의 특정과 장단

점을 살펴보면서 단계적으로 진행하겠다.

7.6.1 자바 코드를 이용한 빈 설정
첫 번째 작업은 XML을 없애는 것이다. 애노테이션과 자바 묘드로 XML을 대체해볼
것이다.
지금까지 사용한 XML은 원래 자바 코드로 만든 오브젝트 팩토리의 기능을 프레임
워크를 도움을 받아서 간략한 방식으로 표현한 것이다. 1.8절의 내용을 다시 살펴보면
XML과 DaoFactory가 통일한 정보를 표현하고 있다는 사실을 알 수 있다. 지금까지는
자바 코드보다 간결하고 편하게 DI 정보를 담을 수 있었기 때문에 XML을 사용해왔지
만 이제는 애노테이션과 새로운 스타일의 자바 코드로 바꿀 것이다.
XML에 담긴 DI 정보는 스프링 태스트 컨텍스트를 이용해서 테스트를 작성할 때 사
용된다. 스프링 태스트 컨텍스트의 도움 없이 자바 묘드의 기능을 테스트하는 UserTest
같은 단위 태스트에서는 펼요 없다. 따라서 스프링 프레임워크와 DI 정보를 이용해 테
스트히는 UserDaoTest와 UserServiceTest 두 가지만 신경을 쓰면 된다.
지금까지 만들어왔던 XML 설정정보는 UserDao나 UserService가 실제 운영환경에
서 동작할 때 사용하려고 만든 것은 아니다. 단지 기능이 잘 동작히는지 검증할 수 있게
만든 태스트용 DI 설정정보다. 그래서 이름도 test-applicationContext.xml로 했다. 태
스트 목적으로만 사용될 testUserService 빈도 있고， 메일 발송 기능이 있는 묘드가 동


작하는지 확인하기 위해서만 사용하는 실제 메일 발송 기능은 없는 DummyMailSender
도 등록되어 있다. DB 연결정보를 담은 dataSource 빈은 태스트용 로컬 DB를 이용한
다. 이제부터 진행할 작업에는 DI 관련 정보와 코드를 스프링 3.1
로 변경히는 일과 함
께， 테스트용으로 만들어진 기존 XML에서 애플리케이션이 운영환경에서 동작할 때 펼
요로 하는 DI 정보를 분리해내는 일도 포함된다.

테스트컨텍스트의변경
XML을 더 이상 사용하지 않게 하는 것이 최종 목적이다. 그렇다고 바로 XML 파일을
삭제하고 시작할 필요는 없다. 스프링 3.1
은 애노테이션과 자바 코드로 만들어진 DI 설
정정보와 XML을 동시에 시용할 수 있는 방법도 제공해주기 때문이다.
가장 먼저 할 일은 태스트 코드에서 DI 정보가 XML에 담겨 있다고 정의한 부분을
찾아 DI 정보를 담은 X빠 코드를 사용하도록 바꾸는 것이다. 찾는 방법은 간단하다.
test-appl icationContext. xml
이라는 XML 파일 이름이 나오는 코드를 찾으면 된다.
UserDaoTest와 UserServiceTest에는 리스트 7-82와 같이 XML 위치를 지정히는 코
드가들어가있다.

리스트 7-82 XML 파일올 사용하는 UserD∞，Test

@RunWith(SpringJUnit4ClassRunner.class)
iContextConfiguration(locations="'test-applicationContext.xml")
public class UserDaoTest {

@ContextConfiguration은 스프링 테스트가 태스트용 DI 정보를 어디서 가져외야
하는지 지정할 때 사용히는 애노태이션이다. locations 엘리먼트는 DI 설정정보를 담
은 XML 파일의 위치를 가리킨다. @ContextConfiguration
이 XML 위치 대신 DI 정보
를 담고 있는 자바 클래스를 이용하게 만들어보자.

먼저 DI 정보로 사용될 자바 클래스를 만들어야 한다.DI 설정정보를 담은 클래
스는 평범한 자바 클래스에 @Configuration 애노태이션을 달아주면 만들 수 있다.
@Configuration 애노테이션은 1.5
절에서 DaoFactory 클래스를 스프링 컨테이너가 사
용하는 )oC/DI 정보로 활용되게 할 때 이미 시용해봤다.

간단히 TestApplicationContext라는 이름의 클래스를 리스트 7-83과 같이 생성하
자. 이 TestApplicationContext 클래스가 앞으로 XML을 대체하는 DI 설정정보로 사
용될것이다.

7징-스프링 핵심 기솔의 응용 653



리스트 7-83 미 메타정보로 사용될 TestApplicationContext 클래스

@(onfigration
public class TestApplicationContext (

@Configuration 클래스가 준비됐으니 이제 UserDaoTest와 UserServiceTes
t가
XML 대신 TestApplicationContext 클래스를 테스트의 DI 컨텍스트 정보로 λF용하
도록 변경한다. 방법은 간단하다. @ContextC
onfiguration
의 locations 엘리먼트를 제
거하고 대신 clas
ses를 넣어서 TestApplicationContext를 지정하도록 리스트 7-84와
같이만들면된다.

리스트 7-84 TestApplicationConte셔훌 테스트 건텍스트로 사용하도록 변경한 UserDaoTest

@RunWith (SpringJUnit4ClassRunner .class)
@(ontextConfiguration( classes=TestApplicationContext.class)
public class UserDaoTest {

UserServiceTest도 같은 방식으로 변경한다.

이렇게 바꾸고 태스트를 실행하면 어떻게 될까? 해보나 마나일 것이다. 아직
TestApplicationContext에는 아무런 DI 정보가 없다. 아무런 빈도 만들어지지 않으
니 태스트는 실패할 것이다. 테스트를 성공시키려면 XML에 있던 빈 설정정보를 모두
TestApplicationContext로 옮겨야 한다. 그런데 한 번에 다 옮기자니 부담스럽다. 이
럴 때는 TestApplicationContex
t에 모든 빈 정보를 담는 대신 XML의 도움을 받도록
만드는게좋겠다.

자바 클래스로 만들어진 DI 설정정보에서 XML의 설정정보를 가져오게 만들 수 있
다. 리스트 7-85와 같이 @ImportResource 애노테이션을 이용하면 된다.

리스트 7-85 Tes여pplicationContext를 테스트 컨텍스트로 사용하도록 변경한 UserD∞ITest

@(onfiguration
@ImportResource("/test-applicationContext.xml")
public class TestApplicationContext {

이제 태스트를 돌려보자. UserDaoTest와 UserServiceTest 테스트가 모두 성공할 것
이다.


아직은 TestApplicationContext를 앞에 내세웠을 뿐 여전히 XML의 Dl 정보를 활
용한다. 하지만 앞으로 진행할 작업의 중요한 기반을 만든 것이다. 이제부터 XML의
Dl 정보를 단계적으로 TestApplicationContext로 옮길 수 있다. 미처 옮기지 못한 내
용은 그대로 XML에 남겨두면 된다. TestApplicationContext에 자바 묘드와 애노테이
션으로 정의된 Dl 정보와 @!mportResource로 가져옹 XML Dl 정보가 합쳐져서 최종
DI 설정정보로 통합된다. 단계적으로 XML의 내용을 옮기다가 XML에 더 이상 아무
런 Dl 정보가 남지 않으면 그때 XML 파일과 함께 @!mportResource를 제거하면 XML
에서 자바 코드로의 전환 작업이 모두 마무리될 것이다.

(context:annotation-config η 제거

XML
의 내용을 TestApplicationContext 내부로 옮기는 작업을 본격적으로 진행해
보자.

시작하기 전에 현재 XML의 전체 내용을 한 번 살펴보자. 리스트 7-86은 7.5절까지
만들었던 Dl 설정정보를 담은 test-applicationContext. xml
이다.

리스트 7-86 test-ap때icationContext.xml

<?xml version="1.0'’ encoding="UTF-8"?)
(beans ...)
(context:annotation-config /)

(!--db --)
(bean id="dataSource"

class="org.springframework . jdbc .datasource .SimpleDriverDataSource")
(property name="dri verClass" value=“com.mysql. jdbc .Driver" /)
(property name="url"

value="jdbc:mysql:/
!l
ocalhost/springbook?characterEncoding예TF-8
“ /)

(property name="username" value="spring" /)
(property name=개assword" value="book'’ /)
(/bean)

(bean id="transactionManager"
class="org. springframework. jdbc .datasource. DataSOLωII써
히nsactioαn배히n1
ager"

uπrceTra
Ma매녕
“‘

(property name="dataSource" ref=‘’dataSource" /)
(/bean)

(!--sql service --)
(bean id=갱qlService" class=갱
pringbook.user
.
sqlservice
.
OxmSqlService")
(property name="unmarshaller" ref=“ unmarshaller" /)

까당-스프링 핵심 기술의 응용 655



(property name="sqlRegistry “ ref=영qlRegistry'’ /)
(/bean)

(bean id="sqlRegistry"

class=당
pringbook
.
user.sqlservice.updatable.EmbeddedDbSqlRegistry")
(property name=‘ dataSource" ref=갱mbeddedDatabase" /)
(/bean)

(jdbc:embedded-database id="embeddedDatabase' type='HSQL')
(jdbc:script location=
"classpath:springbook/user/sqlservice/updatable/sqlRegistrySchema.sql"/)
(/jdbc:embedded-database)

(bean i
d="띠미매nl
arsha
c
las
s="퍼
sprin1
gfra
meworlk.oxmnι. 재
려ller"

띠
u
1m녕
려ller"‘“. org
.
매빙
메
‘
따
jaxb .Jaxb2
Marsha
’

unrr뻐


(property name="contextPath “ value="springbook .user.sqlservice . jaxb' /)
(/bean)

(!--aop --)
(tx:annotation-driven /)

(!--application components --)

id="피
c
sprin1밍
이‘
이
dbc
"

(bea히n userDaoψ" 이lass="닝
때gboα00Jkk.ι.lμuse
r.
daoα.λ.UserDao)η]삐
‘‘l
(properπty name="dataSource" ref="dataSource" /)
(property name=꺼qlService" ref="sqlService" /)

(/bean)

(bean id="userService" class="springbook.user.service.UserServicelmpl ‘>
(property name="userDao" ref="userDao' /)
(property name=‘ mailSender' ref=‘ mailSender" /)

(/bean)

(bean id='testUserService"

class=갱
pringbook.user.service.UserServiceTest$Tes
tU
serService"

parent="userService" /)

(bean id="mailSender" class=닝pringbook.user
.
service
.
DummyMailSender' /)
(/beans)

test-applicationContext. xml은 여러 개의 <bean>과 스프링 전용 태그로 구성되어
있다. 그런데 이 중에서 바로 제거해도 좋은 것이 한 가지 있다. 가장 앞부분에 나오는
<context:annotation-config />이다. 정말 그런지 <context:annotation-config />
을 삭제하고 테스트를 다시 돌려보자. 태스트는 아무 문제 없이 모두 성공한다.


<context:annotation-config />을 삭제했는데도 왜 아무런 문제가 없을까?
<context:annotation-config />은 @PostConstruct를 붙인 메소드가 빈이 초기화된
후에 자동으로 실행되도록 사용했다. <context:annotation-config />에 의해 등록되
는 빈 후처리기가 @
PostConstruct와 같은 표준 애노태이션을 인식해서 자동으로 메소
드를 실행해준다. 예를 들어 OxmSqlService의 loadSql() 메소드는 OxmSqlService가
바르게 동작하기 위해 반드시 미리 실행돼야 하므로 @PostConstruct를 부여했다.

<context:annotation-config />이 펼요했던 때와 달라진 것은 하나뿐이다. 스프링
컨테이너가 참고히는 DI 정보의 위치가 XML에서 TestApplicationContext라는 자바
클래스로 바뀐 것이다. 바로 이 때문에 <context:annotation-config />을 제거해도
된 것이다. 스프링 컨테이너의 구현도 여러 가지다.XML에 담긴 DI 정보를 이용핸
스프링 컨테이너를 사용하는 경우에는 @PostConstruct와 같은 애노테이션의 기능이 필
요하면 반드시 <context:annotation-config />을 포함시켜서 필요한 빈 후처리기가
등록되게 만들어야 한다. 반면에 TestApplicationContext
처럼 @Configuration
이 붙은
설정 클래스를사용하는 컨테이너가시용되면 더 이상
<context:annotation-config />
을 넣을 필요가 없다. 컨테이너가 직접 @PostConstruct 애노테이션을 처리하는 빈 후
처리기를 등흑해주기 때문이다. 이에 관해서는 Vol.2
의 1.5
절에서 상세하게 설명할 것
이다. 일단은 @Configuration
이 붙은 자바 클래스를 DI 정보로 사용하면 XML에 있던
<context:annotation-config />은 더 이상 필요하지 않다고만 기억해두자.

<context:annotation-config />을 XML에서 제거하고 태스트를 돌려서 아무런 이
상이 없다면다음단계로넘어가자.

(bean)의 전환

이변엔 <bean>을 이용해서 작성한 빈 정보를 자바 코드로 전환해보겠다.

1.8절에서는 자바 묘드로 만들었던 빈 등록 정보를 XML로 바꾸는 작업을 했다. 리
스트 1-35
에서 살펴봤듯이. <bean>으로 정의된 DI 정보는 자바 코드， 특별히 @Bean
이
붙은 메소드와 거의 1:1
로 매핑된다. @Bean은 @Configuration
이 붙은 DI 설정용 클래
스에서 주로 사용되는 것으로 메소드를 이용해서 빈 오브젝트의 생성과 의존관계 주입
을 직접 자바 코드로 작성할 수 있게 해준다.
일단 DB 연결과 트랜잭션 매니저 빈을 옮겨보자. dataSource 빈은 XML에 리스트
7-87과 같이 정의되어 있다.

7징-스프링 핵심 71술의 응용 657


리스트 7-ffl XML을 이용한 dataSource 빈의 정의

<bean id="dataSource"
class="org.springframework .jdbc .datasource.SimpleDriverDataSource">
<property name="dri verClass" value="com .mysql. jdbc .Driver" />
<property name="url"
value="jdbc:mysql:/
!l
ocalhost/springbook?characterEncoding예TF-8" />
<property name="username" value="spring" />
<property name=“ password" value="book'’ />

</bean>

<bean>은 @Beanoj 붙은 public 메소드로 만들어주면 된다. 메소드 이름은 <bean>
의 id 값으로 한다. 메소드의 리턴 값 타입은 조금 신중하게 결정해야 한다. 많은 경우
에 class 애트리뷰트의 클래스를 그대로 사용해도 상관없지만 정확히 하려면 빈을 주
입받아서 사용하는 다른 빈이 어떤 타입으로 이 빈의 존재를 알고 있는지 확인할 펼요
가 있다. dataSource 빈은 UserDao 등에서 DataSource 타입의 프로퍼티를 통해 주입
받아 사용한다. SimpleDriverDataSource 클래스는 DataSource의 한 가지 구현일 뿐이
다.DI 원리에 따라 빈의 구현 클래스는 자유롭게 변경이 가능하다. 변경하더라도 해
당 빈에 의존하는 다른 빈의 묘드는 바뀔 필요가 없어야 한다. 그런데 빈을 정의하는
dataSource() 메소드의 리턴 값을 SimpleDriverDataSource로 해버리면 이를 참조하는
쪽에서 실수로라도 SimpleDriverDataSource 타입으로 주입받을 위험이 있다. 당장엔
문제가 없지만 이후에 dataSource 빈의 구현 클래스가 바뀌면 참조하는 다른 빈의 코드
도 같이 변경해야 한다. 그래서 빈의 의존관계가 인터페이스를 통해 안전하게 맺어지도
록 dataSource 빈의 리턴 값 타입은 DataSource 인터페이스로 하는 것이 좋다.

지금까지 매핑한 내용을 가지고 메소드의 틀만 만들어보면 다음과 같이 나올 것
이다.

@Bean

public DataSource dataSource() {

이제 메소드 내용을 만들어보자.

가장 먼저 할 일은 빈 오브젝트를 만드는 것이다. @Bean 메소드에서는 빈 인스턴스
생성과 프로퍼티 설정 등을 모두 실제 동작하는 묘드로 만들 필요가 있다. 코드로 만드
는 것이 조금 번거로운 점도 있지만 내용이 직관적이고 IDE의 도움을 받으면 긴 이름의
클래스 이름을 넣기도 편하다. 또한 단순히 의존관계의 빈을 수정자뚱tter 메소드를 통해

넣어주는 것 말고 다른 작업을 수행할 수도 있다.


생성할 빈 오브젝트의 클래스는 <bean)
의 class
에 나온 것을 그대로 사용하면 된다.
아무런 프로퍼티가 없다면 오브젝트 생성과 동시에 바로 리턴해버리면 되지만 프로퍼
티가 있는 경우엔 일단 로컬 변수로 받아둬야 한다.

그런데 변수의 타입은 어떻게 해야 할까? 메소드의 리턴 값 타입은 다른 빈과의 관계
를 고려해서 대표되는 인터페이스를 사용해야 한다고 했다. 그렇다면 빈 오브젝트를 저
장할 로컬 변수도 디음과 같이 DataSource 인터페이스 타입으로 선언해야 할까?

DataSource dataSource = new SimpleDriverDataSource();

이건 아니다. @Bean 메소드 내부에서는 빈의 구현 클래스에 맞는 프로퍼티 값 주입
이 필요하다. 프로퍼티는 구현 클래스에 의존적인 경우가 대부분이다. DB 연결정보를
넣기 위해 당장에 setUrl ()이나 setUsername() 같은 수정자 메소드가 필요하다. 그런
데 DataSource에는 이런 메소드가 존재하지 않는다
DataSource는 DB 커넥션을 가져
오는 기능만 정의하고 있다. 따라서 빈 내부에서 new 키워드를 사용해 빈 인스턴스를 만
드는 경우에는 다음과 같이 구현 클래스 타입으로 변수를 만들어야 한다.

SimpleDriverDataSource dataSource = new SimpleDriverDataSource();

이제 필요한 프로퍼티 값을 넣어주도록 수정자 메소드를 호출히는 코드를 추가하고，
마지막으로 생성된 빈 오브젝트를 리턴해주면 된다. 수정자 메소드 호출은 <property)
마다 하나씩 넣어준다. 한 가지 주의할 점은 username 같은 프로퍼티는 타입이 스트
령이므로 XML에서처럼 문자열을 만들어서 넣으면 되지만 driverCl ass 프로퍼티
는 Class<? extends Driver) 타입이라 "com.mysql. jdbc .Driver" 같은 문자열 대신
Cl ass 타입의 드라이버 클래스를 시용해야 한다. XML에서는 스프링 컨테이너가 빈의
프로퍼티 타입을 보고 문자열로 되어 있는 "com. mysql. jdbc. Dri ver
“를 Cl ass 타입의
com.mysql.jdbc.Driver.class로 알아서 변환해준다. 반면에 자바 코드로 작성할 때는
다음과 같이 프로퍼티 타입에 맞게 값을 넣어야 한다.

import com.mysql .jdbc.Driver;

ds.setDriverClass(Driver.class);

리턴 값과 빈 로컬 변수， 프로퍼티 값의 타입에 주의해서 리스트 7-87
의 <bean)을
자바 메소드로 모두 옮겨보면 리스트 7-88과 같이 만들어진다.

견!t 스프링 핵심 기술의 응용 659


리스트 7-88 자바 코드로 작성한 dataSource 민

@8 ean
public DataSource dataSource() {
SimpleDriverDataSource dataSource =new SimpleDriverDataSource();

dataSource.setDriverClass(Driver.class);

dataSource.setUrl("jdbc:mysQl:/
!l
ocalhost/springbook?characterEncoding예TF-8");
dataSource.setUsername( 닝
pring") ;
dataSource.setPassword("book");

return dataSource;

대응되는 자바 코드를 만들었으니 XML에서 dataSource 빈을 정의한 <bean>은 제
거한다. 테스트를 돌려보고 @Bean 메소드로 만든 자바 코드가 dataSource 빈을 잘 만들
어서 동작히는지 확인해보자. 테스트는 깔끔하게 성공할 것이다.

dataSource 빈은 TestApplicationContext
에 있는 dataSource() 메소드로 정의
했는데， 이 빈을 참조해서 사용하는 빈은 XML의 userDao와 transactionManager다.
@Configuration 자바 클래스에서 정의한 빈과 XML에서 정의한 빈은 얼마든지 서로
참조가 가능하다. 여기서는 XML에서 자바 코드로 정의한 빈을 참조했는데， 반대로 자
바코드에서 XML로 정의한 빈을 참조할수도 있다.

dataSource 빈은 다른 빈에 의존하지 않는다. 단지 텍스트나 클래스 타입의 값만 프
로퍼티로 갖고 있을 뿐이다. 이런 프로퍼티는 간단히 수정자 메소드를 샤용해 코드를
작성하면 된다. 그런데 이번에 XML에서 자바 클래스로 옮길 transactionManager 빈
은 값이 아니라 다른 빈 오브젝트를 프로퍼티에 주입해줘야 한다. transactionManager
빈의 프로퍼티에 주입해야 할 빈은 @Bean 메소드로 작성한 dataSource 빈이다. @Bean
메소드로 정의된 빈을 프로퍼티에 주입해주는 방법에 대해서는 1.7.5
절에서 설명했다.
주입해줄 빈의 메소드를 직접 호출해서 그 리턴 값을 수정자 메소드에 넣어주변 된다.
@Bean 메소드의 이름을 빈 아이디와 통일한 것으로 시용했기 때문에 코드도 직관적으로
만들어진다.

리스트 7-89
와 같이 XML
로 정의된 transactionManager 빈을
TestApplicationContext 내의 메소드로 전환하면 리스트 7-90과 같이 된다.


리스트 7-89 XML로 정의한 transactionManager 빈

<bean id="transactionManager"

class=피rg.springframework.jdbc.datasource.DataSourceTransactionManager'’〉

<property name="dataSource" ref="dataSource" />
</bean>

리스트 7• g 자바 코드로 정의한 transactionManager 빈

@Bean

public PlatformTransactionManager transactionManager() (
DataSourceTransactionManager tm = new DataSourceTransactionManager();
tm.setDataSource(dataSource());
return tm;

transactionManager 빈의 인터 페이스는 TransactionManager
가 아니 라
PlatformTransactionManager인 것만 주의하면 된다. XML의 transactionManager 빈
정의를 삭제했으면 테스트를 실행해 아무런 문제가 없는지 확인하자.

XML의 <bean>으로 정의된 빈을 자바 코드로 전환하는 방법을 알았으니 나머지
<bean>도 모두 옮겨보자. 먼저 애플리케이션 로직을 담고 있는 userDao, userService
빈과 트랜잭션 태스트용으로 만든 testUserService 그리고 실제 메일 서비스를 대신해
서 테스트에서 동작하게 만든 mailSender 빈을 자바 묘드로 변환한다.

이때 주의할 것은 testUserService 빈인데 testUserService 빈은 userService와
<property> 정의 부분이 동일하기 때문에 이를 직접 지정히는 대신 parent 정의를 이
용해서 userService의 프로퍼티 정의 부분을 그대로 상속하게 만들었다. XML에서
는 다음과 같이 단순하게 parent만 지정하고 말았지만 @Bean 메소드로 전환할 때는
userService 빈 설정을 참고해서 프로퍼티 값을 모두 넣어줘야 한다.

<bean id="testUserService"
class="springbook .user.service .UserServiceTest$TestUserService"
parent=‘ userService" />

그런데 testUserService 빈을 자바 묘드로 옮기다 보면 TestUserService 클래스를
찾을 수 없다는 에러를 만나게 될 것이다. TestUserServie 클래스는 태스트 용도로 만
든 것이므로 UserServiceTest의 스태틱 멤버 클래스로 정의했다. <bean>에서 class로
지정해서 잘 시용했던 TestUserService 클래스를 자바 묘드에서는 왜 찾을 수 없을까?
그것은 TestUserService가 public 접근 제한자를 갖고 있지 않기 때문이다. 스프링의

7징-스프링 핵심 기술의 응용 661



<bean>
에 넣는 클래스는 굳이 public
이 아니어도 된다. 내부적으로 리플렉션 API를
이용하기 때문에 private으로 접근을 제한해도 빈의 클래스로 사용할 수 있다. 반면에
직접 자바 코드에서 참조할 때는 패키지가 다르면 public으로 접근 제한자를 바꿔줘야
한다.

UserServiceTest 클래스에 있는 TestUserService에 다음과 같이 public을 붙여주
면 문제는 해결될 것이다.

public static class TestUserService extends UserServicelmpl {

리스트 7-91 의 네 개의 <bean> 정의를 자바 코드로 비꾸면 리스트 7-92와 같이 될
것이다.

리스트 7-91 XML의 빈 정의

(bean id="userDao" class="springbook.user.dao.UserDaoJdbc")
(property name="dataSource“ ref="dataSource" /)
(property name="sqlService" ref=갱qlService" /)

(/bean)

(bean id="userService" class="springbook.user.service.UserServicelmpl")
(property name="userDao" ref="userDao" /)
(property nlarme="깨a
맨때der" r매때
라ilSe
n1띠
ref="깨


〈이/bean)

(bean id="testUserService"

class=갱pringbook.user.service.UserServiceTest$Tes
tU
serService"

parent="userService'’ /)

(bean id="mailSender" 이
ass=갱
pringbook
.
user.service
.
DummyMailSender" /)

리스트 7냉12
@Bean 메소드로 변환한 빈 정의

@ßean

public UserDao userDao() {
UserDaoJdbc dao = new UserDaoJdbc();
dao.setDataSource(dataSource());
dao.setSqlService(sqlService());
return dao;

@ßean
public UserService userService() {


UserServicelmpl service = new UserServicelmpl();
service.setUserDao(userDao());
service.setMailSender(mai lSender());
return SerVICe;

OOean

public UserService testUserService() (
TestUserService testService = new TestUserService();
testService.setUserDao(userDao());
testService.setMailSender(mailSender());
return testService;

OOean
public Ma iJSender mailSender() (
return new DummyMailSender();

그런데 변환하고 나니 userDao( )의 다음 줄에서 에러가 난다.

dao .setSqlService(sqlService());

자바 묘드로 빈을 정의할 때 다른 빈을 프로퍼티에 넣어주려면 빈의 아이디와 같은
이름의 메소드를 호출하면 된다고 했다. 그런데 sqlService 빈은 아직 메소드로 만들어
지지 않았다. 그래서 sqlService() 메소드를 호출해서 프로퍼티 값을 가져오는 위의 코
드에서 에러가 난다. sqlService 빈을 XML에서 제거하고 자바 묘드로 변환하면 문제
는해결될것이다.

XML과 자바 클래스를 동시에 DI 정보로 사용하는 경우 자바 코드로 정의한
dataSource 빈은 XML에서 (property)를 이용해 참조할 수 있었다. 반대로 자바 코드
에서는 XML에서 정의한 빈을 참조하려면 어떻게 해야 할까?

XML
에 정의된 빈은 sqlSe
rvice()
처럼 같은 메소드를 호출하는 방법으로는 가
져올 수가 없다. 이런 경우엔 클래스에 @Autowired가 붙은 펼드를 선언해서 XML
에 정의된 빈을 컨테이너가 주입해주게 해야 한다. @Autowired는 UserServiceTest
와 UserDaoTest에서 스프링 컨테이너를 이용한 태스트를 만들면서 사용해본 것이다.
@Autowired가 붙은 필드의 타입과 같은 빈이 있으면 해당 빈을 펼드에 자동으로 넣어준
다. @Autowired는 테스트에서만 사용하도록 만들어진 것은 아니다. 빈 클래스 내부에서

7장-스프링 핵심 기술의 응용 663



도 수정자 주입을 대신해서 펼드 주입으로 사용할 수도 있고， @Configuration 클래스
에서 XML 등으로 정의된 빈을 가져올 때도 시용할 수 있다. 또한 @Configuration 클
래스를 하나 이상 사용하는 경우 다른 클래스의 @Bean 메소드로 정의된 빈을 참조할 때
도사용할수있다.

@Autowired를 이용해서 에러가 나는 userDa이 ) 메소드를 리스트 7-93과 같이 수정
해보자.

리스트 7-영 @AI띠owired톨 이용해서 XML 빈올 참조하게 만든 use
rDa에 머|소드

OAutowired SQlService sQlService;

@ßean

public UserDao userDao() {
UserDaoJdbc dao = new UserDaoJdbc();
dao .setDataSource(dataSource());
dao .setSqlService(this.sQlService);
return dao;

일단 컴파일 에러는 해결했다. 이제 확인할 것은 @Autowired가 붙은 sqlService 펼
드에 sqlService 빈이 주입돼서 userDao() 메소드에서 사용될 수 있는가이다. 결괴는
테스트를 돌려보면 알 수 있다. 테스트를 실행해보자.

이제 남은 <bean>을 모두 @Bean 메소드로 옮겨보자. 남은 <bean>은 SQL 서비스에
서 사용히는 sqlService, sqlRegistry , unmarshaller 세 가지다. embeddedDatabase
는 <bean>
이 아니라 <idbc:embedded-database> 전용 태그로 만들었기 때문에 아직은
XML에 그대로 둘 것이다.

리스트 7-94에 나온 세 개의 <bean>은 리스트 7-95와 같이 메소드 형태의 빈 정의
로전환할수있다.

리스트 견MSQL 서비스톨 위한 세 개의 〈∞an)


<bean id=닝qlService" 이lass=
’ sprin1밍
이’k .use
r.
sq
OxxmδSq

c
매gboo
띠lservice
.
지
띠lServiκce"
<pro때
n1념히뻐
uunrr1m뻐녕
야h념려
’
ref="끼띠미찌매nl
ars
/>

a
미
nars
ller
"
u뻐

perπty 매me="띠매l
a
”’ unnrr1m녕
야haller"

<property name="sqlRegistry’‘ ref="sqlRegistry" />
</bean>

<bean id=연qlRegistry"
class="springbook.user .sqlservice.updatable .EmbeddedDbSqlRegistry">


<property name="dataSource'’ ref="embeddedDatabase “ /)
</bean)

<bean id="unmarshaller" class="org. springframework .oxm. jaxb. Jaxb2Mars야h1녕라
’

벼a
ller'γ"
<property name="contextPath" value=꺼
pringbook.user.sqlservice
.
jaxb" /)
</bean)

리스트 7-95 SQL 서비스톨 위한 세 개의 @Bean 메소드

OOean

public SqlService sqlService() (
OxmSqlService sqlService = new OxmSqlService();
sqlService.setUnmarshaller(unmarshaller());
sqlService .setSqlRegistry(sqlRegistry());
return sqlService;

OResource EmbeddedOatabase embeddedOatabase;

OOean

public SqlRegistry sqlRegistry() (
EmbeddedDbSqlRegistry sqlRegistry = new EmbeddedDbSqlRegistry();
sqlRegistrY .setDataSource(this .embeddedDatabase);
return sqlRegistry;

@8ean

public Unmarshaller unmarshaller() (
Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
marshaller .setContextPath( "springbook .user . sqlservice. j axb");
return marshaller;


그런데 embeddedDatabase 빈은 아직 자바 코드로 변환하지 않았으니 sqlService
빈과 마찬가지로 펼드로 주입받아 시용하게 해야 한다. sqlService 빈은 @Autowired
를 사용했는데 이번 embeddedDatabase 빈은 @Resource 애노테이션을 사용했다.
@Resource는 @Autowired와 유사하게 펼드에 빈을 주입받을 때 사용한다. 차이점은
@Autowired는 필드의 타입을 기준으로 빈을 찾고 @Resource는 펼드 이름을 기준으로
한다는 점이다.XML에서 시용한 <idbc:embedded-database> 전용 태그는 DataSource

7장-스프링 핵심 기술의 응용 665


타입의 빈을 생성한다. 그런데 이미 TestApplicationContext
에 DataSource 타입
의 dataSource 빈이 존재하므로 타입을 기준으로 주입받게 만들면 흔란이 발생할 수
있다. 그래서 필드 이름과 일치하는 빈 아이디를 가진 빈을 주입받을 때 사용하는
@Resource를 이용했다.

태스트를 돌려보자. 아무런 문제 없이 태스트가 모두 성공한다면 XML에 <bean>으
로 정의한 모든 빈 설정을 TestApplicationContext
의 자바 코드로 이전히는 작업이 완
료된것이다.

전용태그전환
XML에는 리스트 7-96에 나온 두 개의 빈 설정만 남았다.

리스트 7-96 XML에 남은 두 개의 빈

<jdbc:embedded-database id=갱mbeddedDatabase" type="HSQL “
<jdbc:script location=
’‘ classpath :springbook/user/sqlservice/updatable/sqlRegistrySchema.sql"/)
</jdbc:embedded-database)

<tx:annotation-driven /)

두 가지 모두 <bean>
이 아니라 특별한 용도로 사용하도록 만들어진 전용 태그다. 전
용 태그도 <bean>과 마찬가지로 빈을 등록히는 데 사용된다. 그런데 내부에서 실제로
어떤 빈이 만들어지는지 파악하기가 쉽지 않다. 전용 태그 하나에 여러 개의 빈이 만들
어질 수도 있다. 환경에 따라서 다른 종류의 클래스를 이용해 빈을 만들기도 한다. 또，
빈을 생성한 뒤에 초기화 작업을 수행하기도 한다.

어려워 보이지만 방법은 다 있다. 하나씩 내용을 자세히 살며보고 자바 클래스로 옮
겨보자.

SQL 서비스에서 시용히는 내장형 DB를 생성하는 <idbc:embedded-database> 전용
태그는 type에 지정한 내장형 DB를 생성하고 <idbc:script>로 지정한 스크립트로 초
기화한 뒤에 DataSource 타입 DB
의 커넥션 오브젝트를 빈으로 등록해준다. 빈의 타입
은 DataSource
다.

스프링이 제공하는 내장형 DB 지원 기능은 <idbc:embedded-database> 전
용 태그만이 아니다. 7.5.2
절에서 내장형 DB
에 대한 학습 태스트를 만들어볼 때
EmbeddedDatabaseBuilder를 이용했다. EmbeddedDatabaseBuilder를 이용해 내장형


DB 종류와 초기화 스크립트 등을 지정하고 build( ) 메소드를 실행하면 내장형 DB를
생성하고 초기화한 뒤에 DB 커넥션 오브젝트를 돌려준다. < i dbc : embedded-database>
가 내부적으로 해주는 작업과 거의 동일하다. EmbeddedDatabaseBuilder를 이용해서
<idbc:embedded-database> 빈 정의에 해당하는 빈 오브젝트를 생성해주는 묘드를 만
들어보면 리스트 7-97과 같이 될 것이다.

리스트 7냉7 내E뺑 DB 빈올 생성하는 @Bean 메소드

@8ean
public Data50urce embeddedDatabase() (

return new EmbeddedDatabaseBuilder()
.setName( 갱mbeddedDatabase
'’ )
.setType(H5QL)
.add5cript(

.‘ classpath:springbook/user/sqlservice/updatable/sqlRegistry5chema.sql")
.build();

embeddedDatabase 빈을 @Bean 메소드로 전환했으니 이제 @Resource로 빈을 가져올
필요가 없다. @Resource로 정의한 필드를 제거하고 embeddedDatabase() 메소드를 호출
해서 빈을 가져오도록 리스트 7-98과 같이 수정하자.

리스트 7-98 embeddedDala벼se() 메소드를 사용해서 빈을 가져오도록 수정한 sqIRegistry()

a T\ ___ •• ___ r_L __LJ _ ...I n ι L___ __L_
___ •

...I...I_...I
n_~_L

<'" ~‘ ... “ ‘ .111‘’「‘
i
‘
i“
"
.1<，，<1
‘’
.. H .---" .. ，.---‘
i
‘·““
~
r. r I ‘ ... 、~.

I

@8ean

public 5qlRegistry sqlRegistry() (
EmbeddedDb5qlRegistry sqlRegistry = new EmbeddedDb5qlRegistry();
sqlRegistrY.setData5ource(embeddedDatabase() );
return sqlRegistry;


태스트를 실행해보고 디음 단계로 넘어가자.

이제 XML에는 딱 한 개의 전용 태그만 남아 있다. @Transactional을 이용한 트랜
잭션 AOP 기능을 지원하는 <tx :annotation-driven />이다.
6장에서 살펴봤던 대로
트랜잭션 AOP를 적용하려면 제법 복잡하고 많은 빈이 동원돼야 한다. AOP를 위해 기
본적으로 어드바이스와 포인트컷이 펼요하고 애노테이션 정보에서 트랜잭션 속성을

7장-스프링 핵심 기솔의 응용 667


가져와서 어드바이스에서 λF용하게 해주는 기능도 필요하다. <tx: annotation-dri ven />
은 옵션을 주지 않는다면 기본적으로 다음 네 가지 클래스를 빈으로 등록해준다.

• org.springframework.aop.framework.autoproxy.lnfrastructure뼈visorAutoProxyCreator
• org.springframework.transaction.annotation.AnnotationTransactionAttributeSource
• org.springframework .transaction.interceptor .TransactionInterceptor
• org
.
springframework
.
transactiα1
.
interceptor.
BeanFactoryTransacticr얘ttributeSource뼈visor

이 네 개의 클래스를 빈으로 등록하고 적절히 프로퍼티 값을 넣어주면
<tx:annotation-driven />을 대체할 수 있다. 펼요한 경우 개발자가 직관적이고 손
쉽게 사용하게 한 EmbeddedDatabaseBuilder와 달리 위의 네 가지 클래스는 기억하기
도 어렵고 어떻게 설정해야 할지 파악하기도 힘들다.XML에서는 용도가 잘 설명되는
전용 태그로 정의돼서 손쉽게 사용했는데 자바 코드에서는 복잡한 로우 레벨의 클래스
를 여러 개나 사용해서 빈을 정의해야 한다면 부담스렵다. 차라리 @!mportResource로
XML을 계속 포함시켜서 <tx:annotation-driven />을 그대로 쓰는 게 나을지도 모르
겠다.

스프링 3.0은 @Configuration을 이용한 자바 코드 DI 설정 방식을 지원하기 시
작했지만， 이런 전용 태그를 대체할 자바 코드를 작성하기가 어렵기 때문에 XML을
완전히 배제하기 힘들었다. 하지만 스프링 3
.1
에서는 더 이상 고민할 펼요가 없다.
<tx:annotation-driven />과 같이 특별한 목적을 위해 만들어진， 내부적으로 복잡
한 로우 레벨의 빈을 둥록해주는 전용 태그에 대응되는 애노테이션을 제공해주기 때
문이다.

<tx:annotation-driven />은 디음 애노태이션을 TestApplicationContext
에 붙여
주는 것으로 간단히 변환할 수 있다.

öEnableTransactionManagement

스프링 3.1은 XML에서 지주 시용되는 전용 태그를 @Enable로 시작히는 애노테이
션으로 대체할 수 있게 다0，，1=한 애노태이션을 제공한다. 가장 대표적으로 사용되는 것이
바로 @EnableTransactionManagement
다.

<tx:annotation-driven />을 대신해서 @EnableTransactionManagement를 넣고 나
면 XML에는 더 이상 빈 설정이 남지 않는다.XML에서 빈 설정정보를 가져오도록 추
가한 @!mportResource도 제거하면 된다. 깔끔하게 test-applicationContext.xml 따일
도제거해버리자.


이제 스프링 DI 정보를 담은 XML 파일의 내용을 모두 DI 설정용 자바 클래스로 이
전했다. 최종 완성된 TestApplicationContext는 리스트 7-99와 같다.

리스트 7-99 XML의 빈 설정정보를 자바 코드로 변환한 Tes여pplicationContext

OConfiguration
OEnableTransactionManagement
public class TestApplicationContext {

/**

* DB 연결과 트랜잭션
*/
@Bean

public DataSource dataSource() {
SimpleDriverDataSource ds = new SimpleDriverDataSource();
dS .setDriverClass(Driver .class);

dS.setUrl("jdbc:mysQl:/
!l
ocalhos
t/
springbook?characterEncoding해TF-8");

dS .setUsername( ‘ spring") ;
dS .setPassword("book");
return ds;

@Bean

public PlatformTransactionManager transactionManager() {
DataSourceTransactionManager tm = new DataSourceTransactionManager();
tm.setDataSource(dataSource());
return tm;

/**

* 애플리케이션 로직 & 테스트
*/

@Autowired SQlService sQlService;

@Bean

public UserDao userDao() {
UserDaoJdbc dao =new UserDaoJdbc();
dao.setDataSource(dataSource());
dao.setSQlService(this.sQlService);
return dao;

F앙-스프링 핵심 기술의 응용 669



@ßean

public UserService userService() (
UserServicelmpl service = new UserServicelmpl();
service.setUserDao(userDao());
service.setMailSender(mailSender());
return service;

@ßean

public UserService testUserService() (
TestUserService testService = new TestUserService();
testService.setUserDao(userDao());
testService.setMailSender(mailSender());
return testService;

@ßean
public MailSender mailSender() (
return new DummyMailSender();

* SQL 서비스
*/
@ßean

public SqlService sqlService() (
OxmSqlService sqlService = new OxmSqlService();
sqlService.setUnmarshaller(unmarshaller());
sqlService.setSqlRegistry(sqlRegistry());
return sqlService;

@ßean

public SqlRegistry sqlRegistry() (
EmbeddedDbSqlRegistry sqlRegistry = new EmbeddedDbSqlRegistry();
sqlRegistrY .setDataSource(embeddedDatabase());
return sqlRegistry;

@ßean
public Unmarshaller unmarshaller() (
Jaxb2Marshaller marshaller =new Jaxb2Marshaller();


marshaller. setContextPath( "springbook .user . sqlservice. iaxb" );
return marshaller;

@8ean
public DataSource embeddedDatabase() (
return new EmbeddedDatabaseBuilder()

.
setName(
년mbeddedDatabase")

.setType(HSQL)

.addScript ("classpath !springbook/user/sqlservice/u때atable/sqlRegistrySch댄la
.
sql ")
.build() ;

마지막으로 테스트를 모두 실행해보자. 테스트 내용은 처음 XML 설정파일만 있을

때와 달라진 게 없다. 애플리케이션 로직을 담은 클래스도 마찬가지다. 단지 XML을 클

래스 파일로 전환했을 뿐이다. XML의 빈 설정정보가 클래스와 메소드로 만들어진 자

바 코드로 깔끔하게 전환됐다면 모든 태스트가 성공할 것이다.

XML을 자바 묘드로 전환한 작업을 마무리했다. 그런데 막상 만들어진 설정용 자

바 코드를 보면 XML에 비해 더 간결해진 것도 없고 설정을 이해하는 데 더 유리한 것

도 없어 보인다. 단지 IDE의 자바 에디터를 이용해 편집하기 때문에 작성하기가 편하

고， 빈의 클래스 이름이나 프로퍼티에 주입하기 위해 사용히는 메소드 이름 등을 작성

할 때 오타가 나는 것을 컴파일러가 미리 잘 잡아준다는 정도 외엔 그다지 장점이 없어

보인다.

그렇다고실망할필요는없다. 지금까지는단지 XML
설정을거의 1:1
로자바코드

로 전환하는 작업을 했을 뿐이다. 설정정보를 자바 코드를 이용해 작성할 때의 본격적

인 장점은 TestApplicationContext를 좀 더 다듬어나가면서 살펴볼 것이다.

7.6.2 민 스캐닝과 자동와이어링
@Autowired를 이용한 자동와이어링
지금까지 사용했던 @Autowired는 스프링 태스트 클래스나 DI 설정용 @Configuration
클래스에서 스프링 컨테이너가 생성한 빈을 클래스의 멤버 필드로 주입받기 위해 사
용했다. 빈의 프로퍼티에 다른 빈을 넣어서 런타임 관계를 맺어주려면 <bean>
의
<property>를 사용해 빈을 정의하거나 자바 묘드로 직접 수정자 메소드를 호출해줘야

얻~ 스프링 핵심 기술의 응용 671



했다. 반면에 태스트나 DI 설정용 클래스에서는 명시적인 프로퍼티 설정 없이 클래스의
필드에 다른 빈 오브젝트가 주입되게 할 수 있었다. 빈으로 시용되는 UserServicelmpl
이나 UserDaoJdbc 같은 클래스에서는 @Autowired를 사용할 수 없을까?

물론 사용할 수 있다. @Autowired는 자동와이어링 기법을 이용해서 조건에 맞는 빈
을 찾아 자동으로 수정자 메소드나 필드에 넣어준다. 자동와이어링을 이용하면 컨테이
너가 이름이나 타입을 기준으로 주입될 빈을 찾아주기 때문에 빈의 프로퍼티 설정을 직
접해주는 자바 코드나 XML의 %딸 대폭 줄일 수 있다. 컨테이너가 자동으로 주입할 빈
을 결정하기 어려운 경우도 있다. 이럴 땐 직접 프로퍼티에 주입할 대상을 지정하는 방
법을병행하면된다.

userDao 빈의 구현 클래스인 UserDaoJdbc는 dataSource와 sqlService 두 개의 빈에
의존한다. 두 개의 빈을 수정자 메소드로 주입할 수 있도록 프로퍼티를 만들어놨다. 현
재 TestApplicationContext
의 userDao( ) 메소드에서는 다음과 같이 수정자 메소드를
호출해서 두 개의 빈 오브젝트를 직접 주입해준다.

dao .setDataSource(dataSource());

dao.setSqlService(this.sqlService);

이 중에서 dataSource 빈을 넣어주는 위의 코드를 자동와이어링을 이용해 제거해
보자.
방법은 간단하다. UserDaoJdbc 클래스의 setDataSource() 메소드 앞에 리스트
7-100과 같이 @Autowired를 붙여주면 된다.

리스트 7-100 없떠없Jr∞ 수정I뻐I@뼈owired 적용

public class UserDaoJdbc implements UserDao (

OAutowired
public void setDataSource(DataSource dataSource) (
this . jdbcTemplate = new JdbcTemplate(dataSource);

userDao() 메소드의 dao.setDataSource(datasource())
를 삭제한 뒤 태스트를 실
행해보자. userDao 빈에 dataSource 빈이 자동으로 주입되고 테스트는 모두 성공할 것
이다.

스프링은 @Autowired가 붙은 수정자 메소드가 있으면 파라미터 타입을 보고 주입 가


능한 타입의 빈을 모두 찾는다. 여기서는 DataSource이므로 DataSource 타입의 빈을
모두 찾는다. 주입 가능한 타입의 빈이 하나라면 스프링이 수정자 메소드를 호출해서
넣어준다. 만약 두 개 이상이 나오면 그중에서 프로퍼티와 동일한 이름의 빈이 있는지
찾는다. DataSource 빈은 두 개가 존재한다. 하나는 userDao 빈이 사용히는 dataSource
빈이고 다른 하나는 SQL 서비스용으로 만든 embeddedDatabase 빈이다. 그중에서
dataSource 빈이 수정자 메소드의 프로퍼 티 이름과 일치하기 때문에 이를 넣어준다. 만
약 타입과 이름을 모두 비교해도 최종 후보를 찾아내지 못하면 주입할 빈을 찾을 수 없
다는에러가날것이다.

디음은 sqlService 프로퍼티에 @Autowired를 적용해보자. 이번엔 리스트 7-101
과
같이 UserDaoJdbc
의 sqlService 펼드에 @Autowired를 부여해보겠다.

리스트 7-101 sqlServi∞ 필드에 @A띠.owired 적용

public class UserDaoJdbc implements UserDao {

Mutowired
private SqlService sqlService;

public void setSqlService(SqlService sqlService) {
this .sqlService = sqlService;

userDao 빈을 정의한 userDao() 메소드에서 더 이상 수정자 메소드를 호출해서 빈을
넣어주는 묘드는 필요 없다. 따라서 리스트 7-102와 같이 userDao( )를 간단히 빈 인스
턴스만 생성하도록 변경하자. 그리고 userDao() 메소드에서 sqlService 빈을 참조하기
위해 사용했던 @Autowired 필드도 더 이상 펼요 없으니 제거하자.

리스트 7-102 @Autowired훌 주입한 후의 userD∞o 메소드


a~__ .-I r __ ,r ‘ 'l__.. ': __ .
onULV" “\:;\..4 J\.A‘」
ε..‘'-~ "'>\..4
ι
」드‘
VH.
드
t

@8ean
public UserDao userDao() {
return new UserDaoJdbc();

낀t_ 스프링 핵심 기솔의 응용 673


UserDao 인터페이스의 구현 클래스로부터 빈 오브젝트를 생성히는 것 외에는 아무것
도 남지 않았다. userDao 빈의 의존관계 설정은 UserDaoJdbc 클래스 내의 @Autowired
가 담당할 것이다. 테스트를 돌려보면 모두 성공한다.

두 번째 sqlService 프로퍼티는 수정자 메소드 대신 주입된 빈 오브젝트를 저장해
둘 필드에 직접 @Autowired를 적용했다. 어차피 수정자 메소드가 실행되면 주입된 빈
오브젝트는 필드에 저장됐다가 사용될 태니 수정자 메소드를 거치지 않고 직접 펼드에
빈 오브젝트를 넣도록 만들어도 무방하다. 필드의 접근 제한자가 private~ 것은 문제
되지 않는다. 원래 자바 언어에서 pnvate 필드에는 클래스 외부에서 값을 넣을 수 없
게 되어 있지만 스프링은 리플렉션 API를 이용해 제약조건을 우회해서 값을 넣어준
다. 필드에 직접 값을 넣을 수 있다면 수정자 메소드는 없어도 된다. 리스트 7-101
의
setSqlService() 메소드는 생략해도 좋다.

반면에 리스트 7-100
의 setDataSource() 수정자 메소드를 없애고 펼드에
@Autowired를 적용하는 건 불가능하다. 왜냐하면 setDataSource() 메소드는 여타 수정
자 메소드처럼 주어진 오브젝트를 그대로 필드에 저장히는 대신 JdbcTemplate을 생성
해서 저장해주기 때문이다.

단순히 필드에 값을 저장하는 수정자 메소드라도 @Autowired를 펼드에 직접 부여했
다고 메소드를 생략하면 안 되는 경우가 있다. 스프링 컨테이너에서 의존관계를 맺어주
는 방식으로만 코드가 사용된다면 상관없지만 스프링과 무관하게 직접 오브젝트를 생
성하고 다른 오브젝트를 주입해서 태스트히는 순수한 단위 태스트를 만드는 경우에는
수정자 메소드가 필요하다. 예를 들어 UserServiceTest
의 upgradeLevels() 태스트 메
소드는 목 오브젝트를 만들어서 UserServicelmpl 오브젝트의 수정자 메소드에 주입해
준다. 이런 경우 UserServicelmpl
의 프로퍼티 펼드에 @Autowired를 적용했다고 수정자
메소드를 제거하면 곤란해진다. 어차피 목 오브젝트를 시용해 태스트를 만들기가 어려
운 DAO는 스프링 컨테이너 안에서 DI가 이뤄진 뒤에 태스트를 수행하는 방법이 적절
하므로 UserDaoJdbc
의 경우처럼 @Autowired를 적용하고 필요 없다면 수정자 메소드를
제거해도 좋다. 반면에 비즈니스 로직을 갖고 있어서 목 오브젝트를 적절히 활용해 빠
르게 동작하는 단위 태스트를 만들 수 있는 UserServicelmpl은 @Autowired를 이용하더
라도 수정자 메소드를 남겨두는 편이 안전하다.

@Autowired와 같은 자동와이어링은 적절히 시용하면 DI 관련 코드를 대폭 줄일 수
있어서 편리하다. 반면에 빈 설정정보를 보고 다른 빈과 의존관계가 어떻게 맺어져 있
는지 한눈에 파악하기 힘들다는 단점도 있긴 하다.


@Component를 이용한 자동 빈 등록
@Component
는 스프링이 애노테이션에 담긴 메타정보를 이용하기 시작했을 때
@Autowired와 함께 소개된 대표적인 애노태이션이다. @Component는 클래스에 부여된
다. @Component가 붙은 클래스는 빈 스캐너를 통해 자동으로 빈으로 등록된다. 정확히
는 @Component 또는 @Component를 메타 애노테이션으로 갖고 있는 애노테이션이 붙은
클래스가 자동 빈 등록 대상이 된다.
userDao 빈 설정용으로 만들었던 @Bean 메소드는 프로퍼티 설정을 @Autowired
로 자동화해서 리스트 7-102
처럼 간단한 오브젝트 생성 코드만 남았다. 이번엔 아예
userDao( ) 메소드 자체를 제거해버릴 것이다.
일단 userDao() 메소드를 삭제해보자. 당장 userDao 빈을 프로퍼티로 사용하는
userService와 testUserService 빈을 위한 메소드에서 컴파일 에러가 난다. userDa이 )
메소드를 호출해서 userDao 빈을 가져오는 코드가 있기 때문이다. 이런 경우엔 어떻게
해야할까?
방법은 간단하다. 앞에서 XML에서 정의된 빈을 자바 코드에서 참조할 때 @Bean 메
소드를 호출하는 대신 @Autowire 필드로 빈을 주입받아서 참조하면 된다고 했다. 자동
등록이든 XML을 통한 등록이든 아무튼 스프링 컨테이너에 등록된 빈을 가져와 시용
할 때는 @Autowired로 가져오면 된다. 심지어 같은 클래스 안에 @Bean 메소드가 존재하
는 경우에도 메소드 호출 대신 @Autowired를 통해 빈을 참조할 수도 있다.
TestApplicationContext에서 userDao()를 제거하고 @Autowired를 통해 userDao
빈을 참조하도록 리스트 7-103과 같이 수정하자.

리스트 7-103 userD뼈) 메소드 제거


ftAutowired UserDao userDao;

@ßean

public UserService userService() {
UserServicelmpl service =new UserServicelmpl();
service .setUserDao( this.userDao );
service .setMailSender(mailSender());
return servlce;

@ßean
public UserService testUserService() {
TestUserService testService = new TestUserService();

낀~-스프링 핵심 기솔의 응용 675


testService .setUserDao(this.userDao);
testService.setMailSender(mailSender());
return testService;

이 상태로 태스트를 돌리면 어떻게 될까? userDao 빈이 등록될 방법이 없으니 당연
히 테스트는 실패할 것이다. 자동 빈 등록 방식을 적용해서 태스트를 성공으로 다시 만
들어보자.

먼저 자동 빈 등록 대상이 될 UserDaoJdbc 클래스에 리스트 7-104와 같이
@(omponent 애노태이션을 넣는다. @(omponent는 빈으로 등록될 후보 클래스에 붙여주
는 일종의 마커
marker라고 보면 된다.

리스트 7-104
@Cαnponenl 적용

@(omponent
public class UserDaoJdbc implements UserDao {

@(omponent 애노태이션이 달린 클래스를 자동으로 찾아서 빈을 등록해주게 하려면
빈 스캔 기능을 사용하겠다는 애노테이션 정의가 필요하다. 빈 자동등록이 컨테이너가
디폴트로 제공하는 기능은 아니기 때문이다. 프로젝트 내의 모든 클래스패스를 다 뒤져
서 @(omponent 애노태이션이 달린 클래스를 찾는 것은 부담이 많이 가는 작업이다. 그
래서 특정 패키지 아래서만 찾도록 기준이 되는 패키지를 지정해줄 필요가 있다. 이때
사용되는 애노테이션은 @(omponentScan
이다. 리스트 7-105와 같이 DI 설정용 클래스
인 TestApplication(ontext
에 @(omponentScan을 추가해주자.

리스트 7-105
@Com∞nentScan 적용

@(onfiguration
@EnableTransactionManagement
@(omponentScan(basePackages="springbook.user")
public class TestApplicationContext {

@(omponentScan
의 basePackages 엘리 먼트는 @(omponent가 붙은 클래스를 스캔할
기준 패키지를 지정할 때 사용한다. 기준 패키지는 여러 개 넣어도 된다. 지정한 패키
지 아래의 모든 서브패키지를 다 검색하므로 springbook.user.dao 패키지 아래에 있는
UserDaoJdbc 클래스도 검색 대상이 된다.


@(omponent
가 붙은 클래스가 발견되면 새로운 빈을 지동으로 추가한다. 빈의 클
래스는 @(omponent
가 붙은 클래스이고 빈의 아이디는 따로 지정하지 않았으면 클래
스 이름의 첫 글자를 소문자로 바꿔서 사용한다. 리스트 7-104의 UserDaoJdbc 클래
스는 userDaoJdbc를 아이디로 하는 빈으로 등록된다. 자동 빈 등록을 이용하는 경우
빈의 의존관계를 담은 프로퍼티를 따로 지정할 방법이 없다. 그래서 프로퍼티 설정에
@Autowired와 같은 자동와이어링 방식을 적용해야 한다. UserDaoJdbc는 이미 모든 프
로퍼티에 @Autowired를 적용해놨다.

@(omponentScan까지 추가했으면 다시 태스트를 실행해보자. userDao() 메소드를 삭
제한 뒤 실패했던 태스트가 이번엔 성공할 것이다. @(omponent 애노테이션을 부여한 것
으로 userDao 빈이 등록된 것을 알 수 있다.

@(omponent
에 의해 빈이 자동으로 등록될 때 빈의 아이디는 클래스 이름을 따라간다
고 했으니 userDao 빈이 아니라 userDaoJdbc 빈이 아닌가? 그렇다. 지금까지 XML
이
나 @Bean 메소드로 정의했던 빈은 아이디가 userDao
였다. 그런데 자동등록 방식으로 하
면서 빈의 아이디가 userDaoJdbc로 바뀌었는데 괜찮을까?

괜찮을 수도 있고 아닐 수도 있다. 태스트가 성공했으니 일단 문제는 없어 보인다.
빈의 아이디가 userDaoJdbc로 바뀌었는데도 문제가 없는 것은 왜일까? 그 이유는 이 빈
을 참조히는 태스트인 UserServiceTestL} DI 설정 클래스인 TestApplication(ontext
에서 모두 @Autowired를 이용해 빈을 주입받기 때문이다.XML의 (property)를 사용
했을 때처럼 아이디를 기준으로 주입할 빈을 찾지 않고 @Autowired에 의해 UserDao라
는 타입으로 빈을 찾게 했다. userDaoJdbc 빈은 UserDao 인터페이스를 구현하고 있으
니 @Autowired
에 의해 자동와이어링 대상이 된다. 따라서 아무 문제가 없다.

반면에 앞에서 잠깐 살펴봤던 @Resource처럼 빈의 아이디를 기준으로 자동와이어링
하거나 XML처럼 명시적으로 빈의 아이디를 지정하는 경우에는 문제가 될 수도 었다.
또는 @Autowired로 찾을 대상이 두 개 이상인 경우 즉 같은 타입의 빈이 두 개 이상인
경우엔 이름을 기준으로 최종 후보를 선택하도록 만들어야 하기 때문에 빈의 아이디가
중요할 수도 있다. 만약 @(omponent가 붙은 클래스의 이름 대신 다른 이름을 빈의 아이
디로 사용하고 싶다면 다음과 같이 애노테이션에 이름을 넣어주면 된다.

@(omponent("userDao")

빈 자동등록에 @(omponent 애노테이션만 사용할 수 있는 것은 아니고 @(omponent
애노테이션을 메타 애노테이션으로 갖고 있는 애노태이션도 시용할 수 있다고 했다.
애노테이션은 @interface 키워드를 이용해 정의한다. @(omponent 애노태이션은 다
음과 같이 정의되어 있다.

7장-스프링 핵심 기술의 응용 677


public @interface Component {

그런데 스프링은 @Component 외의 애노테이션으로도 자동 빈 등록이 기능하게 해준
다. 단지 빈 스캔 검색 대상으로 만드는 것 외에 부가적인 용도의 마커로 사용하게 하기
위해서다. AOP
에서 포인트컷을 작성할 때도 애노테이션을 사용할 수 있다. 애노테이
션 포인트컷을 이용하면 패키지나 클래스 이름 패턴 대신 애노테이션을 기준으로 어드
바이스 적용 대상을 선별할 수 있다. @Transactional
이 대표적인 예다. AOP 적용 대상
이 클래스 전체에 해당한다면 빈 자동등록용 애노테이션도 비슷한 용도로 사용하기 좋
다. 단지 AOP 포인트컷에 λF용할 용도라면 각각 별개의 애노태이션을 만들면 되겠지
만 빈 자동등록 대상임을 나타낼 수도 있어야 하니 뭔가 기준이 펼요하다. 클래스라면
같은 인터페이스를 구현하게 하거나 하나의 클래스를 상속하게 만들어서 여러 개의 클
래스를 같은 그룹으로 묶을 수 있다. 그런데 애노테이션은 상속을 할 수 없고， 인터페이
스를구현할수도없다.

그래서 여러 개의 애노태이션에 공통적인 속성을 부여하려면 메타 애노테이션을
이용한다. 메타 애노테이션은 애노태이션의 정의에 부여된 애노테이션을 말한다. 애
노태이션이 빈 스캔을 통해 자동등록 대상으로 인식되게 하려면 애노테이션 정의에
@Component를 메타 애노테이션으로 붙여주면 된다. SNS 서비스에 접속하는 기능을 제
공하는 빈을 AOP 포인트컷으로 지정할 수 있도록 구분이 필요하다면 @SnsConnector
라는 애노태이션을 하나 만들어 사용할 수 있을 것이다. @SnsConnector 애노태이션을
정의할 때 메타 애노테이션으로 @Component를 부여해주면 클래스마다 @Component를
따로 붙여주지 않아도 자동 빈 등록 대상으로 만들 수 있다. 리스트 7-106은 이렇게 만
들어진 @SnsConnector 애노테이션이다.

리스트 7-106
@Cαnponenl 메타 애노테이션을 가진 애노테이션 정의

@(omponent
public @interface SnsConnector {

이제 @SnsConnector를 다음과 같이 클래스에 부여해주면 자동 빈 등록 대상이 된다.

OSnsConnector
public class FacebookConnector {


자동 빈 등록 대상으로 만든 UserDa이
dbc 클래스는 데이터 액세스 서비스를 제공하
는 DAO 빈이다. 스프링은 이런 DAO 빈을 자동등록 대상으로 만들 때 사용할 수 있게
@Repository 애노테이션을 제공한다. @Component를 부여히는 것만으로도 등록 대상
으로 만드는 데 충분하지만 스프링은 DAO 기능을 제공히는 클래스에는 @Repository
애노테이션을 이용하도록 권장한다. @Repository는 @SnsConnector와 마찬가지로
@Component를 메타 애노테이션으로 갖고 있다.

아무튼， 스프링이 권장하고 있으니 UserDaoJdbc 클래스에도 다음과 같이
@Component 대신 @Repository를 붙여주자.

@없Re매pository

public class UserDaoJdbc implements UserDao {

테스트를 다시 실행해보면 문제없이 성공할 것이다. @Component를 시용했을 때와 마
찬가지로 UserDaoJdbc 클래스가 빈으로 자동등록돼서 사용됐음을 알 수 있다.
자동와이어링과 마찬가지로 자동 빈 등록 방식도 장단점이 있다. 자동 빈 등록을 적
용하는 게 좋은 빈과 그렇지 않은 빈이 있다. 자세한 설명은 V이
2의 l장에 나와 있다.
userService 빈에도 자동와이어령과 자동 빈 등록을 적용해보자. UserServicelmpl
에 @Component와
@Autowired를 적용해보면 리스트 7-107과 같이 될 것이다.

리스트 7-107 자동등록과 자동와이어링 방식을 적용한 UserServicelmpl

@(omponent
public class UserServicelmpl implements UserService (

OAutowired
private UserDao userDao;

@Autowired
private MailSender mailSender;


@Component로 자동등록되게 했으니 TestApplicationContext의 userService() 메
소드는 삭제하자. 그리고 테스트를 실행해보자. 앗， 그런데 실패한다. UserDaoJdbc
의
경우도 동일하게 자동와이어링과 자동등록 기능을 적용했는데 왜 UserServicelmpl은
문제가생겼을까?

걷J 스프링 핵심 기술의 응용 679


리팩토링을 진행하다가 테스트가 갑자기 실패하거나 문제가 생겼다고 당황해서 코
드를 이리저리 비꾸지 말고， 먼저 테스트 실패 원인을 자세히 살펴보는 것이 중요하다.
태스트는 컨테이너 기동 중에 예외가 발생했기 때문에 실패했다. 예외 메시지를 잘 살
펴보면 디음과 같은 내용을 발견하게 될 것이다.

Caused by: org.springframework.beans.factorY .NoSuchBeanDefinitionException: No

unique bean of type [springbook .user .service .UserServicel is defined: expected

single matching bean but found 2: [userServicelmpl , testUserServicel

영어라고 당황하지 말고 치근치근 읽어보면 어렵지 않게 이유를 알 수 있을 것이다.
UserService 타입의 빈이 하나여야 동}는데 두 개가 발견됐다는 내용이다. 발견된 두 개
의 빈 이름을 보니 userServiceImpl과 testUserService다. UserService 타입의 빈은
테스트용으로 하나 더 만든 것이 있어서 두 개가 존재한다. 이 중에서 @Autowired로 주

입할 빈을 결정하지 못해 문제가 된 것이다.

UserServiceTest는 정상적인 UserService 구현 클래스로 만들어진 빈과 트랜잭션
태스트용으로 따로 만든 특별한 UserService 구현 빈 두 개를 모두 태스트에 이용한다.
그래서 UserServiceTest
에는 아래와 같이 @Autowired를 사용해 두 개의 빈을 주입받도

록정의해놨다.

@Autowired UserService userService;

@Autowired UserService testUserService;

@Autowired는 타입을 기준으로 하나의 빈을 찾게 되어 있다. 그런데 지금까지는

왜 문제가 안 됐을까? 그 이유는 @Autowired가 일단 타입을 기준으로 적용할 빈을 찾

아보고， 같은 타입의 빈이 두 개 이상 발견되면 이름을 기준으로 다시 최종 후보를 찾
는 방식으로 동작하기 때문이다. 이 두 개의 필드 이름과 정확히 일치하는 두 개의
UserService 타입 빈이 존재하기 때문에 각 필드에 주입할 빈을 정확히 결정할 수 있었
다. 그런데 @(omponent를 도입한 뒤에는 클래스 이름을 따라서 빈 아이디가 결정되기
때문에 기존에 userService라고 했던 빈이 userServiceImpl 빈으로 바뀌었고， 그래서
첫 번째 @Autowired 펼드가 주입할 빈을 선택하지 못해 에러가 난 것이다.

해결 방법은 두 가지가 있다. 태스트 코드의 @Autowired 펼드 이름을
userServiceImpl로 바꾸거나 @(omponent에 빈 아이디를 userService라고 지정해서 이
름을 일치시커는 것이다. 테스트 묘드의 펼드 이름을 수정하면 이를 참조하는 코드도
따라서 고쳐줘야 하니 @(omponent
에 빈 아이디를 지정해주는 것이 편하겠다.


UserServicelmpl
에 적용할 빈 등록용 애노태이션은 @Component보다는 @Service가
좋겠다. @Service도 @Repository처럼 스프링이 제공하는 빈 자동등록용 애노테이션인
데， 이 애노테이션은 비즈니스 로직을 담고 있는 서비스 계층의 빈을 구분하기 위해 사
용된다. 서비스 계층은 트랜잭션 경계가 되는 곳이라 @Transactional
이 함께 시용되는
경우가많다.

최종적으로 UserServicelmpl 클래스의 애노테이션을 수정해보면 리스트 7-108과
같이 될것이다.

리스트 7-108 @Service 애노테이션의 적용

ftS ervice("userService‘)
public class UserServicelmpl implements UserService {

이제 @Autowired의 빈 아이디 선택에도 문제가 없을 테니 태스트를 돌려보면 모두
성공할것이다.

그런데 userService 빈 말고 태스트용으로 정의한 testUserService 빈은 어떻게 할
까? 일단 이 빈은 자동등록 대상으로 만들지 말고 @Bean 메소드로 만든 설정을 그대로
두자. 이유는 뒤에서 설명하겠다. mailSender 빈도 마찬가지다.

dataSource와 transactionManager 빈은 자동등록 기능 등을 적용하고 싶어도 불
가능하다. 이 두 개의 빈은 스프링이 제공해준 클래스를 사용하는 것이라 소스코드에
@Component나 @Autowired를 적용하려고 해도 방법 이 없다. 또한 dataSource 빈은 프로
퍼티에 텍스트 값을 넣어줘야 하기 때문에라도 불가능하다. 단순한 값은 @Autowired로
자동주입해줄 방법이 없기 때문이다. 그래서 이 두 가지 빈도 그대로 두자.

지금까지 userDao와
userService 두 개의 빈에 자동등록과 자동와이어링 방법을 적
용했다. 두 개의 빈 등록과 관련된 메소드와 필드를 제거해서 TestApplicationContext
클래스는 조금 간결해졌다. 아직 애플리케이션의 로직을 담은 빈은 두 개밖에 안 만들
었기 때문에 두 개의 설정 메소드를 제거했다고 해서 크게 티가 나지는 않는다. 하지만
본격적으로 엔터프라이즈 애플리케이션을 개발하게 되면 수십 개에서 수천 개의 애플
리케이션 빈을 만들 수도 있다. 이런 경우에 모든 빈을 XML이나 자바 묘드에 일일이
설정해주려면 번거롭다. 대신 자동와이어령과 자동등록 방식을 적용하면 DI와 관련된
코드나 설정정보가 간결해질 것이다.


7장-스프링핵심기솔의응용 681


7.6.3 컨텍스트 분리와 @Import
지금까지 만들어온 DI 설정정보는 XML이었을 때나 자바 코드로 만든 지금이나 모두
테스트를 위한 것이었다. 트랜잭션 테스트를 위해 만든 testUserService 빈은 태스트
에만 시용돼야 하고 실제 애플리케이션에는 포함되면 안 된다. 테스트 수행 중에 매번
실제 메일 발송이 일어나면 번거롭기 때문에 메일 발송 기능을 담당하는 빈은 태스트용
으로 만든 더미 오브젝트를 이용했다. 실제 애플리케이션에서는 메일 서벼와 연결돼서
동작하도록 메일 발송 빈을 변경해야 한다. dataSource 빈의 연결정보도 로컬에 위치한
태스트용 DB를 이용하게 되어 있다. 그렇다고 지금까지 작성한 DI 정보가 모두 테스트
만을 위한 것은 아니다. 애플리케이션 로직을 담은 userDao와 userService 빈이나 트
랜잭션 매니저，
SQL 서비스 빈의 설정 내용은 운영 시스템에도 그대로 적용 가능하다.

애플리케이션이 바르게 동작하는 데 필요한 DI 정보와 태스트를 수행하기 위해 만든

DI 정보가 지금은 하나의 파일 안에 흔재해 있다. 1
장부터 지금까지 해온 가장 대표적

인 작업은， 성격이 다르고 변경 이유와 주기가 다른 묘드를 분리해서 깔끔하게 디듬는

것이었다. 그런데 막상
DI 정보를담은빈 설정정보는여러 가지 종류가다른것들이 한

데몰려 있다.

이번에 할 작업은 성격이 다른 DI 정보를 분리하는 것이다.

테스트용컨텍스트분리

자동 빈 등록을 적용한 userDao와 userService 빈은 애플리케이션 운영과 테스트에 모
두 펼요하다. 또한 DB 연결과 트랜잭션 관리， SQL 서비스도 항상 필요하다. 반면에
testUserService 빈은 태스트에서만 시용된다. ma i 1 Sender 빈은 좀 애매하다. 메일 발
송 기능은 애플리케이션이 동작하는 데 쪽 필요하긴 하지만 지금까지 시용해옹 더미
mailSender 빈은 태스트에서나 펼요하지 운영 중에 시용되면 안 된다. 일단 mailSender
빈도 테스트용이라고 하자.

이 두 개의 빈 설정은 테스트용 DI 정보로 구분되고 태스트에서만 사용될 것이고
테스트를 작성하거나 수정할 때 영향을 받고 변경되는 것이니 다른 애플리케이션 빈의
DI 정보에서 분리히는 편이 좋겠다.

DI 설정정보를 분리히는 방법은 간단하다.DI 설정 클래스를 추가하고 관련된 빈
설정 애노테이션， 필드， 메소드를 옮기면 된다. 일단 TestApplicationContext 클래스
의 이름을 AppContext
라고 바꾸자. 태스트 정보를 분리하고 남은 애플리케이션의 핵
심 DI 정보를 남겨둘 클래스이므로 이름에서 Test를 빼는 게 좋겠다. 문제는 Test를


빼고 나면 이름이 ApplicationContext
가 돼서 스프링 컨테이너의 핵심 인터페이스인
ApplicationContext와 혼동된다는 점으로， 자주 쓰는 인터페이스와 이름이 겹치는 건
별로 좋지 않다. 그래서 앞부분을 줄여서 AppContext로 바꾸겠다.

이제 테스트용 빈 정보를 분리해낼 클래스를 만들자. 이름은 TestAppContext로 한
다.01 정보로 사용될 것이므로 @Configuration을 붙이고 태스트 관련 빈 설정 코드를
AppContext에서 가져와서 리스트 7-109와 같이 만들면 된다.

리스트 7-109 분리한 테스트 미 정보

OConfigψurπrat
lO
n

public class TestAppContext (
@Autowired UserDao userDao;

@Bean

public UserService testUserService() (
TestUserService testService = new TestUserService();
testService.setUserDao(this.userDao);
testService.setMailSender(mailSender());
return testService;

@Bean
public MailSender mailSender() (
return new DummyMailSender();


testUserService 빈은 userDao와 mailSender 빈에 의존한다. mailSender 빈
을 정의한 메소드는 같이 옮겼으니 문제가 없다. userDao 빈은 자동으로 등록되도록
@Repository를 적용했으니 @Autowired로 빈을 가져오면 된다. TestUserService 클래
스는 UserServicelmpl
을 상속해서 만들었기 때문에 UserServicelmpl
과 마찬가지로
userDao 프로퍼티는 자동와이어링 적용 대상이다. 간략하게 하려면 userDao 프로퍼티
를 설정히는 코드와 @Autowired 필드를 제거해도 된다. mailSender 프로퍼티도 마찬가
지다. 이 두 가지 프로퍼티 설정 묘드를 제거하면 리스트 7-110과 같이 더 간단해질 것
이다.

7징-스프링 핵심 기술의 응용 683


리스트 7-110 자동와이어링율 활용하도록 간략하게 바문 테스트 DI 정보

W&

m

빠떠

매
廠

←빼

따

n S mw …… {

mw

대

얹

4-nU

-E

-n

) {

K

r

씨ν

να따

m T

m

따

애

때-없

。」

·mYJ

뼈

’

때

W

때

@ßean
public MailSender mailSender() (
return new DummyMailSender();

testUserService 빈 설정을 자동와이어링을 이용하도록 간략하게 바꿔봤다. 그렇
다면 아예 TestUserService 클래스에 @Component를 붙이고 @ComponentScan을 이용해
자동등록이 되게 할 수도 있지 않을까? 물론 가능하다. 하지만 여기서는 별로 권장하고
싶지 않다. 자동 빈 스캔은 기준 패키지를 지정해서 클래스를 찾게 한다. 테스트용 빈과
애플리케이션 빈의 설정정보를 클래스를 분리해서 따로 만들었다면 스캔 대상의 위치
도 분리될 필요가 있다. 하지만 지금은 UserDaoServicelmpl과 UserServ iceTest 등이
같은 패키지 아래 존재하므로 기준 패키지를 정하기 어렵다. 또한 testUserService
처
럼 태스트용으로 특별히 만든 빈은 설정정보에 내용이 드러나 있는 편이 좋다. 태스트
코드에서 @Autowired로 주입받는 UserDao 타입 빈이 왜 두 개인지 testUserService라
는 이름의 빈은 어떻게 구성된 것인지 파악송}기가 좋기 때문이다.

설정용 DI 클래스가 두 개가 됐다. 운영 시스템에서 애플리케이션이 동작할 때는
AppContext만 참조하고 태스트에서는 AppContext와 TestAppContext 두 개의 DI 정보
를 함께 사용하게 해주면 된다.

테스트 코드에 넣은 DI 정보용 클래스도 수정할 펼요가 있다. 기존엔
@ContextConfiguration에 TestApplicationContext를 지정해서 태스트용 컨텍스트
를 만들 때 시용하게 했다. 이제는 AppContext와 TestAppContext 두 개가 모두 필요
하다.

하나 이상의 설정 클래스가 스프링 태스트에서 사용되게 하려면 리스트 7-111
과 같
이 classes
에 적용할 설정 클래스를 모두 나열해주면 된다. 엘리먼트 이름을 보면 알겠
지만 classes는 배열 타입이므로 클래스를 하나 이상 지정할 수 있다.


리스트 7-111 테스트 컨텍스트의 미 설정 클래스 정보 수정

@R unWith(SpringJUnit4ClassRunner.class)
@(ontextConfiguration(classes={TestAppContext.class , AppContext.class})
public class UserDaoTest {

같은 방법으로 UserServiceTest도 두 개의 DI 클래스를 사용하도록 변경한다. 수정
을 마쳤으면 테스트를 실행해서 태스트가 성공적으로 동작히는지 확인해보자.

@Import

태스트에서 사용할 빈 정보는 별도의 클래스로 분리했으니 AppContext
에는 이제 성격

이 같은 빈 설정정보만 남아 있다. 정말 그럴까? 태스트가 아니라 애플리케이션 운영
중에 시용할 빈만 모아뒀다는 점에선 그렇다. 하지만 빈의 내용을 보면 여타 빈 설정과
확연히 구분되는 점들이 있다. 바로 SQL 서비스용 빈이다.

SQL 서비스는 그 자체로 독립적인 모율처럼 취급하는 게 나아 보인다. SQL 서
비스는 다른 애플리케이션에서도 사용될 수 있다. userDao 빈과 같은 DAO에서는
SqlService 타입의 빈을 DI 받을 수 있기만 하면 되지 구체적인 구현 방법을 알 펼요가
없다. SqlService의 구현 클래스와 이를 지원하는 보조 빈들은 다른 애플리케이션을 구
성히는 빈과 달리 독립적으로 개발되거나 변경될 가능성이 높다. 그래서 SQL 서비스와
관련된 빈들을 분리하고 싶다.

분리하는 방법 자체는 간단하다. 태스트용 빈 정보를 분리할 때처럼
@Configuration 클래스를 하나 더 만들면 된다. SqlServiceContext
라는 이름으로 클
래스를 만들어 리스트 7-112와 같이 SqlService 관련 빈을 옮겨보자.

리스트 7-112 SQL 서비스 번 실정을 위한 Sq
IServi∞Context 클래스


OConfiguration

public class SqlServiceContext (
@Bean
public SqlService sqlService() (
OxmSqlService sqlService = new OxmSqlService();
sqlService .setUnmarshaller(unmarshaller());
sqlService.setSqlRegistry(sqlRegistry());
return sqlService;

@Bean

견!I" 스프링 핵심 기술의 응용 685


public SqlRegistry sqlRegistry() {
EmbeddedDbSqlRegistry sqlRegistry =new EmbeddedDbSqlRegistry();
sqlRegistrY.setDataSource(embeddedDatabase());
return sqlRegistry;

@Bean

public Unmarshaller unmarshaller() {
Jaxb2Marshaller marshaller = new Jaxb2Marshaller();
marshaller.setContextPath( 'springbook.user .sqlservice.jaxb');
return marshaller;

@Bean
public DataSource embeddedDatabase() {

return new EmbeddedDatabaseBuilder()
.setName( 갱mbeddedDatabase'’ )
.setType(HSQL)
.addScript(
'classpath:springbook/user/sqlservice/updatable/sqlRegistrySchema.sql")
.build();

빈 내용은 수정할 게 없다. SqlService 타입 빈은 userDao 빈이 @Autowired로 참조
한다. 분리한 SqlServiceContext가 스프링 컨테이너의 설정 클래스로 함께 시용되게
만들어주기만 하면 된다.

DI 설정정보를 담은 클래스가 세 개가 됐다. 두 개는 애플리케이션 핵심 빈 정보를
담고 있고， 하나는 태스트와 관련된 것만 갖고 있다. 설정 클래스가 추가됐으니， 또 태
스트 코드 @ContextConfiguration
의 classes 내용을 수정해야 할까? 물론 그래도 된
다. 하지만그보다더 나은방법이 있다.

테스트용 설정정보는 애플리케이션 핵심 설정정보와 갈끔하게 분리되는 편이 낫다.
반면에 SQL 서비스와 관련된 빈 설정은 별도 클래스로 분리하긴 했지만 애플라케이션
이 동작할 때 항상 필요한 정보다. 그래서 파일을 구분했더라도 애플리케이션 설정정보
의 중심이 되는 AppContext와 긴밀하게 연결해주는 게 좋다.

앞 절에서 DI 설정 클래스와 XML
을 함께 사용한 적이 있다. 그렇다고
@ContextConfiguration
에 TestApplicationContext 클래스와 test



app 1 i cationContext. x m 1
을 함께 넣어주지는 않았다. 01 설정정보로는
TestApplicationContext만 지정하고，
XML 설정정보는 TestApplicationContext에서
@ImportResource를 이용해 가져오게 했다.

같은 방법을 DI 설정 클래스에도 적용할 수 있다. AppContext가 메인 설정정보가 되
고， SqlServiceContext는 AppContext에 포함되는 보조 설정정보로 사용히는 것이다.
자바 클래스로 된 설정정보를 가져올 때는 @ImportResource 대신 @Import를 이용한다.

AppContext
의 클래스 레벨에 리스트 7-113
과 같이 @Import
를 추가해서
SqlServiceContext를 가져오게 만들어보자.

리스트 7-113 @1
m∞d 적용

@(onfig매urπr퍼at
lO
n

@E nableTransactionManagement
@(omponentScan(basePackages="springbook.user")
@Import(SQlService(ontext.class)
public class AppContext {

이제 AppContext가 설정 클래스로 사용되면 SqlServiceContext도 함께 적용될 것이
다. 따라서 태스트 코드의 @ContextConfiguration은 수정하지 않아도 된다. 제대로 적
용되는지 태스트를 실행해서 확인해보자.

7.6.4 프로파일
테스트에서 사용되는 빈 설정은 TestAppContext로 분리해뒀다. 애플리케이션이 동작하
는 데 펼요한 핵심 빈 설정은 AppContext 하나로 충분하다. 태스트에서는 AppContext
에 TestAppContext를 추가해서 사용하면 된다.
그런데 문제가 하나 있다. 지금까지는 태스트를 실행할 때 외부 환경이나 서버에 영
향을 받지 않아도 되도록 메일 서비스 빈은 DummyMailSender라는 태스트용 클래스를
만들어 사용했다. 하지만 운영 시스템에서는 실제 동작하는 메일 서버를 통해 메일을
발송히는기능이 있는메일 발송서비스 빈이 필요하다.
MailSender 타입의 빈은 TestAppContext
에만 존재한다. 운영환경에서
TestAppContext 없이 AppContext만 DI 설정정보로 지정하면 어떻게 될까? AppContext
에는 메일 서비스를 제공하는 MailSender 타입 빈이 존재하지 않으니 이 빈에 의존히는
userService 빈에서 에러가 발생할 것이다.

낀~-스프링 핵심 기술의 응용 687



그래서 AppContext
에 실제 애플리케이션이 동작할 때 사용될 MailSender 타입 빈 설
정을 넣어줘야 할 것 같다. 스프링이 제공하는 JavaMail 기반의 메일 발송용 클래스인
JavaMailSenderlmpl을 이용해 리스트 7-114와 같이 빈을 정의해서 AppContext에 넣
는다고해보자.

리스트 7-114 운영용 메일 서버톨 지원하는 MailSender 빈

@Bean

public MailSender mailSender() (
JavaMailSenderlmpl mailSender =new JavaMailSenderlmpl();
mailSender.setHost("mail .mycompany.com");
return mailSender;

이제 AppContext에도 MailSender 타입 빈이 있으니 AppContext만 가져다 사용해
도 메일 발송 기능에는 문제가 발생하지 않을 것이다. 그런데 이렇게 하면 테스트에 문
제가 생긴다. UserServiceTest를 실행할 때는 AppContext와 TestAppContext에 정의
된 빈들이 함께 사용된다. 그래서 AppContext
에 추가한 운영용 mailSender 빈도 태스
트 중에 만들어진다. 태스트용으로 TestAppContext
에 정의해둔 mailSender 빈과 충돌
이 일어날 수밖에 없다. 같은 타입이면서 아이디도 같은 두 개의 빈이 있으면 스프링이
빈 정보를 읽는 순서에 따라 뒤의 빈 설정이 앞에서 발견된 빈 설정에 우선해서 적용된
다. 그래서 리스트 7-111
과 같은 순서로 설정 클래스를 배열하면 TestAppContext
에 정
의된 mailSender 대신 AppContext
에 추가한 운영용 mailSender 빈이 테스트에 시용되
는문제가발생한다.

태스트환경과 운영환경에서 각기 다른 빈 정의가 필요한 경우가 종종 있다.
tes
tUserService처럼 아예 테스트할 때만 필요한 빈이라면 태스트용 설정 클래스에만
넣으면 되지만. ma i 1 Sender 빈처럼 OJ쪽 모두 펼요하면서 빈의 내용이 달라져야 히는
경우에는 빈 설정정보 작성이 곤란해진다. ma i 1 Sender 빈은 @Autowired를 이용한 자동
와이어링 방식으로 주입되기 때문에 빈 아이디를 다르게 설정하는 것으로 간단히 해결
할수도없다.

이 문제를 해결하려면 운영환경에서는 반드시 펼요하지만 테스트 실행 중에는
배제돼야 하는 빈 설정을 별도의 설정 클래스를 만들어 따로 관리할 필요가 있다.
AppContext에 추가했던 리스트 7-114의 mailSender 빈 설정을 리스트 7-115와 같이
ProductionAppContext
라는 이름의 새로운 클래스를 만들어 옮겨보자.


리스트 7-115 운영환경에서만 필요한 빈을 담은 빈 설정 클래스

@(onfiguration

public class ProductionAppContext (
@Bean
public MailSender mailSender() (

JavaMailSenderlmpl mailSender = new JavaMailSenderlmpl();
mailSender .setHost("localhost");
return mailSender;

ProductionAppContext도 SqlServiceContext처럼 AppContext에서 @Import로 가져
오게 할 수 있을까? 그래서는 곤란할 것 같다， AppContext는 태스트에도 쓰이기 때문
이다.

@Import
로 AppContext
에 항상 포함되는 SqlServiceContext
를 제외하고
TestAppContext와 ProductionAppContext 두 개의 설정 클래스가 추가됐다. 태스
트환경에서는 @ContextConfiguration
에 AppContext와 TestAppContext를 지정해
서 두 개 클래스의 빈 설정이 조합돼서 태스트가 동작하게 만들었고， 운영환경에서는
AppContext와 ProductionContext 두 개의 클래스가 DI 정보로 시용되게 설정하면 될
것이다. 서버환경에서 동작하는 애플리케이션에 스프링 DI 설정을 어떻게 하는지는
VoI，
2
에서 자세히 설명하겠지만 아무튼 하나 이상의 XML 또는 설정 클래스를 적용
하는 데 문제는 없다. 단， 이런 식으로 실행환경이나 기능에 따라서 설정파일이 여러 개
로 쪼개지고 그중 몇 개를 선택해서 동작하도록 구성하는 일은 번거로울 수 있다. 특히
애플리케이션 구조가 커지고， 모율이 많아지고， 스프링 컨테이너가 동작히는 환경도 단
순히 태스트와운영 두 가지 이상이 될 수도 있기 때문에 이런 식의 파일 조합을 이용한
DI
설정은불편하다.

@Profile과 @ActiveProfiles
스프링 3，
1
은환경에 따라서 빈 설정정보가달라져야히는경우에 파일을여러 개로쪼
개고 조합하는 등의 번거로운 방법 대신 간단히 설정정보를 구성할 수 있는 방법을 제
공한다. 실행환경에 따라 빈 구성이 달라지는 내용을 프로파일로 정의해서 만들어두고，
실행 시점에 어떤 프로파일의 빈 설정을 사용할지 지정하는 것이다.
프로파일은 간단한 이름과 빈 설정으로 구성된다. 특정 실행환경에만 적용돼야 히는

얻t_ 스프링 핵심 기술의 응용 689



빈 설정은 이미 독립된 클래스로 깔끔히 구분해뒀다. 다만， 명시적으로 파일을 매번 조
합해야 하는 번거로움이 있을 뿐이다. 프로파일을 적용하면 하나의 설정 클래스만 가지
고 환경에 따라 다른 빈 설정 조합을 만들어낼 수 있다.

프로파일은 설정 클래스 단위로 지정한다. 리스트 7-116과 같이 @Profile 애노테이
션을 클래스 레벨에 부여하고 프로파일 이름을 넣어주면 된다.

리스트 7-116 @Profile율 지정한 T않tAppCo
nte성

OConfiguration

OProfile( "test")

public class TestAppContext {

이제 TestAppContext는 test 프로파일의 빈 설정정보를 담은 클래스가 됐다. 같은
방법으로 ProductionAppContext는 production 프로파일로 지정해보자.

AppContext나 SqlServiceContext 클래스에는 굳이 프로파일 지정을 할 펼요가 없
다. 스프링 3.1
은 프로파일이 지정되어 있지 않은 빈 설정은 default 프로파일로 취급
한다. 이름 그대로 디폴트 빈 설정정보로 취급되어 항상 적용된다.

프로파일을 적용하면 모든 설정 클래스를 부담 없이 메인 설정 클래스에서 @!mport
해도 된다는 장점이 있다. AppContex에 리스트 7-117과 같이 @!mport로 두 개의 클래
스를모두추가해보자.

리스트 7-117
@1m∞야에 모든 설정 클래스 추가

OConfig야따떠

ujπrat
lOn

@E
nableTransa라C다tio띠onManagement

OComponentScan(basePackages="springbook.user")
@Import({SqlServiceContext.class , TestAppContext.class , ProductionAppContext.class})
public class AppContext {

이제 AppContext
가 모든 설정 클래스를 @!mport 하고 있으니 태스트의
@ContextConfiguration
에 더 이상 TestAppContext를 넣을 필요가 없다. UserDaoTest
와 UserServiceTest
의 @ContextConfiguration을 다음과 같이 AppContext 하나만 남
도록수정하자.

OContextConfiguration(classes=AppContext.class)


이 상태로 테스트를 실행하면 어떻게 될까? AppConte
x
t가 TestAppContext 클래스를
@Import로 가져오도록 지정했으니 테스트용 빈들이 잘 생성돼서 테스트가 동작할까?
아니다. 태스트를 실행해보면 실패한다. 발생한 에러 메시지를 살펴보면 mailSender 빈
이 필요한데 찾을 수 없다고 되어 있을 것이다. ma i 1 Sender 빈은 AppContext가 @Import
하는 TestAppContext와 ProductionAppContext에 모두 존재하는데도 이 빈을 찾을 수
없다고 나온다. 왜냐하면 이 두 개의 설정 클래스는 프로파일이 지정되어 있어서 현재
태스트 설정 가지고는 어느 것도 포함되지 않기 때문이다.

@Profile이 붙은 설정 클래스는 @Import로 가져오든 @ContextConfiguration에 직
접 명시하든 상관없이 현재 컨테이너의 활성
active 프로파일 목록에 자신의 프로파일 이
름이 들어 있지 않으면 무시된다. 활성 프로파일이란 스프링 컨테이너를 실행할 때 추
가로 지정해주는 속성인데 아직 태스트에 활성 프로파일을 지정한 적이 없으니 test 프
로파일로 지정된 TestAppConte
x
t를 @Import로 포함하려고 해봤자 소용없다.

UserDaoTest나 UserServiceTest가 실행될 때 활성 프로파일로 test 프로파일을 지
정하려면 @ActiveProfiles 애노태이션을 사용하면 된다. UserServiceTest
라면 다음
과 같이 @ActiveProfiles를 넣어 test 프로파일을 활성 프로파일로 사용하게 해줄 수
있다.

리스트 7-118 활성 프로파일을 지정한 UserServiceTe엉

@R unWith(SpringJUnit4ClassRunner .class)
OActiveProfiles("test")
@(ontextConfiguration(classes=AppContext.class)
public class UserServiceTest {


UserDaoTest
에도 test 프로파일이 사용되도록 @ActiveProfile
s를 넣어주자. 그
리고 태스트를 실행해보면 태스트가 깔끔하게 성공할 것이
다. test 프로파일이 지
정된 TestAppConte
x
t
의 빈 설정은 포함되고 ProductionAppConte
x
t
의 빈 설정은
production 프로파일로 선언되어 있으므로 무시된다. 프로파일이 일종의 펼터처럼 적
용된다고이해해도좋다.

애플리케이션이 정식으로 동작하는 환경이라면 설정 클래스를 AppConte
x
t로 하고
활성 프로파일을 production으로 지정해주면 된다. TestAppContext의 빈 설정은 무시
되고 ProductionAppContext의 빈 설정이 AppContext와 함께 사용될 것이다.

얻L 스프링 핵심 기솔의 응용 691


컨테이너의 빈 등록 정보 확인
그런데 정말 활성 프로파일이 제대로 적용돼서 지정한 프로파일의 빈 설정만 적용되고
나머지는 무시됐을까? 의도한 빈 정보만 적용됐는지 어떻게 알 수 있을까? 컨테이너가
생성한 빈에 어떤 게 있는지 한 번쯤 눈으로 확인해보고 싶을 수도 있을 것이다.
간단히 스프링 컨테이너에 등록된 빈 정보를조회하는방법을살펴보자.
스프링 컨테이너는 모두 BeanFactory라는 인터페이스를 구현하고 있다. 1
장에서 직
접 만들어본 DaoFactory 같은 역할을 범용적으로 해주는 오브젝트 팩토리라는 의미다.
BeanFactory의 구현 클래스 중에 DefaultListableBeanFactory가 있는데 거의 대부분
의 스프링 컨테이너는 이 클래스를 이용해 빈을 등록하고 관리한다. 스프링은 친절하게
도 DefaultListableBeanFactory 오브젝트를 @Autowired로 주입받아서 이용하게 해준
다. DefaultListableBeanFactory에는 getBeanDefinitionNames() 메소드가 있어서 컨
테이너에 등록된 모든 빈 이름을 가져올 수 있고 빈 이름을 이용해서 실제 빈과 빈 클
래스정보등도조회해볼수있다.
스프링 태스트 클래스는 @Autowired로 태스트용 컨텍스트에서 원하는 빈을 주입
받을 수 있다. 이를 이용해서 DefaultListableBeanFactory를 가져와 등록된 빈 이름
과 빈 오브젝트의 구현 클래스를 출력해주는 간단한 태스트 메소드를 UserDaoTest나
UserServiceTest
에 리스트 7-119와 같이 추가해보자.

리스트 7-119 등록된 빈 내역을 조회하는 테스트 메소드

@Autowired DefaultListableBeanFactory bf;

@Test
public void beans() (
for(String n bf.getBeanDefinitionNames()) (
System .out.println(n + " \t "+ bf.getBean(n).getCl ass().getName());

bean() 태스트를 실행해보면 테스트 컨텍스트에 등록된 빈 이름과 빈의 클래스
를 모두 얻을 수 있을 것이다. 출력된 내용을 살펴보면 mailSender는 하나만 등록
되어 있을 것이고， 구현 클래스는 TestAppContext
에 있는 mailSender 빈 설정대로
DummyMailSender가 사용됐다. 기대한 대로 test 프로파일이 적용됐음을 알 수 있다.

이번엔 테스트의 @ActiveProfiles
의 활성 프로파일을 production으로 바꾸


고 beans() 태스트를 실행해보자. 이번엔 ProductionAppConte
xt
에서 정의한
JavaMailSenderlmpl 클래스로 만들어진 빈이 등록됐음을 확인할 수 있을 것이다.
확인이 끝났으면 테스트의 활성 프로파일은 test로 돌려놓자.

중접 클래스를 이용한 프로파일 적용
처음에 하나였던 빈 설정 클래스를 빈의 종류와 적용 환경 등을 고려해 여러 개로 분리
한 뒤. @
Import로 모아 메인 설정 클래스만으로 설정이 가능하게 했고， 프로파일을 적
용해서 환경에 맞는 빈만 적용되게 했다.
그런데 역시 파일이 많아지니 전체 구성을 살펴보기가 조금은 번거로워졌다. 서로
의존관계를 맺고 있는 빈들이 많아진다면 어느 빈이 어디서 적용됐는지 확인하기 위해
여러 개의 클래스 파일을 열어봐。F 할 것이다. 프로파일마다 빈 구성이나 구현 클래스
에 어떤 차이가 있는지 한눈에 비교하기 불편할 수도 있다.
그래서 이번에는 프로파일에 따라 분리했던 설정정보를 하나의 파일로 모아보자. 기
껏 클래스를 분리하고 프로파일까지 적용해놨는데 단지 파일 개수가 좀 많아졌다고 원
상태로 돌리지는 얘기는 아니다. 프로파일이 지정된 독립된 설정 클래스의 구조는 그대
로 유지한 채로 단지 소스코드의 위치만 통합하는 것이다. 스태틱 중첩 클래스를 이용
하면된다.
리스트 7-120과 같이 ProductionAppContext와 TestAppContext를 AppContext의
중첩 클래스로 만들 수 있다. 각각 독립적으로 사용될 수 있게 스태틱 클래스로 만들어
줘야 한다. 그리고 기존의 ProductionAppConte
xt와 TestAppContext 클래스 파일은 삭
제하자.

리스트 7-120 Tes여ppConte차와 ProductionAppCαltext톨 충첩 클래스로 만든 AppContext


@(onfig야urπr퍼at
lO
n

@EnableTransactionManagement
@(omponentScan(basePackages="springbook.user")
@Import({SqlServiceContext .class ,

AppContext.TestAppContext.class , AppContext.ProductionAppContext .class })
public class AppContext {

@(onfiguration

@Profile( "production‘’ )

public static class ProductionAppContext {

7징-스프링 핵심 기솔의 응용 693


@(onfiguration

@Profile("test")

public static class TestAppContext (

두 개의 클래스에 staHc만 붙여서 AppContext로 가져온 뒤 @Import에 지정했던 클
래스를 내부로 이동시킨 클래스로 바꿔주기만 하면 된다.

이제 AppContext만 열어보면 디폴트로 적용될 빈이 무엇인지， 프로따일을 지정하기
에 따라 어떤 빈이 등록될지 또 프로파일에 따라 같은 빈의 구현 클래스가 어떻게 달라
지는지를 좀 더 손쉽게 확인할 수 있게 됐다.

이렇게 중첩 멤버 클래스로 프로파일 설정 클래스를 포함시키면 한 가지 혜택이 더
있다. 다음과 같이 @Import
에 지정했던 두 개의 프로파일 설정 클래스를 아예 제거해도
된다.

@Import(SqlServiceContext.class)

이렇게 바꾸고 테스트를 실행해보자. TestAppContext와 ProductionAppContext를
넣지 않아도 아무런 문제가 없을 것이다. 스태틱 중첩 클래스로 넣은 @Configuration
클래스는 스프링이 자동으로 포함해주기 때문이다.

각 프로파일 클래스에 빈 설정정보가 많다면 하나의 파일로 모았을 때 전체 구조를
파악하기가 그다지 유리하지 않을 수 있다. IDE의 자바 에디터가 제공하는 중첩 클래
스 폴딩 기능을 활용하면 보기는 조금 좋겠지만 그래도 스크롤을 많이 해야 내용을 파
악할 수 있다면 그냥 파일을 분리하는 편이 나을 수도 있다. 어쨌든 지금 예제는 프로파
일에 정의한 빈 설정의 양이 많지 않으니 AppContext
에 모으는 방법이 깔끔해 보인다.

프로파일을 적용하고 중첩 클래스로 모으는 작업까지 마무리한 AppContext는 리스
트
7-121
과같다.

리스트 7-1낀 프로파일을 적용한 AppCαltext 설정 클래스

@(onfiguration
@EnableTransactionManagement

@(omponentScan(basePackages=닝
pringbook.user")

@Import(SqlServiceContext.class)


public class AppContext (
@8 ean
public DataSource dataSource() (

SimpleDriverDataSource ds = new SimpleDriverDataSource();
dS.setDriverClass(Driver.class);
ds .
setUr
l(“
jdbc:mysql://loca
lh
ost/springbook?characterEncoding예TF-8");
ds. setUsername( "spring");
dS.setPassword("book");
return ds;

@8 ean

public PlatformTransactionManager transactionManager() (
DataSourceTransactionManager tm = new DataSourceTransactionManager();
tm.setDataSource(dataSource());
return tm;

OConfiguration
@Profile("production")
public static class ProductionAppContext (

@8ean

public MailSender mailSender() (
JavaMailSenderlmpl mailSender = new JavaMailSenderlmpl();
mailSender.setHost("localhost");
return mailSender;

OConfiguration
@P rofile("test" )
public static class TestAppContext (

@8ean
public UserService testUserService() (
return new TestUserService();

@ßean
public MailSender mailSender() (
return new DummyMailSender();


얻il: 스프링 핵심 기솔의 응용 695


7.6.5 프로퍼티 소스
프로파일을 이용해 태스트환경과 운영환경에서 각각 다른 빈 설정이 적용되게 만들
었다. 하지만 아직 AppContext
oJl는 태스트환경에 종속되는 정보가 남아 있다. 바로
dataSource
의 DB 연결정보다. DB 드라이버 클래스나 접속 URL. 로그인 계정 정
보 등은 개발환경이나 테스트환경， 운영환경에 따라 달라진다. AppContext
에 정의된
dataSource 빈은 프로파일에 속하지 않은 빈 설정정보이므로 태스트와 운영 시점 모두
통일한 DB 연결정보를 가진 빈이 만들어진다.
지금까지 dataSource 빈의 구현 클래스는 태스트에서 간단히 사용할 수 있게 스
프령이 제공하는 것을 사용했다. 운영환경이라면 JNDI를 이용해 서버가 제공하는
DataSource를 가져오거나 애플리케이션에 내장할 수 있는 DB 커넥션 풀을 이용할 필
요가 있다. 빈 오브젝트 생성과 초기화 방법 자체가 달라질 수 있으니 프로파일을 이용
해 여러 개의 dataSource 빈을 만들어두는 게 이상적이겠지만， 여기서는 스프링 3.1
의
새로운 기능을 설명하기 위해 일단 dataSource 빈의 클래스는 모든 환경에서 동일한 것
을 λF용한다고 가정해보자.
문제는 SimpleDriverDataSource 오브젝트를 만든 뒤 DB 연결정보를 프로퍼티 값
으로 넣어주는 부분이다. 적어도 DB 연결정보는 환경에 따라 다르게 설정될 수 있어야
한다. 또한같은종류의 환경이더라도 펼요에 따라손쉽게 변경할수 있으면좋겠다. 그
래서 이런 외부 서비스 연결에 펼요한 정보는 자바 클래스에서 제거하고 손쉽게 편집할
수 있고 빌드 작업이 따로 필요 없는 XML이나 프로퍼티 파일 같은 텍스트 파일에 저장
해두는편이낫다.

@Prope까ySource
프로퍼티에 들어갈 DB 연결정보는 텍스트로 된 이름과 값의 쌍으로 구성되면 된다. 복
잡한 XML을 정의해서 시용할 것 없이 간단히 자바의 프로퍼티 따일 포뱃을 이용하면
충분하다.
프로퍼티 파일의 확장자는 보통 properties
이고， 내부에 키=값 형태로 프로퍼티를
정의한다. dataSource 빈의 설정에 λF용된 프로퍼티 이름과 값을 리스트 7-122와 같
이 프로퍼티 파일 포뱃으로 만들어 database. properties 따일에 저장하자. 다른 종류의
서비스 정보를 추가하면 비슷한 이름의 프로퍼티가 있어서 혼동될 위험이 있으니 앞에
‘db.
’을 붙여서 구분하자.


리스트 7-122 data벼se.pr。야미es 파일

db .driverClass=com.mysql.jdbc.Driver

db
.
url=jdbc:mysql
:
//localhost/springbook?characterEncoding며TF-8

db.username=spring

db
.
password며ook

AppContext
의 dataSource() 메소드가 database. properties 파일의 내용을 가져와
DB 연결정보 프로퍼티에 넣어주도록 만들어보자.

스프링 3.1
은 빈 설정 작엽에 펼요한 프로퍼티 정보를 컨테이너가 관리하고 제공해
준다. 스프링 컨테이너가 지정된 정보 소스로부터 프로퍼티 값을 수집하고， 이를 빈 설
정 작업 중에 사용할 수 있게 해준다. 컨테이너가 프로퍼티 값을 가져오는 대상을 프로
퍼티 소스property source라고 한다. 환경 변수나 시스랩 프로퍼티처럼 디폴트로 프로퍼
티 정보를 꿀어오는 프로퍼티 소스도 있고 프로퍼티 파일이나 리소스의 위치를 지정해
서 사용되는 프로퍼티 소스도 있다.DB 연결정보는 database.properties라는 특정 파일
에서 프로퍼티 값을 가져와야 하므로 프로퍼티 소스를 등록해줘야 한다. 프로퍼티 소스
등록에는 @PropertySource 애노테이션을 이용한다.

리스트 7-123과 같이 database. properties 파일의 내용을 컨테이너의 프로떠티 소스
로 사용하도록 @PropertySource를 넣어주면 된다.

리스트 7-123
@Prα)e따없Jn∞ 적용

@(onfiguration
@EnableTransactionManagement
@(omponentScan(basePackages="springbook.user")
@Import(SqlServiceContext.class)
@P roperty$ource('/database.properties')
public class AppContext {


@PropertySource로 등록한 리소스로부터 가져오는 프로퍼티 값은 컨테이너가 관
리하는 Environment 타입의 환경 오브젝트에 저장된다. 환경 오므젝트는 빈처럼
@Autowired를 통해 펼드로 주입받을 수 있다. 주입받은 Environment 오브젝트의
getProperty() 메소드를 이용하면 프로퍼티 값을 가져올 수 있다. dataSource ( ) 메소
드에서 DB 연결정보 프로퍼티 값을 넣어줄 때 환경 오브젝트로부터 프로퍼티 값을 가
져오도록 수정하면 리스트 7-124와 같이 될 것이다.

7장-스프링 핵심 기슐의 응용 697


리스트 7-124 환경 오브젝트로부터 프로퍼티 값을 가져오도록 수정한 da넙Sourl∞() 메소드

öAutowired Environment env;

@ßean
public DataSource dataSource() {
SimpleDriverDataSource ds = new SimpleDriverDataSource();

try {
ds.setDriverClass((Class<?
extends java.sQl.Driver>)Class.forName(env.getProperty("db.driverClass‘)));

catch(ClassNotFoundException e) (
throw new RuntimeException(e);

ds.setUrl(env.getProperty("db.url"));

ds.setUsername(env.getProperty(
닝b.username"));

ds.setPassword(env.getProperty("db.password"));

return ds;

Environment 오브젝트의 getProperty() 메소드는 프로퍼티 이름을 따라미터로 받아
스트링 타입의 프로퍼티 값을 돌려준다. url
이나 username, password 등은 이 값을 그
대로 사용하면 되는데， 문제는 driverCl ass 프로퍼티다. dri verClass 프로퍼티는 DB
연결 드라이버의 클래스로 클래스의 이름이 아니라 Cl ass 타입의 클래스 오브젝트를 넘
겨야 한다. 그래서 getProperty()
로 가져온 드라이버 클래스 이름을 Cl ass. forName()
메소드의 도웅으로 Class 타입으로 변환한 뒤 시용해야 한다. 이때 클래스를 찾을 수 없
다는 체크 예외가 발생할 수 있기 때문에 이를 다시 런타임 예외로 변환하는 등의 번거
로운 작업이 필요하다. XML에 dataSource 빈을 정의했을 때는 텍스트 값으로 드라이
버 클래스 이름을 넣어주면 스프링이 빈의 프로퍼티 타입을 보고 알아서 변환을 해췄다.
그런데 자바 코드로 전환한 뒤에는 직접 드라이버 클래스의 Cl ass 오브젝트를 넘겨야 했
고， 이를 다시 프로퍼티 값으로 가져오도록 수정하니 이번엔 타입 변환 작업을 직접 해
야 한다.XML 설정을 이용했을 때의 편리함을 생각하면 좀 아쉬움이 있다.

어쨌든 DB 연결정보는 설정 클래스에서 완전히 분리됐다. AppContext
의
dataSource 빈은 이제 환경에 상관없이 사용할 수 있다. 실행환경이 바뀐다고
AppContext 소스코드를 수정하고 다시 빌드할 필요가 없다. 환경에 따라 달라지는 빈


설정은 활성 프로파일을 변경해주면 되
고. DB 연결정보와 같이 환경
에 따라 달라지는
정보는프로퍼티 파일 내용을수정하기만하면 된다.

PropertySourcesPlaceholderConfigurer

앞에서는 프로퍼티 정보를 가져오기 위해 컨테이너가 관리하는 Environment 타입 오
브젝트를 DI 받F아서 사용했다. Environment 오브젝트 대신 프로퍼티 값을 직접 DI 받
는 방법도 가능하다. 지금까지 사용했던 @Autowired는 빈 오브젝트를 필드나 수정자 메
소드 파라미터로 주입받을 때 사용된다. dataSource 빈의 프로퍼티는 빈 오브젝트가
아니
므로 @Autowired를 시용할 수는 없다. 대
신 @Value 애노태이션을 이용하면 된다.
@Value는 이름 그대로 값을 주입받을 때 사용한다. @Value의 사용 방법은 여러 가지가
있는데
， 여기서는 프로퍼
티 소스로부터 값을 주입받을 수 있게 치환지.p
laceholder를 이용

해보겠다.

리스트 7-125와 같이 컨테
이너가 제공히는 프로퍼티 값을 주입받을 펼드를 선언하
고 앞에 @Value 애노태이션을 붙여준다. 그리고 @Value에는 프로퍼티 이름을 ${} 안에
넣은 문자열을 디
폴트 엘리먼트 값으로 지정해준다.

리스트 7-125 @Value룰 이용한 프로떠티 강 주입

@P ropertySource("/database. properties ")

public class AppContext (
@Value("S{db.driverClass} ") Class(? extends Driver> driverClass;
@Value( '’S{db.url}") String url;
@Value( "S{db.username} ") String username;
@Value("S{db.password} ’') String password;


@
Value
의 디폴트 값으로 넣은 ${
db.drvierCla
ss}
를 치환자라고 부르는 이
유는
XML에서 <property>의 va
lue에 사용하는 값 치환 방식과 유λ봐기 때문이다.
XML
에서는 다음과 같이 프로퍼티 값에 문자열로 된 치환자를 넣어두면， 컨테이너가 프로퍼
티 파일 등에서 가져온 실제 값으로 바꿔치기하게 만들 수 있다.

(property name="driverCl ass" va lue="S{db.driverClass} " />

XML에서는 치환자 자리의 값을 바꿔주는데 @Value에서는 @Value가 붙은 필드의
값을주입해주는방식으로동작한다.

@Value와 치환자를 이용해 프로머티 값을 필드에 주입하려면 특별한 빈을 하나 선언

7장-스프링 핵심 기솔의 응용 699


해줘야 한다. 프로퍼티 소스로부터 가져온 값을 @Value 필드에 주입히는 기능을 제공해
주는 PropertySourcesPlaceholder(onfigurer를 리스트 7-126과 같이 빈으로 정의해
줘야한다.

리스트 7-126 프로퍼티 소스톨 이용한 치환자 설정용 빈

@Bean

public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() (
return new PropertySourcesPlaceholderConfigurer();

빈 팩토리 후처리기로 사용되는 빈을 정의해주는 것인데 이 빈 설정 메소드는 반드
시 스태틱 메소드로 선언해야 한다.

이제 @Value로 선언한 네 개의 필드에는 @PropertySource로 지정한 파일에서 가져
온프로퍼티 값이 자동으로주입될 것이다. 마지막으로 dataSource 빈이 이 펼드값을
사용하도록 리스트 7-127과 같이 수정하자.

리스트 7-1'Z1 @Value 필드를 사용하도록 수정한 da녕없Jr<∞() 메소드

@Bean
public DataSource dataSource() (
SimpleDriverDataSource ds = new SimpleDriverDataSource();

dS.setDriverClass(this.driverClass);
dS.setUrl(this.url);
ds .setUsername(this.username);
dS.setPassword(this.password);

return ds;

@Value를 이용하면 driver
Cl
ass
처럼 문자열을 그대로 사용하지 않고 타입 변환이
필요한 프로퍼티를 스프링이 알아서 처리해준다는 장점이 있다. 지저분한 리플렉션
API나 try/catch가 없어서 깔끔하다. 반면에 dataSource 빈에서만 시용되는 프로퍼티
인데 값을 주입받도록 클래스에 펼드를 선언하는 것이 조금 부담스러워 보이긴 한다.
Environment를 이용해 프로퍼티 값을 가져오는 방법과 @Value를 이용히는 방법 중에서
작성하기 편하고 묘드를 이해하기 쉽다고 생각되는 방법을 선택하면 되겠다.


7.6.6 빈 설정의 재사용과 @Enable*
SqlServiceContext는 SQL 서비스와 관련된 빈 설정정보가 여타 빈 설정정보와 성격이
다르다고 보기 때문에 분리했다. 로우 레벨의 SqlService 구현 방법이 그대로 노출되는
빈 설정 코드를 애플리케이션의 전체 빈 구성 정보를 담은 AppContext
에 넣는 대신 따
로 분리해두는 것이 깔끔하다. 그뿐 아니라 SQL 서비스를 라이브러리 모률로 뽑아내서
독립적으로 관리하고， 여러 프로젝트에서 재사용되게 하려는 이유도 있다.
XML 같은 외부 리소스에 DAO에서 사용할 SQL을 저장해두고 필요에 따라 손쉽
게 변경할 수 있게 만들면 매우 유용하다. 물론 여기서 작성한 SQL 서비스 관련 빈들
은 DI를 적용히는 예를 보여주고자 간단히 만든 것이고， 실전에서는 iBatis 같은 고급
SQL 매핑 기술을활용해야한다. 어쨌든
SQL 서비스가꽤 잘만들어져서 기업 내 여
러 프로젝트에서 사용되는 상황이라고 가정해보자.
SQL 서비스 빈은 서비스 인터페이스， 즉 API
인 SqlService만 DAO에 노출하면 되
고 나머지 구현 기술이나 방법은 내부에 감춰두고 필요에 따라 자유롭게 변경할 수 있
어야 한다. SQL 서비스의 구현 클래스들은 애플리케이션의 다른 빈에 의존하지 않기
때문에 얼마든지 독립적으로 패키정해서 배포가 가능하다.
OXM과 내장형 DB 등을 활용해 만든 SQL 서비스를 적용하려면 네 개의 빈 설정이
펼요하다. 클래스와 인터페이스， 스키마 따일 등은 패지키를 독립적으로 바문 뒤에 jar
파일로 묶어서 제공하면 되지만 빈 설정은 프로젝트마다 다시 해줘야 하는 번거로움이
있다. 다행히 이번 절에서 SQL 서비스관련 빈 설정을독립적인 자바클래스로 만들어
뒀기 때문에 빈 설정정보도 라이브러리에 함께 패키징해서 제공할 수 있게 됐다. SQL
서비스를 사용하고 싶은 프로젝트라면 다음과 같이 @Import 한 줄만 추가해주면 SQL
서비스 관련 빈 등록을한 번에 끝낼 수 있다.

@Import(SqlServiceContext.class)

빈설정자
SQL 서비스를 재사용 가능한 독립적인 모률로 만들려면 해결할 문제가 아직 한 가지
남아있다.
리스트 7-128은 OxmSq
lService의 내부 클래스인 OxmSqlReader인데， 자세히 보
면 SQL 매핑 내역을 담은 sqlmap.xml 파일의 위치를 지정히는 부분이 있다. 그런데
UserDao 인터페이스가 위치한 클래스패스로부터 sqlmap.xml을 가져오게 되어 있다.

깐~ 스프링 핵심 기술의 응용 701


이건 좀 곤란하다. SQL 서비스를 사용히는 각 애플리케이션은 SQL 매핑파일의 위치
를 직접 지정할 수 있어야 하는데 지금은 예제 코드의 UserDao 위치로 고정되어 있다.

리스트 7-128 특정 sqlmap 파일 위치 종속적인 OxmSqlReader 클래스

private class OxmSqlReader implements SqlReader (

private Unmarshaller unmarshaller;

private Resource sqlmap =new ClassPathResource( ' sQlmap.xml' ’ UserDao.class);

SQL 매핑 리소스의 위치인 sqlmap 프로퍼티의 디폴트 값을 UserDao 같은 시용자 예
제에 종속되지 않게 다음과 같이 바꿔보자. 필요하면 설정을 통해 바꿀 수 있지만， 디
폴트 파일 이름과 위치를 따르겠다면 설정을 아예 생략할 수 있게 만드는 것도 나쁘지
않다.

private Resource sqlmap = new ClassPathResource('/sQlmap.xml');

SQL 매핑 리소스를 디폴트 위치와 다르게 만들려면 어떻게 해야 할까? 애플리케이
션에 따라 SQL 매핑파일 이름이나 위치한 패키지를 변경할 수도 있고， 클래스패스가
아니라 서블릿 컨텍스트나 파일 시스탬 HTTP를 통해 접근할 수 있는 리소스로 만들고
싶을 수도 있다. 결국 SQL 매핑 리소스는 빈 클래스 외부에서 설정할 수 있어야 한다.

이미 OxmSqlReader의 sqlmap 프로퍼티 값은 OxmSqlService에 있는 같은 이름의 프
로퍼티를 통해 전달받을 수 있게 해놨다. 예제에서는 sqlmap.xml 파일이 UserDao와
같은 위치에 있으니 변경한 디폴트 리소스 위치와 다르다. UserDao 클래스패스에 있는
sqlmap.xml 파일을 이용하게 하려면 SqlServiceContext에서 OxmSqlReader 클래스로
빈을 정의히는 메소드를 리스트 7-129와 같이 수정해주면 된다.

리스트 7-129 sql않rvæ 빈 설정으로 sqlmap 파일 리소스 지정

@8ean

public SqlService sqlService() (
OxmSqlService sqlService =new OxmSqlService();
sqlService .setUnmarshaller(unmarshaller());
sqlService.setSqlRegistry(sqlRegistry());
sqlService.setSQlmap(new ClassPathResource( ' sQlmap.xml' ’ UserDao.class)) ;
return sqlService;


SQL 서비스 구현 클래스 내부의 의존성은 제거했지만 아직 설정 클래스에는
UserDao
.
class
라는 특정 애플리케이션에 종속된 정보가 남아 있다. 이대로 두면 다른
애플리케이션에서 SqlServiceContext를 수정 없이 @Import로 가져다 사용할 수 없다.
SqlServiceContext
의 소스코드를 제공해서 펼요한 부분을 수정해 사용하면 되겠지만
컴파일된 클래스 파일 형태로 모률에 포함할 수는 없다.

DI 설정용 클래스인 SqlServiceContext까지 독립적인 모률로 분리하려면 코드에
남아 있는 UserDao 의존성을 제거해야 한다. 지금까지 이런 문제는 여러 번 다뤄봤다.
JDBC 쿼리를 실행히는 템플릿 코드에서는 SQL과 같이 매번 달라지는 내용을 콜백 형
태로 만들어서 전달하는 방법을 썼다. 그에 반해 sqlmap 리소스의 위치는 바뀔 일이 없
으니 초기에 한 번만 지정해주면 된다. 이런 경우엔 템플릿/콜백 패턴보다는 기본적인
DI를이용해야한다.

1
징벼l
서 처음 만든 UserDao로부터 DB 커넥션 책임을 분리해내던 것과 유사한 작업
을 하면 된다. SqlServiceContext
에서 분리하고 싶은 것은 SQL 매핑파일의 위치를 지
정하는 작업이다. 파일의 위치와 리소스 종류가 달라지더라도 SqlServiceContext는 수
정할 필요가 없어야 한다.

일단 리스트 7-130에 나온 대로 인터페이스를 하나 정의하자.

리스트 7-130 얼IMapConfig 인터페이스

import org.springframework.core.io.Resource;

public interface SqlMap(onfig (
Resource getSqlMapResouce();


SqlMapConfig 인터페이스에 SQL 매핑파일의 리소스를 돌려주는 간단한 메소드를
하나 추가했다. 이제 사용자 예제에 적용할 SqlMapConfig 인터페이스의 구현 클래스
를 만들자. 이름은 UserSqlMapConfig으로 하고 getSqlMapResource() 메소드를 리스트
7-131
과같이 작성한다.

리스트 7-131 SqIMapConfig 인터페이스률 구현한 클래스

public class UserSqlMap(onfig implements SqlMap(onfig (
OOverride
public Resource getSqlMapResouce() {

return new (lassPathResource(
닝qlmap.xml". UserDao.class);

7장-스프링 핵심 기솔의 응용 703


다음 작업은 SqlServiceContext가 변하지 않는 SqlMapConfig 인터페이스에만 의
존하게 만들고. SqlMapConfig 구현 클래스는 빈으로 정의해 런타임 시 주입되게 만드
는 것이다. SqlMapConfig 타입 빈을 @Autowired를 이용해 필드로 주입받아 시용하도록
SqlServiceContext를 리스트 7-132와 같이 수정한다.

리스트 7-132 SqIMapConfig 타입 빈에 의존하게 만든 SqIServ뼈Context

@(onfiguration
public class SqlServiceContext (
êAutowired SqlMap(onfig sqlMap(onfig;

@ß ean

public SqlService sqlService() (
OxmSqlService sqlService = new OxmSqlService();
sqlService.setUnmarshaller(unmarshaller());
sqlService.setSqlRegistry(sqlRegistry());
sqlService.setSqlmap(this.sqlMap(onfig.getSqlMapResouce());
return sq1Service;

UserDao를 비롯해 사용자 관리 예제에 종속적인 정보는 SqlServiceContext
에 더 이
상남아있지않게됐다.

한 가지 남은 작엽이 더 있다. SqlMapConfig을 구현한 UserSqlMapConfig 클래스를
빈으로 등록히는 것이다. AppContext에 리스트 7-133과 같。
1 @Bean 메소드를 추가해
서 UserSqlMapConfig으로 빈을 생성하게 하자.

리스트 7-133 sqlMapConfig 빈 설정

public class AppContext (

@II ean
public SqlMap(onfig sqlMap(onfig() (
return new UserSqlMap(onfig();


sqlMapConfig 빈은 SqlConfigService 빈에 @Autowired를 통해 주입돼서 사용될 것
이다.

이제 SqlServiceContext 코드는 SQL 매핑파일의 위치 변경에 영향을 받지 않
는다. SqlServiceContext는 SqlMapConfig과 함께 SQL 서비스 모률에 함께 패커징
돼서 수정 없이 재사용될 수 있다. SQL 서비스 기능을 사용하려는 애플리케이션은
SqlMapConfig을 구현한 빈을 만들어 원하는 리소스로부터 SQL 매핑정보를 가져오게
만들수있다.

이처럼 설정정보를 담은 코드도 리팩토링하면 반복적으로 시용되는 부분은 수정 없

이 재사용될 수 있고， 적용환경에 따라 바뀌는 부분은 인터페이스로 분리하고 DI를 통
해 외부에서 주입되게 만들 수 있다.

그런데 지금까지 별도의 모률로 분리할 SqlServiceContext를 제외하고 나머지 빈

설정은 AppContext로 통합했다.SQL 매핑파일 리소스 위치도 애플리케이션의 빈 설정

에 관련된 정보인데， 이 때문에 새로운 클래스를 하나 추가한 것이 좀 못마땅하다. 따일
을 줄이고 좀 더 간결하게 만들 수는 없을까?
UserSqlMapConfig 클래스와 관련 빈 설정을 아주 간단히 만들 수 있는 방법이
있다.

@Configuration 애노테이션이 달린， 빈 설정으로 사용되는 AppContext 같은 클
래스도 스프링에선 하나의 빈으로 취급된다. 그래서 빈의 자동와이어링에 쓰는
@Autowired를 이용할 수 있다. UserSqlMapConfig은 빈으로 만들어져서 SqlMapConfig
타입 빈에 의존하는 SqlServiceContext
에 주입된다. SqlServiceContext
가 펼요로 하
는 빈은 SqlMapConfig 인터페이스를 구현하고 있기만 하면 된다. 그렇다면 AppContext
가 이 SqlMapConfig을 직접 구현하게 하면 어떨까?

AppContext는 빈을 정의하고 DI 정보를 제공하는 설정용 클래스이면서 스스로도 빈
으로 사용된다. AppContext에는 @Configuration이 달려 있는데， 이 @Configuration은
다음과 같이 @Component를 메타 애노테이션으로 갖고 있는 자동 빈 등록용 애노테이션
이기도 하다. 원한다면 @Configuration 클래스도 빈 스캐너를 통해 자동등록되게 만들
수 있다. AppContext처럼 컨테이너의 기본 설정정보로 클래스를 지정히는 경우에도 빈
으로등록된다.

@(omponent
public @interface Configuration {

7징-스프링 핵심 기슐의 응용 705


하나의 빈이 꼭 한 가지 타입일 펼요는 없다.7.2.5절에서는 자기참조 빈을 만들면서
빈 클래스하나가여러 개의 인터페이스를구현하게 했다. 빈을
DI 받아서 사용하는쪽
은 빈이 특정 인터페이스를 구현하고 있는지에만 관심이 있다. 그래서 코드의 양이 많
지 않고， 같은그룹으로묶을수 있는 여러 개의 빈을하나의 클래스로만들기도한다.

AppContext가 빈이긴 하지만 애노태이션과 메소드를 통해 컨테이너의 기본 빈 설정
정보로 시용되는 것이 주 목적이라 별다른 인터페이스를 구현하고 있지 않다. 하지만
원하면 얼마든지 인터페이스를 구현하게 만들 수 있다.

AppContext
가 직접 SqlMapConfig 인터페이스를 구현하게 만들면 어떻게 될까?
AppContext는 빈으로 등록된다고 했으니 컨테이너에 의해 빈 오브젝트로 만들어진다.
SqlServiceContext는 @Autowired 필드에서 SqlMapConfig 타입의 빈을 주입받으려고
할 것이다. AppContext가 SqlMapConfig을 구현하게 했으니 AppContext로 만들어진 빈
오브젝트는 @Autowired에 의해 SqlServiceContext에 주입되어 시용된다.

이렇게 AppContext가 SqlMapConfig을 구현한 빈이 되게 만들어주변 번거롭게
UserSqlMapConfig 클래스를 추가할 필요가 없고， 빈으로 만들기 위해 sqlMapConfig( )
메소드를 넣을 필요도 없다. 펙분에 코드는 간결해지고 애플리케이션의 빈 관련 설정은
AppContext로 모두 통합될 것이다. 물론 이렇게 바문다고 해도 SqlServiceContext
에
수정할 내용은 전혀 없다.

리스트 7-134
는 AppContext
가 SqlMapConfig
을 구현하게 만든 것이다.
UserSqlMapConfig 클래스와 AppContext
에 넣었던 @Bean sqlMapConfig() 메소드는 제
거하자.

리스트 7-134 SqIMapConfig을 구현하게 만든 AppConte잉

public class AppContext implements SQl
삐apConfig {

OOverride
public Resource getSQl
삐apResouceO (
return new ClassPathResource( ‘ sQlmap.xml" ’ UserDao.class);

이제 태스트를 실행해서 모든 기능이 정상적으로 동작하는지 확인해보자.


@Enable* 애노테이션
SqlServiceContext는 이제 SQL 서비스 라이브러리 모률에 포함돼
서 재사용될
수 있다. SQL 서비스가 필요한 애플리케이션은 메인 설정 클래스에서 @Import
로
SqlServiceContext 빈 설정을 추가하고 S
qlMapConfig을 구현해 SQL 매핑파일의 위치
를 지정해주기만 하면 된다.
스프링 3.1
은 SqlServiceContext
처럼 모률화된 빈 설정을 가져올 때 사용하는
@
Import를 다른 애노테이션으로 대체할 수 있는 방법을 제공한다.
@Compone
nt는 빈 자동등록 대상을 지정할 때 사용히는 애노테이션인데， 많은 경우
@Component를 직접 사용하기보다는 @RepositorYLf @Service처럼 좀 더 의미 있는 이
름의 애노테이션을 만들어 사용한다. @Component를 메타 애노테이션으로 넣어서 애노
테이션을 정의해주면 @Component와 동일한 빈 등록기능이 적용되면서 자동등록되는 빈
의 종류나 계층이 무엇인지 나타낼 수도 있고， AOP를 이용해 특정 애노태이션이 달린
빈만 선정해 부가 기능을 제공하게 만들 수도 있다.
비슷한 방식으로 @
Import도 다른 이름의 애노테이션으로 대체 기능하다. @Import
애노테이션과 빈 설정 클래스 값을 메타 애노테이션으로 넣어서 리스트 7-135와 같이
애노테이션을 만들어주면 된다.

리스트 7-135
@1
mpαt롤 메타 애노테이션으로 넣은 애노테이션 정의

@Import (value=SqlServiceContext.class)
public @interface EnableSqlService (

새로 정의한 애노테이션의 이름은 @Ena
bleSqlService
다. SqlService를 사
용하겠다는 의미로 보면 된다. @Enable
로 시작하는 애노테이션은 이미 앞에
서 한 번 사용해봤다. XML
의 <tx:annotation-driven />과 기능이 통일한
@EnableTransactionManagement
다. @EnableTransactionManagement 애노테이션도 리
스트 7-136에서 볼 수 있듯이 @Import를 메타 애노테이션으로 갖고 있다.

리스트 7-136 @EnableTransactionManagement 애노테이션


@
Import
(
Tran
sactionManagementConfi띠gurπrationSelecto
r.
class)

public @interface EnableTransactionManagement {

깐~-스프링 핵심 기술의 응용 707


@EnableTransactionManagement
를 사용한다는 것은 결국
TransactionManagementConfigurationSelector 설정 클래스를 @Import 히는 셈이다.
이제 AppContext
의 @Import
를 리스트 7-137
과 같이 새로 정의한
@EnableSqlService로 바꿔보자.

리스트 7-137@εnanbleSq
lServi∞ 적용

tlConfiguration

tlC
αnponentScan(basePackages=
“
springbook.user")
@단1ableTransactionManagement
@담lableSqlService

öPropertySource("/database.properties")
public class AppContext implements SqlMapConfig {

SQL
서비스를시용하겠다는의미가잘드러나고깔끔해보인다.

직접 정의한 애노태이션에 @Import를 메타 애노태이션으로 부여해서 사용하는 방법
은 이 밖에도 여러 가지 장점이 있다. 애노태이션을 정의하면서 엘리먼트를 넣어서 옵
션을 지정하게 할 수도 있다. SqlMapConfig 인터페이스를 통해 SqlServiceContext
에
SQL 매핑파일을 전달하게 했던 방식을 다음과 같이 간결하게 만들 수도 있다.

@E
nableSqlSer땐{:classpath:/springbook/user/s빼ap.xml")

@Enable 애노태이션을 이용한 빈 설정정보의 재시용과 확장 방법에 대해서는 Vol.2
의 l
장과
7징써l서 자세히 설명할것이다.
사용자 관리 예제에 스프링 3.1 의 새로운 DI 스타일을 적용하는 작업은 이좀에서 마
무리하겠다. 최종 완성된 AppContext는 리스트 7-138과 같다.

리스트 7-138 스프링 3.1 이 방식올 적용한 AppContext 설정 클래스

tlConfiguration
@E nableTransactionManagement
tlComponentScan(basePackages=‘ springbook.user‘ )

@단1ableSq
lService

öPropertySource("/database.properties")

public class AppContext implements SqlMapConfig (
@Value("${db.driverClass}") Class<? extends Driver) driverClass;
@Value("${db.url}") String url;
@Value("${db .username}") String username;
@Value("${db.password}") String password;


OOverride
public Resource getSqlMapResouce() (
return new ClassPathResource(
갱qlmap
.
xml"， UserDao .class);

@Bean
public static PropertySourcesPlaceholderConfigurer placeholderConfigurer() (
return new PropertySourcesPlaceholderConfigurer();

@Bean
public DataSource dataSource() (
SimpleDriverDataSource ds = new SimpleDriverDataSource();

ds.setDriverClass(this .driverClass);
ds .setUrl(this.url);
ds .setUsername(this.username);
ds.setPassword(this.password);

return ds;

@Bean

public PlatformTransactionManager transactionManager() (
DataSourceTransactionManager tm = new DataSourceTransactionManager();
tm.setDataSource(dataSource());
return tm;

OConfiguration
@Profile("production")
public static class ProductionAppContext (

@Bean

public MailSender mailSender() (
JavaMailSenderlmpl mailSender = new JavaMailSenderlmpl();
mai lSender. setHost(" localhost");
return mailSender;

OConfiguration
@P rofile("test" )
public static class TestAppContext {

7징-스프링 핵심 기술의 응용 709


@ß ean
public UserService testUserService() {
return new TestUserService();

@ßean
public MailSender mailSender() {
return new DummyMailSender();

지금까지 XML에 담겨 있던 빈 설정정보를 애노테이션과 자바 묘드로 비꾸고， 자동
등록과 와이어링 기능을 적용하고 실행환경에 따라 달라지는 빈 설정정보를 분리해서
프로파일을 적용했다. 외부 서비스 접속에 필요한 정보는 프로퍼티 파일로 만들어두고
프로퍼티 소스를 통해 빈 설정에서 시용하게 했다. 마지막으로， 독립적으로 재시용 가
능한 묘드와 설정정보를 분리해내고， 손쉽게 가져다 쓸 수 있게 전용 애노테이션도 도
입했다.

지금까지 소개한 XML과 자바 묘드를 이용한 DI 설정 방법은 스프링 3.1
이 제공하
는 DI 설정 방법의 일부일 뿐이다. 좀 더 다OJ=한 DI 설정 전략과 기술은 V이
.
2에서 본
격적으로다룰것이다.

;r"~ 정리

7장에서는 스프링 DI와 서비스 추상화 등을 응용해 새로운 SQL 서비스 기능을 설계하
고 개발한 뒤에 이를 점진적으로 확장， 발전시키는 방법을 알아봤다. 스프링 사용자라
면 객체지향적인 설계와 DI를 효과적으로 활용하는 방법에 익숙해야 한다. 스프링이 제
공해주는 내장 기능에만 만족하지 말고 스프링의 기반기술을 자유자재로 활용할 수 있
도록 다%댄f 시도를 해야 한다. 스프링이 제공해주지 않는 기능을 직접 구현할 때도 적
극적으로 DI와 서비스 추상화. AOP 등을 활용할 수 있어야 한다. 그것이 스프링이 프
레임워크로서 제공하는 가치를 제대로 누리는 방법이다.

여기서 살펴본 내용은 다음과 같다.

710


.
SQL처럼 변경될 수 있는 텍스트로 된 정보는 외부 리소스에 담아두고 가져오게 만들면 편
리하다.

• 성격이 다른 코드가 한데 섞여 있는 클래스라면 먼저 인터페이스를 정의해서 코드를 각 인
터페이스별로 분리하는 게 좋다. 다른 인터페이스에 속한 기능은 인터페이스를 통해 접근하
게 만들고， 간단히 자기참조 빈으로 의존관계를 만들어 검증한다. 검증을 마쳤으면 아예 클
래스를분리해도좋다.
• 자주 사용되는 의존 오브젝트는 디폴트로 미리 정의해두면 편리하다.
• XML과 오브젝트 매핑은 스프링의 OXM 추상화 기능을 활용한다.
• 특정 의존 오브젝트를 고정시걱 기능을 특화하려면 멤버 클래스로 만드는 것이 편리하다.
기존에 만들어진 기능과 중복되는 부분은 위임을 통해 중복을 제거하는 게 좋다.
• 외부의 파일이나 리소스를 사용히는 코드에서는 스프링의 리소스 추상화와 리소스 로더를
사용한다.
• DI를 의식하면서 묘드를 작성하면 객체지향 설계에 도움이 된다.
• DI에는 인터페이스를 사용한다. 인터퍼l이스를 사용하면 인터페이스 분리 원칙을 잘 지키는
데도도움이된다.
• 클라이언트에 따라서 인터페이스를 분리할 때 새로운 인터페이스를 만드는 방법과 인터페
이스를 상속하는 방법 두 가지를 사용할 수 있다.
• 애플리케이션에 내장하는 DB를 사용할 때는 스프링의 내장형 DB 추상화 기능과 전용 태
그를 시용하면 편리하다.
7장-스프링 핵심 기술의 응용 711


Al 금까7.1 λ냉자 정보에 대한 DAO와 서비스 모률을 만들고 발전시키는 과정을 통

| 해 스프링의 주요 특정과 기술을 살펴봤다. 스프링은 기본적으로 IoC와 DI를 위
한 컨테이너로서 동작하지만 그렇다고 “스프링은 단지 IoC/ DI 프레임워크다”라고는 말
할 수 없다. 스프링은 단순히 IoC
/DI를 편하게 적용하도록 돕는 단계를 넘어서 엔터프
라이즈 애플리케이션 개발의 전 영역에 걸쳐 다OJ=한 종류의 기술에 관여한다.

그렇다면 과연 스프링이란 무엇이고 어떻게 설명할 수 있을까? 스프링 프레임워크가
만들어진 이유와 존재 목적， 추구히는 가치는 무엇일까?

8장에서는 지금까지 살펴본 스프링의 모습 속에서 어렴풋하게 느껴졌을 스프링의 사
상과 가치， 그리고 적용된 원칙을 좀 더 갚이 있게 생각해보겠다. 그 과정을 통해 스프
링이란 도대체 무엇이고 왜 존재하는지를 좀 더 체계적으로 이해할 수 있다면 앞으로
스프링을 더 쉽게 이해하는 데 도움이 될 것이다.

I[:1iJ 스프링의 정의 편

스프링이란 이런 것이다라고 한마디로 정의하기는 쉽지 않다. 스프링은 간단한 몇 단어
로 규정하기에는 쉽지 않은 독특한 특징이 있기 때문이다. 게다가 스프링에 대한 여러
가지 정의를 본다고 해서 스프링이 무엇인지 간단히 이해되는 것도 아니다. 그렇다고
스프링을 그때그때 필요한 API 사용 방법 위주로만 공부하면 스프링을 오해하거나 그
가치를 충분히 누리지 못할 수 있다. 그래서 한 번쯤은 스프링
의 정의를 통해 스프링이
어떤 것인지 큰 그림으로 이해해보려고 노력할 펼요가 있다. 정의란 원래 시물의 본질

8~仁
스프링이란 무엇인가? 713


적인 뭇을 담고 있다. 따라서 정의를 이해하려는 노력은 스프링을 김이 이해하고 그 가
치를 파악하는 데 도움이 될 것이다. 또 스프링의 정의 하나쯤은 기억해두면 유용하다.
스프링을 잘 모르는 고객이나 상사가 어느 날 “스프링이 도대체 뭐야?"라고 질문했는데
간단명료하게 대답을 못히는 것도 곤란할 테니까 말이다.

스프링에 대해 가장 잘 알려진 정의는 이렇다.

자바 맨터프라01즈 개발을 편하게 해주는 오픈소스 경료답 애를리케이션 프레임워크

정의를 봐도 스프링이 무엇이지 감이 바로 오지는 않을 것이다. 하지만 이 정의에는
스프링의 중요한특정이 잘담겨 었다.
이 정의를 하나씩 풀어서 살며보자.

애플리케이션 프레임워크
일반적으로 라이브러리나 프레임워크는 특정 업무 분야나 한 가지 기술에 특화된 목
표를 가지고 만들어진다. 예를 들면 웹 계층을 MVC 구조로 손쉽게 만들 수 있게 한
다거나， 포뱃과 출력장치를 유연하게 변경할 수 있는 애플리케이션 로그 기능을 제
공한다거나， 간단한 설정만으로 관계형 DB와 자바오브젝트를 매핑해주는 ORM 기
술을 제공하는 것들이다. 그래서 프레임워크는 애플리케이션의 특정 계층에서 주로
동작히는 한 가지 기술 분야에 집중된다. 하지만 스프링은 이와 다르게 ‘애플리케이
션 프레임워크’라는 특징을 갖고 있다.
애플리케이션 프레임워크는 특정 계층이나 기술 업무 분야에 국한되지 않고 애
플리케이션의 전 영역을 포괄하는 범용적인 프레임워크를 밀한다. 애플리케이션 프
레임워크는 애플리케이션 개발의 전 과정을 빠르고 편리하며 효율적으로 진행하는
데 일차적인목표를두는프레임워크다.
스프링이 자바 엔터프라이즈 개발의 전 영역을 포괄송F는 애플리케이션 프레임워
크가 된 데는 스프령의 탄생배경과 밀접한 관련이 있다. 스프링은 처음부터 독자적

인 프레임워크로 개발된 것이 아니다. 재미있게도 스프링의 기원은 J2EE 기술서적
에 딸린 예제 코드다. 스프링을 처음 만든 사람은 로드 존슨R∞ Johnson이라는 유명
한 자바 개발자다. 로드 존슨은 2003
년에 '"Expert One-on-One J2EE Design and
DevelopmentJ라는 책을 출간했다. 자바 엔터프라이즈 개발에 관한 자신의 풍부한
경험을 바탕으로 J2EE 애플리케이션 설계와 개발의 모든 영역에 대한 개발 전략을
다룬 책이다. 이 책에 소개된 독창적인 개발 전략과 기존 기술에 대한 대안은 설명으
로만 그치지 않고， 그 개념을 증명할 수 있도록 만들어진 3만 라인가량의 샘플 애플


리케이션 형태로 제공됐다. 이 책에서 강조한 중요한 전략의 하나는 “항상 프레임워
크 기반으로 접근하라”는 것이었다. 당연히 책의 예제 애플리케이션도 프레임워크를
먼저 만들고 나서， 프레임워크를 이용하는 코드를 만드는 방식으로 작성됐다. 바로
이 예제에 포함된 프레임워크가 스프링 프레임워크의 기원이다. 이 책에서 주장하는
자바 엔터프라이즈 개발의 이상적인 프로그래밍 모델을 추구히는 데 펼요한 기반이
돼주는 코드， 즉 프레임워크가 지금 스프링의 원시 버전이라고 보면 된다.

이 책의 내용과 예제로 제공된 프레임워크에 매료된 개발자들이， 책의 독자들이
토론히는 출판사 포럼에 모이기 시작했다. 그리고 그중 의욕 있는 일부 개발자는 책
에 나오는 프레임워크를 단지 예제 수준으로 두기에는 아깝다는 생각을 했고， 그것
을 발전시켜서 지속적으로 개발하자는 의견을 냈다. 그런 열의를 가진 몇몇 개발자
와 그들에게 설득당한 저자인 로드 존슨도 참여하면서 정식으로 스프링 프레임워크
라는 이름의 오픈소스 프로젝트가 시작돼서 오늘날에 이른 것이다.

스프링의 기원이 된 예제 애플리케이션의 프레임워크는 책에서 설명한 각종 자바
엔터프라이즈 개발 전략의 핵심을 담아서 개발됐다. 이 책 자체가 자바 엔터프라이
즈 개발의 전 계층에 등장하는 기술과 애플리케이션의 전 영역에 대한 효과적인 설
계와 개발 기법을 다루고 있었기 때문에 예제 프레임워크 또한 애플리케이션 전반에
걸친 모든 분야를 포괄하고 있었다. 결과적으로 이 예제 프레임워크로부터 시작된
스프링은 자연스럽게 애플리케이션의 전 영역을 지원하는 종합적인 애플리케이션
프레임워크가된 것이다.

단지 여러 계층의 다OJ=한 기술을 그저 한데 모아뒀기 때문에 애플리케이션 프레
입워크라고 불리는 건 아니다. 애플리케이션의 전 영역을 관통하는 일관된 프로그래
밍 모델과 핵심 기술을 바탕으로 해서 각 분야의 특성에 맞는 필요를 채워주고 있기
때문에， 애플리케이션을 빠르고 효과적으로 개발할 수가 있다. 바로 이것이 스프링
이 애플리케이션 프레임워크라고 불리는 이유다.

스프링을 MVC 프레임워크 또는 JDBC/ORM 지원 프레임워크라고 생각히는 것
은스프링이 다루는 일부 영역만봤기 때문이다. 또， 스프링을
IoC/
D1 프레임워크나
AOP 툴이라고 보는 이유는 스프링이 제공히는 핵심 기술에만 주목했기 때문이다.
스프링의 일차적인 존재 목적은 핵심 기술에 담긴 프로그래밍 모댈을 일관되게 적용
해서 엔터프라이즈 애플리케이션 전 계층과 전 영역에 전략과 기능을 제공해줌으로
써 애플리케이션을 편리하게 개발하게 해주는 애플리케이션 프레임워크로 사용되는
것임을기억해두자.

8장-스프링이란무엇인가? 715


·경훌맙
스프링 정의의 다음 항목은 ‘경량급~ightweight’이다. 스프링이 경량급이라는 건 스프링
자체가 아주 가볍다거나 작은 규모의 코드로 이뤄졌다는 뭇은 아니다. 오히려 스프
링은 20
여 개의 모율로 세분화되고 수십만 라인에 달하는 코드를 가진 매우 복잡하
고 방대한 규모의 프레임워크다.
그럼에도 스프링이 가볍다고 히는 이유는 무엇일깨 그것은 불필요하게 무겁지
않다는 의미다. 이는 스프링의 기원이 된 책에서 비판히는 자바 엔터프라이즈 기술
의 불펼요한 복잡함에 반대되는 개념이다. 특히 스프링이 처음 등장하던 시절의 자
바 주류 기술이었던 예전의 EJB 같은 과도한 엔지니어링이 적용된 기술과 스프링을
대비시켜 설명하려고 사용됐던 표현이다.
당시 EJB는 기술에 대한 과도한 욕심으로 인해 개발환경과 운용서버， 개발과 빌
드， 태스트 과정， 작성된 코드 모두를 매우 무겁고 복잡하게 만들었다. EJB가 동작
하려면 고가의 느리고 무거운 자바 서버WAS가 펼요했다. 또한 툴의 도움 없이는 다
루기 힘든 난해한 설정파일 구조와 까다로운 패키징， 불편한 서벼 배치
deploy 등으로
인한 부담 때문에 고가의 제품으로 구성된 제대로 된 개발환경을 갖추지 않고는 개
발하기가힘들었다.

그에 반해 스프링은 가장 단순한 서버환경인 톰켓Tomcat이나 제티
Jetty에서도 완벽
하게 동작한다. 단순한 개발툴과 기본적인 개발환경으로도 엔터프라이즈 개발에서
펼요로 하는 주요한 기능을 갖춘 애플리케이션을 개발하기에 충분하다. 서블릿 컨테
이너만으로충분하니 EJB 컨테이너를비롯해 복잡한 기능이 잔뜩포함된 고급
WAS
를 굳이 사용하지 않아도 된다. 그만큼 개발 과정도 단순해진다. 스프링의 장점은 그

런 가볍고 단순한 환경에서도 복잡한 EJB와 고가의 WAS를 갖춰야만 가능했던 엔
터프라이즈 개발의 고급 기술을 대부분 사용할 수 있다는 점이다. 묘드는 더 단순하
고 개발 과정은 편리하면서도 EJB에서조차 불편했던 고급 기능을 세련된 방식으로
적용할수있다.

결과적으로 스프링은 EJB를 대표로 하는 기존의 많은 기술이 불필요하게 무겁고
복잡했음을 증명한 셈이고 그런 변에서 스프링은 군더더기 없이 깔끔한 기술을 가
진 ‘경량급’ 프레임워크라고 불린 것이다.

스프링의 이런 특정은 개발환경과 서버에만 국한된 게 아니다. 경량급이라는 의
미는 스프링을 기반으로 제작되는 코드가 기존 EJB나 여타 프레임워크에서 동작하
기 위해 만들어진 코드에 비해 상대적으로 작고 단순하다는 돗이기도 하다. 같은 기


능을 수행하는 코드인데도 스프링 기반의 코드가 가벼운 이유는 코드에 불필요하게
등장하던， 프레입워크와 서버환경에 의존적인 부분을 제거해주기 때문이다. EJB와
WAS 같은 기술과 환경을 지원하기 위해 군더더기처럼 우겨넣어야 했던， 판에 박힌
듯이 반복되던 코드가 제거되고 나니 가장 단순하고 가벼운 코드만 남게 됐다.

다시 말하지만 스프링이 가볍다는 건 기술수준이 가볍다거나， 스프링이 유치하고
용도가 제한적이라는 의미는 결코 아니니 오해하지 말기를 바란다. 고성능이면서 내
구성도 좋은 스포츠카가 그저 덩치만 크고 성능은 떨어지는 차에 비해 오히려 중량
은 가볍고 차체도 작다는 것과 마찬가지 개념이라고 생각해도 좋을 것 같다. 만들어
진 묘드가 지원히는 기술수준은 비슷하더라도 그것을 훨씬 빠르고 간편하게 작성하
게 해줌으로써 생산성과 품질 면에서 유리하다는 것이 바로 경량급이라는 말로 표현
되는 스프링의 특정이다.

• 자바 엔터프라이즈 개발을 편하게
이번에 살펴볼 정의 내용은 ‘자바 엔터프라이즈 개발을 편하게 해주는’이다. 스프링
뿐 아니라 기존에 등장했던 대부분의 자바 엔터프라이즈 기술과 프레입워크는 저마
다 깨발을 편하게 해준다’고 주장하고 있다. 하지만 스프링이 밀히는 ‘엔터프라이즈
개발을 편하게’라는 말은 그 무게가 다르다. 스프링은 근본적인 부분에서 엔터프라이
즈 개발의 복잡함을 제거해내고 진정으로 개발을 면하게 해주는 해결책을 제시한다.
단순히 편리한 몇 가지 도구나 기능을 제공해주는 차원이 아니다. 엔터프라이즈 개
발의 근본적인 문제점에 도전해서 해결책을 제시한다는 것이 기존 기술의 접근 방법

과 스프링의 접근 방법의 차이점이다.

흥미롭게도 이 문구는 EJB가 처음 등장했을 때도 사용됐다. 엔터프라이즈 개발을
위한 본격적인 자바 기술로 세싱써l 처음 등장했던 EJB 버전 1.0
의 스펙문서를 살펴
보면 EJB
의 목표를 다음과 같이 이야기하고 있다.

EJB를 사용하면 애플리케이션 작성을 편하게 할 수 있다. 로우레벨의 트랜잭션

이나 상태 관리， 멀티스레
딩， 리소스 풀링과 같은 복잡한 로우레벨의 API 따위

를 이해하지 못하더라도 아무런 문제 없이 애플리케이션을 개발할 수 있다.

-Enterprise JavaBeans 1.0 Specification. Chapter 2 Goals

이 목표에서 볼 수 있듯이 편리한 애플리케이션 개발이란 개발자가 복잡하고 실
수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않으면서도 애플리케이션의 핵심인
사용자의 요구사항， 즉 비즈니스 로직을 빠르고 효과적으로 구현하는 것을 말한다.

8장-스프링이란 무엇인가? 717


EJB
의 비전과 목표는 바로 이것이었다. EJB는 약속대로 일정 부분에서는 엔터프
라이즈 개발의 고민거리와 부담을 덜어줬다. 문제는 이 과정에서 다른 차원의 더 큰
복잡함을 애플라케이션 개발에 꿀고 들어오는 실수를 저질렀다는 점이다. 이 때문에
거의 대부분의 EJB 개발자는 처음 기대외는 달리 이전보다 더 어렵고 불편해진 애플
리케이션 개발에 지쳐갔고 결국 EJB
의 접근 방법은 잘못됐음을 깨닫고는 다른 대안
을 찾게 됐다. 스프링도 당시 티B의 잘못된 접근 방법에 대한 대안을 모색하는 중에
등장한것이다.

따라서 스프링은 EJB가 궁극적으로 이루고자 했던 이 목적을 제대로 실현하게 해
주는 프레임워크다. 스프링은 애플리케이션 개발지들이 스프링이라는 프레임워크가
제공히는 기술이 아니라 자신이 작성히는 애플리케이션의 로직에 더 많은 관심과 시
간을 쏟게 해준다. 초기에 스프링의 기본 설정과 적용 기술만 잘 선택하고 준비해두
면， 이후로 애플리케이션 개발 중에는 스프링과 관련된 묘드나 API
에 대해 개발자가
거의 신경 쓸 일이 없다. 스프링이 ‘엔터프라이즈 개발을 편하게 해준다’라는 EJB와
동일한목적을추구하지만그과정에서 다른불편함을추가하지 않아도되게 만들었
기 때문에 가능한 일이다.

스프링은 또한 엔터프라이즈 개발의 기술적인 복잡함과 그에 따른 수고를 제거해
준다. 여기서 제거한다는 건 그런 기술적인 펼요를 무시한다는 의미는 아니다. 엔터
프라이즈 개발에서 필연적으로 요구되는 기술적인 요구를 충족하면서도 개발을 복
잡하게 만들지 않는다는 점이 스프링의 뛰어난 면이다. 과연 어떻게 해서 스프링이
개발을 펀하게 만들어주는지는 뒤에서 계속 이야기하겠다.

스프링을 경험한 많은 개발자가 “스프링을 쓰지 않았을 때는 애플리케이션 개발을
어떻게 했었는지 상상이 안 된다”라는 이야기를 하는 이유도 바로 스프링 제공하는
엔터프라어즈 시스랩 개발의 편리함에 감동했기 때문이다.

·오픈소스
스프링은 오푼소스 프로젝트 방식으로 개발돼왔다. 지금도 여전히 오푼소스 개발 모
델과 오픈소스 라이선스를 가지고 개발되는 중이며， 이 사실은 앞으로도 바뀌지 않
을것이다.
오픈소스란 말 그대로 소스가 모두에게 공개되고， 특별한 라이선스를 취득할 필요
없이 얼마든지 가져다 자유흡게 이용해도 된다는 뭇이다. 소스를 지쉬홈게 열람하고
자신의 목적에 맞게 사용할 수 있을 뿐만 아니라， 펼요하면 맘대로 수정할 수 있고，
수정된 제품과 소스를 다시 공개적으로 배포하는 자유도 허용된다. 물론 오푼소스도


저작권이 있기 때문에 원 저작자에 대한 정보와 라이선스는 유지한 채로 사용하거나
배포해야지， 자신이 만든 것처럼 슬며시 가져다 사용해도 좋다는 뭇은 아니다.
스프령에 적용된 오픈소스 라이선스는 오픈소스 라이선스 중에서도 비교적 제약

이 적고 사용이 매우 자유로운 편인 아파치 라이선스 버전 2.0 Apache License Ver 2
.0이
다. 아파치 라이선스에 따르면 스프링을 상업적인 목적의 제품에 포함시키거나 비공
개 프로젝트에 자유롭게 이용해도 된다. 다만 스프링을 사용한다는 점과 원 저작자
를 밝히고 제품을 패키정할 때 라이선스 정보를 포함시키는 등의 기본적인 의무사항
을 따르면 된다. 또， 펼요하다면 스프링 소스코드를 가져와 수정해서 사용할 수도 있
다. 수정을 했더라도 수정한 소스를 공개해야 히는 의무는 없다.

대부분의 오픈소스 프로젝트처럼 스프링도 오픈소스 개발과 사용자를 위한 온라
인 커뮤니티가 있다. 커뮤니티를 통해 자유흡게 개발에 관한 의견을 공유하거나 토
론할 수도 있고 자신이 발견한 버그를 신고하거나 새로운 기능을 추가해달라고 요청
할 수도 있다. 그런 요청이나 버그 신고가 어떻게 처리되고 있는지도 이슈트래커 시
스댐을 통해 공개적으로 확인이 가능하며， 수정된 코드도 언제든지 살펴볼 수 있다.

이렇게 개발 과정에 많은 사람이 자유롭게 참여한다는 것이 오픈소스 프로젝트로
서 스프링이 가진 장점이다. 그러나 스프링의 개발 과정은 공개되어 있지만 공식적
인 개발은 제한된 인원의 개발자에 한정된다. 원한다고 아무나 개발팀에 들어와 스
프링 프레임워크 코드 개발에 참여할 수는 없다. 실제로 스프링은 대형 IT 기업의 사
업부인 스프링소스Spring
So
urce가 그 개발을 전적으로 책임지고 전담하고 있다. 비록
개발 과정이 공개되어 있고， 간접적으로 개발에 영향을 줄 수 있는 의견 제시나 패치
제공， 버그 신고， 공개적인 토론 등이 가능하다고 할지라도 직접적으로 스프링을 개
발하는 일은 특정 조직에 소속된 개발자로 한정되어 있다는 것이다. 이렇게 개발팀
이 폐쇄적으로 운영되고 있다는 사실은 미션크리티컬한 시스멈 개발에도 사용되는
엔터프라이즈 프레임워크인 스프링 입장에서는 중요한 의미가 있다.

모든 것이 다 그렇겠지만 오픈소스라는 것도 장단점이 있다.

오푼소스의 장점은 공개된 커뮤니티의 공간 안에서 투명한 방식으로 다양한 참여
를 통해 개발되기 때문에 매우 빠르고 유연한 개발이 가능하다는 것이다. 오픈소스
제품의 사용지는 소스코드를 다운받아서 품질과 기능을 얼마든지 검증하고 분석해
볼 수 있다. 발견한 버그를 신고하거나 기능 개선을 제안했다면 그것이 어떻게 처리
되는지도 지켜볼 수 있다. 개발 중인 경우에도 소스코드까지 투명하게 공개되기 때
문에 다양한 현장에 있는 사용자의 피드백이 그만큼 빨리 전달되고 반영된다. 인기

8장-스프링이란무엇인가? 719


있는 오픈소스 제품이라면 베타 버전임에도 전 세계의 수많은 개발자가 자발적으로
다운받아서 사용해보고 다OJ=한 방식으로 피드백을 주기도 한다.

오푼소스 개발 모댈을 사용하는 스프링 역시 전 세계의 많은 엔터프라이즈 시스
뱀 개발자의 참여를 통해 발전해왔다. 때로는 새로운 기능에 대한 아이디어나 만들
어진 코드를 제공받아서 적용하기도 했다. 포럼이나 이슈트래커를 통해 제안된 기능
이나 요청사항 등이 다음 버전에 적용되는 사례를 꼽자연 끝도 없을 정도다. 자바 엔
터프라이즈 환경이라는 게 워닥 다양하기 때문에 개발팀이 모든 환경과 기술 조햄l
대해 일일이 테스트해보기는 불기능하다. 하지만 다OJ=한 환경에서 개발히는 개발자
가 자신이 경험한 문제점이나 발견한 버그 등을 그때마다 커뮤니티를 통해 개발팀에
게 전달하기 때문에 잠재적인 버그와문제점이 빠르게 발견되고 해결될 수 있다.

물론 오픈소스 제품을 사용하는 기업이나 사용자 입장에서 보자면 라이선스 비용
에 대한 부담이 없다는 것도 큰 장점으로 꼽을 수 있다.

이런 여러 가지 장점이 있기 때문에 오푼소스 개발 모벨은 이제 비영리 개발그룹
에서만이 아니라 상용 제품을 만들고 영리를 추구하는 일반 기업에서도 적극적으로
이용한다. 대형 소프트웨어 개발업체가 자신이 만든 제품의 일부 또는 전체 소스코
드를 오푼소스 커뮤니티에 기증하거나 기업 웹λ}이트 등을 통해 공개하는 일도 적지
않게일어나고있다.

하지만 오픈소스 개발 모텔에는 단점도 었다. 오픈소스 개발 방식의 가장 큰 취약
점은 지속적이고 안정적인 개발이 계속될지가 불확실하다는 것이다. 상당수의 오픈
소스 제품은 핵심 개발자의 여가시간을 이용해 일종의 취미활동으로 만들어진다. 그
런데 개발자의 개인적인 사정으로 인해 개발을 더 진행할 수 없거나， 개발자가 중간
에 교체되거나， 개발팀에 불화가 생겨서 개발을 정상적으로 진행하기가 힘들 때도
종종 었다. 어떤 때는 단순한 버그 하나가 수정되기까지 몇 년씩 걸리거나 개발자들
이 다 떠나서 프로젝트 자체가 사장되는 최악의 상황까지도 갈 수 있다. 개발 프로젝
트라는 게 대부분 그렇긴 하지만 오푼소스 프로젝트는 특히 개발자 개개인에게 극
히 의존적이다.

스프링 같은프레임워크는기업의 가장중요한핵심 업무를관장히는엔터프라이
즈 시스템의 개발에 λF용된다. 오류가 발생하거나 문제가 생기면 치명적일 수 있는
미션크리티컬한 시스뱀의 개발에도 사용된다. 그런 데서 기반이 되는 프레임워크가
버그가 있는 채로 방치된다거나， 지속적으로 안정적인 개발이 진행되지 못한다는 건
심각한 문제다. 그런 이유 때문에 엔터프라이즈 시스댐 개발자는 언제 개발이 중단


되거나 지연될지 모르는 오픈소스 프레임워크의 도입을 부정적으로 생각할 수밖에
없었다.

스프링 개발자는 이런 오픈소스의 문제점과 한계를 잘 알고 있었다. 그래서 오픈
소스 개발이라는 방법을 선택하기는 했지만 프레임워크 사용자에게 지속적인 신뢰
를 줄 수 있도록 개발을 책임지고 진행할 수 있는 전문 기업을 만들었다. 이를 통해
스프링의 핵심 개발자가 따트타임이나 여가시간 대신 정규 업무시간에 풀타임으로
오픈소스 개발에 전념할 수 있었고， 덕분에 안정적이고 전문화된 개발과 품질관리가
기능해졌다. 기존 오픈소스 개발 방식의 단점을 극복할 수 있는 대안은 기업이나 기
관의 지원을 받는 전문 개발자가 오푼소스 개발을 책임지게 하는 것이다.

스프링을 개발하고 있는 스프링소스는 스프링의 창시자인 로드 존슨을 비롯해 스

프령이 오픈소스화되는 데 가장 큰 역할을 한 유겐 휠러
Juergen Hoeller와 자바 엔터프
라이즈 세계에서 손꼽히는 최^d-급 개발지들이 주축이 돼서 만든 회사다. 이 회시는
스프링에 대한 전문적인 기술지원과 컨설팅 그리고 스프링을 기반으로 개발된 시스
뱀을 안정적으로 운용할 수 있도록 돕는 상용 제품을 제공함으로써 수익을 얻고， 한
편으로는 오픈소스 프로젝트로서 스프링이 효율적으로 개발되도록 지원하고 있다.
엔터프라이즈 영역에서 사용되는 대표적인 오픈소스 제품의 경우는 이렇게 특정 기
업이 주도하거나 지원하는 방식으로 개발되는 일이 상당히 보편회됐다. 사용자는 개
발이 중단될까 봐 염려하지 않아도 되고 필요한 경우에는 비용을 지불하고 개발팀
의 전문적인 기술지원 서비스나 컨설팅을받을수도 있기 때문이다.

스프링 개발업체인 스프링소스는 2009년에 세계적인 IT 기업인 VMWare
에 전략
적으로 합병됐다. 그 덕분에 이전보다 더욱 안정된 환경과 조직의 지원을 통해 오픈
소스 스프링의 개발에 더욱 전념할 수 있었다.

스프링은 오픈소스의 장점을 충분히 취하면서 동시에 오픈소스 제품의 단점과 한
계를 잘 극복하고 있는， 전문적이고 성공적인 오픈소스 소프트웨어라고 할 수 있다.

{ ~ 스프링으| 목적 텐l

지금까지 스프링의 정의를 살펴봄으로써 스프링의 기본적인 특정을 알이봤다. 이번에
는 좀 더 구체적으로 스프링의 개발 철학과 궁극적인 목표가 무엇인지를 생각해보자.
모든 기술이나 지식이 다 그렇지만 스프링은 더더욱 그 목표를 분명히 알고 사용하지
않으면 그 가치를 제대로 얻기 힘들다. 그저 스프링을 가져다가 어떻게든 사용해서 개

8장-스프링이란 무엇인가? 721


발만 하면 스프링을 적용한 것이고， 스프링의 장점이 개발에 반영됐다고 할 수 있을까?
결코 그렇지 않다. 스프링을 사용하기는 해도 스프링이 주는 혜택을 전혀 누리지 못하
고오히려 사용하지 않느니만못한경우도적지 않다.

스프링을 제대로 사용하는 건 생각보다 쉽지 않다. 이런 식으로 만들면 된다는 표준
생플이 있는 것도 아니다. 스프링의 개발 표준 따위가 존재하지도 않지만， 스프링 적용
베스트 프랙티스를 모아다가 그대로 따른다고 해도 스프링을 잘 사용하고 있다고 확신
할수는 없다. 레퍼런스매뉴얼을착실히 읽고관련서적을여러 권공부한다고해도스
프링을 사용해 어떻게 개발해야 할지 막막할 수도 있다.

스프링은 그 기능과API 사용 방법을잘 안다고 해서 잘쓸수 있는 게 아니다. 이 말
이 이상하게 들릴지도 모르겠지만 자바를 처음 배울 때를 생각해보면 이해가 될 것이
다. 자바 언어 문법과 JDK의 API 시용법이 자세히 설명된 두꺼운 자바 입문서를 읽고，
더 욕심을 내면 웬만한 철학서적보다도 더 지루한 자바 언어 스펙까지도 공부했다고 치
자. 그러면 자바로 개발을 잘할 수 있을까? 자바의 장점을 잘 살려 애플리케이션을 개
발할 수 있을까? 그렇지 않다는 것은 자바로 개발을 해온 개발자라면 누구나 잘 알 것
이다. 자바 언어와 JDK 라이브러리는 모두 일종의 편리한 도구로서 자바 언어의 특정
인 객체지향 프로그래밍을 좀 더 손쉽게 할 수 있도록 돕고 있을 뿐이다. 자바로 개발을
잘하려면 결국 근본적인 프로그래밍 실력이 필요하다. 자바의 근본적인 목적은 객체지
향 프로그래밍을 통해 유연하고 확장성 좋은 애플리케이션을 빠르게 만드는 것이다. 자
바를 가져다가 절차지향 언어처럼 사용한다면 자바를사용하는 가치를 얻을수 없다.

마찬가지로 스프링도 목적을 바로 이해하고 그 목적을 이루는 도구로 스프링을 잘
활용해야만 스프링으로부터 제대로 된 가치를 얻을 수 있다. 어떤 기술이든 그 자체로
는 도구에 불과하다. 그것을 용도에 맞게 잘 활용해서 궁극적으로 이루고자 하는 목표
를 이루는 것이 중요하지 도구의 사용법만 열심히 익힌다고 결괴를 저절로 얻을 수 있
는건아니다.

그렇다면 스프링의 목적은 무엇인가? 스프링이 만들어진 이유는 무엇이고， 스프링
을 통해 궁극적으로 이루려고 히는 것은 무엇인개 그것은 정의를 통해 살펴봤듯이 ‘경
량급 프레임워크인 스프링을 활용해서 엔터프라이즈 애플리케이션 개발을 편하게’ 하는
것이다. 그렇다면 굳이 스프링을 사용해서 엔터프라이즈 애플리케이션 개발을 편하게
하려는 이유는 뭘까? 원래 엔터프라이즈 개발이란 편하지 않기 때문이다.


8.2.1 엔터프라이즈 개발의 복즙템
2000년대 초반 각종 자바 컨퍼런스에서 자주 논의됐던 주제는 ‘왜 자바 엔터프라이즈
JavaEE 프로젝트는 실패하는가?’였다. 당시 IT 리서치기업의 조사에 따르면 80% 이상의
자바 엔터프라이즈 프로젝트가 실패했다고 한다. 프로젝트가 아예 중단되고 취소된 것
까지는 아니더라도， 원래 정해진 기간과 계획된 예산을 맞추지 못한 경우가 그만큼 많
다는 뭇이다. 또는 원하는 만큼의 기능과 완성도를 갖춘 시스템을 못 만들고 적당히 마
무리하기도 했을 것이다. 아무튼 자바 엔터프라이즈 개발이 실패히는 이유에 대해 많은
논의가 있었다. 그 과정에서 밝혀진 여러 가지 원인이 있었지만， 그중 가장 대표적인 게
‘엔터프라이즈 시스멈 개발이 너무 복잡해져서’였다.

복잡함의근본적인이유

그렇다면 엔터프라이즈 시스뱀 개발은 왜 복잡할까? 크게 두 가지 원인을 생각해볼 수

있다.

• 첫 번째는 기술적인 제약조건과 요구사흥1'0
1 늘어가기 때문이다
엔터프라이즈 시스댐이란 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시
스템을 말한다. 엔터프라이즈 시스랩은 많은 사용자의 요청을 동시에 처리해야 하
기 때문에 서버의 자원을 효율적으로 공유하고 분배해서 사용할 수 있어야 한다. 또
한 중요한 기업의 핵심 정보를 처리하거나 미션 크리티컬한 금융， 원자력， 항공， 국
방 등의 시스탱을 다루기도 하기 때문에 보안과 안정성
， 확장성 면에서도 뛰어나야
한다. 따라서 뛰어난 성능과 서비스의 안정성이 요구되고 그런 점을 고려한 개발 기
술이 필요하다. 즉 엔터프라이즈 시스렘을 개발하는 데는 순수한 비즈니스 로직을
구현하는 것 외에도 기술적으로 고려할 사항이 많다는 돗이다
. 또 웹을 통한 사용자
인터페이스뿐만 아니라， 타 시스탱과의 자동화된 연계와 웹 이외의 클라이언트와의
접속을 위한 리모팅 기술도 요구된다. 기업의 시스템이 복잡함에 따라 다중 데이터
베이스를 하나의 트랜잭션으로 묶어서 사용하는 분산 트랜잭션의 지원도 필요하다.
문제는 이러한 엔터프라이즈 시스템의 기술적인 요구사항은 단순히 고가의 애플리
케이션 서버
WAS나 툴을 시용한다고 충족될 수 있는 게 아니라는 점이다. 따라서 이
런 종류의 기술적인 문제를 고려하면서 애플리케이션을 개발해야 하는 부담을 안게
된다.

엔터프라이즈시스뱀이 기업 업무를처리하는데 핵심적인 역할로등장하고중요
해지면서 점점 더 기술적인 요구는 심화되고 그에 따른 복잡도는 증가한다. 이전에

8장-스프링이란 무엇인가? 723


는 그다지 신경 쓰지 않았던 보안에 관한 부분도 갈수록 중요해지고， 그에 따라 시스
뱀 설계자와 개발자 개개인이 져야 할 기술적인 부담은 점점 더 커져갔다.

• 두 번째는 엔터프라이즈 애폴리케이션이 구현해야 할 핵심기능인 비즈니스 로직의 복
잡힘이 증가하기 때문이다
예전에는 기업 업무 중 회계처럼 복잡한 계산이나 빠른 분석 작업이 펼요한 영역에
서만 IT 시스탱을 활용했다. 하지만 갈수록 엔터프라이즈 시스템을 이용해 기업의
핵심 업무를 처리하는 비율이 늘어갔고， 점차 대부분의 업무 처리는 검퓨터를 이용
하지 않고는 아예 진행하기 힘들 만큼 엔터프라이즈 시스템에 대한 업무 의존도가
높아졌다. 그만큼 다양하고 복잡한 업무 처리 기능을 엔터프라이즈 시스템이 구현해
야 했다는 뭇이다. 원래 기업 업무란 그 자체로 복잡한데다， 다양한 예외상황도 많
고， 처리해야 하는 정보의 규모도 상당하다. 엔터프라이즈 시스템이 관여하는 업무
의 비율이 급격하게 커지고 있으니 당연히 애플리케이션 개발도 힘들고 복잡해져 가

는것이다.

더 큰 문제는 2000
년 전후로 전 세계에 불어 닥친 경제위기가 기업의 체질을 크게 바
꿨다는 사실이다. 한번 업무 프로세스와 정책이 결정되면 제법 오랫동안 유지하던 전통
적인 기업조차도 경제 흐름과 사회의 변화， 업계의 추이에 따라서 수시로 업무 프로세
스를 변경하고 조종하는 것을 상시화할 만큼 변화의 속도가 빨라졌다. 결국 이런 업무

구조와 프로세스의 변회는 이를 뒷받침해줘야 하는 엔터프라이즈 시스템의 변경을 요

구할수밖에 없다. 벼그나오류가있어서가아니라， 기능요구사항과업무정책등이 바

뀌기 때문에 애플리케이션을 지주 수정해줘야 하는 시대가 된 것이다. 그만큼 이전과

다르게 시스템 개발과 유지보수， 추가 개발 등의 작업에 대한 부담은 커지고 그에 따른
개발의 난이도는 더욱 증가한 것이다.

복잡함을 가중시키는 원인

엔터프라이즈 애플리케이션 개발이 실패하는 주요 원인은 비즈니스 로직의 복잡함과
기술적인 복잡함이다. 복잡하다는 건 단지 양이 많고 어렵다는 뭇이 아니다. 세부 요소
가 이해하기 힘든 방식으로 얽혀 있고， 그 때문에 쉽게 다루기 어렵다는 의미다. 자칫
잘못 손을 댔다가는 더 엉망이 되기 쉬우며， 들인 노력과 시간이 허사가 될 수도 었다.
자바 엔터프라이즈 시스뱀 개발이 어려운 가장 큰 이유는 근본적인 비즈니스 로직과 엔
터프라이즈 기술이라는 두 가지 복잡함이 한데 얽혀 있기 때문이다. 하나씩 놓고 봐도

만만치 않은데， 그 두 가지를 한 번에 다뤄야 하니 복잡함이 몇 배로 가중되는 것이다.


예를 들면 이런 경우다. 고객의 기존 거래내역을 분석하고 그 특성을 파악해서 그에

따른 적절한 추천상품을 선정하는 로직을 담당하는 코드를 작성한다고 생각해보자. 그

런데 그 작업 요청을 XML 문서를 통한 리모팅 서비스로 받기 때문에 그것을 파성해서

고객 ID를 추출하기 위해 XML 파서 라이브러리를 사용해야 하고， 고객의 최신 정보를

얻기 위해 DB를 조회할 때 캐시를 먼저 점검하려고 캐시 API를 호출하고， 없으면 서버

가 제공하는 DB 풀에서 커넥션을 가져와서 JDBC API를 이용해 다OJ=한 타입의 펼드로

된 정보를 가져외야 한다. 그때 가져옹 정보를 분석한 내용을 만일을 위해 로그로 남겨

놓도록 분산 파일 시스댐을 이용하는 로그 라이브러리를 매번 호출한다. 현재 요청을 보

낸 사용자의 정보를 보안 API를 통해 가져와 요청한 작업에 대한 권한이 있는지도 파악

해야 하고， 권한이 없으면 그에 따른 예외를 발생시켜야 한다. 최종적으로 추천상품으로

선정한 내역을 로컬 DB
에 저장하고 메시지로도 전송해야 하는데， 반드시 하나의 트랜

잭션 안에서 동작하도록 하기 위해 JTA를 이용해야 한다고 생각해보자.

고객에 대한 추천제품 선정이라는 비즈니스 로직을 제대로 구현히는 일도 만만치 않

은데 동시에 이런저런 다OJ=한 기술적인 문제도함께 신경 써야한다면 어떨까? 각종 엔

터프라이즈 기술 서비스를 적용하기 위한 코드와 각종 기술적인 API의 호출 코드를 비

즈니스 로직에 대한 구현 코드와 함께 덕지덕지 붙여서 만드는 것은 매우 어렵다. 더 큰

문제는 그렇게 기술과 비즈니스 로직의 복잡함에 영켜 있는 코드를 유지보수하는 일이

다. 만약 적용한 기술을 변경해야 한다면? 또는 특정 로직을 수정해야 한다면? 하나의

수정 요구를 적용하기 위해 복잡하게 얽혀 있는 코드를 헤매다 보면 정작 수정할 대상

이 아닌 부분에까지 영향을 줘서 새로운 버그를 만들 수도 있다.

일반적으로 사람은 성격이 다른 두 가지 종류의 일을 동시에 생각하고 처리하는 데

매우 취약하다. 그럼에도 전통적인 자바 엔터프라이즈 개발 기법은 대부분 비즈니스 로

직의 복잡한 구현 코드와 엔터프라이즈 서비스를 이용히는 기술적인 코드가 자꾸 혼재

될 수밖에 없는 방식이었다. 결국 개발자가 동시에 그 두 가지를 모두 신경 써서 개발해

야 하는 과도한 부담을 췄고， 그에 따라 전체적인 복잡함은 몇 배로 가중됐다.

8.2.2 복잡함을 해결하려는 도전
제거될 수 없는 근본적인 복짙합
엔터프라이즈 개발의 근본적인 복잡함의 원인은 제거할 대상은 아니다. 물론 구현해야
할 비즈니스 로직의 적용범위를 줄이고 기술적인 요구조건을 일부 생략한다변 그만큼
개발은 편해질 것이고 적어도 실패하지 않을지는 모른다. 하지만 현실적으로는 불기능

8장-스프링이란 무엇인가? 725


하다. 기술적인 복잡함을 해결하고자 보안을 취약하게 방치한다거나， 시용자가 늘어나
도더 이상확장이 불가능한시스템을만들수는없다. 기업의 업무처리에서 IT가차지
히는 비중을 생각해볼 때 업무의 일부를 다시 수작업으로 가져가서 시스렘 개발의 부담
을 줄이겠다는 것도 말이 되지 않는다.

결국 근본적으로 엔터프라이즈 개발에 나타나는 복잡함의 원인은 제거 대상이 아니
다. 대신 그 복잡함을 효과적으로 상대할 수 있는 전략과 기법이 펼요하다. 문제는 비즈
니스 로직의 복잡함을 효과적으로 다루기 위한 방법과 기술적인 복잡함을 효과적으로
처리하는 데 적용되는 방법이 다르다는 점이다. 따라서 두 가지 복잡함이 코드에 한데
어우러져 나타나는 전통적인 개발 방식에서는 효과적으로 복잡함을 다루기가 힘들다.

따라서 가장 먼저 할 일은 성격이 다른 이 두 가지 복잡함을 분리해내는 것이다.

실패한해결책: EJB
EJB가 처음 등장했을 때 내세웠던 목표를 봐도 알 수 있듯이 EJB의 기본 전략도 이 두
가지 종류의 복잡함을 분리하는 것이었다. 개발자가 로우레벨의 기술적인 복잡함에 신
경 쓰지 않고 비즈니스 로직을 효과적으로 개발히는 데 더 집중할 수 있게 하자는 목표
가있었다.
하지만 기존 EJB는 결과적으로 그런 목표를 달성동}는 데 실패했다. EJB는 기술적인
복잡함을 애플리케이션의 핵심 로직에서 일부분 분리히는 데 성공하긴 했다. 선언적 트
랜잭션이나 선언적 보안， 컨테이너를 통한 리모팅 기술의 적용， 컴포넌트 단위의 배치，
JNDI를 통한 서비스 검색 지원， 서비스 오브젝트의 풀링， 컴포넌트 생명주기 관리 등은
EJB의 목표를 어느 정도 충족시켰다. 반면에 EJB 환경에서 동작하기 위해 특정 인터페
이스를 구현하고， 특정 클래스를 상속하고 서버에 종속적인 서비스를 통해서만 접근하
고시용이 가능하게 만드는등의 EJB 개발방식은잘못된 선택이었다. 애플리케이션 로
직을 담은 핵심 코드에서 일부 기술적인 코드가 제거된 건 사실이지만， 오히려 EJB라는
환경과 스펙에 종속되는 코드로 만들어져야 히는 더 큰 부담을 안게 됐다.
EJB는 결국 일부 기술적인 복잡함을 떨어주려는 시도를 하다가 오히려 더 큰 복잡함
을 추가하는 실수를 범했다. 가장 치명적인 건， EJB라는 틀 안에서 자바 코드를 만들게
강제함으로써 자바 언어가 원래 갖고 있던 장점마저 잃어버렸다는 사실이다. EJB
의 특
정 클래스를 상속하게 함으로써 더 이상 상속구조를 적용하지 못하게 만들거나， 다형성
적용을 근본적으로 제한한다거나 하는 것들이다. EJB는 결국 객체지향적인 특성은 잃
어버린 빗빗한 서비스 스크립트성 코드로 변질돼갔다. 별다른 장점은 없는데다 개발 방
식은 너무 불편했기 때문에 개발자에게 점점 외면당하는 신세가 돼버혔다.


물론 스프링이 처음 등장했을 때의 EJB와는 달리， 그 후에 등장한 EJB는 훨씬 개선
되긴 했지만 여전히 서버환경에 의존적인 기능을요구하는등의 단점이 남아 있는데다，
한번 인식이 나빠진 이후로는 개발자에게 점차 외면되고 있는 것이 현실이다. 게다가
EJB
의 발전주기는 너무 느려서 엔터프라이즈 개발 기술의 발전을 따라잡지 못하는 것
도문제점이다.

비침투적인 방식을 통한 효과적인 해결책: 스프링
스프링은 EJB의 실패를 교훈으로 삼아서 출발했다. EJB의 처음 목표와 마찬가지로 기
술적인 복잡함을 애플리케이션 핵심 로직의 복잡함에서 제거하는 데 목표를 뒀다. 하지
만 그 과정에서 EJB
처럼 개발자의 코드에 난입해서 지저분하고 복잡한 코드를 만들어
버리는 실수를 하지는 않았다. EJB
처럼 어떤 기술을 적용했을 때 그 기술과 관련된 코
드나 규약 등이 코드에 등장한 경우를 침투적인InvaSlve 기술이라고 한다. 물론 꼭 필
요한 기능을 사용해야 하기 때문에 특정 기술의 API를 이용하게 되는 건 어쩔 수 없다.
그런데 꼭필요한기능을사용히는것도아니면서 단지 어떤 기술을바탕으로만들어진
다고 해서 특정 클래스나 인터페이스 API 등의 코드에 마구 등장한다면 그것은 침투적
인 기술이 되며 복잡함을가중시키는원인이 된다.
반면에 비침투적인non--lnvaSlve 기술은 기술의 적용 사실이 코드에 직접 반영되지 않
는다는 특징이 있다. 어딘가에는 기술의 적용에 따라 필요한 작업을 해줘야 하겠지만，
애플리케이션 묘드 여기저기에 불쑥 등장하거나， 묘드의 설계와 구현 방식을 제한하지
는 않는다는 게 비침투적인 기술의 특정이다.
스프링이 성공할 수 있었던 비결은 바로 비침투적인 기술이라는 전략을 택했기 때문
이다. 스프링을 이용하면 기술적인 복잡함과 비즈니스 로직을 다루는 코드를 깔끔하게
분리할 수 있다. 중요한 점은 그 과정에서 스프링 스스로가 애플리케이션 코드에 불필
요하게 나타나지 않도록 히는 것이다. 꼭 펼요할 것 같은 경우조차도 기술 코드가 직접
노출되지 않도록 만들어췄다.
결괴는 성공적이었다. 물론 스프링을 적용한다고 해서 근본적인 복잡함의 원인이 사
라진 건 아니다. 하지만 스프링을 통해 성격이 다른 복잡함들을 깔끔하게 분리해줬기
때문에 각각을 효과적으로 상대할 수 있는 기반이 마련됐다. 동시에 스프링이 묘드에
불필요하게 등장해서 부가적인 복잡함을 가져오지도 않았다. 이러한 전략 덕분에 많은
프로젝트를 실패로 몰아가고 비효율적인 개발로 개발자를 고생시켰던 문제를 공략할
수있게 된것이다.

8징-스프링이란 무엇인가? 727


8.2.3 복짙떻}을 상대하는 스프링의 전략
스프링의 기본적인 전략은 비즈니스 로직을 담은 애플리케이션 코드와 엔터프라이즈
기술을 처리하는 코드를 분리시키는 것이다. 이 분리를 통해 두 가지 복잡함의 문제를
효과적으로 공략하게 해준다.

기술적 복잡함을 상대하는 전략

기술적인 복잡함을 분리해서 생각하면 그것을 효과적으로 상대할 수 있는 적절한 전략

을 발견할 수 있다. 스프링은 엔터프라이즈 기술을 적용했을 때 발생하는 복잡합의 문

제를 두 가지로 분류하고 각각에 대한 적절한 대응 방법을 제공한다.

• 첫 번째 문저1: 기슐에 대한 접근 방식이 일관성이 없고， 륙정 환경에 종속적이다
환경이 바뀌고， 서벼가 바뀌고， 적용되는 조건이 바뀌면 적용하는 기술이 달라지고 그
에 따라 묘드도 바뀐다는 건 심각한 문제다. 비록 동일한 목적으로 만들어졌지만 API
의 시용 방법이 다르고， 접근 방식이 다른 기술이 난립하는 것이 현실이다. 그래서 목
적이 유사하지만 호환이 안 되는 표준 비표준， 오픈소스 상용 제품 등。
l 제공뺨 각
기 다른
API를사용하도록코드를 일일이 변경해야하는번거로움이 발생한다.
이렇게 일관성 없는 기술과 서버환경의 변화에 대한 스프링의 공략 방법은 바로

서비스 추상화다. 앞에서 살펴봤던 트랜잭션 추상화나 OXM 추상화， 데이터 액세스

에 관한 일관된 예외변환 기능， 데이터 액세스 기술에 독립적으로 적용 가능한 트랜
잭션 동기화 기법 등이 그런 대표적인 예다. 기술적인 복잡함은 일단 추상화를 통해
로우레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고， 환경과 세부
기술에 독립적인 접근 인터페이스를 제공히는 것이 가장 좋은 해결책이다.

때론 자바메일과 같이 해당 기술을 사용히는 묘드의 테스트를 어렵게 만드틴잘못
설계된)
. 그럼에도 표준으로 먹 하니 자리 잡은 기술에 대해서도 서비스 추상회를 적용
할 필요가 있다. 이를 통해 태스트 편의성을 증대시키고 기술에 대한 세부 설정과 환
경으로부터 독립적인 묘드를 만들 수 있다.

데이터 액세스 예외에 대한 추상회는 비즈니스 로직을 담은 서비스 레이어의 코
드가 특정 기술이 발생시키는 예외에 종속되지 않고 불필요하게 예외를 집。}야 하
거나 throws를 선언해야 히는 것을 방지해준다.

스프링이 제공히는 탬플릿/콜백 패턴은 판에 박힌 반복적인 작업 흐름과 API 사
용 코드를 제거해준다. 이를 통해 기술을 사용히는 코드도 최적화된 핵심 로직에만
집중하도록도외준다.


• 두 번째 문제: 기술적인 처리를 담등F하는 코드가 성격이 다른 쿄드에 섞여서 등장흔}다
앞에서도 살펴봤듯이 비즈니스 로직 전후로 경계가 설정돼야 하는 트랜잭션， 비즈니
스 로직에 대한 보안 적용， 계층 사이에 주고받는 데이터와 예외의 일괄 변환이나 로
깅이나 감λj-a
udit 기능 등이 대표적인 예다. 책임에 따라 계층을 구분하고 그 사이에
서로의 기술과 특성에 의존적인 인터페이스나 예외처리 등을 최대한 제거한다고 할
지라도 근본적으로 엔터프라이즈 서비스를 적용하는 한 이런 문제는 쉽게 해결할 수
없다. 이런 기술과 비즈니스 로직의 흔재로 발생하는 복잡함을 해결하기 위한 스프링

의 접근 방법은 바로 AOP다.

AOP는 최후까지 애플리케이션 로직을 담당하는 묘드에 남아 있는 기술 관련 코
드를 깔끔하게 분리해서 별도의 모률로 관리하게 해주는 강력한 기술이다. AOP를
적용하지 않았을 때는 기술과 비즈니스 로직이 지저분하게 얽혀서 다루기 힘들다는
문제도 있지만， 기술적인 코드가 여기저기 중복돼서 나타난다는 것도 심각한 문제점
이다. 이 때문에 기술적인 작업을 처리히는 방식이 변경될 경우 많은 곳을 수정해야
한다. AOP는 기술을 다루는 코드로 인한 복잡함이 기술 그 자체 이상으로 불필요하
게 증대되지 않도록 도외주는 가장 강력한 수단이다.

비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
기술적인 코드， 침투적인 기술이 가져온 불필요한 흔적 등을 제거하고 나면 순수하게
애플리케이션의 주요 기능과 비즈니스 로직을 담은 코드만 독립적으로 존재하게 된다.
이 중에서 기술적인 부분과 느슨하게나마 연관되는 데이터 처리 코드나 웹이나 리모트
인터페이스 코드 등을 제외하면 비즈니스 로직 코드를 다루는 코드가 남는다. 비즈니스
로직을 담은 코드는 애플리케이션에서 가장 중요한 핵심이 되는 부분이다. 또한 업무의
변화에 따라 자주 변경되거나 수정되는 부분이기도 하다. 따라서 대체로 복잡하다. 자
주 바뀌는 업무 정책， 비즈니스 규칙， 업무 흐름을 담고 있을 뿐만 아니라 복잡한 데이
터를 분석하고 그에 따른 작업을 수행하고， 클라이언트가 필요한 결과를 만들어내야 하
기도 한다. 기술적인 부분이나 사용자 인터페이스에 관한 오류가 발생했을 경우에는 시
스템을 복구하거나 빠르게 대응해주면 당장에 큰 문제가 발생하지는 않는다. 반면에 비
즈니스 로직을 다루는 핵심 묘드에 오류가 있으면 엔터프라이즈 시스댐을 사용하는 업
무 자체에 큰 지장을 주거나 치명적인 손실을 끼칠 수도 있다.
증권사의 거래 사이트가 사용자가 늘어났지만 확장성이 떨어져서 가끔 서비스가 느
려지는 문제라면 시스탱을 리셋하든 서벼를 증설하든 어떻게든 대응을 하면 된다. 기

8장-스프링이란 무엇인가? 729


술적인 문제도 방치할 수는 없지만 대부분은 심각한 상황까지 가지는 않는다. 반면에
비즈니스 로직에 오류가 발생하면 엄청난 사고로 이어질 수 있다. 증권사 사이트를 통
해 주식거래를 분명히 완료했는데도 실제로는 체결이 되지 않았다거나 계좌의 잔액이
이유도 없이 줄어든다면 어떻게 될까? 아마 당징}에 성난 고객들이 몰려와서 난동을 부
리고， 자칫하면 회사 문을 닫이야 할지도 모른다
.

그래서 비즈니스 로직은 가장 중요하게 다뤄져야 하고 가장 많이 신경 써야 한다. 예
전에는 비즈니스 로직의 상당 부분을 DB에 두는 것이 유행이었다.SQL을 통해 비즈니
스 로직을 표현하고，
DB에서 동작하는 저장 프로시저를 통해 핵심 로직을 처리하는 경

우도 많았다. 하지만 엔터프라이즈 시스댐의 규모가 커지고 복잡함이 증가하면서 DB

에 비즈니스 로직을 두는 건 매우 불편할뿐더러 위험한 일이라고 여겨지기 시작했다.
가장 확장하기 힘들고 확장하더라도 많은 비용이 드는 공유 자원인 DB에 커다란 부담
을 주는 것도 문제고， 데이터 액세스를 중심으로 로직을 다루면 개발과 유지보수는 물
론이고 태스트도 매우 어렵다.

따라서 엔터프라이즈 시스댐 개발의 흐름은 점차로 비즈니스 로직은 애플리케이션
안에서 처리하도록 만드는 추세다.DB는 단지 데이터의 영구적인 저장과 복잡한 조건
을 가진 검색과 같은 자체적으로 특화된 기능에만 활용하고， 데이터를 분석하고 가공하
고 그에 따라 로직을 처리하는 부분은 확장하기 쉽고， 비용도 싼 애플라케이션 서버 쪽
으로 이동하는 것이다. 오브젝트에 담긴 로직은 테스트하기도 쉽다. 목 오브젝트 둥을
이용하면 심지어 DB
가 없어도 테스트를 할 수 있다. 게다가 CBD를 비롯한 최신 설계
와 개발 기법， 모댈링을 중심으로 한 개발 방법은 오브젝트 기반의 설계와 구현에 잘 들
어맞는다.

자바는 객체지향 언어의 장점을 잘 살려서 설계된 언어다. 객체지향 프로그래밍 기
법과 언어가 주는 장점인 유연한 설계가 가능하고 재사용성이 높다는 점을 잘 활용하면
자주 바뀌고 조건이 까다로운 비즈니스 로직을 효과적으로 구현해낼 수 있다. 객체지향
분석과 설계OOAD를 통해서 작성된 모댈을 묘드로 구현하고 지속적으로 발전시킬 수도
있다.

환경에 종속적인 기술과 침투적인 기법으로 인해 추가된 군더더기에 빙빼만 받지 않
는다면 객체지향 언어로서의 장점을 잘 살려 비즈니스 로직의 복잡함을 최대한 효과적
으로 다룰 수 있는 깔끔한 코드를 만드는 건 어렵지 않다.

물론 이 영역은 스프링조차 관여하지 않는다. 비침투적인 기술인 스프링은 핵심 로
직을 다루는 묘드에는 (특별한 이유가 없다연) 스프링의 흔적조차 찾을 수 없을 만큼 자신을


드러내지 않는다. 다만 뒤에서 비즈니스 로직을 담당히는 오브젝트들에게 적절한 엔터
프라이즈 기술 서비스가 제공되도록 은밀히 도외줄 뿐이다.

결국 비즈니스 로직의 복잡함을 상대하는 전략은 자바라는 객체지향 기술 그 자체
다. 스프링은 단지 객체지향 언어의 장점을 제대로 살리지 못하게 방해했던 요소를 제
거하도록도와줄뿐이다.

핵심 도구: 객체지향과 DI
기술과 비즈니스 로직의 복잡함을 해결하는 데 스프링이 공통적으로 사용하는 도구가
있다. 바로 객체지행O이다. 스프링 개발자는 자바 엔터프라이즈 기술의 가장 큰 장점
은 바로 객체지향 설계와 프로그래밍을 가능하게 해주는 자바 언어라고 생각했다. 그런
데 EJB 등이 등장해서 자바 언어의 객체지향 프로그래밍의 장점을 취하지 못하게 하면
서， 특정 기술의 스펙에 종속된 설계 방식을 강요했다는 점에 불만을 가졌다.
스프링의 모토는 결국 “기본으로 돌아가자”이다. 자바의 기본인 객체지향에 충실한
설계가 가능하도록 단순한 오브젝트로 개발할 수 있고 객체지향의 설계 기법을 잘 적
용할 수 있는 구조를 만들기 위해 01 같은 유용한 기술을 편하게 적용하도록 도외주는
것이 스프링의 기본 전략이다.
지금까지 살펴봤듯이 기술적인 복잡함을 효과적으로 다루게 해주는 기법은 모두 01
를 바탕으로 하고 있다. 서비스 추상화 랩플릿/콜백， AOP와 같은 스프링의 기술은 01
없이는 존재할 수 없는 것들이다.
그리고 01는 객체지향 설계 기술이 없이는 그 존재의미가 없다. 1
장에서 살펴봤듯이
01란 특별한 기술이라기보다는 유연하게 확장할 수 있는 오브젝트 설계를 하다 보면 자
연스럽게 적용하게 되는 객체지향 프로그래밍 기법일 뿐이다. 스프링은 단지 그것을 더
욱 편하고 쉽게 사용하도록 도외줄 뿐이다.
객체지향 언어를 쓴다고 해서 자연스럽게 객체지향 설계가 되고 객체지향 프로그래
밍을 할 수 있는 것은 아니다. 그래서 많은 개발자는， 심지어는 EJB
의 설계자와 같은 세
계적인 전문가도 그 가치를 놓칠 때가 있다. 그런 면에서 01는 자연스럽게 객체지향적
인 설계와 개발로 이꿀어주는 좋은 동반자다.01가 자연스럽게 확장성이 좋은 설계로 이
끄는 과정을 생각해보자.01를 의식하다 보면 오브젝트를 설계할 때 자주 01를 적용할
후보가 더 이상 없을까를 생각해보게 된다. 여기서 바뀔 수 있는 것은 무엇일까? 여기서
성격이 다르고， 변경의 이유가 다른 기능은 무엇일까? 그리고 그런 후보를 찾을 수 있다
면 01를 적용해서 오브젝트를 분리하고 인터페이스를 도입하고，
01로 관계를 연결해줄

8장-스프링이란 무엇인가? 731


것이다. 결국 Dl는 좋은 오브젝트 설계의 결과물이기도 하지만， 반대로 Dl를 열심히 적
용하다 보면 객체지향 설계의 원칙을 잘 따르고 그 장점을 살린 설계가 나올 수도 있다.

그런 변에서 객체지향과 Dl는 서로 떼놓고는 생각할 수 없다. 만약 스프링을 시용하
고 Dl를 적용했다고 하지만， 기계적인 방법으로 항상 사용하는 틀에 박힌 구조의 빈만
정의하고 나머지 묘드에는 Dl를 적용해볼 생각조차 안 한다면 Dl를 잘못 사용하고 있
는것이다.

기술적인 복잡함을 해결하는 문제나 기술적인 복잡함이 비즈니스 로직에 침범하지
못하도록 분리히는 경우에도 Dl가 바탕이 된 여러 가지 기법이 활용된다. 반면에 비즈
니스 로직 자체의 복잡함을 해결하려면 Dl보다는 객체지향 설계 기법이 더 중요하다.
왜 스프링이 힘들게 비즈니스 로직 자체를 기술적인 묘드와 특정 기술의 스펙이 침범하
지 않는 코드로 만들어주는 데 그토록 힘을 썼을까 생각해보자. 단지 코드가 좀 더 단순
해지고 명확해지기 때문만이 아니다. 그보다는 순수한 비즈니스 로직만을 담고 있는 코
드에는 객체지향 분석과 설계에서 나온 도메인 모델을 쉽게 적용할 수 있기 때문이다.
객체지향적인 특성을 잘 살린 설계는 상속과 다형성， 위임을 포함해서 많은 객체지향
디자인 패턴과 설계 기법이 잘 녹아들어 갈 수 있다. 기술적인 묘드에 침범당하지 않았
다면 이런 설계를 비즈니스 로직을 구현하는 코드에 그대로 반영할 수 있다. 그래서 객
체지향 기술의 장점을 최대한 활용해서 복잡하고 지주 변하는 업무를 지원하는 시스랩
을 만들 때도 손쉽게 대응이 가능해지는 것이다.

결국 모든 스프링의 기술과 전략은 객체지향이라는 자바 언어가 가진 강력한 도구를
극대화해서 사용할 수 있도록 돕는 것이라고 볼 수 있다. 스프링은 단지 거들 뿐이다.
현장의 업무를 잘 지원하고 유연하게 대응할 수 있는 뛰어난 애플리케이션을 만드는 것
은 객체지향을 잘 활용해서 복잡한 문제를 풀어나갈 줄 아는 개발자의 능력에 달려 있
다는 사실을 잊지 말아야 한다. 스프링만 잘 공부하면 자바 언어 자체나 객체지향 설계
와 개발 실력 따윈 별로 신경 쓰지 않아도 복잡한 엔터프라이즈 시스댐 개발을 잘할 수
있을거라고생각하면오산이다.

[ ~아O 프로그래밍 채|

스프링의 목적은 애플리케이션 개발의 복잡함을 줄여주는 것 또는 효과적으로 대응하
게 해주는 것이라고 하면 맞는 말이긴 하지만 좀 추상적이다. 좀 더 기술적으로 스프링
이 지향하는 목적이 무엇인지 정의해보자.

732


스프링의 핵심 개발지들이 함께 쓴 rprofessional Spring FrameworkJ라는 책이 있

다. 이 책에서 스프링 핵심 개발자들은 “스프링의 정수.essence는 엔터프라이즈 서비

스 기능을 POJO에 제공히는 것”이라고 했다. 엔터프라이즈 서비스라고 히는 것은 보

안， 트랜잭션과 같은 엔터프라이즈 시스템에서 요구되는 기술을 말한다. 이런 기술을

POJO에 제공한다는 말은 뒤집어 생각해보면 엔터프라이즈 서비스 기술과 POJO라는

애플리케이션 로직을 담은 묘드를 분리했다는 뭇이기도 하다. ‘분리됐지만 반드시 필요

한 엔터프라이즈 서비스 기술을 POJO 방식으로 개발된 애플리케이션 핵심 로직을 담

은 코드에 제공한다는 것이 스프링의 가장 강력한 특정과 목표다.

8.3.1 스프링의 핵심
:POJO
스프링의 핵심이 POJO 프로그래밍이라는 사실은 스프링의 핵심을 가장 나타내고 있
다고 알려진 그림 8-1의 스프링 삼각형을 통해서도 잘 알 수 있다. 이 그림은 스프링
소스의 CTO인 아드리안 콜리어
Adrian Colyer가 스프링의 핵심 개념을 설명하기 위해 만

들었다.

+

설계정보

PSA

그림 8-1 스프링 삼각형

그림 8-1
은 스프링으로 개발한 애플리케이션의 기본 구조를 보여준다. 스프링 애플리
케이션은 POJO를 이용해서 만든 애플리케이션 묘드와. POJO가 어떻게 관계를 맺고
동작하는지를 정의해놓은 설계정보로 구분된다.DI의 기본 。}이디어는 유연하게 확장
가능한 오브젝트를 만들어두고 그 관계는 외부에서 다이내믹하게 설정해준다는 것이
다. 이런 DI
의 개념을 애플리케이션 전반에 걸쳐 적용하는 것이 스프링의 프로그래밍
모델이다.

스프링의 주요 기술인 IoC/DI. AOP와 PSAPortable Service Abstraction는 애플리케이션
을 POJO로 개발할 수 있게 해주는 가능기술enabling technology이라고 불린다.

8gr-스프링이란 무엇인가? 733


8.3.2 POJO란 무엇인가?
스프링 애플리케이션 개발의 핵심인 POJO를 좀 더 자세히 알아보자. pOJO는 Plain
Old Java Object의 첫 글자를 따서 만든 약자다. 최근 몇 년간 자바에서 유행어처럼 사
용되고 있는 이 단어는 마틴 파울러
Ma미
n Fowler가 2000년에 컨퍼런스 발표를 준비하다
가 만들어낸 용어라고 한다. 그런데 POJO라는 용어를 만들어낸 이유가 재미있다. 마틴
파울러는 당시 인기를 꿀고 있던 EJB처럼 복잡하고 제한이 많은 기술을 샤용하는 것보
다는 자바의 단순한 오브젝트를 이용해 애플리케이션의 비즈니스 로직을 구현하는 편
이 낫다고 생각했다. 그럼에도 왜 개발지는 자바의 단순한 오브젝트를 사용하길 꺼리는
지 궁금했다. 그 이유를 찾아보니 평범한 자바오브젝트에는 EJB와 같은 그럴싸한 이름
이 없기 때문이었다. 그래서 뭔가 있어 보이도록 만든 이름이 바로 POJO
였다. 같은 설
명이지만 그냥 “간단한 자바오브젝트를 사용하는데요”라고 말히는 것보다는 “POJO 방
식의 기술을 사용합니다”라고 하면 핸지 세련되고 첨단기술을 쓰는 것처럼 느껴진다는
심리를 이용한 것이다. 펑범한 자바오브젝트에 멋진 이름을 붙여줬던 시도는 기대 이상

으로성공적이었다.

단지 POJO라는 폼 나는 이름 때문만은 아니겠지만， 아무튼 그 이후로 POJO 프로

그래밍에 관한 개발자들의 관심이 높아졌고 POJO를 지원한다는 걸 장점으로 내세우는

많은 프레임워크와 기술이 쏟아져 나오기 시작했다. 심지어 EJB조차 3.0에서는 기존의

문제점을 반성하고 POJO 프로그래밍의 장점을 적극 도입하려고 했다.

8.3.3 POJO의조건
그렇다면 이 POJO 프로그래밍이란 무엇인가? 그저 EJB를 사용하지 않으면 POJO
일
까? 특정 프레임워크의 클래스를 상속하지 않으면 POJO
일까? 단순하게 보자면 그냥
평범한 자바오브젝트라고 할 수 있지만 좀 더 명확하게 하자면 적어도 디음의 세 가지

조건을 충족해야 POJO라고 불릴 수 있다.

• 특정 규약contract에 종속되지 않는다
POJO는 자바 언어와 콕 필요한 API 외에는 종속되지 않아야 한다. 따라서 EJB2와
같이 특정 규약을 따라 비즈니스 컴포넌트를 만들어야 하는 경우는 POJO가 아니다.
스트렷츠 l
과 같이 특정 클래스를 상속해서 만들어야 하는 규약이 있는 경우도 마찬
가지다. 특정 규약을 따라 만들게 하는 경우는 대부분 규약에서 제시히는 특정 클래
스를 상속하도록 요구한다. 그럴 경우 자바의 단일 상속 제한 때문에 더 이상 해당


클래스에 객체지향적인 설계 기법을 적용하기가 어려워지는 문제가 생긴다. 또한 규

약이 적용된 환경에 종속적이 되기 때문에 다른 환경으로 이전이 힘들다는 문제점이

있다.

스트릿츠 l 의 ActionForm을 상속한 폼 정보를 담는 객체는 스트릿츠의 규약에 독
립적이어야 하는 서비스 레이어로 전달하기에 적합하지 않기 때문에 거의 비슷한 구
조를 가진 DTO를 만들어 복사해줘야 히는 번거로움이 있다. 당연히 객체지향적인
설계로 만든 POJO 도메인 모벨 오브젝트를 그대로 웹 레이어에서 사용할 수는 없
다. EJB 2 또한 비즈니스 컴포넌트가 EntityBean 클래스를 상속해야만 한다. 별다
른 가치를 주지도 못히는 규약 따위에 종속되지 않。바 하고， 객체지향 설계의 자유
로운 적용이 가능한 오브젝트여야만 POJO라고 불릴 수 있다.

• 특정 환경에 종속되지 않는다
특정 환경에 종속적이어야만 동작히는 오브젝트도 POJO라고 할 수 없다. EJB 3는
분명 이전 벼전의 문제점이던 규약에 따라 오브젝트를 만들어야 한다는 단점은 극복
했다. 어떤 면에서 POJO
에 가까운 설계와 구현이 가능해졌다. 하지만 여전히 JNDI
라는 서버 서비스를 필요로 한다. EJB 3 빈의 의존 오브젝트 정보는 JNDI를 통해
가져외야 하기 때문이다. 따라서 JNDI가 없는 환경에서는 그대로 시용하기가 힘들
다. 이렇게 JDNI와 같은 특정 환경이 의존 대상 검색 방식에 종속적이라면 POJO라
고할수없다.
어떤 경우는 특정 벤더의 서버나 특정 기업의 프레임워크 안에서만 동작 가능한
코드로 작성되기도 한다. 또 환경에 종속적인 클래스나 API를 직접 쓴 경우도 있다.
예들 들면 WebLogic 서버에서만 사용 가능한 API를 직접 쓴 코드를 갖고 있거나
특정 OS에서 제공하는 기능을 직접 호출하도록 만들어진 오브젝트 등이다. 이런 식
으로 순수한 애플리케이션 로직을 담고 있는 오브젝트 코드가 특정 환경에 종속되게
만드는 경우라면 그것 역시 POJO라고 할 수 없다. POJO는 환경에 독립적이어야
한다.

특히 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경정보나 웹 기술
을 담고 있는 클래스나 인터페이스를 사용해서는 안 된다. 설령 나중에는 웹 컨트
롤러와 연결돼서 사용될 것이 뻔하다고 할지라도 직접적으로 웹이라는 환경으로 제
한해버리는 오브젝트나 API
에 의존해선 안 된다. 그렇게 하면 웹 외의 클라이언트
가 사용하지 못하게 된다. 또 웹 서버에 올리지 않고 독립적으로 테스트하기도 힘
들어진다. 기술적인 내용을 담은 웹정보가 비즈니스 로직과 얽혀 있으니 이해하기

8장-스프링이란 무엇인가? 735


도 힘들고 수정하기도 어렵다. 비즈니스 로직을 담은 코드에 HttpServletRequest
나
HttpSession, 캐시와 관련된 API가 등장하거나 웹 프레임워크의 클래스를 직접 이
용히는 부분이 있다면 그것은 진정한 POJO라고 볼 수 없다.

요즘은 소스코드에 직접 메타정보를 추가해주는 애노테이션을 많이 시용한다. 그
렇다면 애노태이션을 시용했을 경우에는 POJO일까 아닐까? 이전에 XML에 담겨
있던 설정정보를 자바 코드로 가져왔으니 이는 POJO가 아니라고 할지 모르겠지만
목 그런 건 아니다. 애노테이션이 단지 코드로 표현하기는 적절치 않은 부가적인 정
보를 담고 있고， 그 때문에 환경에 종속되지만 않는다면 여전히 POJO라고 할 수 있
다. 하지만 애노태이션이나 엘리먼트 값에 특정 기술과 환경에 종속적인 정보를 담
고 있다면 그때는 POJO로서의 가치를 잃어버린다고 할 수 있다.

그럼 특정 기술규약과 환경에 종속되지 않으면 모두 POJO라고 말할 수 있는가?
많은 개발자가 크게 오해히는 것 중의 하나가 바로 이것이다. 그저 명범한 자바 클래
스를 써서 개발했다고 해서 POJO 방식으로 개발했다고 생각한다. 단지 자바의 문법
을 지키고， 순순하게 JavaSE API만을 사용했다고 해서 그 코드를 POJO라고 할 수
는 없다. POJO는 객체지향적인 자바 언어의 기본에 충실하게 만들어져야 하기 때문
이다. 그것이 POJO라는 이름을 붙이면서까지 단순한 자바오브젝트에 집착히는 이
유다. 자바는 객체지향 프로그래밍을 가능하게 해주는 언어이지만， 자바 언어 문법
을 사용했다고 해서 자동으로 객체지향 프로그래밍과 객체지향 설계가 적용됐다고
볼수는없다.

책임과 역할이 각기 다른 코드를 한 클래스에 몰아넣어 덩치 큰 만능 클래스로 만
드는 경우， 재사용이 불가능할 정도로 다른 레이어와 영역의 코드와 강한 결합을 가
지고 만들어지는 경우， 상속과 다형성의 적용으로 처리하면 깔끔한 것을 if/switch
문이 기득 찬 길고 긴 메소드로 작성해놓은 경우라면 과연 그것이 객체지향적인 자
바오브젝트라고 할 수 있을지 의문이다. 그런 식으로 설계되고 개발된 오브젝트라면
단지 특정 기술과 환경에 종속적이지 않다고 해서 POJO라고 부르기는 힘들다.

진정한 POJO란 객체지향적인 원리에 충실하면서， 환경과 기술에 종속되지 않고 펼
요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트를 말한다. 그런 POJO에 애플리
케이션의 핵심 로직과 기능을 담아 설계하고 개발히는 방법을 POJO 프로그래밍이라고
할수있다.


8.3.4 Pα0의 장점
그렇다면 POJO 프로그래밍의 장점은 무엇인가? 바로 POJO가 될 수 있는 조건이 그대
로 POJO의 장점이 된다.
특정한 기술과 환경에 종속되지 않는 오브젝트는 그만큼 깔끔한 코드가 될 수 있다.
로우레벨의 기술과 환경에 종속적인 코드가 비즈니스 로직과 함께 섞여 나오는 것만몸
지저분하고 복잡한 코드도 없다. 그런 코드는 개발하기도 힘들고， 오류를 찾고 디버깅
하기는 더더욱 힘들다. 코드를 읽고 이해하기도 어려울뿐더러 검증이나 테스트 작성에
도 한계가 있으므로 유지보수는 큰 부담이 된다.
또 POJO로 개발된 코드는 자동화된 태스트에 매우 유리하다. 환경의 제약은 코드의
자동화된 태스트를 어렵게 한다. 컨테이너에서만 동작을 확인할 수 있는 EJB 2는 태스
트하려면 서버의 구동 및 빌드와 배치 과정까지 필요하다. 자동화된 테스트가 불가능한
건 아니지만 매우 복잡하고 번거로우므로 대부분 수동 태스트 방식을 선호한다. 간단한
코드 수정에도 빌드， 배치， 수동 확인이라는 번거로운 사이클을 따라 작업하기가 얼마
나 힘든지는 EJB 개발자들이 경험적으로 잘 알고 있다. 그에 반해 어떤 환경에도 종속
되지 않은 POJO 코드는 매우 유연한 방식으로 원하는 레벨에서 코드를 빠르고 명확하
게태스트할수있다.
객체지향적인 설계를 자유롭게 적용할 수 있다는 것도 큰 장점이다. 개발자들이 자
바와 객체지향 프로그래밍， 모델링과 설계에 대해 배울 때 그려봤던 도메인 모댈과， 오
랜 경험을 통해 쌓여온 재활용 가능한 설계 모댈인 디자인 패턴 등은 POJO가 아니고
는 적용하기 힘들다. 로드 존슨은 특정 기술과 규약， 환경보다 자바 언어와 객체지향 기
술이 더 중요하다는 사실을 끊임없이 강조했다. 그저 로드 존슨이 객체지향 기술의 광
적인 땐이기 때문일까? 아니다. 로드 존슨은 대규모 자바 엔터프라이즈 시스템을 개발
해온 수많은 경험을 통해 자바 언어의 객체지향적인 설계와 구현 방식이야말로 그 어떤
새로운 기술과 환경， 툴보다 더 실제 프로젝트를 성공시키는 데 중요한 요소임을 알고
있기 때문이다.
객체지향 프로그래밍은 지금까지 나온 프로그래밍 패러다임 중에서 가장 성공했고，
가장 많은 언어에 적용됐으며， 무엇보다도 엔터프라이즈 시스뱀에서와 같이 복잡한 문
제 도메인을 가진 곳에서 가장 효과적으로 사용될 수 있다는 사실이 이미 오랜 시간을
통해증명됐다.
그렇다면 왜 이런 장점이 있는 POJO 방식， 어쩌면 가장 기초적이라고 할 수 있는，
자바의 초기부터 애용되던 이러한 POJO를 이용한 개발 방식이 왜 EJB처럼 제약이 심

8장-스프링이란 무엇인가? 737


하고 특정 기술에 종속적인 코드를 강요하고 자바의 객체지향적인 특정을 무시해버리
는 기술에 밀려버렸던 것일까? 그것은 앞에서 살펴봤듯이 엔터프라이즈 시스템의 개발
이라는 복잡한 과제에 대해 잘못된 접근 방법을 선택했기 때문이다.

8.3.5 POJO 프레임워크
스프링은 POJO를 이용한 엔터프라이즈 애플리케이션 개발을 목적으로 하는 프레임워
크라고 했다. pOJO 프로그래밍이 가능하도록 기술적인 기반을 제공히는 프레임워크를
POJO 프레임워크라고 한다. 스프링 프레임워크와 하이버네이트를 대표적인 POJO 프
레임워크로 꼽을 수 있다. 주로 DB 이용 기술에 POJO를 적용히는 것을 목적으로 하는
하이버네이트와 달리， 스프링은 엔터프라이즈 애플리케이션 개발의 모든 영역과 계층
에서 POJO 방식의 구현이 가능하게 하려는 목적으로 만들어졌다.
스프링을 이용하면 POJO 프로그래밍의 장점을 그대로 살려서 엔터프라이즈 애플리
케이션의 핵심 로직을 객체지향적인 POJO를 기반으로 깔끔하게 구현하고， 동시에 엔
터프라이즈 환경의 각종 서비스와 기술적인 필요를 POJO 방식으로 만들어진 코드에
적용할수있다.
그림 8-2는 스프링이 엔터프라이즈 시스댐의 복잡함을 어떻게 다루는지를 보여준
다. 스프링은 비즈니스 로직의 복잡함과 엔터프라이즈 기술의 복잡함을 분리해서 구성
할 수 있게 도와준다. 하지만 자신은 기술영역에만 관여하지 비즈니스 로직을 담당하는
POJO에서는 모습을 감춘다. 데이터 액세스 로직이나 웹 UI 로직을 다룰 때만 최소한
의 방법으로 관여한다. pOJO 프레임워크로서 스프링은 자신을 직접 노출하지 않으면
서 애플리케이션을 POJO로 쉽게 개발할 수 있게 지원해준다.

팩월 팩월

비즈니스
맨터프라이즈 로직의 복잡항
애플리케이선

팩월 팩월

전체의 복잡힘

엔터프라이즈

ζ〉
ζ)ζ3


기슐의 복잡힘

스프링 프레임워크

그림 8-2 엔터프라이즈 개발의 복잡함을 상대하는 스프링 프레임워크와 POJO


이제 스프링이 어떤 목적으로 만들어졌고 스프링을 사용하면 개발자가 어떤 혜택을 누
릴 수 있는지 어느 정도 이해할 수 있을 것이다. 물론 객체지향적 POJO 프로그래밍을
어떻게 효과적으로 적용할지는 개발자에게 또 하나의 숙제이고 부담이다. 이를 위해 객
체지향 분석과 설계에 대한 지식을 습득하고 훈련해야 한다. 당연히 자바 언어와 JVM
플랫폼 그리고 JDK API
의 사용법도 잘 알。바 한다. 객체지향 기술의 선구자들이 잘
정리해놓은 디자인 패턴과 구현 패턴， 좀 더 나은 코드 구조를 만들기 위한 리팩토링 기
술또한펼요하다.

스프링을 사용한다고 해서 이런 부담이 줄어드는 건 아니다. 대신 스프링은 개발자
들이 복잡한 엔터프라이즈 기술보다는 이러한 객체지향적인 설계와 개발의 원리에 좀
더 집중할 수 있도록 기회를 준다. 동시에 스프링이 제공하는 기술과， 프레임워크 API
및 확장 포인트는 그것을 이용하는 코드가 자연스럽게 객체지향적인 설계원리를 따라
가도록 이꿀어주기도 한다. 좋은 코드와 좋은 프레임워크의 특정은 그것을 사용해서 만
들어지는 코드가 나쁜 코드가 되기 어렵다는 점이다. 스프링은 매우 자연스럽게 개발자
가좋은묘드를 만들게 해주는특별한 재주가 있다. 이게 바로 스프링이 전 세계적으로
그토록 많은 개발자에게 인정받고 인기를 누리는 이유다.

I~ 스프링의 기술 텔)

기술과 비즈니스 로직을 분리하고 POJO 방식의 애플리케이션 개발을 가능하게 한다
는 스프링의 목적을 쉽게 이루려면 스프링과 같은 POJO 프레임워크가 필요하다. 스
프링에는 POJO 프로그래밍을 손쉽게 할 수 있도록 지원하는 세 가지 가능기술enabling
technology을 제공한다. 앞서 살펴봤던 스프링 삼각형이라는 그림에 나와 있듯이， 엔터프
라이즈 개발에서 POJO 개발이 가능하려면 삼각형의 각 변을 이루고 있는 기술들이 뒷
받침돼야 한다
. 그 세 가지 기술은 바로 IoC/ DI , AOP, PSA
다.

이 세 가지 모두 스프링이 있기 이전에도 여러 가지 형태로 시도됐고 발전하고 있던
기술이었다. 사실은 객체지향의 설계와 개발원리를 잘 적용하다 보면 자연스럽게 만들
어지는 것이기도 하다. 다만 스프링은 그것을 통일성 있게， 더 세련된 방법으로， 자바
엔터프라이즈 개발의 전 영역에 걸쳐 효과적으로 적용될 수 있도록 프레임워크 형태로
제공하고있다.

어떤 개발자는 스프링을 단지 이런 기술을 제공하는 기술 프레임워크로 이해하기도
한다. 스프링은 IoC/DI 컨테이너라거나， AOP 툴이라거나 엔터프라이즈 서비스 추상

8장-스프링
01란 무엇인가? 739


화PSA를 제공해주는 프레임워크라는 식으로 이해한다는 뭇이다. 물론 틀린 얘기는 아니

지만 그렇게 스프링을 특정 기술을 지원해주는 단순한 프레임워크로 이해하면 스프링

의 목적과 가치를 놓치기 쉽다.

스프링의 기술들은 스프링 프레임워크가 만들어진 진정한 목표인 POJO 기반의 엔

터프라이즈 개발을 편리하게 해주는 도구일 뿐이다. 또 다른 관점에서 보자면 IoC/DI,

AOP, PSA라는 것 자체가 이미 스프링이 중요한 가치를 두는 객체지향의 원리를 충실

히 적용해서 나온 결과이기도 하다. 스프링은 엔터프라이즈 개발에 등장히는 다%댄f 기

술에 대해 이미 잘 만들어진 서비스 추상화 기능을 제공하고 있지만， 그렇다고 스프링

이 제공하는 PSA만 달랑 사용하고 말라는 뭇은 아니다. 스프링 사용자라면 스프링이

직접 제공하지 않는 기술에 대해서도 P
SA를 적용할 줄 알아야 한다. 그것이 스프링의

목적과 개발 철학에 부합히는 스프링의 사용법이다. 그래서 스프링의 기술들은 스프링

의 목적과 핵심 가치를 기준으로 살며보고 이해하는 것이 중요하다.

8.4.1 제어의 역전(loC)/ 의존관계 주입(미)
IoC/DI는 스프링의 가장 기본이 되는 기술이자 스프링의 핵심 개발 원칙이기도 하다.
나머지 두 가지 기술인 AOP와 PSA도 IoC/DI
에 바탕을 두고 있다.3대 기술은 아니지
만 자주 등장하는 탱플릿/콜백 패턴이 적용된 부분도 IoC/DI가 그 핵심 원리다. IoC/
DI의 기본 원리는 I장에서 충분히 살펴봤으니， 여기서는 IoC/DI의 활용 방법을 생각해
보자.
이런 질문을 해볼 수 있다. 왜 두 개의 오브젝트를 분리해서 만들고， 인터페이스를
두고 느슨하게 연결한 뒤， 실제 사용할 대상은 DI를 통해 외부에서 지정하는 것일까?
이렇게 DI 방식으로 히는 것이 그렇지 않은 경우， 즉 직접 자신이 사용할 오브젝트를
new 키워드로 생성해서 시용히는 강한 결합을 쓰는 방법보다 나은 점은 무엇일까?
가장 간단한 답변은 ‘유연한 확장이 가능하게 하기 위해서’라고 할 수 있다.
DI는 개
방 폐쇄 원칙
OCP이라는 객체지향 설계 원칙으로 잘 설명될 수 있다. 유연한 확장이라는
장점은 OCP의 ‘확^d'에는 열려 있다t개방)’에 해당한다.DI는 역시 OCP의 ‘변경에는 닫혀
있다t예쇄)’라는 말로도 설명이 가능하다. 폐쇄 관점에서 볼 때 장점은 ‘재사용이 가능하
다’라고볼수있다.
A→B라는 의존관계를 갖는 오브젝트 구조라고 생각해보자. 여기서 확장은 B가 자
유롭게 변경될 수 있음을 의미한다. 이는 B가 변경돼도 A는 아무런 영향을 받지 않고

그대로 유지 가능하다는 돗이기도 하다.
B 관점
에서는 유연한 확장이고 A 관점으로 보


자면 변경 없이 재사용이 기능하다고 볼 수 있는 것이다.8가 81，
82，
83로 구현 방법
이 바뀌어도 된다고 볼 수도 있고， 81 , 82, 83
처럼 의존 대상이 바뀌어도 A는 그대로
재사용이 가능하다고 볼 수도 있다.

DI의활용방법
개념적인 설명 말고 좀 더 구체적으로 01
의 활용 방식을 살펴보면서 그 장점을 생각해
보자.

-핵심기능의변경
01의 가장 대표적인 적용 방법은 바로 의존 대상의 구현을 바꾸는 것이다. 디자인 패
턴의 전략 패턴이 대표적인 예다.A→B 구조에서 A의 기능 일부를 B에게 위입한다
고 했을 때 B의 구현 방식을 펼요에 따라 통째로 81，
82，
83로 비꾸는 것이다.

예를 들어보면 서비스 오브젝트가 사용하는 DAO가 있다고 할 때， DAO의 구현
을 JD8C로 했다가， 그것을 lPA, 하이버네이트， JDO, i8atis 등으로 변경하는 것을
생각할 수 있다. 구현 방식을 통째로 바꾸는 것이다. 샤용짜 관리 서비스라고 보자면

샘자의 등급을 결정핸 정책을 담은 묘드를 m로 분리할 추 있다 만약 비즈니스

로직이 변경돼서 새로운 등급결정 정책을 적용해야 한다면，
01를 이용해 새로운 정
책을 담은 클래스로 통째로 변경해주면 된다.
이렇게 실제 의존히는 대상이 가진 핵심기능을 미 설정을 통해 변경하는 것이 대
표적인 01의 활용 방법이다. 하지만 이게 다는 아니다.

• 핵심기능의 동적인 변경
두 번째 활용 방법은 첫 번째랑 비슷하게 의존 오브젝트의 핵심기능 자체를 바꾸는
것이다. 하지만 일반적인 01를 이용한 변경 방법과는 달리， 동적으로 매번 다르게 변
경할 수 있다.
01도 기본적으로는 런타임 시에 동적으로 의존 오브젝트를 연결해주
는 것이긴 하지만， 일단 01 되고 나면 그 후로는 바뀌지 않는다. 즉 동적인 방식으로
연결되지만 한번 m
되면 바뀌지 않는 정적인 관계를 맺어주는 것이다.
하지만 01를 잘 활용하면 애플리케이션이 통작하는 중간에 그 의존 대상을 다이
내믹하게 변경할수 있다.

예를 들면 시용자의 등급에 따라서 다른 DataSource를 사용하게 만들 수도 있다.
DAO는 DataSource에 의존한다. DAO• DataSource 관계가 만들어진다. 그런데 이
를 DAO 하나가 여러 개의 DataSource에 의존하게 만들 수도 있다. 그리고 현재 접

8장」 스프링이란 무엇인가? 741


속한 사용자의 등급에 따라서 그때그때 다른 DataSource를 OAO가 사용하게 할 수
도 있다. VIP 사용자는 좀 더 속도가 빠른 OB를 이용하게 해서 빠른 처리 속도를 보
장해주려고 할 때 적용할 수 있는 기법이다. 물론 DAO를 따로 만들 펼요는 없다. 대
신 매우 지능적인 방식으로 동작하는 01 덕분에 선택적으로 사용할 Data
S
our
c
e를
바꿔주는 기법이 가능하다.

또 다른 예를생각해보면 사용자별로 모두독립적인 의존오브젝트를두게 만들수
도 있다. 한번 로그인한 사용자는 로그아웃하거나 다른 브라우저로 다시 들어오기 전
에는 계속 자신만의 오브젝트를 유지하게 하고 서비스 오브젝트가 이를 미 받아서 사
용하게 할 수 있다. 이때는 핵심기능이 바뀐다기보다는 기능은 같지만 독립적인 상태
정보를 저장할 수 있는 자신만의 오브젝트를 가질 수 있다는 뭇이다. 매번 요청이 있
을 때마다 새로운 오브젝트가 필요하다변 new
를 이용해 새로 만들어도 그만이겠지만，
한번 로그인한 사용자에게는 계속 같은 오브젝트가 적용되려면 01를 이용하는 이 방
식이가장편리하다.

동적인 방식으로 핵심기능을 변경하는 건， 기술적으로 보자면 다이내믹 라우팅
프록시나 프록시 오브젝트 기법을 활용한 것이다. 그런 기법을 적용할 수 있었던 이
유는 역시 01가 있기 때문이다.01 없이는 불가능하다.
01의 원칙은 여전히 지켜지
므로확장과
재사용이라는장점은손상되지 않고오히려 더 가치를드러낸다.

• 부가기능의추가
01의 세 번째 활용 방법은 핵심기능은 그대로 둔 채로 부가기능을 추가하는 것이다.
데코레이터 패턴을 생각해보면 된다. 인터페이스를 두고 사용하게 하고， 실제 사용
할 오브젝트는 외부에서 주입하는 01를 적용해두면 데묘레이터 패턴을 쉽게 적용할
수 있다. 그래서 핵심기능과 클라이언트 묘드에는 전혀 영향을 주지 않으면서 부가
적인 기능을 얼마든지 추가할수 있다.
트랜잭션 기능을 부여했던 것이 그 대표적인 예다. 때로는 핵심기능은 그대로 둔
채로 결과나 전달 파라미터를 조작할 수도 있고， 파라미터나 리턴 결괴를 활용해 로
깅이나 보안 처리 같은 부가적인 작업을 수행할 수도 있다. 부가기능이라기보다는
부가작업이라고본다면 이벤트 발생 작업의 추가같은 것도생각해볼수 있다. 부가
기능의 추가 방식을 특정 오브젝트가 아니라 좀 더 많은 대상으로 일반화해서 적용
하면
AOP가된다.

부가기능을 추가할 수 있는 것도 바로 01 덕분이다.
01 구조로 만들어놨기 때문
에 가능한 것이며 01의 핵심 원칙인 OCP에도 충실하게 잘 들어맞는다.OCP가 말


하는 확장에 열려 있다는 것은 전략 패턴에서처럼 핵심기능을 변경해서 쓰는 수준만
을말히는게아님을기억해야한다.

• 인터페이스의변경
때로는 사용하려고 하는 오브젝트가 가진 인터페이스가 클라이언트와 호환되지 않
는 경우가 있다. 또는 여러 종류의 인터페이스를 가졌지만 사실은 비슷한 기능을 담
당하는 오브젝트를 바꿔가면서 사용하고 싶을 때도 있다. 이렇게 클라이언트가 사용
하는 인터페이스와 실제 오브젝트 사이에 인터페이스가 일치하지 않는 경우에도 01
가유용하다.
A가 C 오브젝트를 사용하려 한다고 해보자. 하지만 A는 원래 B 인터페이스를 사
용하도록 만들어져 있고 C는 B 인터페이스를 구현하지 않았다. 이때 A가 01를 통
해 B
의 구현 오브젝트를 받도록 만들어져 있다면 B 인터페이스를 구현했으면서 내
부에서 C를 호출해주는 기능을 가진 어랩터 오브젝트를 만들어 A에 01 해주변 된다.
220V 전기를 원히는 9V, 6V, 12V 식으로 바꿔주는 어랩터처럼， 인터페이스가 다
른 오브젝트를 클라이언트가 사용히는 인터페이스로 바꿔주는 기능을 이용하면 되
는 것이다.A→B
(c로 위임)----+c처럼 구성된다. 여전히 A는 01 덕분에 자신의 코드를
수정하지 않아도 된다. 이처럼 인터페이스가 일치하지 않는 호출이 필요한 경우에도
01는 유용하다. 디자인 패턴에서 말하는 오브젝트 방식의 어랩터 패턴의 응용이라고
볼수있다.

이를 좀 더 일반화해서 。때 인터페이스가 다른 다OJ=한 구현을 같은 방식으로 사
용하도록， 중간에 인터페이스 어랩터 역할을 해주는 레이어를 하나 추가하는 방법도
있다.01의 응용 방법 중 하나이자 스프링의 대표적인 기술로도 분류되는 일관성 있
는 서비스 추상회PSA가 그런 방법이다. PSA는 클라이언트가 일관성 있게 사용할 수
있는 인터페이스를 정의해주고 01를 통해 어랩터 역할을 하는 오브젝트를 이용하게
해준다. 이를 통해서 다른 인터페이스를 가진 로우레벨의 기술을 변경하거나 확장해
가면서 사용할수 있는 것이다.

·프록시

프록시 패턴의 전형적인 응용 방법도 있다. 필요한 시점에서 실제 사용할 오브젝트
를 초기화하고 리소스를 준비하게 해주는 지연된 로딩
lazy loading을 적용하려면 프록
시가 필요하다. 원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사
용할 수 있게 해주는 원격 프록시를 적용하려고 할 때도 프록시가 펼요하다. 두 가지
방법 모두
01를펼요로한다. 스프링은
EJB 원격 호출을포함해서 웹 서비스， REST

8εL 스프링이란 무엇인가? 743


호출， HTTP 방식의 호출 등 다양한 리모팅 기술을 지원한다. 당연히 모두 DI를 통
해이뤄진다.

• 템롤릿과콜백
댐플릿/콜백 패턴은 DI의 특별한 적용 방법이다. 반복적으로 등장하지만 항상 고정
적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 댐플릿과 콜백으로 만들
고 이를 DI 원리를 응용해 적용하면 지저분하게 매번 만들어야 히는 코드를 간결하게
만틀 수 있다. 스프링이 제공하는 20
여 가지의 템플릿/콜백이 적용된 기능을 가져다
활용히는 것뿐 아니라 펼요에 따라서는 01 원리를 따라 직접 응용할 수 있어야 한다.
콜백을 렘플릿에 주입하는 방식으로 동작하게 히는 것은 01
의 원리에 가장 충실한 응
용 방법이다. 콜백을 얼마든지 만들어서 사용할 수 있다는 건 개방을 통한 유연한 확
장성을 보여주는 것이며， 템플릿은 한 번 만들어두면 계속 재시용할 수 있다는 건 기
능의 확장에도 변하지 않는다는 OCP의 폐쇄 원칙에 가장 잘 들어맞는 것이다.
• 싱글톤과 오브젝트 스코프
DI가 펼요한 중요한 이유 중 한 가지는 DI 할 오브젝트의 생명주기를 제어할 수 있
다는 것이다.01를 프레임워크로 이용한다는 건 DI 대상 오브젝트를 컨테이너가 관
리한다는 의미다. 오브젝트의 생성부터 관계설정， 이용 소멸에 이므기까지의 모든
과정을 01 컨테이너가 주관하기 때문에 그 오브젝트의 스묘프를 자유롭게 제어할 수
있다.
가장 기본이 되는 스코프는 역시 싱글톤이다. 하나 또는 소수의 오브젝트가 수많
은 클라이언트를 상대로 고성능 서비스를 제공하는 방식은 엔터프라이즈 개발에서
매우 중요하다. 상태를 갖지 않도록 만든 오브젝트가 동시에 여러 스레드의 요청을
처리하는 이런 방식을 적용하려면 만들어지는 오브젝트의 개수를 제어히는 일이 매
우 중요하다. 전통적인 싱글톤 패턴은 오브젝트에 많은 제약을 가해서 만들어지기
때문에 그다지 권장되지 않는다. 그보다는 컨테이너가 오브젝트를 관리히는 IoC 방
식이 유용하다. 스프링의 DI는 기본적으로 싱글톤으로 오브젝트를 만들어서 사용하
게 한다. 컨테이너가 알아서 싱글톤을 만들고 관리하기 때문에 클래스 자체는 싱글
톤을 고려하지 않고 자유롭게 설계해도 된다는 장점이 있다.

때론 단일 싱글톤이 아니라 임의의 생명주기를 갖는 오브젝트가 필요할 때도 있
다. 스프링에서는 싱글톤 외에도 다OJ=한 스코프를 갖는 오브젝트를 만들어 DI
에 사
용할 수도 있다. HTTP 요청당 하나의 오브젝트가 만들어지거나， HTTP 세션당 하
나씩 오브젝트가 만들어지게 할 수 있다. 개발자 스스로 일정한 스묘프를 갖는 오브
젝트를 만들고 이를 DI에 적용하는 것도 가능하다.


이렇게 오브젝트 스코프를 제어히는 방법 또한 01를 적용했기 때문에 가능한 활
용방법이다.

• 테스트
마지막으로 살펴볼 DI
의 중요한 용도는 바로 테스트다. 여타 오브젝트와 협력해서
동작히는 오브젝트를 효과적으로 테스트하는 방법은 가능한 한 고립시키는 것이다.
즉 다른 오브젝트와의 사이에서 일어나는 일을 태스트를 위해 조작할 수 있도록 만
든다. 그래야만 테스트 대상인 오브젝트의 기능에 충실하게 태스트가 기능하다. 자
칫 다른 오브젝트와의 협 력을 통해 통작하는 기능을 다 허용하고 태스트하다가는 한
번에 수십 개의 오브젝트와 DB 환경까지 모두 테스트해야 하는 부담을 안을 수 있
다. 그래서 태스트할 대상이 의존하는 오브젝트를， 테스트를 목적으로 만들어진 목
오브젝트로 대체하면 유용하다. 복잡한 테스트 데이터가 준비되어 있어야 원히는 결
과를 가져올 수 있는 DAO를 시용히는 오브젝트가 있다고 해보자. DAO를 이용하
는 서비스 오브젝트를 태스트하기 위해서 DAO도 완벽하게 작성되어 있음을 먼저
확인해야 하고. DAO가 태스트를 위해 적합한 결괴를 돌려주도록， 필요한 테스트 데
이터까지 모두 준비해야 한다면 배보다 배꼽이 더 큰 일이 되기 십상이다. 정작 원하
는 것은 십여 줄밖에 안 되는 조건에 따라 다르게 동작하는 서비스 오브젝트 묘드인
데， 테스트를 준비하면서 DAO와 테스트 데이터 때문에 너무 많은 시간을 쏟아야 한
다면 곤란하다. 그래서는 테스트 만드는 게 짐이 되고 태스트를 사용하기가 점점 꺼
려질것이다.

그래서 의존 오브젝트를 대신해서 스럽 또는 목 오브젝트 같은 태스트 대역을 활
용해야 한다. 이때도 01는 중요한 역할을 한다.01를 위해 만든 수정자 메소드를 사
용하면 태스트 코드 안에서 수동으로 목 오브젝트를 주입할 수 있다. 또는 태스트용
으로 설정을 별도로 만드는 방법도 있다.
01 없이는 이런 태스트 기법을 적용하기란
불가능하다. 갈수록 태스트의 중요성이 커져가고 있으니 01
의 활용 방법에서 테스트
가 차지하는 비중도 커질 것이다.

그 외에도 01의 활용 방법은 다OJ=하다. 이 정도만 살펴봐도 런타임 시 유연하게 구
현을 비꿀 수 있다는 01라는 개념이 실전에서 얼마나 활용도가 다%댄지 알 수 있을 것
이다. 잘 살펴보면 DI의 용도는 디자인 패턴 중에서 오브젝트 합성 방식을 따르는 패턴
과관련이 있음을 알수 있다. GoF
의 디자인 패턴 중에서 인터페이스를두고 오브젝트
를 분리히는 구조를 가진 오브젝트 스코프의 패턴은 DI
의 구조에 대부분 잘 들어맞는
다. 그런 패턴의 장점들을 애플리케이션 전 영역에서 간단한 설정만으로 자연스럽게 적
용할 수 있게 만들어주는 것이 바로 DI다.

8장-스프링이란 무엇인가? 745


이런 활용 방법은 한 번에 한 가지만 선택적으로 시용해야 송}는 건 아니다. 여러 가
지 활용 방법을 한 번에 적용할 수도 있다. 예를 들변 하나의 DI 대^J-에 대해 핵심기능
도 업무 변화에 따라 바꾸면서， 부가기능도 여러 개 추가해넣고， 테스트에서도 활용하
는 식으로 사용해도 된다.

8.4.2 애스펙트 지향 프로그래밍(AOP)
애스펙트 지향 프로그래밍이라고 많이 알려진 AOP도 스프링의 3
대 가능기술의 하나

다. 계속해서 스프링은 객체지향 기술과 프로그래밍을 위해 존재하는 프레임워크라고

설명했는데， 난데없이 애스펙트 지향 프로그래밍이라는 새로운 프로그래밍 패러다임이

왜 펼요할까? 사실 애스펙트 지향 프로그래밍은 객체지향 프로그래밍OOP처럼 독립적인

프로그래밍 패러다임이 아니다. AOP와
OOP는서로배타적이 아니라는말이다.

객체지향 기술은 매우 성공적인 프로그래밍 방식임에 분명하다. 하지만 한편으로

는 점점 복햄R
져 가는 애플리케이션의 요구조건과 기술적인 난해함을 모두 해결하는

데 한계가 있기도 하다. AOP는 바로 이러한 객체지향 기술의 한계와 단점을 극복하도

록 도와주는 보조적인 프로그래밍 기술이다. AOP를 사용하면 그 결과로 OOP를 더욱

OOP답게 만들 수 있다. AOP는 90년대부터 연구됐고， 여러 가지 제품으로도 나왔지만

이를 가장 성공적으로 엔터프라이즈 개발에 보급한 것이 바로 스프링이다.

스프링의 목적인. POJO만으로 엔터프라이즈 애플리케이션을 개발하면서도 엔터

프라이
즈 서비스를 선언적으로 제공하는 데 반드시 필요한 것이 바로 이 AOP 기술이

다. IoC
/DI를 이용해서 POJO에 선언적인 엔터프라이즈 서비스를 제공할 수 있지만 일

부 서비스는 순수한 객체지향 기법만으로는 POJO의 조건을 유지한 채로 적용하기 힘

들다. 바로 이런 문제를 해결하기 위해 AOP가 펼요하다. 스프링의 AOP는 스프링이

POJO 프로그래밍을 지원하려는 그 핵심 목적을 위해 중요한 역할을 하고 있다.

AOP의적용기법
AOP를 자바 언어에 적용하는 기법은 크게 두 가지로 분류할 수 있다.

• 첫 번째는 스프링과 같이 다이내믹 프록시룰 사용하는 농법이다
이 방법은 기존 묘드에 영향을 주지 않고 부가기능을 적용하게 해주는 데코레이터
패턴을 응용한 것이다. 자바의 객체지향 패턴을 활용한 방법이기 때문에 만들기 쉽
고 적용하기 간펀하다. 대신 부가기능을 부여할 수 있는 곳은 메소드의 호출이 일어
나는지점뿐이라는제약이 있다. 인터페이스와
DI를활용하는데코레이터 패턴이 기


반원리이기 때문이다. 부가기능을 구현한 코드나 기능을 적용할 대상을 찾는 방법
모두 평범한 자바 클래스로 만들면 된다. 스프링의 기본적인 AOP 구현 방법은 다이
내믹 프록시를 이용하는 프록시 AOP 방식이다. 엔터프라이즈 개발에서 필요로 하
는 AOP는 대부분이 이 프록시 방식의 AOP
면 된다.

-두 번째는 자바 언어의 한겨|를 넘어서는 언어의 확장을 이용하는 방법이다
AspectJ라는 유명한 오픈소스 AOP 툴이 있다. 이 AspectJ는 강력한 고급 기능을 가

진 AOP를 제공한다. AspectJ는 프록시 방식의 AOP에서는 불가능한 다양한 조인
포인트를 제공한다. 메소드 호출뿐 아니라 인스턴스 생성
， 필드 액세스， 특정 호출
경로를 가진 메소드 호출 등에도 부가기능을 제공할 수 있다. 이런 고급 AOP 기능
을 적용하려면 자바 언어와 JDK의 지원만으로는 불가능하다. 그 대신 별도의 AOP

컴파일러를 이용한 빌드 과정을 거치거나， 클래스가 메모리로 로딩될 때 그 바이트
코드를 조작히는 위빙과 같은 별도의 방법을 이용해야 한다. 그만큼 사용하기 까다
롭고 번잡하지만 경우에 따라서는 프록시 방식의 AOP로는 할 수 없는 작업을 위해
AspectJ를 사용해야 한다.

스프링은 프록시 방식의 AOP를 기본으로 하고 있지만， 원한다면 AspectJ를 이용한
AOP로 바꿔서 시용할 수 있다. 스프링의 특별한 기능 중에는 Aspec
tJ를 꼭 사용해야
히는것도있다.

AOP의적용단계
AOP가 객체지향 개발 방법에서 기본 아이디어를 가져왔다고는 하지만 본격적으로 적
용하기에는 그 성격이 자바의 일반적인 개발 방법과는 상당히 다르기 때문에 제대로 적
용하려면 충분한 시간과 노력이 필요하다. 또 AOP
의 장점이 많다고 해서 무작정 사용
하면 심각한 문제가 발생할 위험이 있다. 개발자 개개인이 아무렇게나 AOP를 남발해
서 사용하다 보면 다른 개발자가 만든 코드가 예상하지 않은 방식으로 돌아가는 등의
혼란을 초래할 수 있기 때문이다. AOP는 하나의 모률이 수많은 오브젝트에 보이지 않
게 적용되기 때문에 매우 주의해서 사용해야 한다.
AOP
에 익숙하지 않은 상태라면 차근차근 단계를 밟아 AOP를 도입히는 접근 방법
이좋다.

• AOP 적용 1단겨1: 미리 준비된 AOP 이용
일단 처음에는 스프링이 미리 만들어서 제공히는 AOP 기능을 그대로 가져다 적용하
8장-스프링이란 무엇인가? 747


는 것으로 시작한다. 스프링이 직접 제공하는 대표적인 AOP는 바로 트랜잭션이다.
DB를 사용하는 애플리케이션이라면 트랜잭션이 필요할 테니 이 트랜잭션 적용을 스
프링 AOP 도입의 첫 번째 단계로 이용한다. AOP 설정을 통해서 트랜잭션이 어떻
게
많은 오브젝트에 투명하게 적용되는지 관찰해보고， AOP의 특성과 동작원리를 이해
해보자.

스프링에는 트랜잭션만큼 자주 사용되진 않지만 특정 아키텍처를 선택했을 때 사
용할 수 있도록 준비된 AOP 기능이 하나 더 있다. @Configurable 애노태이션을 이
용해서 도메인 오브젝트에 DI를 자동적용해주는 AOP 기능이다. 도메인 오브젝트를
전용 계층에 두고 접근하는 아키텍처 방식을 따를 때 반드시 필요하다. 프록시 AOP
면 충분한 트랜잭션과 달리， @Configurable을 위해서는 AspectJ를 이용한 AOP가
반드시필요하다.

이 두가지가스프링이 미리 준비해서 제공히는대표적인
AOP 기능이다. 두가지
모두 간단한 설정을 추가히는 것만으로도 쉽게 적용되기 때문에 AOP에 대한 지식이
나경험이 많지 않더라도간단히 이용가능하다는장점이 있다.

• AOP 적용 똥배1: 전담팀올 통한 정책 AOP 적용
다음 단계는 좀 더 적극적으로 AOP를 적용할 차례다. 아직까지는 개발자 개개인이
AOP 기능을 직접 이용하게 해서는 안 된다. 대신 애플리케이션 전체적으로 이용 가
능한 것을 소수의 AOP 담당자 관리하에 적용해볼 수 있다. 대표적으로 비즈니스 로
직을 가진 오브젝트에 대한 보안， 특정 계층의 오브젝트 이용 전후의 작업 기록을 남
기는로깅， 데이터 추적을위한트레이싱， 특정 구간의 실시간성능모니터링과같은

정책적으로 적용할 만한 기능에 AOP를 이용하는 것이다.

이런 기능을 개발자가 직접 자신이 만드는 묘드에 추가하려면， 개발 표준이나 가
이드라인이 미리 완벽하게 준비되어 있어서 이를 따라 개벌하게 해야 한다. 하지만
개발자가 실수로 빼
먹을 수도 있고， 가이드라인을 제대로 따르지 못하고 엉뚱하게
적용할 수도 있다. 더 큰 문제는 개발 정책이나 기준이 바뀌면 모든 개발자가 지금까
지 작업한 것을 모두 수정하고 일일이 검증해야 하는 큰 부담을 지게 된다. 하지만
이런 일을 AOP를 이용해 한 번에 적용한다면 일반 개발자의 작업에는 전혀 영향을
주지 않을 수 있다. AOP를 책임지는 소수의 팀만 수고하면 그만이다.

또한 AOP는 언제든지 기능을 추가하거나 제거할 수 있다. 기존 코드에는 당연히
아무런 영향을 주지 않으면서 말이다. 이런 특정을 잘 이용하면 운영 중에 필요한 기
능 외에 개발 가이드라인이나 표준을 따라서 코드가 작성되어 있는지를 검증하는 작


업을 AOP를 이용해 할 수 있다. 예를 들면 레이어 간의 호출에 대한 제한이 있다고
생각해보자. JSP 뷰에서는 DAO나 서비스 계층의 오브젝트를 직접 호출하면 안 된
다는 정책이 있다. 하지만 개발자는 곧잘 이런 기준을 무시하고 제멋대로 짜기 일쑤
다. 이런 것을코드 리뷰를통해 일일이 검증하기는쉽지 않다. 이럴 때 AOP가유용
하게 쓰일 수 있다. 모든 DAO의 메소드 호출에 적용되는 AOP 모률을 하나 만든다.
그리고 메소드 호출이 일어났을 때 어드바이스를 통해 호출 경로를 조사할 수 있다.
만약 서비스 계층 같은 허용된 계층으로부터의 호출이 아니라면 정책위반 예외를 던
지게 할 수 있다. 또 서비스 계층에서 던질 수 있는 예외의 종류가 정해져 있다고 해
보자. 그런데 개발자가 임의의 예외를 만들거나 선택해서 마구 사용할 수도 있다. 이
런 경우라면 서비스 계층의 메소드에 대해 예외가 던져졌을 때만 통작히는 AOP 모
률을 만들 수 있다. 그리고 그 안에서 예외의 종류를 검사해서 허용된 게 아니면 역
시 정책위반 예외를 만들어서 던지고 관리자에게 통보가 가도록 할 수 있다. 이렇게
AOP는 동적으로 동작하면서 개발 정책을 위반한 코드를 잡아내는 데도 유용하다.
물론 개발이 묻나고 실전에 적용할 때는 정책 검증을 위한 AOP 설정을 간단히 제거

해버리면된다.

• AOP 적용 3단겨I:AOP의 자유로운 이용
첫 번째와 두 번째 단계를 거쳐서 AOP
에 어느 정도 친숙해지고， 그 장단점과 응용
전략， 위험성 등을 어느 정도 이해했다면 이제는 개발자 스스로가 AOP를 활용할 수
있는 단계로 넘어갈 수 있다. 이전 단계에서는 애플리케이션 전체적으로 적용되는
정책 AOP를 위주로 했다면 이제는 개발자가 구현하는 기능에 적용하면 유용한 세부
적인 AOP를 이용할 수 있다. 큰 범위에 걸쳐서 적용되는 기능은 아니지만 한 모율
또는 특정 기능 안에서도 AOP로 분리하면 유용한 것들이 있다. 물론 다른 팀이나 개
발자가 만든 코드에 몰래 적용되는 AOP 기능은 만들어선 안 된다. 그런 위험만 주
의한다면 얼마든지 개발자가 자신이 다루는 코드에 AOP를 적극 활용할 수 있다.

8.4.3 포터블 서비스 추상화(PSA)
세 번째 가능기술은 환경과 세부 기술의 변회에 관계없이 일관된 방식으로 기술에 접근
할 수 있게 해주는 PSAPortable Service Abstraction다. POJO로 개발된 코드는 특정 환경이
나 구현 방식에 종속적이지 않O싸 한다. 스프링은 JavaEE를 기본 플랫폼으로 히는 자
바 엔터프라이즈 개발에 주로 사용된다. 따라서 다양한 JavaEE 기술에 의존적일 수밖에
없다. 특정 환경과 기술에 종속적이지 않다는 게 그런 기술을 사용하지 않는다는 뭇은

8장-스프링이란 무엇인가? 749


아니다. 다만 POJO 코드가 그런 기술에 직접 노출되어 만들어지지 않는다는 말이다. 이
를 위해 스프링이 제공히는 대표적인 기술이 바로 일관성 있는 서비스 추상화 기술이다.

스프링은 엔터프라이즈 개발에 사용되는 다양한 기술에 대한 서비스 추상화 기능을
제공한다. 어떤 것은 AOP나 템플릿/콜백 패턴과 결합돼서 시용되기 때문에 직접적으
로 서비스를 이용할 필요가 없다. 대신 설정을 통해 어떤 종류의 기술을 시용할지 지정
해줘야한다.

트랜잭션 서비스 추상회는 코드를 이용해 트랜잭션을 제어하지 않는다면 직접 이
용할 이유가 없다. 트랜잭션은 대부분 AOP를 이용해 적용하기 때문에 직접 코드
를 만들지 않기 때문이다. 대신 설정에서는 스프링의 트랜잭션 추상화 인터페이스인
PlatformTransactionManager를 구현한 구체적인 서비스 클래스를 빈으로 등록해줘야
한다. JTA를 이용해 트랜잭션을 적용하고 싶다변 J
t
aTransact
i
onManager를 빈으로 등
록하고 JTA 환경에 대한 설정을 프로퍼티로 넣어주면 된다.

직접 스프링이 제공하는 API를 사용해서 만드는 경우도 있다.OXMO]나 JavaMail
을 이용한다면 스프링이 정의한 추상 API를 이용해 묘드를 작성한다. 그리고 구체적인
기술과 설정은 XML 파일 안에서 지정한다.

스프링의 서비스 추상화의 개념과 장점을 잘 이해한다면 때에 따라 직접 서비스 추
상화 기법을 적용할 필요도 있다. 엔터프라이즈 개발에 사용되는 기술은 끊임없이 쏟
아져 나옹다. 표준 기술뿐 아니라 오픈소스 라이브러리， 상용 프레임워크 형태로도 하
루가 멀다 하고 새로운 기술이 등장한다. 보편적으로 사용되는 기술이라면 아마도 다음
버전의 스프링에서 서비스 추상화 대상으로 포함시킬 가능성이 있다. 하지만 그것을 굳
이 기다려야 할 이유는 없다. 필요하면 스프링이 그랬던 것처럼 직접 추상 레이어를 도
입하고 일관성 있는 API를 정의해서 사용하면 된다.

서비스 추상회를 위해 필요한 기술은 DI뿐이다. 결국 DI 응용 방법의 한 가지이므로
DI를 적극 활용해서 개발한다면 서비스 추상화는 자연스럽게 만들어 쓸 수 있다. 서비
스 추상회는 단지 구체적인 기술에 종속되지 않게 하기 위해서만 사용되는 건 아니다.
태스트가 어렵게 만들어진 AP
I나 설정을 통해 주요 기능을 외부에서 제어하게 만들고
싶을 때도 이용할 수 있다.


[ ~ 정리

8장에서는 스프링의 기본적인 정의와 그 목적 그리고 그것을 이루기 위해 제공히는 기

술을간략히살펴봤다.
스프링의 상세한 기술을 공부하기 전에 먼저 이해하고 기억해야 할 사항은 다음과

같다.

• 스프링은 그 개발철학과 목표를 분명히 이해하고 사용해야 한다
• 스프링은 오픈소스 소프트웨어이며， 애플리케이션 개발의 모든 기술과 영역을 종합적으로
다루는 애플리케이션 프레임워크다.
• 엔터프라이즈 애플리케이션 개발의 복잡함은 비즈니스 로직과 엔터프라이즈 시스템의 기술
적인 요구에 의해 발생한다 기존의 접근 방법은 이 복잡도를 낮추지 못하며 자바의 객체지
향적인 장점을 포기해야 한다는 문제점이 있다.
• 자바의 근본인 객체지향적인 원리에 충실하게 개발할 수 있으며， 환경과 규약에 의존적이지
않은 POJO를 이용한 애플리케이션 개발은 엔터프라이즈 시스댐 개발의 복잡함이 주는 많
은 문제를 해결할 수 있다.
• 스프링의 목적은 이
런 POJO를 이용해 엔터프라이즈 애플리케이션을 쉽고 효과적으로 개발
할 수 있도록 지원해주는 데 있다.
• POJO 방식의 개발을 돕기 위해 스프링은 IoC/Dl, AOP, PSA와 같은 가능기술을 프레임
워크와 컨테이너라는 방식을 통해 제공한다.
스프링이 어떻게 해서 엔터프라이즈 개발이 주는 복잡함을 제거하고， POJO 프로그
래밍이라는 효과적인 방법을 사용할 수 있게 하는지에 관심을 갖는 것이 스프링을 가장
빠르게 이해하고 적용할 수 있는 지름길이다.

8장-스프링이란 무엇인가? 751


9짱 스프렁프로젝트
시작하줬j

9장에서는 프링을 이용해 애플리케이션 프젝트를 처음 구성할 때 알。야 할 기

본적인 내용을 다룬다. 또， 스프링 개발에 도움이 되는 개발 툴과 빌드 방법도 살펴
볼 것이다. 마지막으로 스프링을 애플리케이션에 적용할 수 있는 아키텍처의 종류와 특
징에 대해서도 알아본다.

스프링은 어떤 종류의 애플리케이션에도 잘 들어맞도록 매우 유연하게 설계된 범용
프레임워크다. 그래서 아키텍처의 종류나 프로젝트를 구성하는 방법에 대한 자유도가
매우 높다. 그만큼 프로젝트 구성 방법이나 아키텍처를 선택할 때 주의를 기울일 필요
가 있다. 스프링이 유연하다고 해서 아무렇게나 가져다 쓰면 스프링이 주는 유익을 제
대로 얻지 못할수도 있기 때문이다.

f (!Ji] 자바 엔터프라01즈 플랫폼과 스프링 애플리케이션펙|

스프링으로 만들 수 있는 애플리케이션의 종류에는 제한이 없다. 자바 언어를 사용하는
모든 종류의 프로젝트라면 어디든 사용할 수 있다. 웹을 이용히는 자바 엔터프라이즈
시스템 개발에도 사용할 수 있고， 스원이나 이클립스 RCP로 만드는 독립형
standalone 프
로그램에도 적용 가능하다. 사용할 수 있는 기능에 제한이 있기는 하겠지만 애플릿이나
모바일 애플리케이션 개발에도 이용할 수 있다. 심지어 스프링을 핵심 엔진으로 사용하
는 엔터프라이즈 미들웨어 제품도 있다.

그러나 스프링의 탄생 배경이나 스프링이 주로 제공하는 기능의 목록을 봐도 알 수
있듯이， 스프링은 주로 자바 엔터프라이즈 환경에서 동작하는 애플리케이션을 개발하

9징-스프링 프로젝트 시작하기 753


는 목적으로 사용된다. 서버에서 동작히는 엔터프라이즈 애플리케이션을 제외한 다른

형태의 애플리케이션에 스프링을 제대로 적용하기 위해서는 SpringRCP 프로젝트나

Spring.ME 같은 추가적인 스프링 지원기술이 필요하다. 따라서 이 책에서는 자바 엔터

프라이즈 환경에서 사용되는 스프링 개발에 관한 내용만을 다룰 것이다.

자바 엔터프라이즈 애플리케이션은 서버에서 동작하며 클라이언트를 상대로 서비스

를 제공하도록 되어 있다. 즉 클라이언트의 요청을 받아서 그에 대한 작업을 수행하고

그 결과를 돌려주는 것이 기본적인 동작 방식이다. 하지만 클라이언트의 요청 없이도

정해진 시간이나 특정 이벤트 발생에 따라 독자적으로 작업을 수행하기도 한다.

9.1.1 클라이언트와 백엔드 시스템
엔터프라이즈 애플리케이션은 자신이 클라이언트가 돼서 또 다른 엔터프라이즈 시스템
에 서비스를 요청할 수도 있다. 또는 데이터베이스나 레거시 시스댐 같은 엔터프라이즈
정보 시스탱
EIS이라고 불리는 백엔드 시스템의 기능을 이용해 동작하기도 한다.
가장 많이 사용되는 구조는 클라이언트가 웹 브라우저이고 백엔드 시스템이 DB
인
구성이다. 간단히 ‘DB를 사용히는 웹 애플리케이션’이라고 한다. 웹 클라이언트와 DB
가 사용되지 않는 시스댐은 거의 없으니， 이를 스프링이 사용되는 애플리케이션의 기본
구조라고 생각할 수도 있다. 그런 변에서 스프링의 주요 기능은 웹 브라우저를 클라이
언트로 하고 DB
에 데이터를 저장， 조회하는 데 집중되어 있다.
그렇다고 해서 쪽 클라이언트는 웹 브라우저여야 하며 백엔드 시스렘은 DB를 이용
해야 송}는 것만은 아니다. 웹 브라우저에서 동작하기는 하지만， HTML을 사용하는 표
준 웹 클라이언트 외에도 Flex나 X 인터넷 제품처럼 독립적으로 강력한 기능을 가진
RIARich Internet Application 클라이 언트가 사용되기도 한다. 또는 HTTP 프로토콜을 이용
해 통신하는 다른 엔터프라이즈 시스렘일 때도 있다. 자바 서버가 받아들일 수 있는 방
식으로 요청을 보내기만 한다면 어떤 종류의 클라이언트이든 상관없다. 실제로 MS
의
.NET 애플리케이션도 스프링을 이용하는 클라이언트로 많이 사용된다. 하나의 스프링
애플리케이션이 동시에 여러 종류의 클라이언트를 상대로 서비스를 제공히는 경우도
흔하다.
스프링 엔터프라이즈 애플리케이션이 이용하는 백엔드 시스템으로는 DB는 물론이
고 메시정 서버， 메일 서버， 메인프레임도 가능하다. 자바가 제공하는 접속 방식을 지원
하는 시스템이면 된다. 웹 서비스를 제공하는 서버도 자주 사용된다. 원격 EJB 서버를
사용할 수도 있다. 당연히 한 번에 여러 종류의 백엔드 시스템을 이용할 수 있다. 여러
개의 DB를 동시에 이용히는 것도 가능하다.


그림 9-1
은 스프링이 엔터프라이즈 애플리케이션으로 사용되는 방식을 나타낸다.

웹 브라우저
/H
TML

RWFlex. X 인 터 넷
스프링 앤터프라이즈 애율리케이선

NET/Mobile/독 링형

XftJf ø 01흩i!/~이전 A.ftJf{JIν:4S)

엔터프라이츠 시스템

데이터베이스
메시징/메일 서버
레거시 시스템
엔터프라이즈 시스템
클라이g트 백
f!!!드 A./스텅

그림 9--1스프링 엔터프라01즈 애플리케이션의 서비스와 협력 구조

9.1.2 애플리케이션 서버
스프링으로 만든 애플리케이션을 자바 서버환경에 배포하려면 JavaEE
(또는
J2EE) 서버가
필요하다. JavaEE 표준을 따르는 애플리케이션 서버는 크게 두 가지로 구분할 수 있다.
하나는 JavaEE의 대부분의 표준 기술을 지원하고 다양한 형태의 모률로 배포가 가능
한 완전한 웹 애플리케이션 서버WAS이고， 다른 하나는 웹 모률의 배포만 기능한 경량급
WAS 또는 서블릿/JSP 컨테이너다.

• 경량급 WAS/서블릿 컨테이너
스프링은 기본적으로 톰켓Tomcat이나 제티
Jetty 같은 가벼운 서블릿 컨테이너만 있어
도 충분하다. EJB나 리소스 커넥터. WAS가 제공핸 분산 서비스 등이 굳이 필요
하지 않다면 서블릿 컨테이너로도 엔터프라이즈 애플리케이션에 필요한 핵심기능을
모두 이용할 수 있다. 기존에 EJB와 WAS를 사용해야 가능했던 선언적인 트랜잭션
이나 선언적 보안.DB 연결 풀링， 리모팅이나 웹 서비스는 물론이고 추가적인 라이
브리러의 도움을 받으면 분산/글로벌 트랜잭션까지도 가능하다.
• WAS
물론 고가의 WAS를 사용하면 그만를 장점이 있다. 성능 변에서는 대단히 낫지 않더
라도 미션 크리티컬한 시스뱀에서 요구하는 고도의 안정성이나 고성능 시스템에서
필수적인 안정적인 리소스 관리 레거시 시스템의 연동이나 기존 EJB로 개발된 모률
을 함께 사용동}는 등의 필요가 있다면 상용 또는 오푼소스 WAS를 이용할 수 있다.
또 WAS는 상대적으로 관리 기능이나 모니터링 기능이 뛰어나서 여러 대의 서버를

동시에 운영할 때 유리한 점이 많다.

9장-스프링 프로젝트 시ξh하기 755



무엇보다도 자바 엔터프라이즈 버전(JavaEE
) 표준을 최대한 활용할 수 있다. 스프링은

3.0 기준으로 J2EE 1
.4와 JavaEE 5.0에 완벽히 호환된다. 또 일부 JavaEE 6.0의
기능을 지원하기도 한다.
스프링의 개발팀은 펼요할 때는 비용을 들이더라도 적합한 조건을 가진 WAS를 사
용할 것을 권장한다. 스프링은 JavaEE와 배타적이라고 생각하는 사람들도 있는데 그
렇지 않다. 스프링은 JavaEE 표준 기술을 적극 지원하고 있다. 물론 WAS를 시용할 때
는 분명한 이유와 근거가 있는지 먼저 충분히 검토해야 한다. 훨씬 가볍고 빠르며 저렴
한 비용으로 사용할 수 있는 서블릿 컨테이너로도 대개는 충분한데 특별한 이유도 없
이 무겁고 다루기 힘든데다 비싸기까지 한 WAS를 사용할 필요는 없기 때문이다.

스프링소스 tcServer

실제로 개발환경과 운영환경에서 가장 많이 사용되는 자바 서버는 웹 모률만 지원히는

서블릿 컨테이너인 아파치 톰켓이다. 스프링을 개발을 책임지고 있는 기업인 스프링소

스에는 아파치 프로젝트인 HTTPD 서버와 톰켓의 핵심 개발자들이 포진해 있다. 톰켓

전문가인 이들이 중심이 돼서 톰켓을 기반으로 엔터프라이즈 스프링 애플리케이션에

최적화된 경량급 애플리케이션 서버인 tcServer를 개발했다. tcSeπer를 이용하면 기존

톰켓에서는 아쉬웠던 고급 서버 관리 기능 배포 기능과 진단 기능을 포함해서 톰켓 전

문가에게 받는 기술지원도 함께 제공받을 수 있다. 대부분의 기능은 사용하지도 않을

고급 WAS를 구매히는 데 비싼 비용을 들이기는 부담스럽고， 그렇다고 운영하고 관리

하기 불편한데다 펼요할 때 기술지원도 받을 길이 없는 오픈소스 제품인 톰켓을 그대로

시용하기는 불안하다면 tcServer가 좋은 대안이다. tcServer의 가장 큰 장점은 스프링

개발회사가 개발하는 것인 만큼 스프링 애플리케이션 개발과 운영에 목 펼요한 중요한

기능이 많이 제공된다는 점이다. tcSeπer는 개발자 버전이 따로 있어서 개발을 위해서

라면 자유롭게 이용 기능하다. 정식 운영서버에서 사용하고 기술지원을 받으려면 유료

로 라이선스를 구매해야 한다.

9.1.3 스프링 애플리케이션의 배포 단위
스프링으로 만든 애플리케이션은 다음의 세 가지 단위로 배포할 수 있다.

·독립웹모률
스프링은 보통 war로 패키정된 독립 웹 모률로 배포된다. 톰켓 같은 서블릿 컨테이
너를 쓴다면 독립 웹 모률이 유일한 방법이다. WAS로 배포한다고 하더라도 독립 웹
모률을 사용하는 경우가 대부분일 것이다. EJB 모률을 함께 사용한다거나 여러 개의
웹 모률을 묶어서 하나의 웹 애플리케이션 모률로 만들지 않는 한 독립 웹 모률이 가
장 단순하고 편리한 배포 단위다.

• 엔터프라이즈 애풀리케이션
경우에 따라선 확장자가 ear~ 엔터프라이즈 애플리케이션으로 패키정해서 배포할
수도 있다. 스프링 애플리케이션에서 EJB 모률을 긴밀하게 사용하거나 반대로 EJB
모률에서 스프링으로 만든 애플리케이션을 이용해야 한다면， EJB와 스프링 웹 모률
을 엔터프라이즈 애플리케이션으로 통합해야 한다
. 때로는 EJB 모률은 없지만 엔터
프라이즈 애플리케이션 배포 방식을 선택하는 경우가 있다. 하나 이상의 웹 모률과
별도로 분리된 공유 기능한 스프링 컨텍스트를 엔터프라이즈 애플리케이션으로 묶
어주는방법이다.
• 백그리운드서비스모둘
이 두 가지 방법 외에도 J2
EEl
，4에서 등장한 rar 패커정 방법도 있다. rar는 리소스
커넥터를 만들어 배포할 때 사용하는 방식인데， 만약 스프링으로 만든 애플리케이션
이 UI를 가질 필요는 없고 서벼 내에서 백그라운드 서비스처럼 동작할 필요가 있다
면 rar 모률로 만들어서 배포할 수 있다. 이때는 J2
EEl
，4나 그 이상의 표준을 따르
는 WAS가 반드시 필요하다.
운영 플랫폼이나 서버의 종류는 개발 중에라도 언제든지 필요에 따라 변경이 가능하
다. 어차피 서플릿 컨테이너나 웹 모률 모두 JavaEE 표준의 일부일 뿐이기 때문에 설
정만바꾸면 어렵지 않게 이전이 가능하다. 다만특정 서버환경에서만제공하는기능을
시용한다면 변경이 힘들 수도 있다. 장기적으로 서버를 변경하거나 서버의 종류를 비꿀
가능성이 있다면， 서버의 기능에 종속되지 않도록 주의하거나 손쉽게 다른 서벼의 기능
으로 변경 기능하도록 추상화해서 사용해야 한다.

9징-스프링 므로잭트 시작하기 757


I~ 개발도구와 환경 l

9.2.1 JavaSE오. JavaEE
JavaSE/JDK
스프링 3.0은 JavaSE 5 버전에서 추가된 새로운 언어와 문법의 특정을 최대한 활용해
서 개발됐기 때문에 기본적으로 JDK 5.0 또는 그 이상을 필요로 한다. 또 일부 기능은
JDK 6.0의 API를 이용해 개발된 것도 있다. 예를 들어 JDBC 4.0의 새로운 API를 사
용히는 스프링의 기능이 필요하다면 JDK 6.0을 써야 한다. 스프링 3.0 이전에는 JDK

5.0 이싱벼l
서 사용할 수 있는 최적화된 기능을 별도의 모률로 제공했었다. 하지만 이제
는 JDK 5.0
이 기본이 됐으므로 스프링 모률에서 그런 구분 자체가 사라졌다.
특별한 상황이 아니라면 이미 씬SUN에서 공식지원을 종료해서 그 수명이 다한 JDK

1
.4나 그 이전 환경을 고집할 이유는 없다. 아직도 JDK 1
.4
.2
에 머물고 있다면 스프링
3.0을 사용하기 위해서라도 JDK 5.0이나 그 이후 버전으로 업그레이드해야 한다.
JavaEE/J2EE
스프링 3.0
이 사용될 자바 엔터프라이즈 플랫폼으로는 J2EE 1.4 버전이나 JavaEE 5.0
이 펼요하다. 스프링 3.0 자체는 JDK 6.0과 JavaEE 5.0을 기준으로 개발됐지만 주요
기능은 JDK 5.0
에서 동작하는 J2EE1 .4 버전과 호환되게 제작되어 있다.
다만 J2EE 1.4 버전 서버를 사용할 때는 JDK 5.0에서 동작하는지 반드시 확인해
야 한다. 만약 WAS 자체가 JDK 5.0에서는 사용할 수 없다면 스프링 3.0의 이용은 불
가능하다. 상용 WAS 중에서 WebLogic 9이나 WebSphere 6.1 같은 서버는 J2EE 1.4
서버이긴 하지만 JDK 5.0에서 사용할 수 있는 것이다. 따라서 스프링 3.0의 적용이 가
능하다.

9.2.2 IDE
스프링 애플리케이션은 자바 5 또는 그 이상의 언어를 지원하는 자바 개발도구와 스키
마를 지원히는 XML 편집기 정도만 있다면 어떤 개발환경에서는 불편 없이 개발이 가
능하다. 여기에 ANT나 Maven 같은 빌드 물을 지원하고 톰켓이나 자바 서버로 바로 배
포해서 실행해볼 수 있는 환경이라면 더할 나위 없을 것이다.

예전에는 텍스트 에디터와 명령행 도구를 이용해서 복잡한 EJB 애플리케이션까지

758


개발하던 시절도 있었지만 요즘은 대부분 개발 툴을 떠나지 않고도 개발 과정에서 필요

한모든 일을 처리할수 있도록 만들어진 통합개발환경
IDE을 사용하는추세다.

90% 이상의 사용률을 기록하며 사실상 자바의 표준 IDE로 여겨지는 이클립스를 비

롯해서 씬에서 직접 만들어서 제공하고 있는 넷빈즈 상용 자바 개발 툴 중 가장 오랫동

안 안정적인 사용자층을 확보하고 있는 Intell iJ IDEA 등이 대표적인 IDE로 꼽힌다. 최

근에는 상용 제품이었던 IntelliJ IDEA도 주요한 기능을 모아 커뮤니티 버전을 만들고

이를 오픈소스로 공개하기도 했다. 이렇게 대표적인 자바 IDE가 모두 무료로 사용할 수

있고 확장성도 뛰어난 오픈소스 제품이라는 건 대단한 일이다.

이 세 가지 IDE 모두 자바 엔터프라이즈 개발을 지원하며 스프링 개발을 편하게 도

외주는 스프링 지원 기능도 갖고 있다. 따라서 이 중에서 편하고 익숙한 IDE를 골라서

사용하면된다.

9.2.3 SpringSoruce Tool Suite
스프링 애플리케이션 개발을 위한 IDE로 이클립스를 선택했다면， 스프링 개발업체인
스프링소스가 직접 만들어 제공하는 이클립스의 확장판인 SpringSource Tool Suite
(보
통
STS라고 쁨다)의 사용을 고려해보자.

STS는 최신 이클립스를 기반으로 주요한 스프링 지원 플러그인과 관련 도구를 모

아서 스프링 개발에 최적화되도록 만들어진 IDE
다. 이클립스와 같이 플러그인 방식을

지원하는 툴을 사용하면 원히는 기능을 필요에 따라 추가할 수 있다는 장점이 었다. 반

면에 각 플러그인과 이클립스의 버전을 호환되도록 계속 관리해야 하는 불편한 점도

있다.

요즘은 플러그인 업그레이드 버전이나 이클립스의 새로운 서비스 팩이 몇 달에 한

번씩 등장을 하고， 새로운 기능을 가진 플러그인도 자주 쏟아져 나오니 그때마다 플러

그인 조합을 새로 해서 IDE 구성을 변경할 필요가 있다. 그런데 매번 플러그인의 호환

성을 검증하는 건 만만한 일이 아니다. 업그레이드한 플러그인이 기존에 설치된 여타

플러그인과 함께 사용이 불가능해서 다시 되돌려야 하거나， 플러그인 하나를 업그레이

드하려고 하면 이에 의존하고 있는 여타 플러그인도 함께 업그레이드해줘야 하는 등의

번거로운 플러그인 의존성 관리에 시달릴 수밖에 없다. 자칫 버전이 잘 맞지 않으면 이

클립스가 오작동할 수도 있다.

스프링 개발을 직접 지원하거나 도움이 되는 관련 이클립스 플러그인의 종류는 제법

많다. 이런 플러그인들을 이클립스 기본 버전에 추가해서 사용해도 상관없다. 하지만

g앙-스프링 프로젝트 시ξh하기 759


매번 시행착오를 거쳐가며 플러그인 버전 호환성 문제를 직접 확인하고 해결해야 하는
부담을
안이야한다.

그렇기 때문에 스프링소스가 제공하는， 플러그인 조합이 완료된 STS를 사용히는 편
이 여러모로 유리하다. 스프링 팀이 매번 베타 버전 RC 버전을 거쳐가면서 플러그인의
호환성 문제나 버전 이슈를 충분히 검증해주기 때문에 STS 정식 버전은 안심하고 가져
다 바로 사용할 수 있다. STS는 이클립스의 최신 버전과 이전 버전에 대해서 윈도우，
맥， 리녹스용으로 만들어진 설치 프로그랩을 제공해준다.

그림 9-2는 STS의 설치화면이다. STS 설치 프로그랩은 톰켓을 확장해서 만든
SpringSource tc Server를 포함해서 스프링 개발에 유용한 몇 가지 서 버와 툴도 함
께 설치할 수 있게 해준다. STS 설치 프로그램은 http: //www.springsource.com/
products/sts에서 받으면 된다.

• tj1RmIiA=-'!11i1i!&1J’깐만밴
l
시t
l! I~J I히l
Select Installation Packages

Step 4 of 8 Adlvl혀。n 0' VMware

‘’
F핸!~

Select the packs you want to Install:
Note: Grayed packs are required.

l.
~
_miiiiMiiiiI.연........,_.•••••를..
딘 SpringSource dm Server 1.0,2,SR02
딘 SpringSource tc Server 6,0,20,C
~ Spring Roo 1,0,0,AC2
딘 Grails 1,2,0,M3

IIU뻐••1염

26, 04 MB
25, 01 MB
1, 65 MB
57, 46 MB

Description
Installs SpnngSource Tool Suke 2. 2. 0.AELEASE

299,$ MB
1뻐.
47 GB

“ .. -αP_
.
h에.:II~
。매

딘헌괜그 |댁월J[프관그

그림 9-2 STS 설치화면

그림 9-3은 STS를 띄우면 처음에 만날 수 있는 대시보드 화면이다. 대시보드에는
스프링과 관련 프레입워크에 대한 튜토리얼， 스프링 개발팀이 작성한 스프링 블로그，
최신 뉴스， 웹에서 진행되는 세미나(웨비나)나 교육정보 최신 다운로드 링크 등이 나와
있다. 유용한 정보가 자주 업데이트되는 만큼 정기적으로 내용을 확인해보면 도움이
된다.


f)1, ξd~ 퍼·애，110 S,.rch f'찌.
ct Ilun )!tIndow Ijelp
i
[j
.~~힐 i~ i.'O. g. .q. . i
~~.
(6. i~
~
a-a#
'
~ 용흩효김
i~
•힐. <.:> <>.~
.

" 11

이 I Sprl때ISoUrce T 001 Sulte l Se3 tch spring
so
u
κe.co
m | 댐
Ts ~ .._._--• •-


1'-'’ TutoñãIs l훨J
~ ‘한P센nξ 擬 11 "

SpringSource 8109

þ Introduc‘lon to OS61 • Double Webinar Wednesday
~ Spring+Tomcat and Spring+Flash 를

Thi,Wødnud. y fø
ι
uru11 dout.μ'ø htllpinp 01 wlIbinttr!J 101' Ihø

Sprlng Dynamlc Modules '0' OSG’“m) Runtimes ’., ....


’(• ) • dm Server 2.0.0,M6 (09. 10.27 by 8en Hale)

Sprlng Frame‘ ork

• Sprlng Securlty
dm SøfVtlr 2. O. O.Mtf ;5 now "~"J시aα， .써 c." bø downloadtld , 11 s
• SpringOne 2G X뼈 -Wrap-up (어 10. 23 by Adam Frtzgerald: 11 p
SρringOntl 2GX 2009 wrepped up witlt 111α)olJ1~"/
~53i，α'" 1'-8p,
ln9 Web F’ow • SpringOne 2G X 2OCI9 -Day Two Aeport (09. 10. 22 bv Adam Fit
Þ Sprlng Web Servlces Thtll"n/，，~
ι
5f1
5~∞" continvtld on 1ft" 5
t1
ζ‘"，d dtty 0/Spd""•

Þ Sprlng Web
•

• Inηoducing tc Se,...er Developer Edition -with Spring Insight (α
W""rt1
ιlI"oud
l
o
α'UI!nt 1ft. Sp’αg 따꺼mν'nity with 11 ,.,øw 100.

홈uzz ξ Wøbîn ars a-ndP니
bìiëatlons-'Oc. Oö wñlòads • 、
녕?

• •

텀
The Ultimale Enlerprise Ja...a Build Sol. IISprlngSource Ic Server Whitepaper 톰 뻐S이ng Web Flow 2.0.8 Aeleased
Enlørpfl!JtI JIWII 8vι'd RtIftlrenctl Afζ'hJi
lll Thi!J papør
ιlFovidtl
!J IIn αtJfviø .... o!
lhð.
‘mα‘
/I!Jtldlo IInnαJnCtl Ihlll thtl Sp
Iü) Gralls 'IS Rails vs Django --Grails 써「톨 톨
M때tlng Enterprise Ap
pllc때
ons 10 S~톨 &밑ì!
NowAyaa
l
abb
1
e: 끼…얘
띠
댄
Too

셰쩌’’셰끼히메;J띠셔
비
Spαpri
19S0
uωrπc
e

삐벼
rin
뼈。미’ Sui
훨옳Uz
a:S
pmgF
m
rkTkTTu

헤띠”띠뼈빼뼈뼈빼배셔빼뼈뼈빼

때
빼뼈뼈뼈뼈뼈쩌뼈’씨
뼈떼셰
Groo
J
a. 찌
디디11
띠끼

G
ra허떼a
11，닝s. 뼈Y\I
. 씨.，얘
뼈ann
d Web ~O따c뼈l뻐IìS
p
g-AM
ge(s Oller이
ew iilSpring.NET 1.3. 0ACI Released
Enjoyed Spring Tomcat Seminar 꺼 (야) wh(때) AtlfNJP(배) tI(an) r(때) d(앤) tl!JC(a) (얘) (n) ，ηibø
!J thtl cortl t닝 w. ’re pløtl!Jtld 10 IInnounCtl Ihtll Spri

’(m)

Yu/ørdlly, J....øn/ 10 Ihø Spri끼rgTomζ
Iiì Sprlng In Produc이
on 밑
SprÎn
g Aoo 1. 0.0.ACI Released
텀
Security Ad'li
so
깨 Sun JDK 1. 5 and S~ 톨
Current An alysis In
-d
eαh Report on 81 Spnj깨
R∞ 1 O. O.flC1 htl!J now bøøn r,
Sprirψ
Sou끼cø hll!J i!J!J‘Itld tl !J
tl
CU，
톨
Burton Group Report 밑
Spring In앤
gr떼on 1. 0.3 Released

끼ν "

멍
Sp빼Sωrce Ac Qulres Hype띠 to Unif /al Com찌’
tlnl
/lfVfI닝...，ζh αtl
lVitl .... Sp..1 1
11，깨 쩌lI!Jød 10 tlnnouncø Ihtll Ihe S.μ
’‘ i J ’‘--_. ’ •. !!!J ‘。
ι~~
.. ~"
A_ iA .n ~‘~ ... ~I n:ll C'
A":~~ n ‘Io. A_ I nn。‘ι-“
..’

T .. :.-t:: _A :l A

Oashboard IKnowtedge 8..11 Ex’ensklnsl Cor에gur해on
’

i 0‘ U;o-I!!llt~

그림 9-3 STS 대시보드

STS
에는 이클립스의 기본 설치 버전에는 없는 스프링 개발지원 플러그인들이 기본적
으로 포함되어 있다. 이런 플러그인의 지원 기능에 대해 알아보자.

SpringlDE 플러그인
SpringIDE는 스프링 개발에 유용한 기능을 제공히는 플러그인의 모음이다. 스프링 프
로젝트와 설정파일 생성 위저드， 펀리한 스프링의 XML 설정따일 에디터， 빈의 의존관
계 그래프， 네임스페이스 관리 기능 등의 펀리한 기능과 도구를 제공한다.
XML 설정파일을 사용했을 때 가장 불편한 점은 빈의 클래스 이름이나 레퍼런스 이
름을 입력하면서 오타가 발생하기 쉽다는 것이다. 빈의 클래스 이름은 패키지를 포함해
서 전체 클래스 이름을 입력
해야 하기 때문에 번거롭다. 하지만 SpringIDE가 제공하는

XML 설정파일 에디터를 이용하면 클래스 이름이나 참조하는 빈의 이름을 실시간으로

검증해서 오류를 확인해주기 때문에 오타로 인한 에러의 위험을 사전에 방지해준다.

그뿐 아니라 클래스 이름이나 프로퍼티 이름을 자바 편집기 내의 자동완성 기능과
비슷하게 찾을 수 있게 해줘서 매우 편리하다. SpringIDE
의 XML 에디터의 자동완성
기능 몇 가지를 살펴보자.

9징-스프링 프로젝트 시작하기 761



• 빈 클래스 01름 자동완성
가장 유용한 건 bean 태그의 class 애트리뷰트를 입력할 때 클래스 이름에 대
한 자동완성을 지원한다는 것이다. 자바 펀집기에서 클래스 이름을 입력할 때
와 거의 비슷하다고 보면 된다. 이름이 org.springframework.jdbc.datasource.
SimpleDriverDataSource
인 클래스를 빈으로 등록해야 한다고 생각해보자. 패키지
이름과 클래스 이름을 다 기억하고 이를 입력한다는 건 불가능할 태고， 아마도 API
문서를 열거나 관련 자료를 참고해서 패키지와 클래스 이름을 복사해서 붙여야 할
것이다.
Spring
lD
E
의 자동완성 기능을 이용하면 이런 긴 클래스 이름도 간단하게 입

력할 수 있다. 클래스 이름인 SimpleDriverDataSource의 각 단어 첫 글자를 따서
SDDS라고 입력하고 다퍼+댈줄행힘 키를 함께 눌러주면 된다. 그러면 현재 프로
젝트의 모든 소스와 라어브러리. JDK 안의 모든 클래스 중에서 첫 글자가 SDDS
인 클래스 목록을 보여준다. 그림 9-4는 SDDS로 시작히는 클래스를 자동으로 보
여주는 화면이다. 만약 SDDS로 시작하는 클래스가 SimpleDriverDataSource뿐이
었으면 이렇게 선택창이 뜨는 대신 바로 org.springframework.jdbc.datasource.
SimpleDriverDataSource 전체가 입 력됐을 것이다. 클래스 후보가 두 개 나왔으니
그중에서 SimpleDriverDataSource를 선택해주변 된다. 그러면 패키지 이름을 포함

해 클래스 이름이 정확히 입력된다.

an id-"dataSource" class-’SDDS

i:SDDocumentSour야 순om.suiüiiiil.lrr빼al.
Wl.ápl빼빼F
(i SimpleDriYerDataSource -org
.s
pringfr하nework.
jdb
c~-datasource
그림 9-4 SpringlDE의 클래스 이룡 자동완성 기능

클래스 이름이 길 때는 이렇게 단어의 첫 글자를 입력히는 방법이 유용하다. 이름이
길지 않거나 여러 단어로 되어 있지 않다면 클래스 이름 앞부분을 몇 글자 입력하고
자동완성 기능을 이용해도 된다. SpringD 정도 입력하고 다퍼+
1꿇줄행힘를 눌러도
쉽게 SimpleDriverDataSource 클래스 이름을 찾을 수 있다.

빈의 프로퍼티를 등록할 때도 자동완성 기능은 유용하다. 프로떠티 이름도 자
주 오타가 나는 부분이다. 수정자를 가진 클래스라면 다음과 같이 property 태
그의 name 부분에서 아무것도 입력하지 않은 채로 다퍼+
1꿇략행려를 눌러주면 클
래스가 가진 프로퍼티 목록을 전부 볼 수 있다. 여기서 원하는 프로퍼티를 선
택해주면 오타의 걱정 없이 프로퍼티를 정확히 추가할 수 있다. 처음 한두 글


자를 입력하고 찾으면 더 빨리 원하는 프로퍼티를 선택할 수 있다. 그림 9-5는
SimpleDri verDataSource 클래스의 빈을 등록하고 프로퍼 티를 입 력히는 중에 딘머

+
[효략랙렐를 누른 화면이다. 빈의 클래스 내의 모든 프로퍼티 목록과 그 타입을 바
로 확인하고 선택할 수 있다.
<bean id-~꿇ogrce" cla~3-"org. springframevork. jdbc. datasource. SimpleDriverDa taSource">

〈톨_ n
ame-에 ’〉<1-톨〉
</bean> r. conn8c1ionProp8r118S -Abstra뼈끓퍼꿇굶따딩굶파8.굶tConnectionPropB배8S(꽤끊굶끓
COI

I
.d끼
ver -SimpleDriverOataSource.setOriver<Driver d끼
ver)
i
.d
rlVerCc
1
as
s -Simpp
1
eDαr끼iver띠잉!녀
미rπce..S8
이riverιr
ass
디l녀양
dψriverC
l
as
s)
미메얘띠디녀앓
띠미벼
Da
aSoωu
‘
히tD
Cl녀
익(κc
as
s 띠
띠디녀앓


! • loginTimeout -AbstractDataSource.setLoginTimeout(int timeout)
.Iog에i앤
r -NlstractDataSource. se‘
LogW때 r(PrintWriter pw)

• password -NlstractDriver8asedDataSource.setPassword(String password) url -Ab strac tD
riverBasedDa이aSource. setUrl(String u
끼) i(I ) •(• ) username -Nl
st때Driver8asedDataSource. setUsername(SI빼

그림 9-5 SpringlDE의 프로퍼티 자동완성 기능

마찬가지로 ref 애트리뷰트로 다른 빈을 참조할 때도 자동완성 기능을 사용할 수
있다.

• 빈설정오류검증기능
자동완성 기능은 처음 입력할 때 유용하고 개발 중에 클래스나 프로퍼티 이름이 변
경됐거나 XML 파일을 직접 수정하다가 주요한 이름을 잘못 건드린 경우에는 빈 설
정 오류검증 기능이 도움이 된다.
이 빈 설정 오류검증 기능은 자바 코드를 작업할 때 실시간으로 컴파일 오류를 분
석해서 화변에 빨간색 X 마크를 보여주듯이 빈 설정 내용을 작업하다가 존재하지 않
는 클래스 이름을 넣거나 잘못된 프로퍼티 이름을 지정하면 바로 오류마크를 보여줘
서 문제가 있음을 확인시켜준다. 따라서 이 기능을 잘 활용해 사전에 빈 설정 내용의
오류를 검증하면 오타로 인해 잘못 들어간 이름 하나를 발견하기 위해 애플리케이션
을 서버에 배치하고 구동해야 하는 번거로움은 없어진다.

프로젝트 생성， 설정파일 생성， 빈 등록 위저드
스프링 프로젝트 생성을 위해 스프링 프로젝트 위저드를 이용할 수 있다. 하지만 스

프링 프로젝트를 만드는 데 필요한 라이브러리 선정이나 빌드 스크립트 추가， 프로
젝트 구조 등을 지정할 수 있는 고급 기능은 이 책을 쓰는 시점에서는 아직 제공되지
않는다. 하지만 앞으로 프로젝트의 특성과 적용 플랫폼， 펼요한 라이브러리를 선택
해서 프로젝트를 만드는 기능을 제공할 예정이라고 하니 기대해볼 만하다. 또한 미
리 준비된 프로젝트 템플릿을 이용해 프로젝트를 생성하는 기능도 제공될 예정이다.
XML 설정파일 생성 위저드는 번거로운 스키마 선언부를 손쉽게 추가하거나 수정할

g장-스프링 프로젝딛 시ξ텀f7
1 763



수 있게 해준다. 기본이 되는 bean 스키마를 비롯해서 aop. tx와 같은 추가 스키마를
설정파일에 적용할 경우 해당 네임스페이스 선언이 펼요하다. 그런데 그 내용이 간

단하지 않아서 직접 입력하기는 힘들고 매번 복사해서 붙여넣어야 히는 번거로움이
있다. 하지만 SpringIDE의 XML 설정파일 생성 위저드를 사용하면 간단히 십여 개
의 스프링 스커마/네임스페이스 중에서 원히는 것을 선택해 한 번에 XML 설정따일
에적용할수있다.

그림 9-6은 빈 설정파일 생성 위저드 중 사용할 네임스페이스와 스키마 버전을
선택히는 화면이다. 물론 생성 중에 펼요한 스키마를 추가하지 못했을 경우에는 빈
편집기 내에서 다시 추가할 수 있다.

••aW'i.'1i4'WidiWli 'JM,••mnmmtllUm Iim

”‘뻐 Springlk월， DefDtiOn fIe
Select XSD namespaces to use with the new Spring Bean Definition

h죠

Select desired 영o name5paCe declar빼005:

n
에에려‘‘
lang -http://www.springframework‘org/schema/lang
口
05gi -http://www.springframework.org/schema/osgi

•

o 'osgix -http‘//www.springframework.org/schema/osgi-compendium
~，
oxm -http://www.springframework.org/schema/oxm
口
@ p -http://www.springframework.org/schema/p 口(口) ‘ sec -http://www.sprin이ramework.org/schema/security

디 ,task -http ://www. springframework.org/schema/task
딘 마
tx -http://www.springframework.org/schema/tx
口
Ila util -http://www.springframework.org/schema/util

Select deslred XSD (H oone Is selected the 뼈fau
l\ 삐
"be used):

口
엠
i
p:///“
wo6rrkk써，orrgg건
매a//1t싱x/sbring-tx
，
xsd i

hhhn씨
ww*wii.s
pFn
비rame
싸 /scchheem

口엠 sprin gframe work. org/sc hem a/tx/spring -tx-2. O. xsd
口템 http ://www.springframework.org/schema/tx/spring-tx-2.5.xsd
딘 힘 http://www.springframework.org/schema/tx/spring-tx-3. O. xsd

그림 똥6 SpringlDE의 빈 설정파일 생성 위저드

빈을 등록할 때 XML을 직접 편집해서 입력하는 대신 위저드 방식으로 빈을 등록할
수도 있다. 그림 9-7은 현재 등록된 빈 목록을 보고 나서 빈을 추가하는 위저드를 실
행한화면이다.

그 밖에도 빈의 의존관계를 그래프로 보여주는 기능과 같이 스프링 설정 작업을
편하게 해주는 다OJ=한 기능을 제공한다.


륨굽표δ급버
aw •• ~----~

\;1 m

Select an element to edit its details


liI • dalaSource,8.an d뼈nltions fll.:

|
'lt'sprlngbook'll'srt:뼈est-ap미icatlonCon뼈xt.xml l헌표또〕

Id :
Nama’ I
Cla••: ~ l
한표되
Param: [ ---기
口
Ign，ore
errors

(î) C츠한E工교한츠그 C웰린그 드프관뜨그

그림 9-7 SpringlDE의 빈 둥록 위저드

빈의존관계그래프

그림 9-8은 스프링 IDE가 그려준 빈의 의존관계 그래프다. SpringIDE는 XML 설

정파일을 읽어서 자동으로 그래프를 그려준다. 각 빈이 서로 어떻게 참조하고 있는

지， 어떤프로퍼티를갖고 있는지를한눈에 볼수 있다.

jdbc :embedded-d하abase embeddedDatabase
@) databaseType
그림 9-8 SpringlDE의 빈 의존관계 그래프

9장-스프링 프로젝트 시ξ녕씨 765


• AOP
적용대상표시
AOP가 어려운 이유는 부가기능을 담은 어드바이스가 어느 오브젝트에 적용될지 한
눈에 보이지 않기 때문이다. @Transactional
처럼 직접 AOP 적용 클래스나 인터페
이스에 애노태이션을 추7r히는 특별한 방법을 사용하는 경우는 그나마 낫다. 하지만
포인트컷 표현식을 사용하거나 이름 패턴을 이용히는 포인트컷 빈을 이용하는 경우
에는 적용 대상을 파악하기가 쉽지 않다. 그래서 기능한 한 단순한 포인트컷 표현식
을 사용하고 명확한 규칙을 가지고 적용 대상 빈을 선정해야 한다. 하지만 잠시 착각
을 하거나 실수에 의해 원하는 대상을 놓치거나 반대로 펼요 없는 빈에 어드바이스
가 적용되는 문제도 발생할 수 있다. 이럴 때 어떤 어드바이스가 어떤 빈 오브젝트에
적용이 되는지 일일이 디버깅하는방법 외에 쉽게 확인할수 있는방법은 없을까?물
론 있다. 바로 SpringlDE가 제공하는 XML 설정파일 편집기를 사용하면 된다.

STS에는 SpringlDE 외에도 AJDT라는 AspectJ 개발 플러그인이 함께 설치된다.
이 AJDT의 지원으로 SpringlDE는 포인트컷이 적용되는 대상 빈을 설정파일 안에
서 한눈에 확인할 수 있도록 도외준다.

빈의 이름을 시용해 트랜잭션 적용 대상을 선정하게 했던 포인트컷 표현식을 한
번 검증해보자. 빈 이름을 이용한 패턴은 메소드 시그니처를 이용한 포인트컷 표현
식보다 만들기 쉽고 대상을 확인하기가 명확해서 자주 사용된다.

리스트 9-)
과 같이 빈 이름을 이용한 포인트컷 표현식을 λF용한 AOP 설정을 사
용한다고해보자.

리스트 9-1 빈 이름을 이용한 포인트컷 표현식

<aop:config)

<aop:advisor advice-ref="transactionAdvice" pointcut="bean(*Service)" /)
</aop:config)

Service
라는 이름으로 끝나는 모든 빈에 트랜잭션 어드바이스를 적용하라
는 AOP 설정이다. 포인트컷의 적용 대상이라고 기대하는 것은 userService,
testUserService 빈이다. 이름 규칙도 단순해서 별문제 없을 것 같다. 하지만
Spring
lD
E가 제공하는 XML 설정파일 편집기에서 살펴보면 이 포인트컷 표현식의
문제점이 한눈에 보인다.

그림 9-9는 설정파일 편집기 화면이다. 자세히 보면 <aop:advisor>로 포인트
컷을 선언한 부분에는 왼쪽으로 열려 있는 퉁근 화살표 모양의 마크가 있다. 이 마


크는 AOP 선언을 나타낸다. 그리고 AOP 어드바이저가 적용될 대상인 빈 설정에
는 오른쪽으로 열려 있는 둥근 회잘표 모양의 마크가 달린다. 빈 설정을 살펴보면
userService 빈과 testUserService 빈에 AOP가 적용된다는 마크가 달려 있다. 여
기까지는 좋은데 그 아래 DAO에 SQL을 제공해주는 기능으로 추가한 sqlService
빈에도 AOP 적용 대상 마크가 붙어 있다. 그러고 보니 이름이 Service로 끝나는 빈
이지만
sqlService 빈은트랜잭션 대상이 아니어야한다. 따라서 불필요하게 트랜잭
션 AOP가 SQL 서비스 빈에 적용되지 않도록 해야 한다.

<aop:confíg>
<aop :advisor advice-ref="transactionAdvice" pointcut="bean(*Service)" />

</a.op:config>

’

<bean id=’ userService’ class= ’ springbook.user.service. UserServiceImpl ’>
<property name= ’ userDso" ref=’ userDBO ’ />
<property name= "mailSender" ref= ’ mailSender" />

</bean>

<bean id=’ testUserService" class=
’
springbook
.
user
.
service
.
UserServi
ce
Test$Te~

<bean id="sqlService’ class= ’ springbook.user.sqlservice.OxmSqlService">
<pr operty name="unmarshal1er’ ref=’ unmsrshaller’ />
<property name= ’ sqlRegistry’ ref=’ sqlRegistry’ />

</ bean>

그림 9-9AOP 적용 대상을 보여주는 SpringlDE의 설정따일 편집기 화연

해결 방법은 두 가지가 있다. 하나는 sqlService의 이름을 bean(*Service) 포인트
컷의 대상이 되지 않도록 변경하는 것
이다. 예를 들어 sqlSvc
라고 이름을 바꿔도 된
다. 그런데 sqlService 빈의 이름을 바꾸면 이를 참조하는 DAO의 ref 값도 모두 변
경해야 한다. 그보다는 포인트컷을 비
즈니스 로직이 담긴 서비스 빈을 구분할 수 있
도록 패키지와 클래스 이름 등을 이용해 작성하면 좋을 것 같다. 비즈니스 서비스 클
래스들은 service라는 패키지 아래에 존재한다. 그렇다면 메소드 시그니처를 이용한
포인트컷 표현식으로 service 패키지 아래에 있는 Service로 이름이 끝나는 클래스
만 적용되도록 리스트 9-2와 같이 수정하자.

리스트 9-2exec띠허 }를 이용하도록 수정한 포인트컷

<aop:config>
<aop:advisor advice-ref="transactionAdvice"
pOlntcut=갱xecution(* *..service.*Service.*(..))" />
</aop:config>


이렇게 AOP의 포인트컷을 변경하고 저장 버튼을 누르는 순간 그림 9-10과 같이
sqlService 빈에 붙어 있던 AOP의 적용 대상임을 알리는 마커가 사라질 것이다.

9장-스프링 프로젝트 시직h하기 767


<aop:config>
1~
1 <aop: advisor advice-ref="transactionAdvice’
p01ntcut=’ execution(* ‘ .. service.*Service ‘ (.. )) ’ />
</aop:config>

‘ <bean id=wuserService’ class=Wspringbook.user.service.UserServiceImpl W>
<property name="userDao’ ref= ’ userDao’ />
<property name=’'mailSendex’ ref= ’mailSender’ />

</bean>

써 <bean id=WtestUserService w class=wspxingbook.user.service. UserServiceTestSTes

<bean id=’ sqlService’ class=’ spxingbook.user.sqlservice .OxmSqlService’>
<property name="unmarshaller" ref=’ unmarshaller" 1>
<property name="sqlRegistry’ ref="sqlRegistry’ />

</bean>

그립 9-10 변경된 트랜잭션 AOP 적용 대상

이렇게 SpringIDE의 XML 설정파일 편집기를 이용하면 AOP
의 적용 대상을 손
쉽게 확인할 수 있다， AOP 적용 마커는 포인트컷을 XML
에서 정의하지 않고
@Transactional 애노테이션을 사용한 경우에도 동일하게 나타난다.

단， AOP 마커를 보이게 하려면 프로젝트를 스프링 프로젝트로 만들고， 프로젝트
설정의 Spring-Bean Support 항목에 XML을 추가해줘야 한다. 자세한 사용 방법
은 STS 매뉴얼을 참고하자.

• 기타지원기능
지금까지 설명한 것 외에도 SpringIDE는 스프링 포트폴리오 프레임워크에 대한 지
원을 포함한 다OJ=한 기능을 제공한다. SpringIDE는 스프링소스와 스프링 개발팀의
지원 속에 계속 발전하고 있으니 항상 최신 버전을 설치하고 시용 방법을 잘 익혀두
면 스프링 개발에 많은 도움이 될 것이다.
스프링은 이미 2，5부터 애노테이션을 이용한 빈 설정 기능을 제공하는 등 많은 부
분에서 XML 설정파일 작성으로 인해 발생할 수 있는 불편한 점을 해소해주고 있다.
하지만 소스코드 내에 삽입하기 힘든 운영환경이나 리소스 관련 설정， 서비스 빈의
셋업 등은 여전히 XML을 이용하는 것이 편리하다. 그런데 일부 개발자는 스프링이
마치 J2EE 시절의 EJB마냥 지저분하고 복잡한 XML 편집을 요구하는 시대에 뒤떨
어진 기술이라고 주장하기도 히는데， 이는 전혀 근거 없는 비방일 뿐이다.

스프링의 XML을 이용한 빈 설정 방식은 꼭 필요한 내용만 작성하도록 최적
화돼서 최소한의 XML 편집 작업이면 충분하다. 일정한 규칙만 부여하면 자동와
이어링과 같은 방법을 통해 많은 설정 내용을 생략하고 자동화할 수 있다. 게다가
SpringIDE와 같은 편리한 입력과 펀집을 지원하는 도구도 얼마든지 활용할 수 있으
니 스프링의 XML 설정 방식을 ‘XML 지옥’ 취급하는 건 고의적인 스프링 깎아내리
기에 불과하다. 물론 스프링도 자바 5 이후 언어 기능 지원을 대폭 추가하면서 애노


테이션 방식의 설정을 많이 도입하긴 했지만， 여전히 XML은 편리하고 강력한 설정
방법이며 특히 툴의 도움을 통해서라면 애노테이션을 이용히는 것 못지않은 빠른 편
집과 정확한 사전 검증이 가능하기 때문에 XML 파일 편집으로 인한 개발 생산성의
저하 같은 건 없다고 생각해도 좋다.

SpringIDE와 관련된 자세한 정보는 STS 웹사이트나 SpringIDE 블로그(http:
//
springide.org/blog
)를 참조하면 된다.

STS
플러그인
STS 플러그인은 스프링 개발과 설정파일 편집을 지원하는 SpringIDE
에 더해서 스프
링 애플리케이션의 서버 배치와 같은 추가 기능을 제공해준다. STS는 대부분의 최신
JavaEE 서버로의 배치는 물론이고 스프링에 최적화된 애플리케이션 서버인 tcSeπer
그리고 OSGi 플랫폼인 dmServer, 스프링 기반의 클라우드 서비스인 스프링소스
Cloud Foundry로 배치할 수 있는 기능을 제공해준다. 앞에서 설명한 것처럼 tcServer
는 스프링 애플리케이션을 배치하고 운영하는 데 가장 최적화된 자바 서버 플랫폼이다.
Cloud Foundry는 아마존의 EC2 클러스터에서 동작하는 스프링 애플리케이션을 위한
클라우드 서비스다. 그 밖에도 VMForce와 같은 VMWare 가상화와 클라우드 서비스
에도 손쉽게 스프링 애플리케이션 배치할 수 있도록 지원해준다.
대시보드 화면도 STS 플러그인의 기능이다. 또 스프링 개발 시 자주 발생하는 예외
에 대한 지식베이스knowledge base를 검색해볼 수 있는 기능도 제공한다.

기타플러그인
STS가 추가로 제공하는 플러그인 중에서 관심을 가질 만한 게 몇 가지 있다.

-M左c1
i
pse
M2Eclipse는 자바의 대표적인 빌드 툴의 하나인 Maven을 지원히는 이클립스 플
러그인이다. Maven은 특히 의존 라이브러리 관리에 뒤어나다. 외부의 리포지토리
에 번들이라고 불리는 라이브러리와 의존정보를 두고 이를 프로젝트 모댈 정보를 이
용해 손쉽게 가져다 쓸 수 있게 되어 있다. 스프링은 그 자체로 20여 개의 세부 모률
로 구성되어 있고 100개가 넘는 많은 의존 라이브러리를 갖고 있기 때문에 라이브

러리의 개수도 많고 의존관계도 복잡하다. 그래서 스프링 애플리케이션 프로젝트는
Maveno1 지원하는 의존 관리 기능을 활용하기에 적합하다. 그래서 STS는 기본적으
로 M2Eclipse라는 Maven 지원 플러그인을 포함하고 있다.

9징-스프링 프로젝트 시작하기 769


M2Eclipse의 사용 방법과 관련 문서는 M2Eclipse 홈페이지뼈p:
/ /m2eclipse.sonatype
org)에서 찾을 수 있다.

• AJDT
AJDT는 AspectJ Development Tool
의 약자로， 이클립스에서 AspectJ AOP를 이용
한 개발을 지원하는 편리한 툴이다. 스프링 애플리케이션에서 AspectJ 방식의 AOP
를 사용할 경우 AspectJ와 관련된 편집 기능과 AOP 적용 대싱에 대한 마커 등의
AJDT 기능을 활용할 수 있다.
AJDT는 이클립스 플랫폼의 대표적인 플러그인이며 관련 정보는 AJDT 홈페이지
(http://www.eclipse. org
/ajdt/l에서 찾을 수 있다.

• VMCI
VMCIV띠ual Machine Core Integ때。n 플러그인은 VMWare 서버 또는 워크스테이션과의

연동을 지원하는 플러그인이다. STS의 VMWare 배치 기능에 주로 사용되기 위해
추가된 것이다. 앞으로 VMWare의 가상화 서버나 클라우드 서비스에 관한 기능이

대폭 추가된다면 이 플러그인의 기능을 직접 활용할 필요도 생길 것이다.

• 이클힐스 표준 폴러그인
이클립스 플랫폼에서 제공히는 주요 표준 플러그인에 포함된 것으로는 웹 개발을 지
원히는 WTpWebT∞I Platform EMpEclipse Modeling Project, Mylyn, DSDpDevice Software
Development Platform 등이 있다.

STS를 사용하면서 추가적으로 펼요한 플러그인은 호환성 문제만 주의하면 얼마든

지 설치해서 사용할수있다.

9.2.4 라이브러리 관리와 빌드 툴
애플리케이션의 아키텍처를 결정하고 λF용 기술을 선정하고 나면 애플리케이션 프로젝
트를 IDE에 구성할 차례다. 이때 가장 어려운 부분은 바로 필요한 프레임워크 모률과

라이브러리 파일을 선택해서 프로젝트의 빌드 패스에 넣어주는 일이다.

라이브러리 관리의 어려움

과연 스프링으로 애플리케이션을 만들 때 어떤 라이브러리 파일들이 필요할까? 스프링
자체만 해도 20개 가께 세분화된 jar 모률이 존재한다. 스프링이 직접 참조하는 필요


라이브러리는 100개가 넘는다. 스프링이 직접 참조하지 않는 프레임워크나 라이브러리
까지 포함하면 스프링으로 만드는 프로젝트에 포함될 가능성이 있는 라이브러리의 종
류는수백여 개에 달할것이다.

요즘은 웬만한 기능은 기존의 오푼소스 라이브러리를 활용하기 때문에 프레임워크
하나에 적게는 5~6개에서 많게는 수십 개씩 의존 라이브러리가 필요한 경우도 많다.
문제는 이런 의존 라이브러리가 항상 필요한 건 아니라는 점이다. 스프링만 해도 207H
의 모률과 1
00
여 개의 직접 참조라이브러리가있지만그모든모률과라이브러리가매
번 다 쓰이는 건 아니다. 펼요한 기능과 시용하기로 결정한 기술에 따라서 적절한 선택
이필요하다.

라이브러리마다 여러 개의 버전이 있다는 것도 문제다. 각 라이브러리마다 정확히
어떤 버전을 사용해야 할지도 알아야 한다.A라는 기능을 사용하는 데 펼요한 라이브러
리는
B의 1.0부터 1.2까지 사이여야하고 B가동작하려면
C 라이브러리의 2.0은반드
시 필요한데，
B
의 일부 기능을 사용할 때는 선택적으로 D 라이브러리의 3.0
이 있어야
한다는 식의 지식이 펼요하다는 뭇이다. 라이브러리 종류는 같지만 버전이 맞지 않으면
컴파일이 되지 않을 수 있고 운이 나쁘면 컴파일은 정상적으로 되고 통작은 하지만 운
영 중에 오류가 발생할 수 있다.

필요한 라이브러리의 조합을 만들다 보면 복잡한 의존관계 속에서 같은 라이브러
리의 다른 벼전이 동시에 펼요해서 문제가 발생하기도 한다. 라이브러리 관리 작업에
서 발생할 수 있는 가장 골치 아픈 상황이다. 예를 들어 A 라이브러리는 B와 C에 의존
한다. 그런데 B와 C가 각각 D라는 같은 라이브러리를 다시 의존하고 있다. 문제는 B
와 C가 각각 다른 버전의 D를 사용하는 경우다. 예를 들어 B는 D의 1.0을 이용하는데
C는 D의 2.0을 이용한다고 해보자.B와 C는 독립적으로 만들어진 프레임워크 또는 라
이브러리라 서로의 호환성에 대해 항상 신경 쓸 수는 없기 때문에 이런 문제가 발생하
는 것이다.0 라이브러리 2.0이 1
.
0과 완벽히 호환된다면 문제가 없다. 이때는 둘 중에
서 최신 버전을 선택하면 된다. 하지만 어떤 경우 버전이 올라가면서 같은 클래스인데
도 완전히 다른 방식으로 동작하거나 내부 구조가 바뀌어서 전혀 호환되지 않는 경우
도있다.

자바는 모률이라는 개념이 없다. 독립 모률로 패키징이 가능한
Jar 파일이 있는데 무
슨 소리냐고 할지 모르겠지만 정말 모률 개념이 없다. 만약 같은 패키지와 이름을 가진
클래스지만 구현이 다른 클래스 파일이 a
.j
ar와 b.jar 두 개에 있다고 하자. 그리고 a.jar
와 b
.j
ar가 모두 클래스패스에 있다고 해보자. 이 경우 모률 a.jar 안에 있는 클래스를 사

g장-스프링 프로젝트 시직하기 771


용하겠다거나 b껴r 안에 있는 클래스를 사용하겠다고 선택할 수 있을까? ajar와 b껴r
가 같은 웹 모률의 라이브러리에 등록되어 있다면
Jar 파일 구분은 별 의미가 없다. 자바

의 jar는 기본적으로 압축 패키정 방법일 뿐이지 구분 기능한 독립된 모률이 아니다.

앞에서 설명한 경우를 다시 생각해보자. 그림 9-11
은 같은 라이브러리의 두 가지 버
전이 존재하는 애플리케이션의 의존관계를 나타낸다. C 1.0과 C 2.0
에 이름이 같지만
구현이 다른 클래스가 있다면 이에 의존하고 있는 A나 B 중 하나는 비정상적으로 동작
할 것이다. 라이브러리 의존관계 관리의 가장 큰 난제다.

library A }---í 니
brary C 2.0 l 서로첼되지앓잃클

애플리케이선 G ‘ 래스를 가졌으므로 충돌이
코드 R 일어나서 A나 B 중 하나는
、
정상적으로 동직h하지 못한다.

library B }--꺼 Library C 1.0
그림 9-11 버전이 다른 라이브러리의 문제

이 문제를 풀 수 있는 가장 간단한 방법은 재패키정
repackaging
이다. 한쪽 버전의 클래스
를 다른 패키지로 옮겨서 서로 구별되는 클래스로 만들어주는 방법이다. 물론 이에 의
존히는라이브러리의 코드도 변경된 패키지 내의 클래스를사용하도록수정돼야한다.

C 1.0과 C 2.0 모두 org.librarY.LibClass
라는 이름의 클래스를 가졌다고 하
자. 두 개의 클래스가 이름은 같지만 호환이 안 된다면 그중 한 버전을 org.library.
repack.Lib
Cl
ass와 같은 식으로 패키지를 바꿔주고 이 버전을 사용하는 라이브러리도
org.librarY.repack 패키지 밑에 있는 클래스를 쓰도록 만들어야 한다. 이런 재패커
징 작업은 간단하진 않다. 모든 소스 또는 바이트코드를 일일이 찾아서 수정해주는 만
만치 않은 작업이다. 실제로 이런 문제가 제법 많이 발생하고 있기 때문에 재패키징을
지원해주는 툴도 존재한다. 구글 코드에서 찾을 수 있는Ja낀ar(http://c여e.google
.com/p/j때ar)

를 이용하면 간단한 명령으로 한 번에 복잡한 라이브러리 클래스를 모두 재패키징할
수있다.
스프링이 샤용히는 라이브러리의 의존관계를 따져보면 이렇게 버전이 다르면서 같
은 라이브러리를 사용하는 경우가 여릿 발견된다. 특히 ASM(http ’/ /asm.ow2.org)은 워낙 많

은 곳에서 사용되면서 서로 버전이 호환이 안 되는 경우가 많아 자주 문제를 일으키는
악명 높은 라이브러리다. 그래서 스프링은 ASM 라이브러리를 통째로 재패키정해서
org.springframework.asm이라는 스프링 패키지 밑으로 클래스를 옮겨두고 이를 시용

한다. 그렇게 해야 하이버네이트를 비롯해서 ASM을 사용하는 여타 라이브러리와 버전
충돌문제를피할수있기 때문이다.


이렇게 스프링을 이용한 애플리케이션을 만들 때 펼요한 라이브러리의 종류와 버전
을 적절히 선정하고 개발하면서 추가적으로 필요로 하는 라이브러리를 추가하거나 또
는 제거하는 등의 관리 작업은 결코 쉬운 일이 아니다.

라이브러리선정
다행히도 이미 프로젝트의 기본틀이 잡혀 있고시용할 라이브러리와프로젝트폴더 구
조까지 다 결정된 프로젝트에 참여해서 순수한 애플리케이션 개발에만 전념할 수 있다
면 이런 걱정은 일단덜 수 있다. 하지만자신이 직접 프로젝트를구성하고 필요한라이
브러리를 선정하거나 추가 제거하는 등의 관리를 해야 송}는 상황이라면 여러모로 신경
써야할게많다.
가장 먼저 해야 할 작업은 스프링으로 만드는 애플리케이션에서 정확히 어떤 기능이
필요한지를 정리하는 것이다. 각 기능을 지원하는 기술이 여러 가지 종류가 있다면 그
중에서 어떤 것을 사용할지도 결정해야 한다.

• 스프링모률
사용할 기능과 기술 목록이 모두 만들어졌으면 일단 스프링 모률부터 선정한다. 스
프링에는 총 20개의 모률이 있다. 일부는 거의 모든 애플리케이션에서 공통적으로
사용되는 필수 모률이다. 그 외의 모률은 애플리케이션의 아키텍처와 사용 기술에
따라서 선택적으로 적용할 수 있다. 어떤 경우에 어떤 모률이 펼요한지에 대해서는
부록 A.2절 ‘스프링 모률의 의존관계’를 참조하기 바란다.
스프링의 모률 사이에도 의존관계가 있다. 모률 사이의 의존관계는 필수와 선택
으로 나닐 수 있다. 예를 들어 A 모률이 의존하는 모률은 B, C, D가 있다고 하자. 이
중 B는 필수이고 C，
D는 선택 가능하다면 A를 사용할 때 B는 무조건 추가해주면 되
고 C와 D는 A 모률이 가진 기능 중 어떤 것을 사용하느냐에 따라서 필요할 수도 있
고 필요 없을 수도 있다. 부록 A에 나와 있는 모률의 의존관계와 주요 기능을 잘 살
펴보고 필수 의존모률과 선택 의존모률을 잘 구분해서 선정하자.

• 라이브리리
스프링의 각 모률은 또 다른 모률에 의존하기도 하지만 오푼소스 라이브러리 또는
표준 API를 필요로 하기도 하고 경우에 따라서는 상용 제품의 라이브러리에 의존한
다. 부록 B에 나와 있는 각 모률과 라이브러리의 의존관계 매트릭스를 보면 각 모률
이 반드시 필요로 하는 라이브러리가 무엇인지 선택적으로 사용히는 것은 무엇인지
g잠-스프링 프로젝트 시작하기 773


알 수 있다. 부록 B
에 나옹 스프링 모률과 그에 의존하는 라이브러리의 종류와 특징
을살펴보고그중에서 적절한라이브러리를선택한다.

부록 B
에 소개된 스프링 의존 라이브러리는 스프링이 직접 참조히는 라이브러리
일 뿐이다. 때로는 각 라이브리리를 활용히는 방법에 따라서 다른 서드파티 라이브
러리를 펼요로 하는 경우가 있다. 예를 들어 하이버네이트는 스프링 애플리케이션에
서 지주 사용되고， 스프링이 직접 지원하고 있기 때문에 스프링의 의존 라이브러리
에 속한다. 그런데 하이버네이트 자체를 놓고 보면 다시 세부 기능을 어떻게 사용하
느냐에 따라서 또 다른 라이브러리가 펼요할 수 있다. 이와 같은 정보는 해당 프레임
워크나 라이브러리의 문서를 참조해서 필요한 라이브러리가 어떤 것인지 직접 찾아
봐야한다.

부록 A와 부록 B
에 나와 있는， 모률과 라이브러리의 의존관계와 필요한 경우에 대한
설명을 주의 깊게 읽어보고 적용하면 기본적으로 필요한 라이브러리를 선정할 수 있다.
하지만 때로는 어떤 라이브러리를 추가해야 할지 말지 애매한 경우가 있다. 그런 경우
에는 어쩔 수 없이 시행착오 방법을 이용해야 한다.

먼저 모든 스프링 관련 라이브러리 jar 파일을 모두 가져다 하나의 폴더에 몰아넣
고 각각 별도의 폴더에 압축을 풀어준다. 대부분의 압축 유틸리티가 지원하는 ‘파일
이름을 폴더로 해서 압축 풀기’ 기능을 활용하면 된다. 그리고 확실히 필요하다고 생
각되는 최소한의 라이브러리와 모률만 가지고 일단 개발을 시작한다. 코드를 만들고
테스트를 수행하거나 애플리케이션을 기동하면 아마도 클래스를 찾을 수 없다는 예외
(C 1as sNotFoundExcept ion
)를 만나게 될 것이다. 찾을 수 없다는 클래스의 이름을 가지고 라
이브러리 압축을풀어둔폴더에서 검색을해본다.
OS
의 탐색기의 검색 기능이나명령
행에서 파일을 검색하는 명령을 사용하면 된다. 클래스를 찾게 되면 그 클래스가 어느
라이브러리 jar 파일에서 나온 것인지 확인한 뒤에 해당 파일을 추가해준다. 그리고
다시 태스트나 애플리케이션을 돌려서 필요한 클래스와 라이브러리 파일을 계속 추가
해준다. 애플리케이션의 주요 기능을 가진 간단한 샘플을 하나 만들어가면서 해보면
빠르면 한두 시간 안에 필요한 라이브러리 파일을 모두 찾아낼 수 있을 것이다. 이왕
이면 어떤 기능을 동작시켰을 때 어떤 클래스와 라이브러리가 필요했는지 기록해두면
나중에 도움이 된다. 단순하고 미련한 방법으로 보이겠지만 스프링 애플리케이션에서
꼭 필요한 라이브러리를 찾는 데 가장 효과적인 방법이다. 인터넷에서 jar 파일을 압
축을 풀지 않고 검색하는 방법이나 Jar 파일 검색을 지원히는 툴을 찾아 시용해도 좋
을것이다.


필요한 라이브러리가 없으면 애플리케이션이 동작하다가 에러가 나거나 아예 컴파
일되지 않는다. 반대로 필요하지 않은 라이브러리가 있을 땐 아무런 문제가 발생하지
않는다. 하지만 불필요한 라이브러리를 추가해두는 것은 또 다른 위험이 있다. 때로는
무작정 모든 라이브러리 파일을 다 추가해놓고 사용하는 개발자도 있다. 그 때문에 애
플리케이션 모률의 파일 크기가 커지는 것은 물론이고 이후에 라이브러리를 관리히는
데 심각한애를먹을수도 있다. 때로는의존라이브러리의 버전충돌문제처럼 풀기 어
려운 문제가 발생하기도 한다. 따라서 불펼요한 라이브러리는 처음부터 추가하지 않아
야 하며， 사용 기술이나 기능이 변경돼서 불펼요해진 라이브러리도 바로 제거할 수 있
도록노력해야만한다.

물론 라이브러리 관리는 어떤 방법을 쓰더라도 간단하지 않다. 이미 만들어진 다양
한 프레임워크와 라이브러리의 조합으로 애플리케이션을 만드는 시대이기 때문이다.
또 빠르게 업데이트되는 기술과 버전이 주는 부담도 있다. 부록 A와 부록 B
에 나오는
의존관계 정보를 참고해서 성실하고 꼼꼼하게 필요한 라이브러리와 모률을 찾아 사용
하는길이 최선이다.

빌드 툴과 라이브러리 관리
Maven과 ANT는 자바의 대표적인 빌드 툴이다. 빌드 툴은 개발팀이나 조직의 정책 또
는 경험에 따라서 결정하면 될 것이고 여기서는 벌드 툴이 지원하는 의존 라이브러리
관리 기능에 대해 이야기해보자.
이클립스와 같은 ID
E는 코드만 작성하면 자동으로 컴파일해주는 자동빌드 기능이
있고， 관련 빌더를 추가하거나 확장함으로써 복잡한 빌드 작업도 간단히 진행할 수 있
다. 하지만 IDE를 사용할 수 있는 환경이 아닌 경우에도 일관된 빌드가 가능하도록 만
드는 것이 중요하다. 예를 들어 서버에 배치했을 때나 통합 태스트 환경에서 애플리케
이션을 직접 빌드해야 할 경우가 있다. 이런 경우에도 IDE에서와 동일하게 애플리케이
션 빌드 작업이 수행돼야 한다. 그래서 자동빌드 기능을 지원하는 IDE를 기본적으로 이
용하면서 ANT나 Maven 같은 환경에 독립적인 빌드 툴을 함께 사용하는 것이 바람직
하다.
ANT가 이클립스에 기본 내장돼서 제공될 정도로 사실상 표준 자바 빌드 툴로 자리
잡고 있을 때 Maven이라는 새로운 개념의 빌드 툴이 등장했다. Maven은 단순 벌드 툴
을 넘어서 개발 과정에서 필요한 빌드， 태스트， 배치， 문서화， 리포팅 등의 다앙한 작업
을 지원하는 종합 프로젝트 관리 툴의 성격을 띠고 있다
Maven의 특정은 POM이라고

9장-스프링 프로젝트 시ξ념}기 775


불리는 프로젝트 모댈 정보를 이용한다는 점이다. 그래서 절차적인 스크립트와 구조가
비슷한 ANT와 달리 Maven은 선언적이다. 프로젝트의 주요한 구조와 특정， 필요한 정
보를 POM의 프로젝트 모댈 정보로 만들어두면 이를 참조해서 Maven에 미리 정해진
절차에 따라 빌드 또는 프로젝트 관리 작업을 진행할 수 있다.

Maven POM
이 가진 독특한 특징 중의 하나는 애플리케이션이 펼요로 히는 의존
라이브러리를 선언해두기만 하면 원격 서버에서 이를 자동으로 다운로드 받아서 사용
할 수 있게 해주는 것이다. 예를 들어 다음과 같이 애플리케이션의 의존정보를 넣으면
Maven으로 벌드할 때 펼요한 라이브러리가 개발 PC
의 공통 저장소에 있는지 확인하고
없으면 Maven
의 원격 서버에서 자동으로 다운로드 받아서 설치해준다.

예를 들어 POM 안에 리스트 9-3과 같이 의존 라이브러리 항목이 들어 있
으면 Maven은 POM
에 선언된 프로젝트를 벌드하면서 log4j
-I
.
2.15.jar와
springframework-asm-3. O. 7.jar, springframework-core-3.0.7 .jar 세 개의 파일을
미리 지정해둔 서버에서 자동으로 다운로드 받아 설치하고 시용할 수 있게 해준다.

리스트 ~3 Maven 메M의 의존 라이브러리 선언

<dependencies>

<dependency>
<groupld>Org.apache.log4j</groupld>
<artifactld>com .springsource.org.apache.log4j</artifactld>
<version>1.2. 15</version>

</dependency>

<dependency>
<groupld>Org.springframework</groupld>
<artifactld>Org.springframework .asm</artifactld>
<version>3.Ð.7</version>

</dependency>

<dependency>
<groupld>Org.springframework</groupld>
<artifactld>Org.springframework.core</arti factld>
<version>3 .Ð.7</version>

</dependency>

Maven
의 의존 라이브러리 관리 기능이 제공하는 더 홍미로운 기능은 전이적떠nsitive
의존 라이브러리 추적 기능이다. POM의 의존정보에 하나의 라이브러리를 지정하면，
지정된 라이브러리가 동작히는 데 필요한 여타 라이브러리까지 함께 다운로드해주는
기능이다.


springframework-core 모률이 동작하려면 commons-logging이라는 라이브러리
가 반드시 필요하다. Maven은 이 런 정보를 springframework-core 모률의 POM 정보
에서 확인해서 springframework-core를 다운로드하면서 commons-logging 라이브
러리도 함께 다운로드해준다. 비록 애플리케이션의 POM에는 직접 지정해준 적은 없어
도 commons-logging은 전이적인 의존 추적 기능을 통해 자동으로 추가된다. 이런 과
정은 모든 라이브러리에 재귀적으로 적용된다. 혹시 commons-logging이 동작할 때
또 다른 라이브러리가 펼요하다고 정의되어 있다면 그 라이브러리도 함께 다운로드될
것이다. 그래서 잘 정의된 의존정보를 가진 라이브러리들을 갖고 있다면 한두 개의 최
상위 의존 라이브러리만 지정해줌으로써 그에 필요한 모든 라이브러리를 손쉽게 추가
할수있다.

Maven
의 이런 기능은 매우 매력적이다. 매번 수십 메가에 달하는 라이브러리를 프
로젝트 안에 포함시켜서 소스코드와 함께 관리하는 건 부담스러운 일이다. 대신 프로
젝트 안에 POM을 통해서 의존 라이브러리 정보만 갖게 하고 펼요한 라이브러리는
Maven 빌드 과정 중에 자동으로 다운로드 받거나 로결 공통 리포지토리에서 가져오게
하면 프로젝트 따일의 크기도 줄어들고 코드 관리도 단순해질 것이다.

스프링의 모든 모률은 POM 정보를 갖고 있다. 이 정보를 참고하면 모률을 사용하는
데 필요한 라이브러리가 어떤 것이고 어떤 버전인지를 알 수 있다는 뭇이다. 그렇다면
이런 POM 안에 담긴 의존정보를 활용하면 스프링을 이용한 애플리케이션의 라이브러
리 관리가손쉽게 가능할까?

그렇지는 않다. 스프링의 모률과 관련 라이브러리들이 자신이 의존하는 라이브러리
에 대한 정보를 모두 정확히 갖고 있다고 해도 문제는 간단해지지 않는다. 그것은 하나
의 모률이 제공하는 기능 중에서 애플리케이션에서 실제로 사용히는 것에 따라서， 또
로우레벨의 구현 기술을 어떤 것을 시용할지에 따라서 실제 필요한 라이브러리가 달라
지기 때문이다. 부록 B에는 스프링의 각 모률이 필요로 하는 라이브러리 목록이 나와
있다. 그중에서 항상 함께 시용되는 필수 라이브러 리는 몇 개 되지 않는다. 대부분은 경
우에 따라 쓸 수도 있고 안 쓸 수도 있는 선택 라이브러리다. 선택 라이브러리는 Maven
의 전이적 의존 라이브러리 추적 기능의 적용을 받지 못한다. 참고는 할 수 있으되 사용
하려면 명시적으로 POM에 선언해줘야 한다는 뭇이다.

결국 Maven을 사용하고 POM 정보를 이용한다고 해도 실제 적용할 라이브러리를
선정하는 수고가 사라지는 것은 아니다. 물론 각 모률의 POM 적용 가능한 후보 라이브
러리 목록과호환가능한 버전 정보를참조할수 있다는 것만해도도움이 된다. 부록
B
의 의존 라이브러리 내역은 스프링 모률의 POM 정보를 참고해서 작성됐다.

9징-스프링 프로젝트 시작하기 777


어차피 개발자가 스스로 필요한 라이브러리를 선택해야 한다면 굳이 Maven과 같은
라이브러리 관리 기능이 있는 툴을 사용할 필요가 있을까? 라이브러리를 원격 리포지
토리 서벼에서 다운로드 받는 것 외에는 결국 일일이 라어브러리 목록을 지정해줘야 하
는데 말이다. 그래도 펼요하다. 라이브러리의 효과적인 관리 측면에서 필요하다.

스프링 개발자들이 정의해서 각 모률의 POM
에 담아놓은 의존 라이브러리 정보 자
체는 그대로 가져다 기계적으로 적용할 수 있는 게 아니다. 스프링을 만든 개발자들은
실제 프로젝트에서 어떤 기술올 사용하고， 어떤 기능은 쓰지 않을지， 그때 라이브러리
는 어떤 것을 이용할지에 대해서는 알지 못한다. 하지만 그 프로젝트에 참여히는 개발
자들은 안다. 또 그 프로젝트의 기술적인 결정사헝을 관리히는 아키텍트 그룹이나 기술
지원팀 내지는 전사 표준과 같은 조직 내 기술 표준을 만드는 사람들은 잘 알고 있다.

그렇다면 이렇게 접근하면 된다. 먼저 조직이나 팀이 관여히는 프로젝트 씨에 변
하지 않고 공통적으로 사용히는 기술 목록을 만든다. 그리고 그 공통적인 기술을 적용
할 때 필요한 모든 스프링 모률과 라이브러리를 선정한다. 그렇게 만든 목록을 가지
고 com. mycompany. common-deps 같은 이름으로 라이브러리 목록만 담긴 간단한
POM 따일을 만든다. 이 POM은 프로젝트를 위한 것이 아니라 라이브러리 목록을 정
의해놓는 것이 목적이다. 그리고 사내 로컬 Maven 리포지토리를 셋업하고 여기에 앞에
서 만든 common-deps POM 파일을 업로드해둔다.

그리고 개별 프로젝트에 Maven POM 따일을 만들고 여기서 만든 common-deps
POM 자체를 의존정보로 넣는다. 이렇게 해주기만 해도 전이적 의존관계 추적 기능에
의해 common-deps POM에 담긴 모든 라이브러리가 프로젝트에 자동으로 등록된다.

공통 부분에는 예를 들어 core, bean, context, aop, aspect, transaction, jdbc, web
등이 들어갈 수 있다. 그리고 각 모률이 필요로 하는 공통적인 의존 라이브러리도 선정
해서 추가해둔다. 태스트 라이브러리와 같이 개발 과정에서 필요한 라이브러리도 정해
진 것이 있다면 그것도 포함시킨다. 프로젝트마다 사용 기술과 아커텍처를 모두 뒤집어
서 전혀 다르게 구성히는 경우는 드물다. 같은 조직이고 같은 팀이라면 공통적인 모률
과 의존 라이브러리를 추출할 수 있을 것이고， 이를 공통 의존 라이브러리 정보로 만들
어두면매우유용하다.

거의 모든 프로젝트에서 사용 가능한 공통 라이브러리를 따로 선언해뒀다면， 다음
은 선택 가능한 기술들을 중심으로 의존 라이브러리 그룹을 만들다. 예를 들어 웹이라
면 SpringMVC, Struts2, JSF 같은 MVC 프레임워크나 AJAX, RIA 기술로 구분할 수
도 있겠고， 데이터 액세스 기술이라면 JDBC, iBatis, Hibemate, JDO, JPA 등으로 나


눌 수도 있겠다. JMS 같은 서비스도 하나의 그룹이 될 수 있다. 각 기술 그룹별로 필요
한 라이브러리를 정리해서 마찬가지로 POM 형태로 만들어둔다. 이렇게 정리된 것을
springmvc-deps 같은 이름의 POM으로 리포지토리에 추가해두자.

이렇게 기업이나 개발팀 내에서 사용하는 의존 라이브러리의 그룹을 만들고 이를
POM과 같은 빌드 툴이 활용할 정보로 생성해두면 그 다음부터는 매우 편리하게 이
를 조합해서 모률과 라이브러리를 지정할 수 있다. common -deps는 기본으로 추가
하면 되고， 웹은 spring-mvc-depso\l ajax -dojo-deps를 사용하고 데이터 액세스는
hibernate-deps, OXM은 oxm-castor-deps, JMS는 jms-activemq-deps 정도 선택
해주면 관련된 수십 개의 의존 라이브러리가 모두 포함된 프로젝트를 손쉽게 만들 수

있다.

처음 한 번과 새로운 스프링 버전이 등장했을 때만 다시 수고해주면 지속적으로 활
용 가능한 효과적인 의존관계 관리체계와 툴을 가져갈 수 있다. 그림 9-12는 common,
springmvc, hibernate라는 세 개의 미리 준비된 의존 라이브러리 그룹을 지정해서 애플
리케이션의 설정을만드는예다.

서 f 니 spnng-c。때l뺑an
s， spring-ct:x.
common 의 존그룹 --+---i spring-tx, spring
-jdbι apache-
L co mmons,cglib,log4j,javax.el

애플러케이선 의존정보
、
í spring-servlet, context-support.common-deps
셔 spnngmvc 으|존그룹 r --~ apache.poi,apache-tiles,velocity,
-springmvc-deps ‘ ’ L jasperreports, jackson-mapper.

-hibernate-deps
“ “ 꺼 } 니 spring-orm, hiberna앤
hibernate 의존그룹 --+커 javax.persistence, hibernate‘
annotation, ehcache,

그림 9-12 의존 라이브러리 그룹의 훨용

만약 Maven을 사용했다면 리스트 9-4와 같이 의존정보를 정의해주면 된다.

리스트 9-4 기술 그룹에 따른 POM을 이용해 애를리케이션의 의존 라이브러리를 선언하는 예

(dependency>

깅퍼리d>com 깨companY
.
deps(/groupld>
groupld와 a에tactld. version을 ID로 해서(artifact ld>common-deps(/artifact ld> 리포지토리에서 정보를 찾는다<
version>1.0.0(/version>

(type>pom(/type>
(/dependency>
(dependency>

(groupld>com.mycompanY.deps(/groupld>

(artifact ld>springmvc-deps(/artifactld>

(version>1 ，
0，
0(/version>~ 의존 라이브러리 구성이 새롭게 갱신되연 그에 맞게 버전을 바꿔주연 된다


9징-스프링 프로젝트 시작하기 779


<type)pom</type)
</dependency)
<dependency)

<groupld)com.mycompany .deps</groupld)

〈어arπtif뎌ac야tld
>h
ibernate
-d
eps
<
/artifactld)

<version)1.0.0</version)

<type)pom</type) ---•-타입을 따n으로 하면 의즌 라이브러
리 목록율 갖고 있는 ∞M을
</dependency)
l포지토리에서 가져와서 의존정보훌 추가해준다，

11μf

만약 Maven
의 시용에 익숙하지 않거나 거부감이 있다면 ANT。어에써λ서
λF용할 수 있는

Ivy끼C(ht빼

t

포지토리에서 라이브러리를 다운로드 받을 수 있는 기능을 제공한다. 따라서 ANT로
벌드 스크립트를 갖고 있다면 Ivy를 활용해도 좋다. 스프링은 Maven과 함께 Ivy에서
도 사용할 수 있는 의존정보 파일을 제공해준다. 실제로 스프링 프레임워크의 개발에는

ANT와 Ivy가 사용됐다.

스프링 모률의 두 가지 이름과 리포지토리

인터넷 검색을 통해 발견할 수 있는 스프링 모률Jar 파일의 이름을 살펴보면 두 가지 종
류가 있다. 예를
들어 스프링의 가장 기본적인 핵심 모률을담은
core 모율이라면 다음
과 같은 두 가지 이름의 파일이 존재한다.

spring-core-3 .0.7.RELEASE.jar

org .springframework.core-3.0 .7.RELEASE . jar

사실 이 두 파일은 동일한 파일이다. 단지 배포되는 기술에 따라서 관례적으로 다른
이름을사용할뿐이다다.
sprmn1멍
아
→
댄싫
뻐뼈써써싸
시사‘용용동하}뜯는 명명 규칙을 따른 것이

따야맨g-cor
3.ρ.0
.
7τ.
REL
SE.껴r는 Maver1얘에어에lμ서~

디띠탬
re-EA
nλ


다. Maven은 그룹 아이디와 아티팩트 아이디， 그리고 버전 세 가지로 라이브러리를 정

의히는데 그중에서 아티팩트 아이디와 버전을 조합해서 따일 이름으로 사용한다. 만약
일반 Maven 리포지토리에서 스프링 모률을 검색하면 이와 같은 이름의 따일을 발견할
것이다. POM에서는 리스트 9-5와 같은 형식으로 의존 라이브러리로 지정할 수 었다.

리스트 9-5 Maven 리포지토리의 스프링 ∞re 모롤

<dependency)
<groupld)org .springframework</groupld)
<artifactld)spring-core</artifactld)


(version)3.0.7 .RELEASE(/version)
(/dependency)

두 번째 파일 이름 org.springframework.core-3. O. 7.RELEASE
.j
ar는 OSGi
의 모
률 명명 규칙을 따른 것이다. 스프링의 모든 모률은 OSGi 호환 모률로 만들어져 있다.
그리고 OSGi 플랫폼에서 사용되지 않는다고 할지라도 OSGi 스타일의 모률 이름을 사
용하도록 권장한다. 그래서 스프링 배포 버전의 dist 폴더에 들어 있는 모률 이름도 모
두 OSGi 스타일의 이름이다.

OSGi 호환 이름을 갖는 스프링 모률을 시용할 경우에는 Maven의 표준 리포지토리
대신 스프링소스가 제공하는 엔터프라이즈 번들 리포지토리를 사용해야 한다. 이때는
Maven POM에 스프링소스 리포지토리 위치를 리스트 9-6과 같이 지정해야 한다.

리스트 똥6 스프링소스의 OSGi 번툴 리포지토리

(repository)
(id)com.springsource.repository.bundles.release(/id)
(name)SpringSource Enterprise Bundle Repository -SpringSource Bundle Releases
(/name)
(url)http://repositorY.springsource.com/maven/bundles/release(/url)

(/repository)

(repository)
(id)com.springsource.repositorY .bundles.external(/id)
(name)SpringSource Enterprise Bundle Repository -External Bundle Releases
(/name)
(url)http://repositorY.springsource.com/maven/bundles/external(/url)

(/repository)

리포지토리를 지정했다면 스프링의 표준 모률 이름을 따라서 리스트 9-7과 같이 의
존라이브러리를선언할수있다.

리스트 f}-7 스프링소스 OSGi 번툴 리포지토리톨 이용하는 경우

(dependency)
(groupld)org .springframework(/groupld)

〈어arπtif염ac다tld
)o
rg.springframework.core(/artifact
ld
)

(version)3.0.7.RELEASE(/version)
(/dependency)


g잠-스프링 프로젝트 시ξh하기 781


스프링소스의 리포지토리에서는 스프링 모률 외의 일반 의존 라이브러리도 제공해
준다. 물론 Ivy에서도 이용할 수 있다. 자세한 정보는 리포지토리 웹사이트(http:
//www
springsource. com
/때ository
/app
f)를 참고하기 바란다.

91'] 애플리케이션 아키텍처 편 l

클라이언트와 백엔드 시스템의 종류와 사용 기술， 연동 방법을 결정했다면 시스댐 레벨

의 아키텍처는 대략 구성된 셈이다. 다음으로 결정할 사항은 스프링 웹 애플리케이션의

아키텍처다.

아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어다. 가장 단순한 정의

를 보자면 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고， 어떤 방식으

로 서로 관계를 맺고 동작히는지를 규정히는 것이라고 할 수 있다. 아키텍처는 단순히

정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로는 그 구조에서 일어나는 동

적인 행위와 갚은 관계가 있다.

9.3.1 계층형 아키텍처
관심， 책임， 성격， 변하는 이유와 방식이 서로 다른 것들을 분리함으로써 분리된 각 요
소의 응집도는 높여주고 서로의 결합도를 낮춰췄을 때의 장점과 유익이 무엇인지 살펴
봤다. 성격이 다른모률이 강하게 결합되어 한데 모여 있으면한가지 이유로변경이 일
어날때 그와상관이 없는요소도함께 영향을받게 된다. 따라서 불펼요한부분까지 변
경이 일어나고 그로 인해 작업은 더뎌지고 오류가 발생할 가능성이 높아진다. 어느 부
분을 수정해야 할지를 파악하기도 쉽지 않다. 따라서 인터페이스와 같은 유연한 경계를
만들어두고분리하거나모아주는작업이 필요하다.

아키텍처와SoC
지금까지는 주로 오브젝트 레벨에서 이런 분리의 문제에 대해 생각해봤다. 성격이 다른
코드가 얽혀 있는 것을 두 개의 오브젝트로 분리하고， 그 사이에 유연한 결합을 가질 수
있도록 인터페이스를 두고 그 관계를 맺어주는 제3
의 존재인 DI 컨테이너를 둬서 오브
젝트끼리는 직접적인 관계를 알지 못하도록 만드는 것이 지금까지 해옹 DI를 기반으로
한 유연한 설계와 구현 전략이었다.


이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다.
오브젝트를 하나의 모률 단위라고 생각해보자. 때론 그보다 작은 단위， 예를 들면 하나
의 클래스 안에 있는 메소드 레벨에서도 같은 원리를 적용할 수 있다. 심지어 하나의 메
소드 안의 코드에도 같은 방식의 접근이 가능하다. 반대로 모률의 단위를 크게 확장해
볼수도있다.

애플리케이션을 구성히는 오브젝트들을 비슷한 성격과 책임을 가진 것들끼리 묶을
수 있다. 예를 들면 데이터 액세스 로직을 담당하는 DAO들은 하나의 단위로 생각해도
좋다. 어떤 DAO든 비슷한 성격을 띠고 유사한 방식으로 다른 오브젝트와 관계를 갖는
다. 또 비즈니스 로직을 구현해놓은 비즈니스 서비스 오브젝트들도 같은 성격으로 묶을
수 있다. 서비스 오브젝트들은 특정 기술과 환경에 종속되지 않으면서 도메인의 업무
에는 밀접하게 관련을 갖고 있는 POJO로 만들어진다. 주로 DAO를 이용해 정보의 저
장과 검색 등을하고，
DB
의 엔티티 모댈과유사한도메인 오브젝트를 이용해 데이터를
저장하고 가공하고 주고받는다. 아직 다루진 않았지만 웹을 처리히는 코드 또한 독자적
인 성격으로 분류가 가능하다. 서블릿 컨테이너로부터 받은 사용자의 요청정보를 해석

해서 그것을 POJO 기반의 서비스 오브젝트에 전달해주고， 결과를 받아서 다시 웹 사용

자 인터페이스에 표시 가능한 형태로 변환해주는 일을 한다.

이렇게 애플리케이션의 오브젝트들은 다시 유사한 성격을 띤 그룹으로 나눌 수가 있
다. 만약 이렇게 나뉘어 있지 않다면 어떻게 될까? DB에서 정보를 어떻게 가져오는지
에 대한 로직을 담은 SQL과， JDBC 코드와 HTML 태그 사이에 읽어온 정보를 넣는 코
드가 함께 존재할 수도 있다. 성격과 책임이 분명히 다른 것들이 한데 모여 얽혀 있으
면 많은 문제가 발생한다. JSP만으로 웹 애플리케이션을 작성해본 경험이 있는 사람이
라면 이런 문제점을 잘 알고 있을 것이다. 테이블을 어떻게 그리는지를 <table> 태그로
작성하다가， 업무 로직에 따라 값을 계산하기 위해 <% if %> 문을 넣었다가，
DB 접속
을 위해 <% getConnection( ... ) %>을 써서 커넥션을 가져오고 SQL도 적고， 결과에 따
라서 다른 화면으로 넘어가게 하는 조건도 달고... 급한 마옴에 일단 동작은 하도록 어
떻게 해서든 만들기는 했지만 나중에 자신이 만든 코드도 다시 손대기 싫을 만큼 지저
분한 것을 보고는 차라리 다시 작성하는 편이 빠르겠다고 생각했을지 모르겠다.

그래서 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다. 이렇게 분리된 각
오므젝트는 독자적으로 개발과 태스트가 가능해서 개발과 변경 작업이 모두 빨라질 수
있다. 또 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연

g앙-스프링 프로전!트 시ξh하기 783


하다. 전체를 이해하기도 상대적으로 쉽다. 물론 아주 간단한 Hello World 정도의 프로
그램이라면 JSP 하나에 모아놓고 만드는 게 더 쉬울지 모르지만， 제대로 된 게시판 하
나만 만들려고 해도 적절한 분리는 필수다.

이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처
차원에서는 계층형 아키택처
layered architecture라고 부른다. 또는 계층이라는 의미를 가진
영어 단어인 티어
tier를 써서 멀티 티어 아키텍처라고도 한다. 보통 웹 기반의 엔터프라이

즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 3겨계|총
(3



카매


A


UUUμHUU

그림 9--133계충 아키텍처

빠l

1.
리케이션이라고도 한다.

물론 반드시 모든 엔터프라이즈 애플리케이션을 3계층으로 만들어야만 하는 것은 아
3계층 아키텍처는 백엔드의 DB나 레거시 시스탱과 연동히는 인터페이스 역할을 하
는 데이터 액세스DataAccess 계층， 비즈니스 로직을 담고 있는 서비스 계층， 주로 웹 기
반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다. 그런데
이 3계층 아키텍처의 각 계층을 부르는 이름은 워낙 다양해서 때론 혼란스러울 수도
있다. 각각 의미가 있는 이름이기 때문에 모두 기억해두고 사용히는 것이 좋다. 그림
9-]3은 3계층 아키택처의 구조와 그 이름을 보여준다.
껴U

니다. 경우에 따라서 전통적인 3
계층 방식이 아닌 다른 구분 방법을 선택하기도 한다.
또 각 계층을 좀 더 세분화해서 더 작은 단위의 계층으로 나눌 수도 있다. 하지만 전형
적인 웹 엔터프라이즈 애플리케이션은 책임과 성격으로 보자면 일단 3
계층의 논리적인
분류가 기능하다. 그것을 물리적으로 또는 전략적으로 세분화하거나 또는 더 결합시켜
서 만들 수도 있기는 하지만 그래도 각기 다른 세 가지 특성을 가진 코드의 분류는 여전
히유효하다.

3겨|층 아키텍처와 수직 계층

hμνH


륭져1

뼈

폐

뱀

뺨

따

따

#샘

뺑

직

뿌

스

j

비서

」
스

때

젠

비

매

뺑

셰」
이

뺀

빼

뺑

웹

뺑

프

M

비



• 데이터액셰스겨|총
데이터 액세스 계층은 DAO 계층이라고도 불린다. DAO 패턴을 보편적으로 시용하
기 때문이다. 또한 데이터 액세스 계층은 DB 외에도 ERP, 레거시 시스템， 메인프레
임 등에 접근하는 역할을 하기 때문에 EIsEnterprise Information System 계층이 라고도 한

다. 하지만 대개는 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임이
다. 또 외부 시스템을 호출해서 서비스를 이용하는 것은 기반~nfrastructure 계층으로 따
로 분류하기도 한다. 따라서 이 책에서는 데이터 액세스 계층이라고 부르겠다.

데이터 액세스 계층은 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있
다. 애플리케이션에서 담당하는 역할에 따라 분류한 3
계층 구조와 달리， 데이터 액
세스 계층 안에서 다시 세분화히는 경우는 추상화 수준에 따른 구분이기 때문에 수
직적인 계층이라고 부르기도 한다. 기본 3
계층은 기술 계층보다는 역할에 따라 구
분한 것이므로 보통 그림으로 나타낼 때도 가로로 배열한다. 반면에 같은 책임을 가
졌지만 추상화 레벨에 따라 구분하는 경우는 세로로 배열해서 표현한다. 스프링의
JdbcTemplate을 사용히는 DAO 계층이라면 그림 9-14와 같이 나타낼 수 있다. 이
렇게 계층이라는 말은 각각 다른 의미와 상햄서 쓰일 수 있으니 문맥에 맞게 적절
한 의미로 이해해야 한다.

DAO 코드
4 추상화
레벨
높음
JdbcTemplate
스프링이추 }
한추상
계층 이 계
층이있기 문에 DA。쿄드는 직 JDBC 트랜잭션 동기화
접
JDB
나 랜잭선 동기회계층의
API를사용할 필요가없다
DataSource • 추싱화레벨낮음
그림 9-14 데이터 액서|스 계충의 수직 계층구조

JdbcTemplate을 사용히는 데이터 액세스 계층의 특정은 JdbcTemplate
이 추상화를
위한 계층으로 사용돼서 로우레벨의 기반 계층에 존재하는 JDBC와 드라이버， 스프
령의 트랜재션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다는 것이
다. 물론 JdbcTemplate
이 있어도 DAO 코드에서 강제로 JDBC API를 직접 이용하
거나 트랜잭션 동기화 API
에 접근하는 것이 불가능하진 않다. 하지만 추상화 계층구
조를 따른다면 항상 JdbcTemplate을 통해 접근하도록 코드를 작성하는 것이 바람직
하다. 추상화 계층은 펼요하다면 얼마든지 추가할 수 있다. 만약 JdbcTemplate
의 기
능과 7장에서 만들었던 SqlService
의 SQL을 가져오는 기능을 묶어서 더 단순한 방
법으로 DAO 코드를 작성하고 싶다면 또 하나의 추상 계층을 추가할 수 있다. 그림

9징-스프링 프로젝트 시ξh하기 785



9-15는 이렇게 새로운 추상 계층을 도입해서 하위 계층의 종류가 다른 서비스를 일
관된 방식으로 접근할 수 있게 만들어주는 구조다.

DAO 코드
S뼈e이lCe와 JdbcTemp~e을 통합해서
SimpleJdbcLayer --+ 손쉽게 사용할 수 있도록 새로운 추상
JdbcTem
빠e l SqlService API
계충을추가했다

그림 9-15 두 개 이상의 서비스를 통합하는 추상 계충의 도입

이렇게 새로운 계층을 추가하면 개발자의 애플리케이션 코드에 지대한 영향을 주기
때문에 매우 신중하게 결정해야 한다. 한번 새로운 계층과 API를 만들어 적용하면
이를 최대한 유지할 수 있도록 하위 계층의 변화에 대응해야 하는 책임도 갖게 된다.
DAO 코드의 시용 패턴을 개발팀 또는 프로젝트 수준에서 잘 분석하고 정리할 수 있
다면 새로운 추상 계층의 도입을 고려해볼 만하다. 만약 추상 계층을 새로 추가하는
것은 부담스럽고 경우에 따라서 유연하게 하위 계층의 API를 활용할 필요가 있다면，
공통적인 기능을 분리해서 유틸리티나 헬퍼 메소드 또는 오브젝트로 제공해주는 것
도 좋은 방법이다. 이때는 하위 계층과 공통 기능의 사용 방법에 대한 가이드라인이
나 코딩 정책이 잘 만들어져서 개발자에게 제공될 필요가 있다.

• 서비스겨|총
서비스 계층은 구조로 보자면 가장 단순하다. 잘 만들어진 스프링 애플리케이션의
서비스 계층 클래스는 이상적인 POJO로 작성된다. POJO로 만든다면 객체지향적
인 설계 기법이 적용된 코드를통해서 비즈니스로직의 핵심을잘담아내고， 이를쉽
게 테스트하고 유연하게 확장할 수 있다. 서비스 계층은 DAO 계층을 호출하고 이
를 활용해서 만들어진다. 때론 데이터 액세스를 위한 기능 외에 서버나 시스템 레벨
에서 제공하는 기반 서비스를 활용할 필요도 있다. 예를 들어 웹 서비스와 같은 원격
호출을 통해 정보를 가져오거나 메일 또는 메시징 서비스를 이용하는 것이 대표적인
예다. 이런 기반 서비스는 3
계층 어디에서나 접근이 가능하도록 만들 수도 있고， 아
키텍처를 설계하기에 따라서 반드시 서비스 계층을 통해 시용되도록 제한할 수도 있
다. 코드의 특정과장단점 활용예를잘살펴서 결정하면 된다.
서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없
다. 단순히 POJO 레벨에서 비즈니스 로직을 모델링하다가 상속구조를 만들 수 있을
진 몰라도 기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일관된 방식으로


접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 때문이다. 기반 서비
스 계층을 사용하는 경우에도 데이터 액세스 계층을 사용하는 경우와 마찬가지로 독
립된 계층의 서비스를 이용하는 것으로 봐야 한다. 비즈니스 로직을 담은 서비스 계
층과 엔터프라이즈 서비스를 제공하는 기반 서비스 계층은 이름 때문에 혼동되기 쉬
우므로주의하자.

그림 9-16은 서비스 계층과 기반 서비스 계층 DAO 계층의 관계를 나타낸 것이
다. 여기서는 기반 서비스 계층이 3
계층 어디에서나 접근이 가능한 구조로 설정했다.
여기서 눈여겨봐둘 것은 기반 서비스 계층이 서비스 계층의 오브젝트를 호출히는 경
우다. 일반적으로는 서비스 계층이 필요에 따라 기반 서비스 계층의 AP1를 호출해
서 이용한다. 하지만 반대로 서비스 계층의 코드를 기반 서비스 계층에서 실행시키
는 경우가 있다. 스케줄링이 대표적인 경우다. 미리 정해진 시간에 특정 서비스 계층
의 로직이 동작하게 만드는 백그라운드 서비스가 필요하다면 그때는 기반 서비스 계
층에서 서비스 계층의 오브젝트를 이용하게 할 수도 있다.

원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 된다. 서
비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들
어서 특정 구현과 기술에 대한 종속성을 제거해야 한다. 또는 AOP를 통해서 서비
스 계층의 묘드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 한다.

서비스 계증
데이터 액셰스 계증

기반 서비스 계증
(트랜잭션， 보안， 리모팅， 메일， 메시징， 스케줄링 )


그림 9--16 서비스 계충과 기반 서비스 계층

이상적인 서비스 계층은 백엔드 시스뱀과 연결되는 데이터 액세스 계층이 바뀌고，
클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어
야 한다. 엔터프라이즈 애플리케이션에서 가장 중요한 자산은 도메인의 핵심 비즈니
스 로직이 들어 있는 서비스 계층이어야 한다.

프레젠테이션계충

프레젠테이션 계층은 가장 복잡한 계층이다. 프레젠테이션 계층은 매우 다C램 기술

과 프레임워크의 조합을 가질 수 있다. 웹과 프레젠테이션 기술은 끊임없이 발전하

고 진보하고 새로운 모댈이 등장하기 때문이다. 따라서 프레젠태이션 계층에서 사용

9장-스프링 프로젝트 시ξt하기 787



할 기술과 구조를 선택하는 일은 간단하지 않다. 엔터프라이즈 애플리케이션의 프레
젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿
이 바탕이 된다. HTTP 외의 프로토콜을 사용하는 엔터프라이즈 서비스가 전혀 없는
것은 아니지만， 방화벽 문제라든가 통합된 보안의 문제 등으로 인해 HTTP로 모두
수렴되는추세다.

단순한 HTML과 자바스크립트만을 사용하는 브라우저이든， 다운로드돼서 브라
우저의 플러그인 오베서 동작하는 플래시 애플리케이션이나 액티브X 기반의 애플리
케이션이든， 닷넷으로 만든 독립형 애플리케이션이든， RESTful 스타일의 클라이언
트 또는 WS-* 방식의 웹 서비스 클라이언트든 상관없이 대부분의 엔터프라이즈 애
플리케이션을 사용히는 클라이언트들은 HTTP 프로토콜을 선호한다. 따라서 이런
클라이언트와 연결돼서 동작하는 프레젠테이션 계층은 자바에서 HTTP 프로토콜을
처리히는 가장 기본 엔진이 서블릿 기술을 바탕으로 한다.

프레젠테이션 계층은 다른 계층과 달리 클라이언트까지 그 범위를 확장될 수도
있다. 초기 클라이언트 모댈은 단순히 HTML로 만들어진 결과를 사람이 볼 수 있도
록 그려주고， 폼을 통해 입력받은 값을 전달하는 것이었다. 모든 프레젠테이션 로직
은 서버의 프레젠테이션 계층의 컴포넌트에서 처리된다. 화면 흐름을 결정하는 것이
나 사용자 입력 값에 대한 검증， 서비스 계층의 호출과 전달되는 값의 포뱃의 변화，
뷰Vlew라고 불리는 화면을 어떻게 그릴지에 대한 로직 등이 모두 서버에서 처리됐다.
이때의 클라이언트는 단순히 서버 프레젠테이션 계층의 기능에 대한 사용자 인터페
이스에 불과했다. 하지만 최근에는 점점 많은 프레젠테이션 로직이 클라이언트로 이

동하고 있다. RIARich Internet Application라고 불리는 기술이나 SOFEAService Oriented

Front End Architecture 아키텍처가 대표적인 예다.

스프링은 웹 기반의 프레젠테이션 계층을 개발할 수 있는 전용 웹 프레임워크를
제공한다. 동시에 스프링은 다oJ=한 서드파티 웹 기술을 지원하기도 한다. 아예 프레
젠테이션 계층을 통째로 스프링이 아닌 다른 웹 기술을 가져다 시용할 수도 있다. 스
프링 애플리케이션에 적용할 수 없는 웹 기술은 없다고 봐도 좋다. 심지어 JSP를 사
용히는 모델 l을 시용할 수도 있으니 말이다.

계층형 아키텍처 설계의 원칙

오브젝트와 그 관계에 적용했던 대부분의 객체지향 설계의 원칙은 아키텍처 레벨의 계

층과 그 관계에도 동일하게 적용할 수 있다. 각 계층은 응집도가 높으면서 다른 계층과

는낮은결합도를유지할수있어야한다.


각 계층은 자신의 계층의 책임에만 충실해야 한다. 데이터 액세스 계층은 데이터 액
세스에 관한 모든 것을 스스로 처리해야 한다. 데이터 액세스 계층에 비즈니스 로직을
담거나 웹 파라미터를 파싱하는 코드나 결과를 화면에 어떻게 뿌릴지 결정히는 묘드가
들어간다면 응집도가 낮아진다. 결과적으로 변화에 대한 유연성이 떨어지고 이해하기
힘든 코드를 가진 계층이 되고 말 것이다. 각 계층은 자신의 역할에만 충실해야 하고 자
신과 관련된 기술이 아닌 다른 기술 API
의 사용을 삼가해야 한다.

자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게
낮아진다. 각 계층이 자신의 책임에 충실하게 작성되어 있다면 필요한 그 밖의 작업은
다른 계층에 요청하게 될 것이다. 이때는 계층 레벨에 정의한 인터페이스를 통해서 요
청을 하게 되고， 계층 간에 사용되는 인터페이스 메소드에는 특정 계층의 기술이 최대
한 드러나지 않게 만들어야 한다. 그렇지 않으면 계층 사이에 결합도가 높아질 뿐만 아
니라， 계층 간의 기술이나 역할이 서로 침범히는 일이 일어난다.

종종 실수하는 계층 간 설계의 예를 살펴보자. 다음은 서비스 계층이 DAO를 호출할
때 시용하도록 정의한 인터페이스의 메소드다.

public ResultSet findUsersByName(String name) throws SQLException;

findUsersByName() 메소드의 문제는 데이터 액세스 계층의 기술과 그 역할을 다른
계층에 노출한다는 점이다. 결과를 JDBC
의 ResultSet 오브젝트로 돌려주면 이를 사용
하는 서비스 계층의 코드는 ResultSet
이라는 데이터 액세스 계층에서 만들어진 오브젝
트를 직접 다뤄야만 한다. 결국 JDBC
라는 특정 데이터 액세스 계층 기술에 종속되는
서비스 계층의 코드가 되고 만다. 또한 ResultSet을 다룰 때 발생하는 예외처리도 필요
하고， 경우에 따라서는 리소스를 반환하거나 08 커넥션을 종료시키는 등의 데이터 액
세스 작업도 맡아야 한다.

예외도 마찬가지다. 앞에서 살펴봤듯이 SQLException
이라는 JDBC 기술 종속
적인 예외를， 그것도 체크 예외로 던져버리면， 이를 사용하는 서비스 계층에서는
SQLException을 해석해서 예외상황을 분석하고 이를 처리하는 코드를 만들어야 한다.
특정 데이터 액세스 계층의 구현에 종속되는 강한 결합이 만들어진다.

계층 간에 강한 결합이 생기면 유연성이 떨어지기 때문에 각 계층의 내부 구현이 변
화되면 다른 계층의 묘드도 함께 수정해줘야 한다. 또한 코드의 중복이 일어날 가능성
이 높고 전체 묘드를 이해하기는 힘들어진다. 오브젝트 간의 강한 결합이 있을 때 발생
하는 문제와 성격이 유사하고 그 파장은 훨씬 심각하다. 계층에는 수많은 오브젝트가

9징-스프링 프로젝트 시ξh하기 789


있고 그 오브젝트가 다른 계층의 오브젝트와 어떻게 관계를 맺는지에 대한 일반적인 규
칙이 있기 때문이다.
앞의 DAO 인터페이스의 메소드는 다음과 같이 수정돼야 한다.

public list<User> findUsersByName(String name) throws DataAccessException;

User는 사용자 정보를 담고 있는 단순한 오브젝트다. 따라서 특정 계층의 기술이나
구현에 종속되지 않는다. 결과는 이렇게 특정 계층에 종속되지 않는 단순한 오브젝트의
형태로 전달해야 한다. 또 데이터 액세스 예외와 같이 특별한 경우에만 전달될 기능성
이 있는 것은 스프링의 DataAccessException처럼 런타임 예외로 만들어야 한다. 그래
서 대개는 그 존재를 무시해도 되도록 만들어야 한다. 특별한 이유로 데이터 액세스 예
외를 다뤄야 히는 경우에라도 1OBC , lPA, 100, 하이버네이트처럼 특정 구현 방식에
종속되지 않는 추상적인 형태로 만들어줘야 한다. 그렇게 해야만 낮은 결합도를 유지할
수 있고유연한변경이 가능해진다.

또， 흔히 저지르는 실수 중의 하나는 프레젠테이션 계층의 오브젝트를 그대로 서비
스 계층으로 전달하는 것이다. 서블릿의 HttpServletRequest나 HttpServletResponse
HttpSession 같은 타입을 서비스 계층 인터페이스 메소드의 파라미터 타입으로 사용하
면안된다. 계층의 경계를넘어갈때는반드시 특정 계층에종속되지 않는오브젝트형
태로변환해줘야한다.

만약 서비스 계층의 코드에 웹 프레젠테이션 계층의 기술을 노출했다고 해보자. 웹
방식의 클라이언트가 아닌 다른 시스뱀에서 요청을 뺨f서 처리해야 하는 경우에는 웹
기술에 종속된 코드는 재사용이 불가능해진다. 결국 같은 로직을 가졌지만 클라이언트
의 종류에 따라서 비즈니스 로직 코드가 달라지는 결과를 초래할 수도 있다. 서비스 계
층에서 웹과 관련된 예외가 발생할 수도 있다. 이때 문제의 원인을 찾기가 어려워지기
쉽다. 더 큰 문제는 테스트다. 서비스 계층에 웹 관련 오브젝트가 존재하면 P010 기반
의 빠르고 간단한 단위 태스트를 작성하기 힘들어진다.

어떤 경우에라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다. 당연
히 계층 사이의 호출은 인터페이스를 통해 이뤄져야 한다. 인터페이스를 하나 더 만드
는 것이 번거롭다고 그냥 클래스를 이용해서는 안 된다. 인터페이스를 사용하게 한다는
건 각 계층의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는 의미다. 여기서 말
하는 인터페이스란 단지 자바의 interface 키워드를 사용하라는 의미가 아니다. 인터
페이스에 아무 생각 없이 클래스의 모든 public 메소드를 추가한다면 인터페이스를 사
용하는 가치가 떨어진다. 한번 정의돼서 다른 계층에서 사용하기 시작한 엔터페이스 메


소드는 변경이 매우 까다롭고 비용이 많이 든다. 따라서 매우 신중하게 결정해야 하며

계층 내부의 예상되는 변화에도 쉽게 바뀌지 않도록 주의해서 만틀어야 한다. 당연히

다른 계층에서 꼭 필요한 메소드만 노출해야 한다.

스프링의 DI는 기본적으로 오브젝트 사이의 관계를 다룬다. 따라서 계층 사이의 경

계나 그 관계에 직접적으로 관여하지 않는다. 하지만 모든 경계에는 오브젝트가 존재하

고 그 사이의 관계도 오브젝트 대 오브젝트로 정의되기 마련이다. 그런 면에서 스프링

의 DI
가계층사이의 관계에도 적용된다고볼수 있다. 하지만
DI는 계층을구분해주지

않기 때문에 빈 사이의 의존관계를 만들 때 주의해야 한다. 한 계층의 내부에서만 사용

되도록 만든 빈 오브젝트가 있는데 이를 DI를 통해 다른 계층에서 함부로 가져다 쓰는

일은 피해야 한다는 말이다. 또， 중간 계층을 건너뛰어서 관계를 갖지 않는 계층의 빈을

직접 DI 하지 않도록주의해야한다.

9.3.2 애플리케이션 정보 아키텍처
엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스댐
이다. 사용자의 작업 상태를 오래 유지할 수 있는 독립 애플리케이션과 달리 엔터프라
이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유
지한다. 애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스랩에 분산돼서 보
관된다. 비교적 장기간 보관되는 상태정보는 주로 DB나 메인프레임 같은 EIS 백엔드
시스랩에 저장된다. 하나의 업무 작업이 여러 번의 요청과 페이지에 걸쳐 일어나는 경
우에 유지돼야 하는 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고 서버
의 사용자별 세션 메모리에 저장되기도 한다.
이렇게 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정
히는 일도 0
]-7
1
텍처를 결정할 때 매우 중요한 기준이 된다. 엔터프라이즈 애플리케이션
에 존재히는 정보를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우， 두 가지
기준으로 구분해볼 수 있다.
데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담
기 위한 목적의 오브젝트 형태로 취급히는 구조다
DB나 백엔드 시스랩에서 가져옹 정
보를 값으로 다루고 그 값을 취급하는 묘드를 만들어 로직을 구현하고 값을 그대로 프
레젠태이션 계층의 뷰， 즉 사용자가 보는 화면과 연결해주는 것이다.
이런 방식은 객체지향 기술이나 언어를 사용하지 않던 시절의 엔터프라이즈 애플리
케이션과 크게 다를 바 없다. 데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의

~-스프링 프로젝트 시ξt하기 791


저장 프로시저나 SQL에 담겨 있는 경우가 많다는 점이다. 보통 DB에서 돌려주는 내용
을 그대로 뱀이나 단순 결과 저장용 오브젝트에 넣어서 전달한다. DB 결과 값을 시용
하는 일부 비즈니스 로직이 서비스 계층에 존재하기도 하고 아무런 가공 없이 그대로

프레젠테이션 계층에 전달되어 사용자에게 보이기도 한다.
데이터 중심 아키텍처는 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB oJl
무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분할 수 있다.

DB/SQL 중심의 로직 구현 방식
데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향

이 있다는 점이다. 예를 들어 사용자의 이름으로 사용자 정보를 검색해서 일치하는 사
용자의 아이디， 비밀번호， 이름， 가입일자만을보여주는작업이 있다고하자. 이것이 하
나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어진다. 사용자 조회
라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다는 뭇이다.

검색조건은 SQL로 만들어진다. 사용자 정보를 웹 페이지에 나타낼 때 가입일자 중
에서 연도만 보여줘야 한다면， 가입일자 필드에서 연도를 추출하는 것은 SQL의 날짜처
리 펑션을 이용해야 한다. 그래야 SQL의 결괴를 그대로 웹 페이지의 정보 필드에 1:1
로 매핑해서 넣어줄 수 있기 때문이다. 결국 SQL은 이미 화변에 어떤 식으로 출력이 될

지알고있는셈이다.

SQL의 결과는 컬럼 이름을 키로 갖는 랩에 저장되거나 조회 페이지에 필요한 네 가
지 정보를 담을 수 있는 단순한 오브젝트를 저장돼서 전달된다. 서비스 계층은 별로 할
일이 없다. 프레젠테이션 계층의 JSP 뷰는 DAO의 SQL에서 정확히 어떤 펼드 값을 리
턴할지， 어떤 포뱃으로 전달할지 알고 있다. SQL의 SELECT 절에 나오는 컬럼 이름을
그대로 사용해서 전달된 랩이나 결과를 저장히는 오브젝트에서 값을 가져와 화면에 출
력한다. 만약 새로운 필드가 추가되거나 DB 태이블의 컬럼 이름이 변경됐다면， 그에
따라서 뱀이나 오브젝트에 저장될 엔트리 또는 프로퍼티 이름이 바뀌거나 추가될 것이

고그에 맞게 뷰의 내용도 변경된다.

모든 계층의 코드는 ‘이름을 이용한 고객 조회’라는 업무에 종속된다. 또한 업무의 내
용이 바뀌면 모든 계층의 코드가 함께 변경된다. 종속적일 뿐 아니라 배타적이어서 다
른 단위 업무에 재시용되기 힘들다. 유사한 방법의 사용자 조회용 DAO 메소드라도 화
면에 나타날 정보가 다르면 SQL
이 달라지기 때문에 새로 만들어야 한다.

대용량 데이터를 다루면서 빠른 처리가 필요한 경우에는 일부 로직을 DB 내에 존재


하는 PL/SQL과 같은 저장 프로시저 형태로 만들기도 한다. 조회 로직이 조건이 많고
복잡하다면 그만큼 복잡한 SQL이 만들어질 것이다. 자바 코드의 로직은 기껏해야 사용
자 요청에 따라서 어떤 SQL을 가진 DAO를 실행할지를 결정히는 정도일 것이다.

대부분의 코드는 대응되는작업 단위에 1 : 1
로 매핑된다. 여러 작업에서 반복되는 기
능이 었다면 그에 대한 코드는 중복되기 쉽다. 보통 작업 단위， 즉 업무 트랜잭션 단위
로 묘드를 묶어서 만들지 기능을 세분화해서 분리하고 재사용하지 않기 때문이다. 하나
의 업무 트랜잭션을 모두 담은 서비스 계층 코드와 해당 업무에 특화된 SQL을 담은 하
나 또는 여러 개의 DAO 메소드로 구성된다. 서비스 계층이 프레젠테이션 계층에 전달
하는 결과의 포뱃은 보통 DAO의 SQL 결과와 같고， 웹 페이지의 출력 내용과도 1: 1로
대응된다. 그림 9-17은 이런 방식의 아키텍처 구조를 나타낸다.

프레젠테이션 계층

•

「

하나의 업무 트랜잭션에 침여하는 코
드가 일괄적으로 만들어진다 대부분
재사용이 불가능하다 이동하는 정보
하나 또는 그 이상의 SQL을 호출하는
것이 대부분인 통짜 업무 트랜잭션이
다. DAO의 결과툴 그대로 조회 회연
주요 비즈니스 로직은 SOL괴 DB에 존재
한다 애플리
케이션의 핵심이 SOL괴 DB
는 대부분 잃L 결과를 담은 단순 데 으로 전달하는 경우기 대부문이다. 독
안에서 실행되는 저징 프로시저에 담겨
이터다 립적인 테스트가 불가능하고 존재의
있다 애툴리케이
션은 DB에 대한 인
터메
미가
별로없다
이스역할로제한된다

그림 9-17DB 중심의 아키텍처

이런 식의 개발 방법과 아키텍처는 사실 자바 기술이 발전하기 이전의 엔터프라이즈 시
스댐에서 흔히 발견할 수 있다. 굳이 자바라는 객체지향 언어와 프로그래밍 기
술을 사

용하지 않더라도
3
계층구조로만드는전통적인 개발방법에서， 또는
서비스계층이 별
의미가 없으므로 주요 로직을 클라이언트의 독립 프로그램에 담아두고 DB 처리 로직만
DB에 분리해둔 2계층 구조에서도 비슷하게 발견할 수 있다.

이런 방식은 개발하기 쉽다는 장점이 있다. 적어도 처음에는 그렇다. 대부분의 개발
자는 이미 복잡한 로직을 SQL로 작성하는 데 익숙하다. 계층으로 세분화되기는 하지만
업무 트랜잭션， 또는 요구사항별로 구분해서 코드로 만드는 건 쉽다. 각 업무의 핵심을

담은 SQL을 중심으로 DAO부터 사용자가 보는 화면까지 한 벌씩 만들면 되기 때문에

툴이나 코드 생성기를 이용해서 자동화하는 데도 유리하다.

하지만 이런 방식은 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이
스 도구로 전락시키는 것이다. 자바의 오브젝트는 단지 HTTP 서비스 채널을 만들어주
고 JDBC를 이용해 DB 기능을 사용하게 히는 스크립트 정도로 역할이 축소된다. 굳이

g앙-스프링 프로젝트 시ξh하기 793



자바를 쓰지 않고 전통적인 언어나 단순한 스크립트 언어 또는 DB 등에서 제공히는 툴
로 대치하더라도 별 차이가 없을 것이다.

이렇게 DB 중심의 업무 단위로 코드를 만들면 애플리케이션 내에서 흘러다니는 정
보는 항상 단순한 포뱃의 데이터다. 간혹 펼요하다면 SQL의 결과로 가져옹 데이터를
분석하거나 조작히는 간단한 비즈니스 로직을 추가할 수는 있다. 하지만 이런 코드는
항상 SQL과 그 결과에 종속되기 때문에 SQL의 변화가 일어나면 같이 변경돼야 한다.
겉으로 보기에는 각 계층이 독립적으로 보이지만 그 사이를 이동하는 데이터가 일종의
접착제 역할을 해서 강한 결합을 만들게 된다.

스프링을 사용하면 이런 데이터 중심의 코드를 만들 수 있을 뿐만 아니라， 실제로
매우 흔하게 발견된다. 데이터와 업무 트랜잭션 중심의 개발에 익숙한 사람들이 많고
이런 아키텍처를 의도적으로 선호히는 개발자도 많기 때문이다. 개발자들끼리 서로 간
섭 없이 자신에게 할당된 기능을 독립적으로 만드는 데도 편하다. 최소한의 공통 모률
정도만 제공되는 것을 사용하고 그 외의 기능은 단위 업무 또는 웹 화면 단위로 만들
어진다.

하지만 이런 개발 방식은 변화에 매우 취약하다. 객체지향의 장점이 별로 활용되지
못히는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다. 중복을 제거하기도
쉽지 않다. 업무 트랜잭션에 따라 필드 하나가 달라도 거의 비슷한 DAO 메소드를 새
로 만들기도 한다. 또한 로직을 DB와 SQL에 많이 담으면 담을수록 점점 확장성이 떨
어진다. DB는 확장에 한계가 있을 뿐 아니라 확장한다 하더라도 매우 큰 비용이 든다.
잘 작성된 복잡한 SQL 하나가 수백 라인의 자바 코드가 펼요한 비즈니스 로직을 한
번에 처리할수도 있다. 하지만과연 바람직한 것일까? 이런 복잡한 SQL을누구나 쉽
게 이해하고필요에 따라유연하게 변경할수 있을까?또， 복잡한
SQL을처리하기 위
해서 제한된 자원인 DB에 큰 부담을 주는 게 과연 바람직한 일인지 생각해볼 필요가
있다.

상대적으로 애플리케이션 서버와 그 안에 담긴 오브젝트는 비용이 적게 든다. 서버
를 늘려 쉽게 확장할 수도 있다. 애플라케이션 서버의 비용은 매우 빠르게 하락하고 있
다. 또 손쉽게 여러 대의 서버를 클러스터로 묶어서 하나의 서버처럼 동작하게 만들 수
있다. 오브젝트를 만들고 코드를 동작시키는 비용은 DB
에서 비슷한 작업을 할 때에 비
해 저렴하다. 따라서 로직을 DB보다는 애플리케이션으로 가져오는 편이 유리한 점이
많다. 비용도 저렴해질 뿐 아니라 안정성도 높아지고 코드를 검증하기도 매우 면하다.

게다가. SQL이나 저장 프로시저에 담긴 로직은 태스트하기 힘들다. 반면에 오브젝


트에 담긴 로직은 간단히 검증할 수 있다. 또한 요즘 유행하는 객체지향 분석과 모댈링
의 결과로 나옹 모벨을 가져다 쉽게 오브젝트로 만들어낼 수 있다. 따라서 DB에는 부
하를 가능한 한 주지 않는 간단한 작업만 하고 복잡한 로직은 오브젝트에 담아서 애플
리케이션 내에서 처리하도록 만드는 편이 낫다. 애플리케이션 서버는 저렴한 비용으로
손쉽게 서버를추가할수 있다.

어쨌든 정치적이거나 현실적인 문제로 인해 이런 아키텍처와 접근 방법을 어쩔 수
없이 선택해야 히는 경우도 있겠지만 단지 익숙하고 편하다는 이유로 스프링 애플리케
이션 개발에도 여전히 DB 중심의 아키텍처를 선택한다면 스프링의 장점을 제대로 누릴
수 있는 기회를 얻지 못할 것이 분명하다.

거대한서비스계층방식
DB에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이
긴 하지만 DB
에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의
비중을 높이는 방법이 있다. DB에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자
제하고 복잡한 SQL을 피하면서， 주요 로직은 서비스 계층의 코드에서 처리하도록 만드
는것이다.
여전히 SQL의 결과를 그대로 담고 있는 단순한 오브젝트 또는 랩을 이용해 데이터
를 주고받는다. 대신 많은 비즈니스 로직을 DB의 저장 프로시저나 SQL에서 서비스 계
층의 오브젝트로 옮겨왔기 때문에 애플리케이션 코드의 비중이 커진다. 그만큼 구조는
단순해지고 객체지향 개발의 장점을 살릴 기회가 많아진다.
비즈니스 로직을 DB나 SQL에 담는 경우에는 항상 최종 결과만 DAO에서 서비스
계층으로 전달된다. 반면에 거대 서비스 계층 방식에서는 DAO에서 좀 더 단순한 결과
를 톨려준다.DAO가 돌려준 정보를 분석， 가공하면서 비즈니스 로직을 적용하는 것은
서비스 계층 코드의 책임이 된다.DAO와 SQL은 상대적으로 단순해지고， 그중 일부는
여러 서비스 계층 코드에서 재사용이 가능해진다.
비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다. 업무
트랜잭션 단위로 서비스 계층의 메소드가 만들어질 가능성이 높은데， 그러다 보면 하나
의 메소드가 매우 거대해지기도 한다. 이를 여러 메소드로 분산시킨다면 메소드 크기는
상대적으로 줄겠지만 전체 클래스 코드의 양은 그대로다. 상대적으로 단순한 DAO 로
직을 사용하고， 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방법은
결국 거대한 서비스 계층.fat service layer을 만들게 된다. 데이터의 분석， 처리와 함께 비즈니

~-스프링 프로젝트 시ξh하기 795


스 로직의 대부분이 서비스 계층 코드에 집중되기 때문이다. 서비스 계층의 묘드는 여
전히 업무 트랜잭션 단위로 집중돼서 만들어지기 때문에 DAO를 공유할 수 있는 것을
제외하면 묘드의 중복도 적지 않게 발생한다.

그림 9-18은 거대 서비스 계층 방식의 아키텍처를 나타낸 것이다. 데이터 액세스 계
층이나 DB는 비즈니스 로직을 직접 담고 있지 않기 때문에 이전보다 훨씬 가벼워진다.
대신 DB가 몰려주는 데이터를 가지고 비즈니스 로직을 구현하는 서비스 계층이 매우
두터워진다.

프레젠테이션 계중

r""
t二二二二;
DAO훌 일부 재사용해서 핵심 로 딘슨 조회가 이니라연 DAO가 돌려주는 비즈니스 로직이 서
비스 계충에 존재하기 때
직올 구현하지만 여전히 특정 업무 값을 문석 또는 가공해서 비즈니스 로 문에 SQU에 복잡한 로직을 담을 필요는 없다
트랜잭션에 종속되는 데이터 구조 직을 만든다 로직이 POJO로 되어 있기 DB에 큰 부하률 주지 않는 단순한 형태로 조
톨갖기쉽다‘ 때문에 테스트가 용이한 편이디. 회해서 그 결과를 서비스 계흥에 전달해주기
만하면된다

그림 9-18 거대 서비스 계흥 방식의 아키텍처

거대 서비스 계층 방식의 장점은 애플리케이션의 코드에 비즈니
스 로직이 담겨 있기 때
문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기도 수월하다는 점이
다. 또한 DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 J:l로 매핑
되지 않아도 되기 때문에 일부 DAO 코드는 여러 비즈니
스 로직에서 공유해서 사용할
수있다.

하지만 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 펼요에 따라
만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다. 서비스 계층의 메소드는 크
기가큰 업무트랜잭션 단위로 만들어지기 때문에 비슷한기능의 코드가여러 메소드에
서 중복돼서 나타나기 쉽다. 자주 사용되는 세부 로직을 추출해서 공통 기능으로 뽑아
내는 일도 불기능하진 않지만 일반화하기는 힘들다. 그 이유는 DAO가 제공해주는 값
의 포뱃에 따라 이를 취급하는 방법이 달라지기 때문이다.

사용자 정보를 간단히 조작해주는 공통적인 기능이 있다고 하자. 그런데 어떤 비즈
니
스 로직에서는 DAO로부터 시용자 정보를 다른 정보와 조인해서 함께 랩에 담에 가
져오고， 또 어떤 로직에서는 사용자 정보 중 일부만 데이터 저장 오브젝트에 담아서 가
져온다고 해보자. 이런 경우 사용자 정보가 담겨 있는 포뱃과 타입이 다르기 때문에 공
통적인 사용자 정보 처리 기능을 만들어 사용하기가 힘들다. 비록 DAO에 복잡한 조건



의 로직을 넣지는 않더라도 서비스 계층에서 펼요한 정보를 한 번에 SQL을 통해 가져

오고， 그 값을 저장하는 방식이 일관성 없이 매번 달라질 수 있기 때문에 서비스 계층의

코드나 DAO에 적지 않은 중복이 발생히는 것이다.

반면에 각 단위 업무별로 독립적인 개발이 가능하므로 초기 개발 속도가 빠르고， 개

발자 사이에 간섭 없이 독립적인 개발이 가능하다는 장점이 있다. 또한 핵심 로직이 자

바 코드 안에 담겨 있으므로 테스트하기가 상대적으로 수월하다. 하지만 본격적인 객체

지향적 설계를 적용하기 힘들고， 개발자 개개인의 코딩 습관이나 실력에 따라서 비슷한

로직이더라도 전혀 다른 스타일의 코드가 나오기 십상이다. 개발 능력이 떨어지는 경우

에는 자바 코드로 구현한 비즈니스 로직이 복잡한 SQL보다 더 이해하기 힘들 수도 있

다. 또한 계층별로 독립된 설계와 개발이 어렵고， 개발이 진행되면서 구현할 비즈니스

로직이나 설계에 변경이 생기거나 유지보수 중에 수정할 필요가 있을 경우 코드를 손대

기가 쉽지 않을 수 있다. 철저한 태스트를 만들어뒀다면 상대적으로 낫겠지만， 태스트

가불충분하거나아예 없다면 오히려 SQL이나저장프로시저보다 더 다루기 힘든스파

게티 묘드로 전락할 위험도 있다.

데이터 중심 아키텍처의 특정은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진

다는 점이다. 화면을 중심으로 히는 업무 트랜잭션 단위로 묘드가 모이기 때문에 처음

엔 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 묘드를 관리하고 발전시키기

힘들다는단점이있다.

9.3.3 오브젝트 중심 아키텍처
오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모댈을
반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사
용한다는 것이다. 그래서 오브젝트 중심 아키텍처는 객체지향 분석과 모댈링의 결과로
나오는 도메인 모댈을 오브젝트 모텔로 활용한다. 대개 도메인 모댈은 DB
의 엔티티 설
계에도 반영되기 때문에 관계형 DB
의 엔티티 구조와도 유사한 형태일 가능성이 높다.
물론 DB에는 없지만 비즈니스 로직에만 존재히는 모델도 있기 때문에 항상 일치하는
것은아니다.
이렇게 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계충 사이에
전달하게 만드는 것이 오브젝트 중심 아키텍처다.

9장-스프링 프로잭트 시직h하기 797


데이터와오브젝트
간단한 예를 가지고 데이터와 오브젝트 방식을 비교해보자.
어떤 업무를분석해보니 카태고리와상품이라는두가지 엔티티가나옹다고해보자.
카태고리 하나에는 여러 개의 상품이 포함된다. 각 상품은 하나의 카태고리에 소속된
다. 전형적인 I:N의 관계다. 이 도메인 모댈을 그려보면 그림 9-19와 같다.


그림 9--19 카테고리와 상품 모델

이를 DB 테이블로 만들면 두 태이블 사이의 관계를 위해서 Product 쪽에 Category와
관계를 만들어주는 외래키
FK를 하나 둬야 한다
. 그래서 표 9-1
과 같은 태이블로 정의됐
다고하자.

표 9--1 카테고리와 상품 테이블
.Category

타입 l 실정

Categoryld int Primary Key

Description varchar(100)

.Product

1

L필튼멀 | 타입 실정 I

Productld int Primary Key
Name varchar(100)
Price Int
Categoryld int Foreign Key (Category)

조건에 맞는 모든 카태고리와 상품 정보를 가져와서 화면에 출력하는 기능을 만든다
고 해보자. 이때 데이터 중심 아키텍처에서는 SQL과 DB 관점에서 생각한다. 이 두 개
의 정보를 조합해서 가져오는 방법은 JOIN을 이용해 2차원 구조의 정보를 만드는 것이
다. 따라서 DAO에서 다음과 같은 SQL을 사용하게 만들 것이다.SQL 실행 결과는 랩
이나배열에담는다.


select c.categoryid , c.description, p.productid , p.name , p.price from product p
join category c on p.categoryid = c.categoryid

배열에 담으려면 인텍스별로 필드 이름을 일일이 기억해야 하기 때문에 불편하다.
배열 대신 랩에 필드 이름과 값을 함께 담고 뱀의 리스트를 만들어 돌려주는 게 편리하
다.DAO에서는 JDBC로 SQL을 실행하고 받은 결과를 리스트 9-8과 같이 담아서 서
비스 계층으로 넘겨줄 것이다.

리스트 9-8SQL 결과를 맙에 담는 DAO 코드

while(rs.next()) (
Map(String , Object) resMap = new HashMap(String , Object)();
resMap .put("categoryid" , rS .getString(l));
resMap .put("description" , rS .getString(2));

list .add(resMap);

서비스 계층에 전달되는 것은 List<Map<String , Object>> 타입이다. 이 타입만 봐
서는 안에 담긴 내용이 어떤 것인지 알 수 없다. 따라서 이 결과를 사용하는 서비스 계
층이나 프레젠테이션 계층의 코드에서는 DAO 메소드에서 두 개의 테이블을 조인해서
다섯 가지 필드의 값을 가져오고 필드 이름을 키로 갖는 랩에 값을 저장했음을 알아야
사용할 수 있다. 만약 DAO에서 SQL을 변경하거나 필드 개수나 순서， 이름을 바문다
면 서비스 계층과 프레젠테이션 계층의 묘드도 같이 변경돼야 한다.1:N 관계에 있는
두 개의 테이블을 조인해서 2차원 구조로 풀어놓은 데이터이기 때문에 이 안에는 원래
Category와 Product가 I:N
의 관계를 맺고 있었고 어떻게 서로 참조할 수 있는지에 대
한 정보는 없다. SQL을 통해서 가공된 데이터의 구조를 알고， 이를 활용하는 것이 전
부다.

이렇게 가져온 정보를 웹 페이지 내에서 수정해서 DB
에 다시 반영해야 한다면 어떻
게 될까? 사용자가 수정한 정보는 다시 뱀이나 배열 등에 담겨서 전달될 것이다
DB 수
정 작업을 담당하는 DAO는 이렇게 전달되는 데이터의 구조를 알고 있어야 할 것이다.

이렇게 데이터 중심의 아키텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의
묘드가 의존하게 된다. 도메인 분석을 통해 작성된 모델정보는 DB
에 대한 SQL을 작성
할 때 외에는 코드에 반영되는 일이 없다.

반면에 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구

9징-스프링 프로젝트 시ξh하기 799



조를 반영해서 만들어진 오브젝트 안에 담긴다. 도메인 모델은 애플리케이션 전 계층에
서 동일한 의미를 갖는다. 따라서 도메인 모텔이 반영된 도메인 오브젝트도 전 계층에
서 일관된 구조를 유지한 채로 시용될 수 있다. SQL이나 웹 페이지의 출력 포뱃， 입력
폼 등에 종속되지 않는 일관된 형식의 애플리케이션의 정보를 다룰 수 있게 된다.

먼저 도메인 모텔의 구조를 따라서 리스트 9-9와 같이 의미 있는 타입과 정보를 가
진클래스를정의한다.

리스트 용-9 도메인 오브젝트

public class Category {

int categoryid;

String description;

Set<Product> products; ~ ~N개의 R∞LCt률 참조하고 있는

컬렉션을가질수있다

// 접근자/ 수정자

지버의 레퍼런스 개념은 상호 침조가
public class Product { 가능하게만들수있다

int productid;

String name;

int price;

Category category; ---을 1개의 Categαy룰 가리키는 레미런스률

직접갖고있다

// 접근자， 수정자

이 구조는 단순히 특정 SQL에 대응되는 맴과 배열， 매번 달라지는 SQL 결과를 담
기 위해 급조해서 만든 오브젝트외는 달리， 애플리케이션 어디에서도 시용될 수 있는
일관된 형식의 도메인 정보를 담고 있다. DB에서 SQL 결과로 가져옹 값을 그대로 사
용하는 경우외는 다르게， 도메인 모댈을 반영하는 오브젝트를 사용하면 자바 언어의 특
성을 최대한 활용할 수 있도록 정보를 가공할 수 있다. 대표적으로 오브젝트 사이의 관
계를 나타내는 방법을 들 수 있다. RDB에서는 테이블 간의 관계를 직접 명시하는 방법
은 없다. 대신 키의 조합을 통해 그때그때 태이블을 조인해서 의미 있는 관계를 만들어
내야 한다. 반면에 자바에는 관계하고 있는 다른 오브젝트와 직접 연결하는 방법이 있
다. 레퍼런스 변수를 이용해서 다른 오브젝트를 참조하는 것이다. 하나 이상의 오브젝
트와관계를가지려면 컬렉션을이용할수도 있다.


그래서 Product 클래스에는 Product 테이블처럼 categoryid
라는 외래키가 없다. 대
신 Category 오브젝트를 가리키는 레퍼런스 변수를 갖고 있다. 반대로 하나의 Category
는 여러 개의 Product와 관계를 가질 수 있으므로 Set
이라는 컬렉션을 이용해 여러 개
의 Product 오브젝트를 참조하게 만들 수 있다. DB
의 Category 테이블에는 Product 테
이블과 어떻게 연결되는지에 대한 정보가 없다. 하지만 자바에서는 레퍼런스 변수를 통
한 상호 참조가 가능하기 때문에 원한다면 Category 오브젝트에서 다음과 같은 묘드로
Category
에 속한 Product를 간단히 가져올 수도 있다.

Set(Product) products =my(ategory.getProducts();

데이터 중심 방식에서는 Category와 그에 대응되는 Product를 찾아 SQL을 이용해
조인한 디음 하나의 뱀에 뭉뚱그려서 가져왔다. 반면에 오브젝트 중심 방식에서는 테이
블의 정보와 그 관계를 유지한 채로 정확한 개수의 Category 오브젝트와 그에 대응되
는 Product 오르젝트로 만들어 사용한다. 따라서 태이블에 Category가 하나이고 그에
대응되는 Product 열이 5
개라면 오브젝트도 하나의 Category 오브젝트와 이에 연결된
5개의 Product가 만들어질 것이다. 이 두 가지 오브젝트는 레퍼런스 변수를 통해 서로
연결되어 있기 때문에 메소드 파라미터나 리턴 값으로 전달할 때 Category 오브젝트 하
나를 전달하더라도 그에 연결된 Product 5
개가 함께 전달된다. 반대로 Product
의 컬렉
션을전달해도된다. 어차피 레퍼런스를따라가면서로참조할수있기 때문이다.

이렇게 도메인 모델을 따르는 오브젝트 구조를 만들려면 DB에서 가져온 데이터를
도메인 오브젝트 구조에 맞게 변환해줄 펼요가 있다. 한 번 변환되면 그 이후의 작업은
수월해진다. DAO는 자신이 DB에서 가져와서 도메인 모댈 오브젝트에 담아주는 정보
가 어떤 업무 트랜잭션에서 어떻게 사용될지는 신경 쓰지 않아도 된다. 서비스 계층 또
한 DAO에서 어떤 SQL을 사용했는지는 몰라도 된다. Category와 Product 정보를 두
개의 SQL로 나눠서 가져왔든， 하나의 SQL로 조인해서 가져왔든 상관없다. 서비스 계
층에서 펼요한 정보를 조건에 맞게 조회해서 도메인 모텔 오브젝트 형태로 돌려주는
DAO를 이용하기만 하면 된다. 그리고 가져온 도메인 오브젝트에 담긴 정보를 활용해
서 비즈니스 로직을 처리하면 된다. 프레젠태이션 계층에 전달할 때도 마찬가지다. 어
떤 DAO가 사용됐고， 어떤 비즈니스 로직을 거쳤는지에 관해선 프레젠테이션 계층은
알 펼요가 없다. 자신에게 전달된 도메인 오브젝트를 활용해서 필요한 정보를 화면에
출력하기만하면된다.

9징-스프링 프로젝트 시직하기 801


도메인 오브젝트를 사용하는 코드
오브젝트 중심 방식에서 비즈니스 로직의 구현이 얼마나 간단하고 명확한지 살펴보자.

어떤 카태고리에 포함된 상품의 모든 가격을 계산해야 하는 로직이 펼요하다면 서비스
계층의 오브젝트 안에 리스트 9-10과 같은 메소드를 만들어 사용하면 된다. 어떤 DAO
를 이용해서 Category를 가져왔는지는 중요하지 않다. 조건을 가지고 Category를 하나
검색했을 수도 있고， 모든 Category 목록을 가져왔을 수도 있다. 어떻게든 Category 오
브젝트를 갖고 있다면 calcTotalOfProductPrice() 메소드를 호출해서 카태고리에 담

긴모든상품가격의합을계산할수있다.

리스트 ~10 Cat엉ory 오브젝트률 사용하는 메소드

public int calcTotalOfProductPrice(Category cate) (
int sum =0;
for (Product prd cate .getProducts()) (

sum += prd .getPrice(); ~ 어앵Y는 도메인 모댈을 따라 만들어진 오브젝트이뾰
Cat영αy에 포함된 모든 Product룰 간단히 가져올 수 있다
return sum;

도메인 모델을 알고 있다면 calcTotalOfProductPrice() 메소드가 무슨 작업을 하
는지 이해하기 어렵지 않다. 테스트를 만들어 검증하기도 간단하고， 로직이 변경될 때
묘드를 수정하기도 수월하다. Category 자체가 독립된 오브젝트이므로 서비스 계층
어디에서든지 Category
의 상품 가격을 계산해야 할 때는 이 메소드를 사용하면 된다.
Category 내의 상품 가격을 계산하는 코드가 여러 개의 업무 트랜잭션에서 필요하다고
해도 코드의 중복이 일어나지 않을 수 있다.

반면에 데이터 중심 방식에서라면 이런 식의 재사용 가능한 메소드를 만들어 시용하
기가 쉽지 않다.DAO에 메소드를 추가해서 select sum(p.price)
로 시작하는 SQL을
실행해 DB가 계산해주는 결과를 한 번에 가져오는 방법을 시용하려고 할지 모르겠다.
아니면 주어진 카테고리에 포함된 상품의 가격 값의 목록을 배열 등에 담아서 돌려주는
DAO를 만들고 배열을 이용해서 합계를 계산하는 코드를 만들 수도 있다. 문제는 하나
의 Category
에 대해 상품 가격의 합을 계산하는 로직이라면 이런 방법을 사용하겠지만，
이미 DAO에서 여러 개의 Category와 Product를 조인해서 가져옹 경우라면 별도의 합
계 계산 코드를 만들어야 한다는 점이다. 아마도 적지 않은 for 문과 if 문을 시용해서
Category와 Product가 함께 들어 있는 뱀이나 리스트를 뒤져 카테고리별 합을 계산하


는 코드를 만들게 될 것이다. Category 내의 Product 가격 합을 계산하는 동일한 로직
인데도 SQL을 통해 데이터를 어떻게 가져왔는지에 따라서 이를 처리히는 다른 코드가
만들어지므로， 묘드에 중복이 발생한다.

오브젝트 구조로 정보를 갖고 있으면 어떤 식으로든 활용하기 펀리하다. 자바에서는
\’을 이용해 레퍼런스 변수를 따라가면 관련된 정보를 손쉽게 이용할 수 있다. Product
오브젝트가 하나 주어졌을 때， 해당 Product의 Category에는 상품이 모두 몇 개가 있는
지 알고 싶다면 다음과 같이 간단한 코드를 사용할 수 있다.

int count = product .getCategory().getProducts().size();

만약 SQL을 이용해 Product와 Category를 조인해서 통째로 가져왔다면， 적지 않은
if 문을 사용해야만 이와 기능이 동일한 코드를 만들 수 있다. 아니면 이런 로직을 JOIN
과 count() 펑션을 시용하는 SQL에 담아 새로운 DAO 메소드를 추가해야 한다. 태스
트를 만드는 펀리함 면에서도 큰 차이가 있다.SQL에 담긴 로직을 테스트하는 건 복잡
하고 불편하다. 반면에 도메인 오브젝트를 사용하는 코드는 간단히 테스트 값을 담은
도메인 오브젝트를 생성해서 쉽게 검증할 수 있다.

도메인 오브젝트 사용의 문제점
일관된 의미를 가지고 유연하며 애플리케이션 전반에 공유 가능한 도메인 모델을 따르
는 오브젝트로 정보를 다루면 많은 장점이 많다. 코드는 이해하기 쉽고 로직을 작성하
기도 수월하다. 프레젠테이션 영역에서도 이미 정의된 도메인 오브젝트 구조만 알고 있
다면 아직 DAO가작성되지 않았어도뷰를 미리 만들수도 있다. 묘드의 재사용성은높
아지고 DAO는 더 작고 효율적으로 만들어질 수 있다.
하지만 단점도 있다. 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에
서 조금은 손해를 감수해야 할 수도 있다.DAO는 비즈니스 로직의 사용 방식을 알지
못하므로， 도메인 오브젝트의 모든 필드 값을 다 채워서 전달하는 경우가 대부분이다.
그런데 하나의 오브젝트에 담긴 필드의 개수가 많아지다 보면 그중에는 드물게 사용되
는 필드도 있을 수 있다. 어떤 비즈니스 로직에서 필요한 정보가 몇 개의 펼드뿐이라면
DAO에서 도메인 오브젝트의 모든 필드 정보를 채워서 전달히는 것은 낭비일 수도 있
다. 비즈니스 로직에 따라서 필요한 정보가 달라질 수 있기 때문에 발생하는 문제다.
오브젝트 관계에도 문제가 있다. 만약 단순히 Product 정보만 필요한 비즈니스 로
직이 있다고 해보자. 그런데 DAO가 돌려준 Product 오브젝트에는 관계를 갖고 있는

9징-스프링 프로젝트 시ξt하기 803


Category 오브젝트도 함께 담겨 있을 것이다. Category
에 담긴 정보까지 시용될 때도
있겠지만， 어떤 경우에는 Product
에 담긴 정보만 필요할 때도 있다. 그럼에도 Category
오브젝트까지 다 조회해서 오브젝트로 만들어서 가져오는 것은 상당한 낭비다.

물론 Product 정보를 가져올 때 Category가 필요한 경우와 그렇지 않은 경우를 구
분해서 DAO를 만틀어줄 수 있다. 하지만 문제는 DAO에서 Product만 가져오게 하
면 Product
의 category 필드에는 null 값이 들어간다는 점이다. 불필요한 오브젝트
를 생성하는 일을 피할 수 있어서 좋기는 한데， 자칫 비즈니스 로직 코드를 작성하
다가 그런 사실을 깜박하고 product
의 category 필드를 사용할 경우 예상치 못했던
NullPointerException을 만날 수도 있다. 결국 최적회를 고려해서 DAO를 작성하려면
DAO는 비즈니스 로직에서 각 오브젝트를 어디까지 시용해야 하는지 어느 정도 알고
있어야 한다. 그래서 데이터 중심 접근 방법의 단점이라고 봤던， DAO와 비즈니스 로직
묘드의 결합도가 높아지는 문제가 발생할 수도 있다. 프레젠테이션 계층에서도 마찬가
지다. Product 오브젝트를 전달받아서 Product 내의 필드 값만 사용할 수도 있고 연결
된 Category
의 정보까지 출력할 수도 있기 때문이다.

이런 문제를 해결하는 접근 방법은 여러 가지가 있다.

지연된 로딩
lazy loading 기법을 이용하면 일단 최소한의 오브젝트 정보만 읽어두고 관
계하고 있는 오브젝트가 필요한 경우에만 다이내믹하게 DB에서 다시 읽어올 수 있다.
물론 도메인 오브젝트를 사용하는 코드는 이런 사실을 전혀 의식하지 않고 처음부터 모
든 오브젝트의 정보가 다 제공된다고 생각하고 작성하면 된다.

필드가 너무 많은 테이블이 있다면 그중에서 지주 시용되는 것을 골라내서 별도의
오브젝트로 정의해두고 필요에 따라 구분해서 사용하게 할 수 있다. 물론 그에 따라
DAO 메소드가 추가돼야 하고 어느 DAO를 사용할지를 서비스 계층에서 알고 있어야
하기 때문에， 약하긴 하지만 계층 사이의 결합이 발생한다.

사실 가장 이상적인 방법은 JPA나 100, 하이버네이트， TopLinK와 같은 오브젝트/
RDB 매핑
ORM 기술을 사용하는 것이다. 이런 데이터 액세스 기술은 기본적으로 지연된
로딩 기법 등을 제공해주기 때문에 번거로운 묘드를 만들지 않고도 도메인 오브젝트의
생성을 최적화할 수 있다. 또한 SQL 결과를 가지고 도메인 오브젝트를 만들고 값을 채
우는 등의 복잡한 DAO 코드를 만들지 않아도 된다. 내부적으로 최적화된 SQL을 사용
하도록 세밀히 튜닝할 수도 있다. 또 자주 변경되지 않으면서 많은 로직에서 참조하는
레퍼런스 태이블이 있다면 이를 ORM
이 제공하는 오브젝트 캐시에 담아두고 사용할 수
도 있다. 묘드 테이블처럼 자주 참조되는 것은 오브젝트 캐시로 만들어두면 매번 DB에


서 읽어오지 않고 메모리 캐시에 가져오게 해주기 때문에 DB
의 부하를 줄여줘서 성능
이많이향상된다.

그래서 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면
ORM과 같은 오브젝트 중심 데이터 액세스 기술을 사용하는 것을 권장한다. 사용하기
쉽고 직관적이며 코드의 양도 대폭 줄기 때문이다. 다%탠f 기법을 이용하면 SQL을 직
접 만들어 쓰는 경우에 못지않게 성능을 향상시 킬 수 있다.

ORM을 사용하지 않고 JDBC를 이용하는 경우라면 지연된 로딩 기법을 제공하는
코드를 추가해주거나， 사용되는 펼드의 종류와 사용되는 관련 오브젝트의 범위에 따라
서 여러 개의 DAO 메소드를 만들어 사용해야 할 수도 있다. 이 경우 DAO 코드나 도
메인 오브젝트 코드의 중복이 일부 발생하고 계층 사이의 결합도도 증가될 수는 있지
만， 데이터 중심 아키텍처에 비하면 미미한 정도다.

오브젝트 중심의 아키텍처는 도메인 모댈을 따르는 오브젝트를 사용해 각 계층 사이
에 정보를 전달하고， 이를 이용해 비
즈니스 로직이나 프레젠테이션 로직을 작성한다.
계층 간의 결합도는 낮아지고 일관된 정보 모벨을 사용하기 때문에 개발 생산성과 묘드
의 품질， 태스트 편의성도 향상시킬 수 있다.

그런데 도메인 오브젝트는 자바오브젝트다. 오브젝트는 원래 데이터를 저장하기 위
해서만 사용히는 것이 아니다. 내부의 정보를 이용하는 기능도 함께 갖고 있어야 한다.
클래스는 속성
attribule과 행위。peralion
의 조합이다. 펼드와 그에 대한 접근자， 수정자만
갖고 있는 오브젝트는 반쪽짜리다. 물론 도메인 모텔을 반영히는 오브젝트 구조에 정보
를 담는 것만으로도 많은 장점이 있지만 이 정도에서 도메인 오브젝트의 사용을 제한
할 필요는 없다. 가능하다면 이를 더 적극적으로 활용하게 만들어야 한다.

오브젝트 중심 아키텍처는 오브젝트의 활용 방법을 기준으로 다시 구분해볼 수 있다.

빈약한 도메인 오브젝트 방식
도메인 오브젝트에 정보만 담겨 있고 정보를 활용하는 아무런 기능도 갖고 있지 않다
면 이는 옹전한 오브젝트라고 보기 힘들다. 그래서 이런 오브젝트를 빈약한anemlc 오브
젝트라고 부른다. 물론 이렇게라도 도메인 모텔을 반영한 오므젝트에 정보를 담아 활용
히는 편이 도메인 오브젝트를 전혀 사용하지 않는 것보다는 훨씬 낫다. 계층 사이의 독
립성을 확보하기 위해서는 특정 계층에 종속되지 않으면서 애플리케이션 전반에서 사
용될 수 있는 정보를 담은 오브젝트가 필요하기 마련이고 그래서 이런 빈약한 도메인
오브젝트 방식도 실제로 많이 시용된다.

9징-스프링 프로젝트 시ξh하기 805


아마도 스프링을 사용하는 개발자가 흔히 시용하는 방식이 이 빈약한 도메인 오
브젝트 방식이 아닐까 싶다. 스프링의 핵심 개발자들이 함께 쓴 스프링 전문 서적인
rprofessioanl Spring-FrameworkJ라는 책이 있다. 이 책과 함께 제공되는 스프링 애플
리케이션 예제에서는 바로 이 빈약한 도메인 오브젝트 방식을 사용했다. 오브젝트 자체
는 복잡한 도메인 모댈을 따라서 잘 만들어져 있고 이 구조를 그대로 모든 계층이 활용
하도록 하고 있기 때문에 깔끔하고 유연한 묘드로 만들어져 있다. 하지만 도메인 오브
젝트는 데이터를 저장해두는 것 외에는 아무런 기능이 없다.

도메인 오브젝트에 넣을 수 있는 기능은 어떤 것일까? 도메인 모댈을 반영해서 만들
어진 도메인 오브젝트이니 그 기능이라고 하면 도메인의 비즈니스 로직이라고 볼 수 있
다. 그렇다면 빈익노한 도메인 오브젝트 방식에서는 비즈니
스 로직이 어디에 존재할까?
바로 서비스 계층이다. 사실 다루는 정보의 구조가 다를 뿐이지 빈약한 도메인 오브젝
트 방식은 데이터 중심 아키텍처의 거대 서비스 계층구조와 비슷하다. 빈약한 도메인
오브젝트 방식도 거대 서비스 계층 방식의 하나라고 보면 된다. 그림 9-20은 빈햄 도
메인 오브젝트 방식의 구조를 보여준다. 도메인 오브젝트는 3
개의 계층에는 독립적으로
존재하면서 일관된 구조의 정보를 담아서 계층 간에 전달히는 데 사용된다.

톤뿔

도메인 오브젝트가 모든 계층에 여전히 핵심 비즈니스 로직은 서비스 계층에 SOL을 직접 사용히는 기술을 이용하면 코
서 일렬되게 사용된다 도메인 모두 담겨 있다 도메인 오브젝트를 사용하지 드에 의해 도메인 오브젝트 형
태로 민들어
오브젝트에는 딘순 정보 외의 만 단순히 정보를 저εh하고 조회하는 용도로만 주는 연환 작업이 필요하다 ORM 기술을
로직은들어있지않다 훨용효κt 사용하면 이런 작업이 간단한 매핑정보 실
정만으로가능하다

그림 9-20 빈약한 도메인 오브젝트 방식

빈의댄f 도메인 오브젝트 방식의 한계는 거대 서비스 계층 방식과 유사하다. 비록 도메
인 오브젝트라는 일관된 오브젝트를 활용하기 때문에 SQL에 의존적인 데이터 방식보
다는 훨씬 유연하고 간결하지만， 여전히 서비스 계층의 메소드에 대부분의 비즈니스 로
직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉽다.

하지만 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3
계층 구조의 특정을 잘
살려서 개발할 수 있는 유용한 아키텍처다.

/


풍성한 도메인 오브젝트 방식

풍성한 도메인 오브젝트rich domain 。미ect 또는 영리한 도메인 오브젝트smaη domain object

방식은 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인
특정을 잘 사용할 수 있도록 개선한 것이다. 어떤 비즈니스 로직은 특정 도메인 오브젝
트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다. 이런 로직을 서비스 계층의 코
드가 아니라 도메인 오브젝트에 넣어주고， 서비스 계층의 비즈니스 로직에서 재사용하
게만드는것이다.

앞에서 서비스 계층의 묘드로 만들었던 calcTotalOfProductPrice()
는 Category
라는 오브젝트와 그 관련 Product
의 정보만을 사용하는 간단한 로직이다. 이것을 굳
이 리스트 9-10처럼 서비스 계층의 메소드에 별도로 만들지 않고 리스트 9-1
1과 같이
Category 클래스의 메소드에 넣을 수도 있다.

리스트 9-11 자신의 정보를 활용하는 로직을 담은 도메인 오브젝트

public class Category (

List<Product> products;

public int calcTotalOfProductPrice() ( -~~~~~를 띠로 파리미터로 받을 밀요가 없다 자신이

가진 정보를 직접 사용하면 되기 때문이다

int sum = ø;
for(Product prd this.products()) (~ 오브젝트가 가진 내부 정보를 훨용해서 필요한 계산이나

로직을수행하면된다

sum += prd.getPrice();
return sum;

이렇게 도메인 오브젝트 안에 로직을 담아두면 이 로직을 서비스 계층의 메소드에
따로 만드는 경우보다 응집도가 높다. 데이터와 그것을 사용하는 기능이 한곳에 모여
있기 때문이다. 만약 Category
에 대해 상품 가격을 계산히는 작업이 CategoryService
외의 서비스 계층 오브젝트에서 필요하다고 해보자. 그때마다 Category 오브젝
트를 파라미터로 해서 CategoryService
의 메소드를 호출하는 것은 번거롭다.
CategoryService를 사용하기 위해 Dl도 해줘야 한다. 다른 모률의 비즈니
스 로직을 작
성하고 있는 개발자는 CategoryService 안에 그런 기능이 있는지 몰라서 같은 기능을
가진 코드를 스스로 만들어 쓸지도 모른다.

현재 재고에 대한 비즈니
스 로직을 담고 있는 InventoryService가 있다고 하자.

g장-스프링 프로젝트 시작하기 807



여기서 특정 카테고리의 상품에 대한 현재 가격의 합을 계산할 펼요가 생겼다. 그
리고 혹시 미리 만들어둔 관련 기능이 있는지 CategoryService를 뒤져보고 거기서
calcTotalOfProductPrice(Category c) 메소드를 찾았다고 하자. 그러면 이 기능을 사
용하기 위해 InventoryService에 CategoryService를 DI 해줘야 한다. 그렇게 주입받
은 CategoryService를 호출해서 그 메소드를 이용해야 한다. 그나마 같은 기능의 코드
를 중복하지 않고 최적화해서 이미 만들어진 비즈니
스 로직을 재활용하는 것인데도 제
법 번거로울 수 있다. InventoryService 클래스는 리
스트 9-12와 같이 작성된다.

리스트 9-12 다른 서비스 오브젝트의 로직을 사용하는 코드

public class InventoryService (
private CategoryService categoryService;

다른 서비스 오브
1 젝트에 담긴 로직public void setCategoryService(CategoryService categoryService) (I | 율사용하기 위해

this.categoryService = categoryService; I a훌 해쥐야 효백

public void complexlnventoryAnalysis() (
int total =this .categoryService .calcTotalOfProductPrice(category);

계신 로직에서 사용윌 정
+
보훌 가진 Category률
따라미
터로 전달해야 한다

이런 식으로 여러 개의 도메인 오브젝트에 대한 로직을 사용해야 동}는 복잡한 코드
라면 각 비즈니스 로직을 담고 있는 서비스 오브젝트를 DI 해서 로직을 담은 메소드를
호출해야 한다. 이미 정보를 담고 있는 오브젝트가 있지만 그 정보를 다루는 메소드는
별개의 서비스 오브젝트에 분리되어 있기 때문이다.

그런데 Category
에 대한 계산 로직을 Category 오브젝트 안에 직접 넣어뒀다면 이런
번거로운 작업이 필요 없다. 그냥 Category 오브젝트에게 직접 멸요한 계산 작업을 요
청하면 되는 것이다. CategoryService를 DI 할 필요도 없다. 비슷한 코드가 여기저기
비즈니스 로직에 중복돼서 나타나지도 않는다. 특정 도메인 오브젝트에 종속되는 비즈
니스 로직은 서비스 계층의 오브젝트가 아니라 도메인 오브젝트 안에 넣으면 된다. 이
제 InventoryService의 코드는 불펼요한 DI 없이 리스트 9-13과 같이 간결하게 만들
수 있다. 리스트 9-12와 리스트 9-13의 코드를 비교해보고 어떤 코드가 이해하기 쉬
운지한번생각해보자.


리스트 ~13 자체 로직울 가진 Category를 사용하는 코드

public class InventoryService {
public void complexlnventoryAnalysis() {

서비스 계충의 메소드를 사용하는
코드보다 훨씬 간결하고 직관적이

int total =category.calcTotalOfProductPrice(); --용 라서 이해하기도 염다 무엇보다도

객체지항적이다

풍성한 도메인 오브젝트 방식은 도메인 오브젝트를 사용한다는 면에서 빈약한 도메
인 오브젝트 방식과 비슷하지만， 실제 작성된 묘드를 살펴보면 훨씬 간결하고 객체지향
적이라는 사실을 알 수 있다. 객체지향 분석과 설계를 통해 만들어진 도메인 모델의 정
보를 정적인 구조뿐 아니라동적인 동작방식에도 적극 활용할수 있다.

물론 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 비즈니스 로직을 담고 있던
서비스 계층 오브젝트가 필요 없어지는 건 아니다. 여전히 서비스 계층은 필요하며 중
요한 역할을 하고 있다. 도메인 오브젝트 안에 메소드로 들어가는 로직들은 대부분 해
당 오브젝트나， 긴밀한 연관관계를 맺고 있는 관련 오브젝트의 정보와 기능만을 활용한
다. 여러 종류의 도메인 오브젝트의 기능을 조합해서 복잡한 비즈니스 로직을 만들었다
면 특정 도메인 오브젝트에 넣기는 힘들다. 이런 비즈니스 로직은 서비스 계층의 오브
젝트에 두는 것이 적당하다.

도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층
의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 펼요하기도 하다. 대개는 비즈니
스 로직을 처리하는 중에 DB에 담긴 정보를 가져와서 활용하거나 결과를 다시 DB나
외부 시스템에 전송히는 등의 작업이 필요하다. 그러려면 서비스 계층의 오브젝트와 같
이 DAO 오브젝트를 DI 받아서 사용할 수 있어야 한다. 하지만 도메인 오브젝트는 그
럴수없다.

왜 도메인 오브젝트는 DAO 오브젝트를 DI 받을 수 없을까? 그것은 도메인 오브젝
트는 스프링 컨테이너가 관리히는 오브젝트， 즉 빈이 아니기 때문이다. 서비스 계층의
오브젝트나 데이터 액세스 계층의 오브젝트는 모두 스프링의 빈으로 등록되기 때문에
필요에 따라 서로 DI 할 수 있다.DI를 받으려면 자신도 역시 스프링 컨테이너에서 관
리되는 빈이어야 한다. 그런데 도메인 오브젝트는 스프링의 빈이 아니다. 도메인 오브
젝트는 애플리케이션의 코드 또는 기타 프레임워크나 라이브러리， JDBC 템플릿 등에
의해 필요할 때마다 새롭게 만들어진다. 따라서 스프링이 생성하거나 관리하는 오브젝

g잠」 스프링 프로젝트 시작하기 809



트가 아니므로 DJ를 받을 수 없다. 결국 이런 도메인 오브젝트는 DAO나 서비스 오브
젝트 같은 스프링의 빈의 기능을 사용할 수 없다.

그래서 수식 계산이나 조건에 따른 데이터의 변경 또는 자신이 가진 정보에 대한 분
석 같은 도메인 오브젝트 자신에 국한된 로직은 도메인 오브젝트 안에 추가할 수 있지
만， 그 결과를 DB
에 저장하거나 메일로 발송하거나 DB를 검색해서 원하는 정보를 가
져와 활용히는 작업은 도메인 오브젝트에서 불기능하다. 그래서 DAO와 기반계층 오브
젝트를 DJ 받아사용할수 있는 서비
스 계층의 묘드가 펼요하다.

서비스 계층은 도메인 오브젝트를 DB나 외부 리소스에서 가져오고 변경된 정보나
새로 등록된 정보를 DB
에 반영히는 등의 작업과 함께 도메인 오브젝트가 갖고 있는 기
능이 있다면 이를 활용해서 비즈니스 로직을 처리해야 한다.

그림 9-21은 풍성한 도메인 오브젝트 방식의 아커텍처를 나타낸다. 스프링의 빈으
로 관리되는 3
계층의 오브젝트들은 도메인 오브젝트를 자유롭게 이용할 수 있지만 그
반대는 안 된다는 사실을 주의해야 한다.

도메인 오브젝트는 3계충의 오브젝트롤 직접 이용할 수 없다 스프링이
관리하는 빈이 아니어서 g 받을 수 없기 때문이다

톤웹

오브젝트가 가진 데이터를 저장 도메인 오브젝트가 제공하는 도메인 로 빈약한 도메인 오브젝트 방식과 열 차이
하는 기능과 함께 데이터를 활 직을 훨용해서 비즈니스 로직을 구현힌 는 없다 하지만 도메인 오브젝트 안에서
용하는로직을강고있다 다 따라서 월씬 간결하고 영확하며 종목 긴딘한 계산이
나 모뱃팅 변
환 조건
에
이 없는 코드가 만들어진다 따라 딜리지는 값을 줄 수 있으므로 SOL
영션의 사용이 줄어들 수 있다
그림 9-21 풍성한 도메인 오브젝트 방식

풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드
가 간결하다. 비즈니스 로직 코드를 이해하기도 쉽다. 따라서 빈약한 도메인 오브젝트
를 피하고 도메인 오브젝트가 스스로 처리 가능한 기능과 도메인 비즈니스 로직을 갖도
록
만드는것이 바람직하다.

물론 빈약한 도메인 오브젝트 방식이 항상 나쁘고 피해야 할 것은 아니다. 도메인 모
댈령과 기능 분석을 통해 이상적인 도메인 오브젝트 설계를 하고 사전에 내부 기능을
충분히 구현해두지 않았다면， 도메인 오브젝트를 활용해서 비즈니스 로직을 구현해야
하는 개발자는혼란을느낄 수 있다. 어떤 경우는도메인 오브젝트에 이미 구현된 코드


가 있는데도 이를 이용하지 못하고 서비스 계층에 비슷한 기능을 중복해서 만들 수도
있고， 도메인 오브젝트의 코드를 일부 서비스 계층의 개발자가 임의로 변경해서 같은
오브젝트를 사용하는 다른 모률의 작업자가 만든 코드가 제대로 동작하지 못하게 되기
도한다.

그래서 충실한 도메인 모댈링과 도메인 오브젝트 개발이 선행되고 그 내용이 개발자
에게 사전에 충분히 공유되지 않았다면 차라리 데이터 구조만 오브젝트 방식으로 정의
해놓은 빈약한 도메인 오브젝트 방식이 혼란을 피할 수 있고 쉽게 접근할 수 있는 대안
이 될 수도 있다. 하지만 처음은 쉬워도 시간이 지나고 시스댐이 복잡해지면 빈약한 도
메인 오브젝트 방식의 단점이 드러날 것은 각오해야 한다.

도메인계층방식
지금까지 살펴본 바로는 도메인 모댈을 따르는 오브젝트를 만들고 이를 활용하는 방법
에는 한계가 있다. 도메인 오브젝트에 담을 수 있는 비즈니스 로직은 데이터 액세스 계
층에서 가져온 내부 데이터를 분석하거나 조건에 따라 오브젝트 정보를 변경， 생성 하
는 정도에 그칠 수밖에 없다. 이렇게 변경된 정보가 다시 DB 등에 반영되려면 서비스
계층 오브젝트의 부가적인 작업이 펼요하다.
도메인 오브젝트가 스스로 필요한 정보는 DAO를 통해 가져올 수 있고， 생성이나 변
경이 일어났을 때 직접 DAO에게 변경사항을 반영해달라고 요청할 수는 없을까?DAO
외에도 다양한 기반계층의 서비스를 이용하도록 할 방법은 없을까? 만약 도메인 오브
젝트가 기존 3
계층의 오브젝트를 DI 받아서 직접 이용할 수 있게 된다면 어떤 일이 일
어날까?
도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 오브젝트 방
식으로는 만족할 수 없다. 그래서 등장한 것이 바로 도메인 오브젝트가 기존 3
계층과 같
은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식이다. 개념은 간단하
다. 도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스
계층의 사이에 존재하게 히는 것이다.
도메인 오브젝트가 독립된 계층을 이뤘기 때문에 기존 방식과는 다른 두 가지 특정
을갖게된다.
첫째는 도메인에 종속적인 비즈니스 로직의 처리는 서비
스 계층이 아니라 도메인 계
층의 오브젝트 안에서 진행된다는 점이다. 서비스 계층에서 사용자가 입력한 정보를 바
탕으로 새로운 도메인 오브젝트를 만들었든 데이터 액세스 계층을 통해 도메인 오브젝

9징-스프링 므로젝드 시ξh하기 811


트를 가져왔든 상관없이 도메인 오브젝트에게 비즈니스 로직의 처리를 요청할 수 있다.
해당 도메인 오브젝트를 중심으로 만들어진 로직이라면 그 이후의 작업은 도메인 오브
젝트와 그 관련 오브젝트 사이에서 진행된다. 일단 도메인 계층으로 들어가면 서비스
계층의 도움 없이도 비즈니스 로직의 대부분의 작업을 수행할 수 있다는 뭇이다.

두 번째 특징은 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능
을 직접 활용할 수 있다는 것이다. 그런데 앞에서 도메인 오브젝트는 스프링에 등록돼
서 싱글톤으로 관리되는 빈이 아니기 때문에 다른 빈을 DI 받을 수 없다고 했다. 그렇다
면 도메인 계층의 도메인 오브젝트들은 어떻게 다른 빈을 이용할수 있을까?물론방법
은 DI
다. 여전히 도메인 오브젝트는 스프링이 직접 만들고 관리히는 오브젝트 즉 빈이
아니다. 하지만 이런 스프링이 관리하지 않는오브젝트에도
DI를 적용할수 있다. 물론
그에 따른 간단한 설정이 추가돼야 한다.

스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요
하다. 물론 스프링 AOP는 부가기능을 추가할 수 있는 위치가 메소드 호출 과정으로 한
정되고 AOP의 적용 대상도 스프링의 빈 오브젝트뿐이다. 하지만 스프링 AOP 대신
AspectJ AOP를 사용하면 클래스의 생성자가 호출되면서 오브젝트가 만들어지는 시점
을 조인 포인트로 사용할 수 있고 스프링 빈이 아닌 일반 오브젝트에도 AOP 부가기능
을 적용할 수 있다. 이를 이용해서 도메인 오브젝트가 생성되는 시점에 특별한 부가기
능을 추가하게 만들어줄 수 있다. 이 부가기능은 오브젝트의 수정자 메소드나 DI용 애
노태이션을 참고해서 DI 가능한 대상을 스프링 컨테이너에서 찾아 DI 해주는 기능이
다. 스프링이 직접 관리하지 않는 오브젝트에 대한 DI 서비스가 일종의 AOP 부가기농
으로 도메인 오브젝트에 적용될 수 있다.

이 방법을 이용하면 도메인 오브젝트가 만들어질 때 스프링의 빈 오브젝트를 DI 받
게 할 수 있다. 결국 도메인 오브젝트가 데이터 액세스 계층이나 기반 계층의 오브젝트
를 이용하도록 만들 수 있다. 이 덕분에 도메인 오브젝트 기능의 제약이 사라진다. 물론
도메인 오브젝트에 담긴 기능은 자신과 관련 오브젝트에 대한 작업으로 한정돼야 한다.

도메인 계층 방식은 이전의 어떤 방식보다 도메인 오브젝트에 많은 비즈니스 로직을
담아낼 수 있다. 그럼에도 서비스 계층의 역할이 완전히 사라지는 건 아니다. 때로는 여
러 도메인 오브젝트의 기능을 조합해서 복잡한 작업을 진행해야 하는 경우가 있다. 특
정 도메인 오브젝트에 담길 수 없는 이런 작업은 서비스 계층에서 도메인 계층과 협력
을 통해 진행히는 것이 바람직하다. 또는 굳이 도메인 계층을 거치지 않고 바로 데이터
액세스 계층으로부터 정보를 가져와 클라이언트에 제공해야 하는 경우도 있다. 이럴 때


도 서비스 계층이 인터페이스 역할을 담당한다. 또 트랜잭션 경계를 설정하거나 특정
도메인 로직에 포함되지는 않지만 애플리케이션에서 필요로 히는 기반 서비스를 이용
해야 옹}는 작업을 위해서라도 서비스 계층은 필요하다.

대신 서비스 계층의 비중과규모는단순히 도메인 오브젝트를사용하는 방식에 비해
훨씬 작다. 복잡하지 않은 애플리케이션에서는 아예 서비스 계층을 제거하고 모든 비즈
니스 로직을 도메인 오브젝트에 담을 수도 있다. 이때는 트랜잭션 경계가 프레젠태이션
계층에서 최초로 호출되는 도메인 오브젝트의 메소드에 설정돼야 한다
.

도메인 오브젝트를 독립적인 계층으로 만들려고 할 때 고려해야 할 중요한 사항이
있다. 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 한
다. 도메인 오브젝트가 계층을 이루기 전에는 모든 계층에 걸쳐 사용되는 일종의 정보
전달 도구 같은 역할을 했다. 하지만 독자적인 계층을 이뤘을 때는 상황이 달라질 수
있다.

선택할 수 있는 방법은 두 가지가 있다.

첫째， 여전히 모든 계층에서 도메인 오브젝트를 시용한다. 도메인 계층은 물론이고
서비스 계층이나 그 앞의 프레젠테이션 계층 화면 출력을 위한 뷰에서도 직접 도메인
오브젝트를 전달받아 사용할 수 있게 하는 것이다. 가장 손쉽고 펀한 방법이다. 도메
인 오브젝트를 이용해 도메인 로직을 적용하면 도메인 계층에서 진행되지만， 그 결과를
DB
에 반영할 때나 화면에 출력하거나 페이지 이동을 위한 정보로 활용하기 위해 프레
젠테이션 계층에서 참조할 때도 도메인 오브젝트를 사용할 수 있다. 따라서 도메인 모
댈을 따르는 오브젝트 구조를 활용하는 면에서 오브젝트 중심 아키텍처의 장점을 그대
로누릴수있다.

하지만 주의하지 않으면 심각한 혼란을 초래할 수 있다. 도메인 오브젝트의 메소드
는 이제 단순한 값의 조작이나 분석 변환 정도가 아니라 중요한 도메인/비즈니스 로직
을 담당하고 있다. 심지어 DB나 백엔드 시스템에 작업 결과를 반영할 수도 있다. 그런
데 이런 막강한 기능을 가진 도메인 오브젝트를 프레젠테이션 계층이나 뷰 등에서 사
용하게 해주면 이를 함부로 사용하는 위험이 뒤따를 수 있다. JSP로 뷰를 만드는 개발
자가 도메인 오브젝트가 담은 정보를 가져와 화면을 출력하는 데만 사용히는 것이 아니
라， 중요한 비즈니스 로직을 담은 메소드를 함부로 호출한다면 심각한 문제가 일어날
수도 있다. 오브젝트를 넘겨받은 이상 그것을 사용히는 데 제약이 없기 때문에 함부로
조작하거나 기능을 실행해버릴 위험이 있다.

이런 문제를 피하려면 어떻게 해야 할까? 가장 간단한 방법은 철저한 개발 가이드라

g당-스프링프로젝트시ξ팅f7
1 813


인을 만들어두고 이를 강력하게 적용하는 것이다. 예를 들어 프레젠테이션 계층에서는
도메인 오브젝트를 전달받!-O]-접근자를 사용해서 정보를 가져오는 경우와 폼의 결과를
반영할 새로운 도메인 오브젝트를 만들어 수정자를 호출히는 경우 외에는 다른 메소드
를 사용하지 않는다는 개발 정책을 만들어두는 것이다.

문제는 이런 규정을 어기는 개발자가 있다는 점인데 이런 문제는 코딩 정책의 적용
을 분석할 수 있는 툴을 이용해 검증하거나 Aspec
tJ의 정책/표준 강제회.policy/standards
enforcement 기능을 시용하면 된다. Aspec
tJ를 이용한 방법은 상당히 편리하다. 간단한
포인트컷 표현식만으로 특정 계층의 오브젝트가 사용할 수 있는 메소드의 범위를 제한
히는 등의 정책 강제화 작업을 간단하게 해낼 수 있다. 이 방법에 대해서는 AspectJ 문
서나 rAspectJ In ActionJ 책을 참조하자.

두 번째 방법은 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것이다. 도
메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트
의 내용을 복사해서 넘겨줘야 한다. 이런 오브젝트는 데이터 전달을 위해 사용된다고
해서 DTOData Transfer Object라고 불린다. DTO는 상태의 변회를 허용하지 않고 읽기전

용으로 만들어지기도 한다. 반대로 사용자가 등록한 값이나 외부 시스댐으로부터 전달
받은 정보를 도메인 계층으로 전달히는 경우에도 DTO를 이용할 수 있다.

DTO는 기능을 갖지 않으므로 사용하기 안전하다. 또 도메인 오브젝트를 외부 계층
의 코드로부터 보호해준다. 반면에 도메인 오브젝트와 비슷한 구조를 가진 오브젝트를
따로 만들어야 하고 이를 매번 변환해줘야 하는 번거로움이 있다. 따라서 AOP와 같은
방법을 이용해 변환을 자동으로 해주도록 만들 필요가 있다.

이 두 가지 방법 중 어느 것이 더 낫다고 말하기는 힘들다. 기존에 DTO를 이용한 개
발에 익숙해져 있다면 후자의 방법도 괜찮을 것이다. 번거로운 작업은 최소화하고 싶고
대신 표준 개발 정책을 잘 따라서 개발하도록 개발팀을 관리할 수 있다면 전자의 방법
이 편리하다.

그림 9-22는 도메인 계층 방식의 구조다.


도메인 모멸을 그대로 반영하는 오브젝트 구조률 이용해
핵심적인 비즈니스 로직의 처리를 담당한다

71능 제한된 도메인 L----


: 오브젝트 또는 DTO

도메인 계충을 밖에서 정보는 제한된 도메인 계충에 핵심적인 비즈니스 로 도메인 계충과 서비스 계층이라는 두 개의 클
정보 접근만올 허용하는 도메인 오브 직 처리를 위임하기 때문에 서비스 라이언트를 강게 된다 결과는 가능한 한 도
젝트나 정보 전딜만을 목적으로 하는 계충은 상딩히 가벼원진다 필요에 메인 오브젝트를 이용해 리턴한다 특히 도메
DTO로 연환돼서 사용된다 따라서 데이터 액세스 계층을 바로 인 계충이 직접 사용하는 메소드는 반드시 그
이용하기도한다 래야한다
그림 9-22 도메인 계충 방식

도메인 계층은 기존 3
계층과 비슷한 수준에서 독립적인 역할을 담당하고 있긴 하지만
그 특성은 확연히 다르다. 서비스를 제공히는 싱글톤으로 계속 존재하는 다른 계층의
오브젝트와 달리， 도메인 계층의 오브젝트는 매우 짧은 시간 동안만 존재했다가 사라지
는 것을 반복한다. 각 사용자의 요청별로 독립적으로 도메인 계층을 이루는 오브젝트들
이 생성됐다가 해당 요청을 처리하고 나면 버려진다. 때론 하나의 복잡한 작업 흐름을
따라서 오래 존재하는 경우도 있지만 여전히 그 생명주기는 짧다. 도메인 오브젝트는
사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문이다. 상태정보를 담
고 있기 때문에 여러 스레드가 공유히는 싱글톤이 될 수가 없다. 또 DAO나 컨트롤러，
또는 스프링 외의 라이브러리를 통해 오브젝트가 만들어지는 경우가 많기 때문에 스프
링이 관리하는 빈으로 등록조차 불가능하다. 그렇기 때문에 특별한 방법으로 DI를 해줘
야지만다른
3
계층의 빈들과협력해서 일을처리할수있다.

이런 여러 가지 제약과 불편을 감수하면서라도 이 방식을 택해야 하는 경우는 매우
복잡하고 변경이 잦은 도메인을 가졌을 때다. 복잡한 도메인의 구조와 로직을 최대한
도메인 계층의 오브젝트에 반영하고， 도메인 모벨과 설계에 변경이 발생했을 때 도메인
계층의 오브젝트도 빠르게 대응해서 변경해주기 위해서다. 도메인 계층은 응집도가 매
우 높기 때문에 단위 테스트를 작성하기가 편리하다.DAO나 외부 서비스 오브젝트와
연동할 때도 도메인 오브젝트 타입을 유지할 수 있기 때문에 목 오브젝트 등을 이용해
단위 테스트로 만들기도 쉽다. 도메인이 가진 복잡함을 객체지향적인 설계의 모든 장점
을 동원해서 가장 유연한 방법으로 대응할 수 있다.

반면에 그만큼 복잡하지 않은 애플리케이션이라면 이런 방식을 선택하는 것 자체가
오히려 과도한 부담을 줄 수도 있다.

앞L 스프링 프로젝트 시ξh하기 815


따라서 도메인 계층을 이용히는 방식을 선택할 때는 오브젝트 중심 。버텍처의 기

본 두 가지 방법을 충분히 경험해보고 오브젝트 중심의 개발 방식에 익숙해진 뒤에 조

심스럽게 접근해야 한다.

AspectJ AOP를 이용해 도메인 오브젝트에 DI를 적용하는 방법은 Vol. 2
의 5장을

참고하기바란다.

DTO와리포트쿼리
오브젝트 중심 아키텍처는 애플리케이션 내의 모든 정보를 항상 도메인 오브젝트에 담
고 다녀야 할까? 콕 그렇지는 않다.
도메인 계층 방식의 경우 도메인 계층을 벗어난 정보를 DTO라 불리는 특정 계층에
종속되지 않는 정보 전달의 목적을 가진 단순 오브젝트에 담아 샤용하기도 한다. 그 외
의 방법에서도 DTO의 사용이 꼭 펼요할 때가 있다.
대표적인 예는 리포트 쿼리
re∞끼 query라고 불리는 DB 쿼리의 실행 결과를 담는 경우
다. 리포트 쿼리는 리포트를 출력하기 위해 생성하는 쿼리라는 의미인데， 단지 리포트
를 위해서라기보다는 보통 종합 분석 리포트처럼 여러 테이블에 걸쳐 존재하는 자료를
분석하고 그에 따른 분석/통계 결괴를 생성하는 쿼리라는 의미다. 이런 쿼리의 결과는
DB 태이블에 담긴 필드의 내용보다는 그 합계， 평균과 같은 계산 값이거나 아니면 여
러 테이블의 펼드를 다양한 방식으로 조합해서 만들어진다. 따라서 DB 쿼리의 실행 결
과를 담을 만한 적절한 도메인 오브젝트를 찾을 수 없다. 그래서 이런 리포트 쿼리의 결
과는 DTO라고 불리는 단순한 자바빈이나 아니면 키와 값 쌍을 갖는 랩에 담아서 전달
해야한다.
때론 DB
의 쿼리 하나로 최종 결과를 만들어내기 힘들기 때문에 코드를 통해 데이터
를 분석하고 가공히는 작업이 필요하다. 이런 경우에도 최종 결괴는 DTO나 랩
， 컬렉션
에 담겨서 전달돼야한다.
때론 웹 서비스 등의 시스템과 자료를 주고받을 때 전송 규약에 맞춰서 도메인 오브
젝트에 담긴 정보를 가공해야 할 때가 있다. 이런 경우도 DTO나 뱀을 이용해 해당 형
식에 맞도록 변경히는 작업이 필요하다.

9.3.4 스프링 애플리케이션을 위한 아키텍처 설계
지금까7.1 3단계로 역할을 분리하는 계충형 아키텍처와 정보를 다루는 방법에 따른 아키
텍처의 종류를 알아봤다. 그 외에도 다OJ=한 기술 조합과 업무조건， 시스탬환경에 따른


많은 결정요소와 변수가 있다. 그중에서 계층구조를 어떻게 나눌 것인가와 애플리케이
션 정보를 어떻게 다룰지를 결정하는 것이 기본이 된다. 그리고 그 위에 각 계층에 사용
될 구체적인 기술의 종류와 수직 추상화 계층의 도입 세세한 기술적인 조건을 결정하
는일이남았다.

계층형아키텍처
3
계층 구조는 스프링을 사용히는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는
구조다. 스프링의 주요 모률과 기술을 살펴보면 3
계층 구조에 적합하도록 설계되어 있
다는 사실만 봐도 알 수 있다. 단 3계층이라는 것은 논리적이고 개념적인 구분이지 쪽
오브젝트 단위로 딱 끊어져서 만들어지는 게 아님을 염두에 둬야 한다. 때로는 하나의
계층이 다시 수평으로 세분화될 수도 있다. 반대로 3
계층에서 두 개의 계층이 통합돼서
하나의 오브젝트에 담기는 일도 얼마든지 기능하다.
예를들어 서비스 계층을굳이 도입하지 않아도 될 만큼 비즈니스로직이 단순한애
플리케이션이라면 서비스 계층과 데이터 액세스 계층을 통합할 수도 있다. 스프링의 데
이터 액세스 기술을 사용하면 복잡하고 지저분하게 반복되는 코드가 대부분 제거되고

핵심 데이터 액세스 로직만 남은 간략한 묘드를 가진 DAO를 만들 수 있다. CRUD2.}
는 약자로 표현되는 정보의 등록， 조회， 수정 삭제에 간단한 조건을 이용한 검색만으
로 대부분의 기능을 수행할 수 있는 복잡하지 않은 애플리케이션이라면 서비스 계층을
데이터 액세스 계층에 통합히는 것도 나쁘지 않다. 이때는 트랜잭션 경계설정 위치를

DAO 메소드로 삼으면 된다. 간략한 로직은 DAO 코드에 넣어도 좋다.

반대로 프레젠태이션 계층에 서비스 계층을 통합히는 방법도 가능하다.DAO는 순
수한 DB 인터페이스 역할을 하는 데이터 액세스 기능만 갖게 하고 조건에 따른 간단한
로직의 적용은 프레젠테이션 계층의 컨트롤러에 넣는 것이다. 이 방법이 불기능하진 않
지만 스프링에서는 그리 권장되지 않는다. 스프링 AOP를 이용해 트랜잭션의 경계를
설정하기가 애매하기 때문이다. DAO가 트랜잭션 경계가 되는 경우에는 트랜잭션 전
파 기법을 이용해 여러 개의 DAO 처리를 하나의 트랜잭션으로 조합해서 간단히 묶을
수 있다. 반면에 프레젠태이션 계층의 오브젝트는 트랙잭션 단위로 삼기에는 너무 크
고 트랜잭션 전파를 통해 조합하기가 애매하다. 그래서 굳이 이런 방식을 써야 한다면
TransactionTemplate을 이용해 코드에 의한 트랜잭션 경계설정을 해야 동}는데 이는 너
무번거롭다.

따라서 3
계층을 단순화해서 2
계층으로 만든다면 서비스 계층과 데이터 액세스 계층

9징-스프링프로젝트시작해
I 817


을 통합하는 편이 낫다. 물론 이때도 논리적으로는 서비스 계층과 데이터 액세스 계층
의 경계를 분명하게 하는 게 좋다. 같은 오브젝트에 담겨 있다고 할지라도 비즈니스 로
직을 적용한다면 각각 독립적으로 메소드를 분리해두는 것이 바람직하다.

프레젠테이션 계층은 보통 MVC라는 이름으로 잘 알려진 패턴 또는 아키텍처를 주
로 사용한다. 스프링의 대표적인 프레젠태이션 기술도 SpringMVC라는 이름을 갖고
있고， 이름처럼 MVC 패턴을지원하게 되어 있다. SpringMVC를다루는
Vol.2의 3장
과 4장에서 자세히 살펴보겠지만， 스프링은 이 MVC 중 가장 부담을 많이 지고 있는 컨
트롤러
(C)에 해당하는 부분을 또 다시 세분화해서 여러 단계의 오브젝트로 만들 수 있도
록 설계되어 있다. 이런 식으로 계층 내의 역할을 좀 더 세분화히는 경우도 있다.

프레젠태이션 계층은 특히 그 경계를 애플리케이션이 배치된 서벼를 떠나서 클라이
언트까지 확장하기도 한다. SOFEAService Oriented Front End Architecture라고 불리는 아키

텍처는 프레젠테이션 계층의 코드가 서버에서 클라이언트로 다운로드돼서 클라이언
트 장치 안에서 동작하면서 서버에 존재하는 서비스 계층 또는 부분 프레젠태이션 계층
과 통신하는 구조로 만들어진다. 브라우저 안에서 동작하는 자바스크립트나 플래시 기
반의 애플리케이션을 포함해서 JVM
나 클라이언트 OS
에서 독립적으로 동작하는 기술
도 계속 발전하고 있다. 이때는 프레젠테이션 계층이 가졌던 사용자와의 인터페이스，
화면 흐름에 대한 제어， 서비스 계층과의 통신， 상태정보의 유지 등을 클라이언트에 다
운로드된 코드에서 대부분 담당하게 된다. 그림 9-2
에 나와 있는 SOFEA는 전통적인
MVC 기반의 모댈 2 아키텍처의 위치를 위협할 만큼 빠르게 성장하고 있다. 스프링 또
한 이런 기술의 변화에 맞춰서 다%댄f 지원을 늘리고 있다.

.,(111/ g lJ/
프레젠테이션 계층이 클라이언트외 서버에
분산되거나 클라이언트에민 존재한다

그림 9-23 SOFEA

스프링을 처음 학습하고 도입히는 입장이라면 일단은 가장 전통적인 서버 기반의 3
계
층 구조에 먼저 익숙해지는 것이 좋다. 프레젠테이션 계층은 SpringMVC를 이용하고
서비스 계층은 POJO로 구현하면서 트랜잭션 AOP를 적용하고， 데이터 액세스 계층은


JDBC를 비롯해서 스프링의 데이터 액세스 전략이 적용된 lPA. 하이벼네이트. JDO 등
을 활용하도록 동}는 것이다. 처음에는 01 3
계층 방식의 아키텍처 위에서 스프링의 철학
과 가치를 따라서 코드를 만드는 데 익숙해진 디음 차차 다OJ=한 방식으로 계층구조의
통합과 분산을 시도해보자.

정보전송아키텍처
스프링의 기본 기술에 가장 잘 들어맞고 쉽게 적용해볼 수 있는 것은 오브젝트 중심 아
키텍처의 도메인 오브젝트 방식이다. 일단은 빈약한 도메인 오브젝트 방식으로 시작하
는 게 가장 쉽다. 도메인 오브젝트를 계층 간의 정보 전송을 위해 사용하고， 이를 각 계
층의 코드에서 활용한다. DAO는 그 기술이 어떤 것이든 상관없이 서비스 계층에서 요
청을 받거나 결과를 돌려줄 때 도메인 오브젝트 형태를 유지하게 만든다. 서비스 계층
의 비즈니스 로직 또한 도메인 오브젝트를 이용해 작성한다. 가능하다면 도메인 오브젝
트에 단순한 기능이라도 추가하도록 노력해보는 것이 좋다. 프레젠테이션 계층에서도
이 도메인 오브젝트를 직접 활용하도록 만든다. 프레젠테이션 계층의 MVC 아키텍처
에서도 모댈은 도메인 오브젝트를 그대로 사용한다. 뷰에 전달하는 정보도 물론 도메인
오브젝트를 사용하는 모댈이고， 사용자가 입력하는 폼의 정보도 도메인 오브젝트로 변
환해서사용한다.
이렇게 도메인 오브젝트를 사용해 애플리케이션의 정보를 일관된 형태로 유지하는
게 스프링에 가장 잘 들어맞는 방식이다. 스프링에 포함된 예제나， 스프링 개발자들이
저술한 책에 나오는 샘플 애플리케이션 그리고 스프링의 각 기술의 API 사용 방법을
살펴보면 거의 대부분이 방식을사용하고 있다.
DB와 SQL에 많은 비즈니스 로직을 담고 있는 레거시 시스템을 스프링으로 전환하
는 경우라면， 일단 데이터 중심의 아키텍처를 시용해도 무방하다. 3
계층의 기본 구조
로 잘 분리할 수만 있다면 DB 중심의 접근 방법을 사용해서 기존에 만들어 사용해봤던
SQL을 재사용한다. 그리고 전환 작업을 마치고 검증이 끝난 후에 단계적으로 로직을
DB에서 애플리케이션으로 가져오고， 오브젝트 중심으로 전환하는 시도를 하면 된다.
레거시 시스댐의 기능은 가져오되 구현은 새롭게 처음부터 시작할 수 있다면 스프링
의 철학과 개념에 가장 잘 들어맞는 도메인 오브젝트 중심의 아키텍처에 도전해보는 편
이 나을것이다.
객체지향적인 도메인 분석과 모댈링에 자신이 있고 도메인 오브젝트 설계와 구현，
독립적인 태스트를 자유롭게 적용할 수 있다면 과감하게 도메인 계층 방식을 도입할

9징-스프링 프로젝트 시ξh하기 819


수도 있다. 다만 도메인 계층에 DI를 적용하기 위해 스프링의 고급 기술을 활용해야 하
고 여러 가지 고려할 점이 많으므로 충분한 사전 학습과 검증이 먼저 진행돼야 한다.

상태관리와번스코프
아키텍처 설계에서 한 가지 더 신경 써야 할 사항은 상태 관리다. 크게는 사용자 로그인
세션 관리부터， 작게는 하나의 단위 작업이지만 여러 페이지에 걸쳐 진행되는 위저드
기능까지 애플리케이션은 하나의 HTTP 요청의 범위를 넘어서 유지해야 하는 상태정보
가있다.
엔터프라이즈 애플리케이션은 특정 사용자가 독점해서 배타적으로 사용되지 않는
다. 하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하게 하기 위해 매번
간단한 요청을 받아서 그 결과를 돌려주는 방식으로 동작한다. 따라서 서버의 자원이
특정 사용자에게 일정하게 할당되지 않는다. 그래서 서버 기반의 애플리케이션은 원래
지속적으로 유지되는 상태를 갖지 않는다slaleless는 특정이 있다. 클라이언트로부터의
요청을 처리히는 매우 짧은 시간 동안만 도메인 오브젝트와 같은 정보저장소에 현재 상
태정보가 보관되지만， 이는 요청 결과를 클라이언트에 돌려주고 나면 바로 폐기된다.
그 덕분에 수많은 동시 사용자의 요청을 제한된 서벼 리소스를 가지고 처 리할 수 있다.
하지만 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업정보는 유지돼
야 한다. 이를 위해서 웹 클라이언트에 URL, 파리미터， 폼 히든 필드， 쿠키 등을 이용
해 상태정보 또는 서버에 저장된 상태정보에 키 값 등을 전달해야 한다. 클라이언트와
서벼 사이에서 많은 양의 정보를 계속해서 주고받을 수는 없으므로 중요한 상태정보
는 파일 시스템， 데이터그리드 DB 등에 저장되기도 한다. 또는 제약이 있기는 하지만
HTTP 세션과 같은 서블릿 컨테이너가 제공하는 저장공간을 활용하기도 한다.
이렇게 상태를 저장， 유지하는 데 어떤 방식을 시용할지 결정히는 일은 매우 중요하
다. 스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장한
다. 웹의 생리에 가장잘들어맞고개발하기 쉽기 때문이다. 또， 서버를여러 대로확장
하기가 매우 쉽다. 반면에 웹 클라이언트에 폼 정보를 출력하고 이를 수정하는 등의 작
업을 위해서는 HTTP 세션을 적극 활용하기도 한다. 대부분의 폼 등록， 수정 작업은 한
페이지짜리 폼이라도 여러 번의 HπP 요청에 걸쳐 일어나기 때문에 작업 중인 폼의 내
용을 짧은 동안에라도 서버에 저장해둘 필요가 있다.
상태는 클라이언트， 백엔드에 저장해두거나 서블릿의 HTTP 세션 정도에 일시적으
로 저장해두는 것이 대부분이지만 경우에 따라서는 장기간 유지되며 중첩될 수 있는 상
태를 다루는 고급 상태 관리 기법을 이용할 수도 있다. 애플리케이션의 특정에 따라서


스프링을 이용해서 상태유지
stateful 스타일의 애플리케이션을 얼마든지 만들 수 있다.

스프링에서는 싱글톤 외에도 다른 스묘프를 갖는 빈을 간단히 만들 수 있다. 빈의 스
코프를 잘 활용하면 스프링이 관리하는 빈이면서 사용자별로 또는 단위 작업별로 독립
적으로 생성되고 유지되는 오브젝트를 만들어 상태를 저장하고 이를 DI를 통해 서비스
빈에서 사용하게 만들 수 있다.

서드파티 프레임워크， 라이브러리 적용
스프링은 거의 대부분의 자바 표준 기술과 함께 사용될 수 있다. 기본적으로는 J2EE

1
.4와 lavaEE 5.0을 지원한다. 따라서 스프링으로 만든 애플리케이션은 lSP, lSF,
EJB , JNDI , JTA, lCA, lAX-WS, lMS , lavaMail, lPA와 같은 JavaEE의 세부 기술
과 함께 사용될 수 있다. 스프링 애플리케이션은 기본적으로 서블릿을 기반으로 하는
독립 웹 모률로 만들어진다. 스프링이 제공하는 많은 APl는 이러한 표준 lavaEE의 인
터페이스를 사용할 수 있도록 설계되어 있다. 최근에 등장한 lavaEE 6
의 표준 일부도
지원하고있다.
표준 기술 외에도 많이 사용되는 오푼소스 프레임워크 라이브러리나 상용 제품도
스프링과 함께 시용할 수 있다. 이런 기술을 스프링과 함께 사용할 때는 먼저 스프링이
공식적으로 지원하는 기술인지 확인해본다. 스프링이 직접 지원하는 오픈소스 ORM
의
대표 제품으로는 하이버네이트와 iBatis 그리고 EclipseLi
뼈，
OpenlPA와 같은 오푼소
스 lPA가 있고， 웹 프레임워크로는 스트렷츠 1/2, WebWork, Tapestry, Tiles 등을 꼽
을수 있다. 그 외에도 다%댄
OXM 라이브러리를 지원하고， 메시징 서버와웹 서비스
기술 등을 지원한다. 스프링의 의존 라이브러리로 등록된 100
여 개의 각종 라이브러리
를 살펴보면 스프링이 직접 API
나 추상화 서비스 등을 통해 지원하는 표준 또는 오픈소
스， 상용 기술에는 어떤 것이 있는지 알수 있다.

그렇다면 스프링이 지원하는 기술이란 무슨 의미일까?

• 첫째， 해당 기술을 스프링의 01 때턴을 따라 사용할 수 있다
프레임워크나 라이브러리의 핵심 클래스를 빈으로 등록할 수 있게 지원해주는 것이
라고 생각해도 좋다. 코드를 이용해 초기화해야만 사용할 수 있는 기능을 빈을 등록
히는 것만으로 바로 사용할 수 있다. 프레임워크의 핵심 오브젝트를 빈의 형태로 등
록해둘 수 있다변 프로퍼티를 이용해 세부 설정을 조정할 수도 있고，
DI를 통해 다른
오브젝트에서 손쉽게 활용할 수도 있다. 또 스프링이 제공히는 추상화 서비스를 통
해 다른 리소스에 투명하게 접근할 수도 있다.
9징-스프링 프로젝트 시ξh하기 821


예를 들어 하이버네이트의 기능을 사용하려면 SessionFactory 오브젝트가 먼
저 만들어져야 한다. SessionFactory가 만들어지려면 설정파일에 대한 정보， 설정
값을 담은 프로퍼티와 DB 연결에 대한 정보가 펼요하다. SessionFactory를 만들
기 위해서는 먼저 설정을 담은 Configuration 오브젝트를 만들고 이를 이용해 다시
SessionFactory를 만드는 등의 작업이 펼요하다.

스프링에서는 하이버네이트의 SessionFactory를 스프링이 제공하는 빈을 등록하
는 것만으로 간단히 생성할 수 있게 해주는 LocalSessionFactoryBean
이라는 클래스
를 제공한다. LocalSessionFactoryBean 클래스를 빈으로 등록하고 적절한 프로퍼
티 설정을 해주면 간단히 SessionFactory 오브젝트가 만들어져 빈으로 등록된다. 이
름에서 알 수 있듯이 LocalSessionFactoryBean은 빈 오브젝트를 생성하고 초기화하
는 기능을 가진 팩토리 빈이다. 이 클래스를 빈으로 등록하면 싱글톤 빈으로 존재하
는 하이버네이트 SessionFactory가 만들어지고 하이버네이트의 SessionFactory가
필요한 모든 빈에서 간단히 DI를 통해 가져다 사용할 수 있다. 또， DataSource와 같
이 SessionFactory가 펼요로 하는 리소스는 스프링의 빈으로 등록된 DataSource를
01 받아 사용하도록 만들어주기도 한다. 리스트 9-14는 LocalSessionFactoryBean
을 이용해 SessionFactory 빈을 정의한 예다.

리스트 9-14 하이버네이트용 SessionFactory 지원 민의 설정

<bean id="myDataSource" class="org.apache.commons.dbcp .BasicDataSource")

스프링 빈으로 등록된 리소스를 미 해서
</bean) 히이버네이트
용되게한다
SessionFactory 설정에

-맥토리 빈으로 ~들어진 Lα:atSessionFactαyBean은
<bean id="mySessionFactory'’ \\ I ~ 므로떠티 정보훌 이용해 않ssionFactory를 E샤를어준다

class="org.springframework
.야~.
hibernate3.LocalSessionFactoryBean
"
)

<property name="dataSource" ref="myDataSource"/)

<property name=
깨appingResources")

<list)<value)product.hbm.xml</value)</list) SessionFactory률 만드는 더|
</property) 필요한각종설정정보

<property name="hibernateProperties")
<value)hibernate .dialect=org .hibernate.dialect .HSQLDialect</value)
</property)

</beans )

<bean id="userDao" c
τco
이kκι.dao.UserDaoσ

이lass=
’”’
이m.epril.springboo〈
’”’

<property name="sessionFactory" ref="mySessionFactory “ 1)
</bean)


<bean id="txManager" class= 스프링 빈으로 만들어진 않lSSionFactory는 필요로 하는

오브젝트에 간단히 g 될 수 있다

"org.springframework .orm .hibernate3 .HibernateTransactionManager")

<property name=닝essionFactory" ref=깨ySessionFactory" /)

</bean)

이처럼 스프링 외의 기술을 접목할 때는 가장 먼저 스프링의 빈으로 등록해서 DI

방식을 통해 사용 가능한지 살펴봐야 한다. 만약 빈으로 등록해서 바로 사용할 수 있
는 구조로 핵심 API나 클래스가 만들어져 있지 않은 경우라면， 위의 예처럼 스프링
빈으로 등록돼서 사용하기에 적합하도록 만들어주는 팩토리 빈을 도입해야 한다. 스
프링이 지원하는 프레임워크나 라이브러리는 대부분 이와 같이 스프링 빈의 설정만
으로 등록하고 사용 가능하도록 팩토리 빈 클래스가 제공된다.

myDataSource 빈에 사용한 DBCP
의 BasicDataSource 같은 경우는 그 자체로 바
로빈으로등록하고프로퍼티 설정해서 사용할수있는구조로되어 있다. 따라서 별
도의 스프링 지원 없이도 손쉽게 스프링 애플리케이션에서 사용이 가능하다.

• 둘째， 스프링의 서비스 추응화가 적용됐다
이미 트랜잭션이나 OXM 등의 예에서 다%댄f 오픈소스 프레임워크 또는 표준 기술
에 대한스프링의 서비스추상화 기술을살펴봤다. 첫 번째 방법은사용할 기술을스
프링의 빈으로 등록하고 설정 가능하도록 지원해췄을 뿐이고， 사용 기술의 API는 애
플리케이션에 그대로 노출한다. 서비스 추상화를 적용하는 경우는 이보다 한 발 더
나아가서 비슷한 기능을 제공하는 기술에 대한 일관된 접근 방법을 정의해준다. 이
를 통해 서드파티 프레임워크를 적용할 수 있을 뿐만 아니라 필요에 따라 호환 가능
한 기술로 손쉽게 교체해서 사용할 수 있다.

자바의 표준 기술이란 JCP를 통해 제정된 표준 스펙일 뿐이다. 다OJ한 벤더와 프
로젝트 그룹이 이 스펙을 따라서 실제 구현을 만든다. 표준 스펙에 정의된 API를 이
용해 개발하기만 하면 실제 기술의 구현 제품은 교환해서 사용할 수 있다.

이와 비슷한 원리를 다양한 비표준 기술과 영역에 확장해서 적용한 것이 바로 스
프링의 서비스 추상화라고 볼 수 있다. 상세한 스펙을 따라서 엄밀하게 적용되는 표
준과는 다르지만， 개발자에게는 표준 기술을 사용하듯이 일관된 방법으로 코드를 작
성하게 해준다는 것은 중요한 의미가 있다. 스프링이 제공하는 서비스 추상화가 표
준 기술 스펙과 다른 것은 서비스 추상화는 이미 존재히는 다OJ한 기술의 공통점을
분석해서 추상화를 했다는 점이다. 따라서 추상 서비스 인터페이스를 구현해서 각
기술과 연동하게 해주는 어랩터 클래스가 필요하다. 서비스 추상화 인터페이스를 구

9징-스프링 프로젝트 시ξh하기 823



현한 클래스들은 모두 스프링의 빈으로 등록되도록 만들어졌고， 세부 기술의 특성에
맞는 설정이 손쉽게 가능하도록 다양한 프로퍼티를 제공하고 있다.

• 셋째， 스프링이 지지하는 프로그래밍 모멜을 적용했다
스프링이 지지히는 프로그래밍 모댈이 적용된 대표적인 예는 스프링의 데이터 액세
스 기술에 대한 일관된 예외 적용이다. 스프링의 데이터 액세스 지원 기능을 사용하
면 데이터 액세스 기술의 종류에 상관없이 일관된 예외 계층구조를 따라서 예외가
던져진다. 여기에는 기술에 독립적인 DAO를 만들 수 있도록 데이터 액세스 예외를
추상화하고， 불필요하게 예외를 처리히는 코드를 피하도록 런타임 위주의 예외를 사
용한다는 스프링의 개발철학이 적용된 것이다. 이를 통해， 서비스 계층의 비즈니스
로직을 담은 코드가 데이터 액세스 계층의 기술에 종속되지 않도록 만들어준다.
넷째， 템폴릿/졸백이 지원된다

스프링은 JDBC, JMS, JCA를 비롯한 20
여 가지 기술을 지원히는 템플릿/콜백을 제

공한다. 이런 기술은 그대로 사용하면 반복적으로 등장송}는 판에 박힌 코드 때문에

전체 코드가 지저분해지고 이해하기 힘틀고 추상화하기도 어려운 구조가 돼
버린다.

스프링은 이런 기술을 간편하게 사용할 수 있도록 댐플릿/콜백 기능을 제공한다. 대

부분의 템플릿 클래스는 빈으로 등록해서 필요한 빈에서 DI 받아 사용할 수 있다.

스프링이 어떤 기술을 지원한다는 건 결국 스프링이 지지히는 개발철학과 프로그래
밍 모댈을 따르면서 해당 기술을 사용할 수 있다는 의미다. 물론 이런 방법을 따르지 않
고도 스프링에서 여타 프레임워크를 사용하거나 라이브러리를 이용할 수는 있다. 그 대
신 스프링의 장점을 포기해야 하고 일관된 구조의 유연하고 확장 가능한 묘드를 만들
기가힘들수있다.

물론 스프링이 세상에 나와 있는 모든 기술과 프레임워크를 지원하진 않는다. 지원
할 수도 없다. 스프링이 직접 지원히는 수십여 가지의 표준， 오픈소스， 상용 기술은 엔
터프라이즈 애플리케이션 개발에 보편적으로 사용되는 유명한 것들로 제한된다. 대신
스프링의 기술 지원 방법은 스프링의 핵심 기술과 프로그래밍 모델만 잘 이용하면 어떤
기술에든지 손쉽게 적용이 가능하다. 따라서 스프링이 직접 지원하는 기술이 아니라도
앞에서 소개한 네 가지 방법을 따라서 사용하도록 만들 수 있다.

스프링 익스벤션(http
://www . springsource. org
/extensions
)은 스프링이 직접 지원하지 않지만
나름 유용한 기술에 대해 스프링 스타일의 지원 기능을 만들어둔 대표적인 프로젝트다.
스프링 개발팀
이
나 스프링 커뮤니티에서 지원 기능을 제공하지 않더라도 서드파티 기


술이나 프레임워크가 자체적으로 스프링
에서 손쉽게 사용될 수 있도록 관련 기능을 제
공하는 경우도 적지 않다. 오라클의 TopLink 같은 상용 ORM 솔루션부터 아파치의
Strut5 2 같은 최신 웹 프레임워크， JB055
의 Seam 같은 애플리케이션 프레입워크에 이
르기까지 다양한 제품이 스프링 내에서 손쉽게 사용할 수 있는 스프링 지원 기능을 직
접제공해주고있다.

개발팀이나 기업에서 자체적으로 만든 사내 기술이나 스프링 지원 기능이 제공되지
않는 새로운 서드파티 기술을 사용해야 한다면 어떻게 해야 할까? 가장 쉽지만 가장 나
쁜 방법은 해당 기술을 사용히는 묘드는 전혀 스프링답지 않게 만드는 것이다. 빈으로
등록되도록 만들지도 않고 펼요할 때마다 여기저기서 오브젝트를 직접 만들고 초기화
하는 코드를 넣어서 시용한다거나 다른 기술로 대체될 가능성이 충분히 있음에도 추
상회를 적용하지 않고 특정 기술에 종속되는 코드에서 직접 사용한다거나， try/ catch/
fi nally 블록으로 범벅된 코드를 마구 중복해가며 사용하는 것이다. 당장 기능은 돌아
가겠지만 기껏 스프링을 사용하면서 깔끔하고 유연하게 만들었던 코드가 금새 지저분
해지고 코드의 일관성도 없어지며 유연성도 떨어질 것이 분명하다. 제법 스프링을 잘
안다고 자신하고 스프링을 적용한 개발 경험이 많다는 개발자도 이런 식으로 접근하는
경우가적지않다.

적어도 스프링을 사용해 애플리케이션을 개발하겠다고 마음먹었다면 사용하려는 모
든 기술에 스프링다운 방식으로 접근해야 하지 않을까?

스프링에 새로운 기술을 연동하려면 이 책에서 설명했던 스프링의 프로그래밍 모댈
과 지지하는 개발철학을 따르면서 앞에서 설명한 네 가지 방법을 이용하면 된다. 가장
기초는 스프링의 빈으로 해당 기술의 핵심 오브젝트가 등록되도록 만드는 것이다. 필요
에 따라 팩토리 빈을 λ}용해서 오브젝트 생성과 초기화 작업 프로퍼티 노출 등을 해줘
야 한다. 애플리케이션 내의 빈들이 새로운 기술에 대해 빈을 DI 히는 방법으로 접근할
수 있게 하는 것이다. 반대로 기존 빈 오브젝트를 새로 추가할 기술에서 사용할 수 있게
해줄 필요도 있다. 어떤 경우든 묘드에 의한 초기화 작업이 필요하므로 팩토리 빈을 만
들어 사용하면 편리하다.

때로는 서비스 추상화를 시도할 경우도 있다. 어떤 경우는 스프링이 이미 제공히는
추상 인터페이스의 새로운 구현으로 만들어질 수 있고 아예 새로운 추상화 인터페이스
를 정의해서 적용할 수도 있다. 특히 JavaMai
l
처럼 태스트가 매우 까다롭게 설계된 기
술이고 DI 해서 사용하기 불편하다면 유연한 설정과 더불어 테스트를 위해서라도 새로
운 인터페이스를 추가할 필요가 있다.

9징-스프링 프로젝트 시ξt하기 825


네트워크 접근이나 파일 10처럼 실패할 가능성이 있는 시도를 하는 기술이라면 템플
릿/콜백 방식의 적용도 적극 고려해보자. 기술을 사용할 때마다 반복적으로 try/catch/
finally 블록이 필요한 기술이라면 템플릿/콜백이 제격이다.

때로는 AOP나 예외 전환을 적용할 수도 있다. 보통 외부에서 가져와서 사용히는 기
술은 내부 구현 방식에 손을 대기 쉽지 않다. 소스코드가 공개되고 수정이 가능한 오픈
소스라고 할지라도 코드를 한번 손대기 시작하면 이후 버전과 호환성이 떨어지기 때문
에 함부로 수정해서 사용하기는 힘들다. 따라서 가능하면 외부 기술의 코드에는 손을
대지 않고사용방법을개선하는작업이 필요하다. 예외 변환은종종
AOP를통해 많이
이뤄진다. 특정 예외가 던져졌을 때에 대한 포인트컷을 만들어두고 어드바이스에서 예
외를 추상화된 런타임 예외로 바꿔서 다시 던져주면 된다. 그러면 해당 API를 샤용하는
코드를 전혀 손대지 않고도 손쉽게 예외 변환이 가능하다
vc이
2
의 2장에서 소개히는
스프링의 하이버네이트나 jPA 지원 기능 중에서 예외 전환을 위해 AOP를 이용하는 예
를 참고해보면 도움이 될 것이다.

스프링이 직접 지원 기능을 제공해주지 않으면 무엇인가 시도해볼 생각도 없이 스프
링 이전의 방식대로 코드를 만들어서 외부 기술을 사용하는 건 부끄러운 일이다. 스프
링을 사용하려면 스프링의 프로그래밍 모댈과 그에 담긴 개발 철학을 따르는 일관된 코
드를 만드는 데 많은 관심을 기울여야 한다.

[ ~ 정리

9장에서는 스프링으로 애플리케이션 프로젝트를 만들면서 초기에 결정해야 할 내용에
대해 살펴봤다. 스프링 자체가 워닥 범용적이고 유연해서 어떤 종류의 아키텍처나 프로
젝트에도 적합하긴 하지만 그렇다고 아무렇게나 가져다 사용해도 되는 것은 아니다.
먼저 최적의 개발환경과 도구， 플랫폼을 결정해서 준비해두고， 애플리케이션의 아키텍
처와 시용할 기술 등을 신중하게 선택해야 한다. 또한 스프링 애플리케이션에 적용할
서드따티 기술과 라이브러리에 대한 접근 방법을 개발이 시작되기 전에 충분히 검토하
고 준비해둘 필요가 있다.

여기서 살펴본 내용은 다음과 같다.

• 스프링은 어떤 플랫폼에서도 사용될 수 있지만. 기본적으로는 자바 엔터프라이즈 플랫폼
(JavaEE
)에 최적화되어 있다. HTTP를 통해 접근하는 웹 클라이언트와 백엔드 DB를 사용하
는 애플리케이션에 적합하다.
826


• 스프링 개발의 생산성을 증대시키고 품질을 높이려면 SpringIDE 플러그인이나 STS 같은
적절한 툴의 지원이 필요하다.
• 스프링은 의존 라이브러리가 방대하기 때문에 라이브러리 관리와 의존관계를 관리히는 데
많은 노력을 기울여야 한다. 가능하면 스프링이 의존관계 정보를 제공해주는 Maven이나
Ivy 같은 빌드 툴을 사용해 의존 라이브러리를 관리하는 것이 바람직하다.
• 스프링 애플리케이션은 역할에 따라 3
계층으로 구분되고， 다시 기술의 추상도에 따라 세분
화되는 계층형 아키텍처를 사용하는 것이 좋다.
• 아키텍처는 애플리케이션이 다루는 정보의 관점에서 데이터 중심과 오브젝트 중심으로 구
분할수있다.
• 스프링에 가장 잘 어울리는 아키텍처는 오브젝트 중심의 아키텍처다
• 스프링이 직접 지원하지 않는 서드파티 기술도 스프링 스타일의 접근 방식을 따라서 사용할
수 있도록 준비해둬야 한다
9앙-스프링 프로젝트 시작하기 827


스프렁모률
• ’ ••• -,.
• .~‘----••--~‘ •• .p 、.• ‘ ·•• ':0.. ~ •
. ...’ ·•••••
삭양놔 ’
스프렁모률
• ’ ••• -,.
• .~‘----••--~‘ •• .p 、.• ‘ ·•• ':0.. ~ •
. ...’ ·•••••
삭양놔 ’
...

-

까、프링 프레임워크는 20개의 작은 모률로 세분화되어 있다. 스프링을 사용하는 목

-적과 환경， 사용 기술에 따라 필요한 모률을 선택해 사용해야 한다. 또， 모률 사이

의 의존관계도 이해할 필요가 있다.

모률의 의존관계는 펼수 의존관계와 선택 의존관계가 있다. 모률 A가 모율 B에 대

해서 필수 의존관계를 갖고 있다면 모률 A를 사용할 때는 모률 B를 반드시 포함시켜야

한다. 반면에 선택 의존관계를 가진 모률도 있다. 모률 A가 모율 C에 대해 선택 의존관

계를 갖고 있다면 모률 A를 사용하기 위해 모률 C가 반드시 펼요한 것은 아니지만， 모

률 A의 특정 기능을 사용할 때는 모률 C가 필요할 수도 있다는 뭇이다. 따라서 선택적

인 의존관계에 있는 모률에 대해서는 어떤 경우에 필요한지 알고 있어야 한다.

부록 A에서는 스프링 3.0을 기준으로 모률의 종류와 의존관계를 설명한다. 스프링


3.1
의 모률의존관계는스프링 3.0과동일하다.
A.1 스프링 모률의 종류와특징 판
l
A.1.1 스프링 모률 이름
스프링 모률은
Jar
확장자를가진파일이다. 모률파일의 이름은 명명 규칙에 따라두가
지로 만들어져 있다. 스프링 모률은 기본적으로 OSGi
의 모률 명명 규칙을 따라서 다음
과 같이 패키지 이름과 모률 버전으로 구성된다.

부톨A.... 스프링 모율 829


org. springframework. core-3.0.7. RELEASE.jar

모율때키지
이를 모둘버전

스프링 모률은 OSGi
의 모률 조건을 충족하는 OSGi 번들이기도 하다. 따라서 OSGi
플랫폼에 바로 가져다 시용할 수 있다. 물론 OSGi가 아닌 일반 JavaEE나 JavaSE 환
경에서도 아무런 문제 없이 시용할 수 있다. 스프링 모률을 OSGi에서 사용하는 방법을
알고 싶으면 스프링 OSGi(http
:(/www.springsource.org/osg
i
)를 참고하자.

Maven의 명명 규칙을 따라 만들어진 스프링 모률 따일도 있다. Maven이나 Ivy를
통해 접근할 수 있는 Maven Central 리포지토리에서는 다음과 같은 Maven 스타일의
모율 이름을 가진 파일을 찾을 수 있다. Maven 모률 이름에는 패키지를 사용하지 않기
때문에 이름이 단순한 편이다.

spring-core-3.O.7.RELEASE.jar

모률이름 모률
버전

이 두 개의 파일은 이름은 다르지만 그 내용은 완전히 동일하다.

A.1.2 스프링 모률 추가
스프링 모률을 프로젝트에 추가하는 방법은 두 가지가 있다. 스프링 배포판에 포함된
모률을 직접 추가하는 방법과 Maveno
1나 lvy의 의존 라이브러리 관리 기능을 이용해
모률 리포지토리에서 자동으로 추가되게 하는 방법이다.

수동추가
스프링 모률을 얻을 수 있는 가장 손쉬운 방법은 스프링 배포판을 이용하는 것이다. 스
프링 프레임워크 배포판은 http:
//www
.springsource.com/download/community에서
다운로드할 수 있다. 배포판 파일의 압축을 풀고 dist 폴더를 열어보면 스프링 모률을
찾을수있을것이다.
스프링 배포판에 포함된 모율파일은 OSGi 호환 모률 이름을 갖고 있다. 사용할 기
능에 따라 적절한 모률파일을 프로젝트에 포함시켜주면 된다. 수동으로 모률을 추가할
때는 모률 의존관계에 따라서 필요한 의존모율을 빼먹지 않도록 주의해야 한다. 모률의
의존관계는 다음 절의 내용을 참고하자.


Maven/lvy 자동 추가

Maven을 이용해 의존 라이브러리를 관리한다면 pom.xml 파일의 의존정보 설정만으

로 필요한 스프링 모률을 가져올 수 있다.

스프링 모률은 Maven Central 리포지토리에 등록되어 있다. 따라서 리포지토리를

따로 지정하지 않아도 스프링 모률을 가져올 수 있다. 이때는 Maven 스타일의 모률 이

름을 사용해서 스프링 모률을 가져외야 한다. 다음은 core 모률에 대한 Maven 의존 라

이브러리 선언 항목이다.

<dependency)
<groupld)org.springframework</groupld)
<artifactld)spring-core</artifactld)
<version)3.0.7.RELEASE</version)

</dependency)

groupld는 항상 동일하다. arti factld는 스프링 모율의 Maven 이름으로 지정해주

면된다.

OSGi 이름을 가진 모률을 사용하려면 스프링소스에서 제공하는 Maven 리포지토리

를 다음과 같이 지정해줘야 한다.

<repository)
<id)com.springsource.repository.bundles .release</id)
<name)SpringSource Enterprise Bundle Repository -SpringSource Bundle
Releases</name)
<url)http://repositorY.springsource.com/maven/bundles/release</url)

</repository)

스프링소스 리포지토리를 지정했다면 다음과 같이 OSGi 이름을 가진 모률을 가져올

수있다.

<dependency)
<groupld)org .springframework</groupld)
<artifactld)org.springframework.core</artifactld)
<version)3.0.7 .RELEASE</version)

</dependency)

Maven Central
에 등록된 모률을 사용할 때와 다른 점은 artifactld
에 OSGi 모률

이름을 사용하는 것이다.

Maven을 이용하면 전이적 의존관계 관리기능이 적용되므로 펼수 의존관계에 있는

부를 A-스프링 모률 831


모률이 자동으로 추가된다. 따라서 모든 모률을 일일이 지정할 필요가 없다. 필수 의존
관계에 대해서는 다음 절을 참고하자.

Ivy도 Maven과 동일한 리포지토리를 사용한다. 스프링 소스의 OSGi 호환 모률을
사용하는 경우에는 http: //www.springsource.com/ repository/app
/faq에 나온 설정을
참고하면된다.

A.1.3 스프링 모률 목록
표 A-l
은 스프링 모률의 목록과 각 모률의 OSGi 이름과 Maven 이름이다.
표
A-1
스프링모둘

| 모률 이름 | 여[tlI 모율 이름
AOP I 0rg
.
spnnglramework.a。
P
ASM 。rg
.s
prInglramew。
rk.asrn
Aspects 。rg.sprInglramew。
rk.aspects
Beans I 0rg.spr1nglrameWOrk.beans
Context I org.springlramework.context

Context. I org.springlramework.context
Support support
Core I 0rg.springlr'amework core
Expresslon I 0rg.springlramework.expresslon
Instrument I org.springlramework.instrument

Instrument. I org.springlramework.instrument
Tomcat .tomcat

JDBC 1
0rg.spnnglramew。rk.jdbc
JMS I 0rg.spnnglramework.jms
ORM I org.springlramework.orm

OXM 1
0rg.spnnglramew。rk
.
oxm


Test org.sprInglramework.test
Transaction 。rg.spnnglramework
.
t「ansactlon


Web 。
rg.sprInglramew。rk.web


Web.Porllet 。rg.sprInglramew。rk.web
.
p。rtle


j 싸n 모률 이름)그춘맏]늘
I spnng-aop I AOP
I spnng-asm I ASM 재때키징
I spnng-aspects As∞ctJ 지원

spnng-beans 빈 팩토리
I spring-context 애플리케이션 컨텍

AE

I spring-context-support 컨텍 AE 부가
기능

I spnng-core 공통 기능
I spnng-expression I SpEL
I spring-instrument An
링 Java

Agent

I spring-instrument 톰갯 클래스
-tomcat 로더
spring-,dbc I JDBC

I spring-jms JMS
I spring-orm I ORM(Hibernate,

JPA
등)

I sprIng-oxm I OXM

spnng-test 테스트
I spnng-tx 트랜잭션
I spring-web 웹 공통
I
spnng-webmvc-portlet 포툴릿

(이어짐)


「
모률 이릅 111모률 이를 ..모률 이름 | 주요 기능

1

Web.Servlet I org.springlramework.web.servlet spring-webmvc 서블릿

Web.Struts I org.springlramework.web.struts spring-struts 스트렷츠
1
지원

ræ 스효람보률으l 의존관계 철I

그림 A-l
은 스프링 모률의 필수 의존관계를 나타낸다.

| 없 휩~ 휩1-휩
l
| 빼--휩 빼 휩| 、\、
|뼈1짧 聊
휩l //?
| ElIPr훌빼l
휩|
| 뼈 휩 빼휩-카 뼈xt 뺨--1 뼈 휩|
l 빼S 윈r-:: 휩뼈~뭘 빼 휩|

| 뼈 휩 없빼휩 빼빼휩|

| 빼POfIIt휩
l

그림 A-1 스프링 모둘의 필수 의존관계

부륙 A.. 스프링 모둘 833



각 화살표는 모률 사이의 필수 의존관계를 나타낸다. 예를 들어 Beans의 펼수 의존모률
은 Core와 ASM
이다. Beans 모률을 사용하려면 Core와 ASM 모률도 함께 추가해줘야
한다.

필수 의존관계는 전이적이다. 예를 들어 Context는 AOP와 Expression 두 개의 펼
수 의존모률을 갖고 있는데 AOP는 다시 Beans에， Beans는 ASM과 Core에 의존하고
있다. 결국 Context는 AOP, Expression뿐만 아니라 Beans, ASM, Core 모률에도 의
존하고 있는 셈이다. 따라서 스프링의 모율을 선택할 때는 펼수 의존관계에 있는 모든
모률을 찾-0]-서 포함시켜야 한다. Mavenoj나 Ivy의 의존 라이브러리 관리 기능을 이용
한다면 전이적인 의존관계를 따라서 모든 펼수 의존 라이브러리가 자동으로 추가된다.
Maven 설정파일에 의존 라이브러리로 Web.Servlet 모률을 지정해췄다면 펼수 의존관
계에 있는 Web, Context.Support, Context, AOP, Expression, Beans, Core, ASM
모률이 자동으로 추가된다.

그림 A-)
에는 나와 있지 않지만 선택 의존관계에 있는 모률도 있다. 예를 들어
OXM은 Web.Servlet의 펼수 의존모률은 아니다. 하지만 일부 Web.Servlet 모률의 기
능은 OXM을 필요로 한다. 이 기능을 사용할 때는 OXM을 추가로 포함시켜줘야 한다.

AspectJ, Instrument, Instrument. Tomcat, Test 네 개의 모률은 여타 모률과 직접적
인 필수 의존관계는 없다. 대신 각각 선택적인 의존관계를 가진 모률이 있다.

A.2.1 모률별 의존관계
각 모율별로 의존하고 있는 모률의 종류와 관련 기능을 살펴보자.
ASM
모률
ASM 모율은 엄밀히 말해 스프링 모율이 아니다. ASM 모률은 클래스 바이트코드 조
작 및 분석 프레임워크인 ASM
(http
://asm.ow2.org
()을 재패키징한 모율이다. ASM 프레임
워크는 스프링뿐 아니라 다른 많은 프레임워크와 라이브러리에서도 사용된다. 그런데
각기 다른 버전의 ASM을 사용히는 경우가 있어서 의존관계에 문제가 생기기도 한다.
그래서 스프링은 다른 ASM을 사용히는 프레임워크와의 충돌을 방지하기 위해 스프링
이 사용히는 버전의 ASM 프레임워크를 org.springframework.asm 패키지로 재패키정
해서 독립적인 모율로 제공한다.
ASM 모률이 의존하는 다른 모률은 없다. ASM 모률은 모든 스프링 프레임워크에
서 필요로하는필수모률이다.


Core
모률
Core 모률은 대부분의 스프링의 모율에서 펼요로 하는 공통 기능을 갖고 있는 핵심 모
율이다. 스프링이 시용하는 주요 타입， 애노테이션， 컨버터， 상수， 유틸리티 클래스 등
을제공한다.
Core 모률의 필수 라이브러리는 없다. 클래스 메타정보를 읽는 기능에서 선택적으로
ASM 모률에 의존하고 있을 뿐이다. Core는 모든 스프링 프로젝트에 반드시 포함시켜
야하는필수모률이다.

Beans
모률
Beans는 스프링 DI 기능의 핵심인 빈 팩토리와 Dl 기능을 제공하는 모률이다. 빈 메타
정보， 빈 리더， 빈 팩토리의 구현과 프로퍼티 에디터가 포함되어 있다. 애플릿이나 모바
일 같은 제한된 환경에서 순수하게 스프링의 Dl 기술만 적용하고 싶다면， Beans 모률
까지만 적용하고 BeanFactory API를 사용할 수 있다.
Beans는 ASM , Core 두 개의 펼수 의존모률을 갖는다.

AOP
모률
AOP는 스프링의 프록시 AOP 기능을 제공하는 모률이다. 프록시 기반 AOP를 만들 때
필요한 어드바이스， 포인트컷， 프록시 팩토리빈， 자동 프록시 생성기 등을 제공한다.
스프링의 AOP는 DI
에 기반을 두고 있다. 따라서 AOP 모률은 Dl 기능을 제공하는
Beans 모률에 의존한다. 물론 전이적 의존관계에 따라서 Beans가 의존히는 ASM과
Core에도 의존한다.

Expression 모률
Expression은 스프링 표현식 언어
SpEL 기능을 지원하는 모률이다.
Expression은 Core 모률에만 의존한다. Core 모률과 함께 사용한다면 스프링 애플
리케이션 밖에서 순수한 표현식 언어 라이브러리로 이용할 수도 있다.

Conte쳐모률
Context는 애플리케이션 컨텍스트 기능을 제공하는 모률이다. 애플리케이션 컨텍스트
를 만드는 데 필요한 대부분의 기능을 포함해서 빈 스캐너 자바 묘드에 의한 설정 기
능， EJB 지원 기능， 포매터
， 로드타임 위빙， 표현식. JMX, JNDI , 리모팅， 스케줄링，

부혹 A-스프링 모률 835


스크립트 언어 지원， 검증기 등의 애플리케이션 컨테이너로서의 주요한 기능을 담고 있
다. 단순한 DI 프레임워크가 아니라 본격적인 엔터프라이즈 애플리케이션 프레임워크
로 사용하기 위해 반드시 필요한 모률이다.

Context는 AOP와 그 상위 의존모률을 필요로 한다. 또 Expression도 Context의 필
수의존모률이다.
Context의 로드타임 위벙
lìW 기능을 시용하는 경우에는 Instrument 모률이 선택적
으로필요하다.

Context.Support 모률
Context. Support는 Context처럼 지주 사용되는 기능은 아니지만， 경우에 따라 애플리
케이션 컨텍스트에서 필요로 히는 부가기능을 담은 모률이다. EhCache. 메일 추상화
서비스. CommonJ와 Quartz 스케줄링 그리고 FreeMarker. JasperReports. Velocity
팩토리 기능을 제공한다. 이런 특별한 기능을 시용하지 않는다면 Context. Support 모
률은 필요 없다. 단， 스프링 MVC가 Context. Support에 의존하기 때문에 스프링 MVC
를 사용한다면 펼수로 추가해야 한다. 그 외의 웹 기술을 시용히는 경우라면 포함시키
지않을수도있다.
Context. Support는 기본적으로 Context 모율에 의존한다. Quartz의 JobStore 기능
을 활용하는 경우에 선택적으로 JDBC와 Transaction 모률이 펼요하다.

Transaction 모률
Transaction은 스프링의 데이터 액세스 추상화의 공통 기능을 담고 있는 모률이다.
DataAccessException 예외 계층구조와 트랜잭션 추상화 기능， 트랜잭션 동기화 저장소
그리고 JCA 지원 기능을 포함하고 있다. 스프링의 데이터 액세스 기술을 사용하는 데
반드시 필요한모률이다.
Transaction의 필수 의존모률은 Contextq.

JDBC
모률
JDBC는 JDBC 템플릿을 포함한 JDBC 지원 기능을 가진 모률이다. JdbcTemplate 등
의 JDBC 지원 오브젝트 외에도 스프링이 직접 제공하는 DataSource 구현 클래스틀이
제공된다.
JDBC는 Transaction 모률에 의존한다.


ORM
모률
ORM은 하이버네이트， JPA, JDO, iBatis와 같은 ORM
에 대한 스프링의 지원 기능을
갖고있는모률이다.
ORM은 JDBC에 의존한다.ORM 모률에서 JDBC 모률의 DataSource나 트랜잭션
매니저 등을 활용하기 때문이다. OpenSessionlnViewFilter와 같은 일부 기능은 Web
모률에 선택적으로 의존한다.

Web
모률
Web은 스프링 웹 기술의 공통적인 기능을 정의한 모률이다. 스프링 MVC 외에도
스프링이 직접 지원하는 스트릿츠 JSF 등을 적용할 때도 필요하다. 또한 Caucho
Httplnvoker, JAX-RPC, JAX-WS 등의 리모팅 기능도 포함하고 있다. 기본적인 바
인딩， 컨텍스트 로더， 필터， 멀티파트， 메시지 컨버터 기능도 제공한다.
Web 모률은 Context 모률을 필수 모율로 갖고 있다. XML을 사용하는 메시지 컨버
터 기능에는 OXM 모률이 필요할 수 있다.

Web.Servlet 모률
Web.Servlet은 스프링 MVC 기능을 제공히는 모률이다. 전통적인 스프링 MVC와 최
신 @MVC 기능이 모두 포함되어 있다.
Web.Servlet의 펼수 의존모률은 Web과 Context. Supportct-. XML을 이용한 뷰나
메시지 컨버터 등을 사용할 때는 선택적으로 OXM 모률을 필요로 한다.

Web.Portlet 모률
Web. Portlet은 Portlet 개발에 사용하는 스프링 모률이다. Web.Portlet의 필수 의존모
률은 Web.Seπlet이다.

Web.Struts 모률
Web.Struts는 스트렷츠 1.x를 지원하는 모률이다. 스트렷츠 l.x를 스프링의 웹 프레젠
태이션 계층으로 시용할 때 유용한 기능을 제공한다.
Web.Struts는 Web 모률에만 의존한다.

부톨A... 스프링 모둘 837


JMS
모률
lMS는 스프링의 lMS 지원 기능을 사용할 때 필요한 모률이다.
lMS는 Transaction 모률에 의존한다.

Aspects
모률
Aspects는 스프링이 제공송}는 Apsect1 AOP 기능을 시용할 때 필요한 모률이다. 스프
링이 직접 제공히는 Aspect1로 만든 기능은 @Configurable을 이용한 도메인 오브젝트
DI 기능， lPA 예외 변환기， Aspect1 방식의 트랜잭션 기능 등이 있다.
Aspects의 펼수 의존모률은 없다. lPA 지원 기능을 사용할 때는 ORM, 트랜잭션 지
원 기능을 사용할 때는 Transaction 모률에 선택적으로 의존한다.

Instrument 모률
Instrument는 스프링의 로드타임 위벼
LTW 기능을 적용할 때 필요한 모률이다. LTW 기
능을 제공하는 Context 모률에도 선택적으로 사용된다.NM의 -javaagent 옵션을 사
용해 자바에이전트로도 사용된다.
Instrument는 다른 의존모률이 없다.

Instrument.T omcat 모률
Instrument. Tomcat은 애플리케이션이 아니라 톰켓 서버의 클래스 로더로 사용히는 모
률이다. 다른모율에 대한의존관계는전혀 없다. 자세한시용방법은스프링 레퍼런스
의 로드타임 위벙 항목을 참고하자.

Test
모률
Test는 스프링의 태스트 지원 기능을 가진 모률이다. 태스트 컨텍스트 프레임워크나 목
오브젝트 등을 이용해 테스트를 만들 때 시용한다. 태스트용 모률이기 때문에 운영 중
에는사용되지않는다.


까、프렁의존
라φl
브균1鍵j

까、 프링 3.0과 스프링 3
.
1
에는 스프링 모율 외에도 100여 개의 의존 라이브러리가
-존재한다. 이 의존 라이브러리는 스프링 프레임워크를 빌드하고 태스트하는 데
펼요한 라이브러리다. 스프링 애플리케이션을 개발하고 운영할 때는 이 외에도 다OJ=한
많은 라이브러리가추가로 멸요할수 있다.

부록 B에서는 태스트 시 시용되는 라이브러리를 제외한 나머지 의존 라이브러리가
어떤 모률의 어떤 기능을 사용할 때 필요한지 설명할 것이다. 스프링의 의존 라이브러
리는 스프링의 업데이트마다 새롭게 추가되거나 버전이 바뀔 수 있다. 스프링이 직접
참조히는 라이브러리의 기능과 API가 바뀌지 않는다면 라이브러리 버전은 스프링 배포
판의 빌드 스크립트에 나온 것과 다른 것을 사용해도 무방하다. 또， 라이브러리의 사용
방법에 따라 여기에 소개하지 않은 라이브러리가 필요할 수도 있다. 부록 B에서는 스프
링 3.0을 기준으로 대략적인 의존 라이브러리를 소개하고 있을 뿐이니 실제 애플리케이
션에 적용할 라이브러리와 버전은 검색과 다OJ=한 태스트를 통해 직접 선정할 수 있어야
한다. 최신 의존 라이브러리 정보는 스프링 배포판이나 Maven 리포지토리의 POM 정
보를참고하자.

[ L;1&] 의존 라이브러리의 종류와 특징 ;펄
I

8.1.1 의존 라이브러리 이름
의존 라이브러리는 스프링 개발팀이 만든 것이 아니므로 모률의 이름에 일정한 패턴이
있지는 않다. 하지만 스프링소스가 OSGi 호환 모률로 재패키정한 모률의 이름은 일정
한패턴이있다.

부륙 B_ 스프링 의존 라이브러리 839


Commons 프로천젝l트(thtt
끼끼//싸

예를 들어보자. 최신 아파치 뼈빼ttp
:
/ιco
mrr
라이브러리 파일의 이름은 commons-logging-l.l.l
껴r이다. Maven 리포지토리에
등록된 라이브러리 따일 이름도 동일하다.

그런데 스프링소스는 Commons Logging 라이브러리 따일을 OSGi 표준에 맞도록
메타정보를 추가해서 재패키정하고 OSGi 모률의 명명 규칙을 따라 디음과 같은 이름
의 파일로 만들어 제공한다.

com. springsource. org.apache. commons.logging-l.l.l ,jar

공통 때키지 이름 모률 이름 버전

OSGi
의 명명 규칙을 따라 모율의 기본 패키지 이름을 모률 이름으로 사용하게 했을
뿐만 아니라， 스프링소스가 OSGi 플랫폼에서 시용 기능한 모률로 재패키정했음을 나
타내도록 항상 com. springsource라는 공통 패키지 이름이 추가되어 있다.

오푼소스 프레임워크나 라이브러리뿐 아니라 자바의 표준 API를 위해서도 OSGi
호환 모률이 제공된다. 예를 들어 서블릿 API는 보통 servlet-api.
j
ar라는 이름의 파
일로 되어 있다. 반면에 스프링소스가 제공하는 OSGi 호환 라이브러리 이름은 com.
springsource.javax. servlet-2. 5.0.jar이다. 앞의 com. springsource 부분을 제외하면
모률의 패키지 이름을 알 수 있으므로 어떤 라이브러리 파일인지 쉽게 확인할 수 있을
것이다. 표준 API는 보통 서버에서 제공되기 때문에 애플리케이션 모률에 포함시킬 펼
요는 없지만， 빌드 작업 중에 펼요하기 때문에 애플리케이션 프로젝트에 포함시켜야
한다.

스프링 모률은 파일의 이름이 달라도 내용은 동일하다. 반면에 스프링소스에 의해서
OSGi 호환 라이브러리로 재패키정된 파일은 라이브러리의 공식 배포파일이나 Maven
에 등록된파일과구성이 조금다를수 있다는점에 주의해야한다.

8.1.2 의존 라이브러리 추가
스프링 프로젝트에 의존 라이브러리를 추가히는 방법은 스프링 모률과 마찬가지로 수
동으로 라이브러리 파일을 직접 넣어주는 방법과， Maven 또는 Ivy의 의존 라이브러리
관리 기능을 사용해 자동으로 넣어주는 방법이 었다.


수동추가
스프링의 의존 라이브러리 파일은 각 라이브러리의 웹사이트에서 직접 다운로드 받을
수 있다. 라이브러리의 웹사이트나 다운로드 정보는 검색엔진 등을 통해 직접 찾아야

한다. 이때는 스프링 버전에 따라서 호환 가능한 의존 라이브러리 버전이 맞는지 확인
해야 한다. 버전이 일치하지 않으면 바르게 동작하지 않을 수도 있다.
스프링소스가 제공히는 OSGi 호환 라이브러리 파일을 사용할 경우에는 스프링소스
의 리포지토리 검색 기능을 활용하면 된다.
스프링소스 엔터프라이즈 번들 리포지토리의 검색 기능(http
:;/ebr.springsource
.
com
/

repository/app
/)을 이용해 라이브러리를 찾으면 된다.

부록 B에서 설명하는 의존 라이브러리는 스프링이 직접 의존하는 라이브러리뿐임
을 주의해야 한다. 스프링이 직접 의존히는 라이브러리가 다시 제
3
의 라이브러리를 펼
요로 할 수도 있기 때문이다. 이때는 필요한 라이브러리가 어떤 것인지 일일이 확인해
서 추가해줘야 한다. 간단한 라이브러리나 표준 API
의 경우에는 의존 라이브러리가 없
기도 하지만， 하이버네이트 같은 복잡한 프레임워크는 사용 기능에 따라 여러 가지 추
가 라이브러리를 필요로 한다. 각 라이브러리의 의존정보는 해당 라이브러리의 문서나
POM 정보를 참고하자. 수동 추가의 경우는 이렇게 추가적으로 필요한 의존 라이브러
리를 일일이 찾아서 넣어줘야 하는 변거로움이 있다.

자동추가
Maven이나 Ivy를 이용하는 경우에는 Maven의 디폴트 리포지토리인 Maven Central
에서 Maven 스타일의 이름을 가진 파일을 가져오는 방법과 스프링소스가 제공히는
Maven 리포지토리에서 OSGi 호환 파일을 가져오는 방법이 있다.

디폴트 리포지토리를 이용하는 경우에는 Maven 검색 λ}이
E(http:/
/
mvn때ository
.
com
/)를

통해 손쉽게 의존 라이브러리 설정정보를 얻을 수 있다.
Commons Loggin
이라면 다음과 같은 <depedency) 태그를 pom
.xm
l
에 넣어주면

된다.

<dependency)
<groupld)commons-logging</groupld)

<artifac다tld)co
mmons-logging
</artifactld)

<version)l.l.l</version)
</dependency)

부톨 B_ 스프링 의존 라이브러리 841



스프링소스가 제공하는 OSGi 호환 라이브러리 Maven 리포지토리를 이용하려면 먼
저 다음과 같은 추가 리포지토리 설정을 pom.xml
에 넣어줘야 한다.

<repository>
<id>com.springsource.repositorY.bundles.external</id>
<name>SpringSource Enterprise Bundle Repository -External Bundle Releases
</name>
<url>http://repository.springsource .com/maven/bundles/external</url>

</repository>

스프링소스 Maven 리포지토리에 등록된 Commons Logging은 다음과 같은 설정을
통해 가져올 수 있다. 각 라이브러리의 Maven 설정정보는 검색
(http:
//ebr.springsource
.
com
/

때ository
/app
f) 결과에서 찾을 수 있다.

<dependency>
<groupld>Org.apache.commons</groupld>

매빙

<arπti fac다tI
d>coαom.ιI.sprin1
gSOLωu따lπrπce.org.apache.commons.logging</artifactld>

<version>1.1.1</version>
</dependency>

가능하면 의존 라이브러리의 리포지토리는 하나로 통일하는 게 좋다. 하지만 스프링
소스의 OSGi 호환 라이브러리 리포지토리는 Maven Central보다 최신 버전의 업데이
트가 느린 편이다. 따라서 스프링소스 리포지토리의 라이브러리를 사용하더라도 일부
라이브러리는 Maven Central 리포지토리에서 가져외야 할 수도 있다.

Ivy
의 리포지토리 설정은 스프링소스 리포지토리의 FAQ(ht따
/ /ebr.springsource.com/

때ository
/app
/
faq)를 참고하기 바란다.

자동 의존 라이브러리 관리 기능을 사용할 경우 라이브러리의 의존정보를 참고해서
추가적인 의존 라이브러리도 포함해준다. 하지만 의존정보가 항상 완벽하진 않고， 프로

젝트마다 선택적으로 추가하거나 제외시켜야 할 것도 있으므로 어떤 라이브러리가 자

동으로 추가되는지 직접 확인해볼 펼요가 있다.


I~ 모률별 의존 라이브러리 의존관계 넷.성I

스프링의 많은 의존 라이브러리 중얘서 어떤 것을 사용할지 결정히는 일은 쉽지 않다.
가장 좋은 접근 방법은 스프링의 각 모률별로 필요한 의존 라이브러리 선택하는 것이
다. 어떤 스프링 모률을 사용할지 결정됐다면， 각 모율별로 활용할 세부적인 기능에 따
라서 펼요한 의존 라이브러리를 선택하면 된다.

거의 대부분의 스프링 의존 라이브러리는 펼수가 아니다. 사용할 모률의 기능에 따
라서 의존 라이브러리가 필요할수도 있고 아닐 수도 있다는뭇이다. 따라서 모률별 선
택 라이브러리 중에서 적절한 라이브러리를 선택할 수 있어야 한다. 이 절에서는 스프
링의 모율별 의존 라이브러리가 어떤 것이 있는지와 어떤 경우에 필요한지에 대해 설명
할 것이다. 하지만 각 라이브러리에 대한 자세한 기능은 설명하지 않는다. 라이브러리
자체에 대
해 알고 싶다면 라이브러리 웹사이트를 참고하기 바란다.

8.2.1 필수 라이브러리
• Commons Logging 1.1.1
com.springsource.org.apache.commons.logging-l . l . l .jar
재패키징 모율인 ASM과 자바 에이전트와 톰켓 클래스 로더로 시용되는 Instrument
와 Instrument-Tomcat 모률을 제외한 모든 스프링 모률은 아파치 Commons 프로

젝트의 Logging 라이브러
èj (http://commons.apache.org
/
l
ogging
/l를 사용해 로그를 남기도록

되어 있다. 따라서 Commons Loggi
n
g
은 모든 스프링 프로젝트에 포함시켜야 하는

필수라이브러리다.
Commons-Logging 대신 SLF4J
(http
://www.sl찌org)를 사용한다면 jcl-over-slf4j
로대체할수도있다.

8.2.2 모률벌 선택 라이브러리
선택 의존 라이브러리 중에서 패키지 이름이 j
avax로 시작하는 것은 자바의 표준 API
라이브러리다. 표준 API 중 일부는 서버에서 제공되기 때문에 벌드 중에는 필요하지만
서버에 배포할 때는 제외해야 하는 것들도 있다. 예를 들어 Servlet API는 코드에서 사
용하는 경우 빌드 과정에는 필요하지만 서버에 배포할 웹 모률 패키지에는 넣을 필요가
없다.

부를 B_ 스프링 의존 라이브러
리 843


ASM
모률
ASM 모률은 단순히 ASM 라이브러리를 재패키징한 것이기 때문에 다른 의존 라이브
러리는없다.

Core
모률

Core 모률의 펼수 라이브러리는 없다.

• AspectJ Weaver 1.6.8
com
Sprriηin멍양
때야응ρorg.aspect
뼈
테-카1.6.8.RELEASE.껴r

이
πI.
삐
g
ce
.
땅
쩨때인j，
weaver-마

빼디대띠
sourπrκ
야때
야띠
싫


AspectJTypeFilter 클래스에서 시용된다. 이 클래스를 사용할 경우. AspectJ 기능
을활용히는 다른모률이 함께 사용된다. Core 모율의 선택 의존 라이브러리이긴 하
지만무시해도좋다.

• JBoss VFS 2.1.0.GA
com. springsource.org.jboss. virtual-2. 1.0. GA.j ar
JBoss 서벼가 제공하는 VFsVirtual File System
에 대한 VFS 리소스 추상화 기능을 위해

사용된다. JBoss VFS
의 리소스를 직접 활용해야 할 경우에 사용한다.

Beans
모률

Beans 모률은 필수 의존 라이브러리가 없다.

• CGLib 2.2.0/2.1.3
com. springsource. net. sf. cglib-2.2. O.jar
프로토타입 빈의 DL 기능을 자동으로 추가해주는 메소드 주입
meth여 |뼈

할때펼요하다.

AOP
모률

• AOP Alliance 1.0.0
com.springsource.org.aopalliance-l.O
.
O껴r

AOP 모율의 펼수 라이브러리다. 어드바이스를 만들 때 사용하는 Advice.
Methodlnterceptor 인터페이스 등이 정의되어 있다.


• Jamon API 2.4.0
com. springsource. com.jamonapi-2.4. O.jar
애플리케이션 모니 터 API안인! Jamon AP
(htt
Q
민lC““빼
정용 어드바이스인 JamonPerformanceMonitorlnterceptor에 사용된다. AOP를 이
용한 간단한 성능측정
/모니터링 기능이 필요한 경우에 시용할 수 있다.

• CGLib 2.2.0/2.1.3
com. springsource. net. sf. cglib-2.2.0.jar
CGLib 기반의 프록시를 만들 때 사용한다. 인터페이스 대신 클래스 상속을 통한 클
래스 프록시를 만들 수 있다.

• Commons Pool 1.5.3/1.3.0
com.springsource.org.apache.commons.pool-l .5.3.jar
AOP에서 시용되는 TargetSource 구현의 하나인 (ommonsPoolTargetSource에서 사
용된다. TargetSource를 풀링 방식으로 설정해서 시용할 수 있는 고급 사용자에게
펼요한 기능이다. 일반적으로는 무시해도 좋다 .
• AspectJ Weaver 1.6.8
com.springsource. org.aspectj. weaver-l .6. 8. RELEASE.jar
AspectJ 스타일의 스프링 AOP를 사용할 경우에 필요하다. AspectJ의 문법과 애노
태이션 등을 차용해서 스프링 AOP를 만들기 위해 필요한 것이지 ApsectJ 컴파일러
나 위빙 기능을 사용하기 위한 것은 아니다. AspectJ 애노테이션을 사용해 만든 어
드바이스， 포인트컷 등을 쓰려면 추가해야 한다.

Expression 모률
Expression 모률은 의존 라이브러리가 없다.

Context 모률
• BeanShell 2.0.0.b4
com.springsource. bsh-2.0. O. b4.jar
스프링의 BeanShell 언어 지원 기능을사용할 때 필요하다. 스프링은
BeanShell 스
크립트를 실행하거나 빈으로 등록해서 시용할 수 있는 기능을 제공한다.

부.B_ 스프링 의존 라이브러리 845


• Backport 3.0.0
com. springsource. edu. emory. mathcs. backport-3.0.0.jar
JSR-166 Backport를 이용한 스케줄링 기능Executor. TaskExecutor 둥)을 사용할 때 펼
요하다.

• JSR-250 Common Annotations 1.0.0

com.springsource.javax. annotation-I. O. O.jar
@Resource, @PostConstruct 같은 표준 애노태이션을 정의하고 있다. 애노테이션을
이용한 DI를 적용하려면 필요하다. 단 JDK6나 JavaEE 1.5 이상에서는 기본적으

로 제공되기 때문에 포함하지 않아도 된다.

• EJB 3.0.0
com. springsource.javax. ejb-3.O. O.jar
스프링의 EJB 지원 기능에 필요하다. EJB 빈을 프록시를 통해 DI 해서 사용할 경우
에쓴다.

• JSR-330 DI for Java 1.0.0
com. springsource껴vax. inject-l.O. O.jar
@Inject와 Provider<T> 같은 JSR-330 애노테이션을 이용해 DI 하는 경우에 필요
하다.

• JMS 1.1.0
com. springsource껴vax
.j
ms-1.l
.0껴r
스프링의 JMS 지원 기능을 사용히는 경우에 필요하다.

• Java Persistence API 1.0.0
com. springsource껴vax.persistence-I
.O.O.jar
JPA 지원을 위한 클래스 로더에서 펼요로 한다. JPA를 사용하지 않는다면 포함시킬
필요는없다.
• JSR-303 Bean Validation 1.0.0.GA
com.springsource.javax.validation-l.O. O. GA.jar

JSR-303의 빈 검증기를 이용한 검증 기능을 적용할 때 필요하다. JSR-303은 웹
환경의 모텔 검증에도 사용되지만 독자적으로 검증기를 만들어 적용할 수도 있다.


• JAX-WS 2.1.1

com.springsource껴vax.xm
l. ws-2. 1.1 ,jar
JAX-WS
의 @WebServiceRef 애노테이션을 사용할 때 필요하다.

• CGLib 2.2.0/2.1.3
com. springsource. net.sf. cglib-2.2.0,jar
스코프 프록시， JMX, 스크립팅 언어 지원 기능등에 사용된다.

• AOP Alliance 1.0.0
com.springsource.org.aopalliance-I.O. O,jar
스프링 이벤트， EJB, JMX, JNDI, 리모팅， 스크립팅 등 많은 기능에 사용한다. 반드
시포함시키도록한다.

• AspectJ Weaver 1.6.8
com.springsource.org.aspectj.weaver-I.6.8. RELEASE.jar
로드타임 위버 기능에 사용된다.LTW를 사용하지 않는다면 필요하지 않다.

• Groovy 1.6.5
com.springsource.org.codehaus.groovy-l.6.5껴r
Groovy 스크립팅 언어 지원 기능에 시용한다
Groovy를 이용해서 빈을 만들어서
사용하거나 Groovy 코드를 실행시켜야 할 때 필요하다.

• Joda Time 1.6.0
com.springsource.org.joda.time-l.6.O,jar
Joda(Java Date and time API http
://joda-time
.
so따ceforge
. net/}를 이용한 포매터 에 사용된다.
• JRuby 1.4.0
com.springsource.org.jruby-I.4. O,jar
JRuby 스크립팅 언어 지원 기능에 사용한다
JRuby를 이용해 만든 빈을 사용할 경
우에필요하다.

Context.Support 모률
• CommonJ 1.1.0

com.springsource
.
commonj-1.1.0깨r

CommonJ를 이용한 스케줄링 기능을 사용할 때 필요하다.

부.
B_ 스프링 의존 라이브러리 847


• FreeMarker 2.3.15
com. springsource. freemarker-2.3. 15,jar
FreeMarker 댐플릿의 지원 기능에 멸요하다. FreeMarker는 스프링 MVC
의 뷰로도
사용하지만독립적인 템플릿 엔진으로활용할수도 있다.

• JAFJavaBeans Activation Framework 1.1.0
com.springsource.javax.activation-l.l.0,jar
JavaMail을 이용한 메일 메시지 추상회에 펼요하다.

• Java Mail 1.4.0
com.springsource껴vax.mail-l
.4
.0껴r
JavaMail을 이용한 메일 메시지 추상화에 펼요하다.

• Ehcache 1.6.2
com.springsource.net.sf.ehcache-l.6.2,jar
EhCacheFactoryBean을 이용해 EhCache 빈을 생성할 경우에 펼요하다.

• JasperReports 2.0.5

com.springsource.net.sf껴sperreports-2.0.5
껴r
JasperReport
를 이용할 때 활용할 수 있는 편리한 기능을 제공해주는
JasperReportsUtils를 사용할 때 필요하다.

• Velocity 1.5.0
com. springsource. org. apache. velocity-l.5.0,jar
Velocity 탱플릿 엔진을 사용하는 경우에 포함시켜야 한다.

• Commons Collection 3.2.1/3.2.0
com.springsource. org.apache. commons. collections-3 .2.1.jar
Velocity를 위한 리소스 로더에 사용된다. Velocity를 사용하는 경우에 추가한다.

• Quartz 1.6.2
com.springsource.org.quartz-l.6.2,jar

Quartz를 이용한 스케줄링 기능을 사용할 때 펼요하다.


Transaction 모률

• AOP Alliance 1.0.0
com.springsource.org.aopalliance-l.O. O.jar
Transaction 모률의 필수 라이브러리다. JPA의 예외자동 변환용 AOP와 트랜잭션
AOP에펼요하다.

• WebSphere UOW 6.0.2.17
com.springsource.com.ibm.websphere.uow-6.0.2.17껴r

웹스피어 UOW 트랜잭션 매니저를 시용할 때 펼요하다. 웹스피어에 특화된 트랜잭
션 확장 기능을 사용할 수 있게 해준다.

• EJB 3.0.0

com. springsource,javax.ejb-3.0. O.jar
EJB 3의 @TransactionAttribute 애노태이션을 트랜잭션 속성을 부여히는 데 사용
하기위해필요하다.

• Java Resource 1.5.0
com.springsource.javax.resource-l.5.0,jar
스프링의 JCA 지원 기능을 사용할 때 필요하다.
• Java Transaction 1.1.0
com.springsource.javax.transaction-l.l.O,jar
JTA
트랜잭션매니저를사용할때 필요하다.

JDBC
모률

• C3PO0.9.1.2

com. springsource. com. mchange. v2. c3pO-O. 9. 1 .2.jar
C3PO는 스프링 애플리케이션에서 애용되는 애플리케이션 내장 DB 커넥션 풀의 하
나다. C3PO를 DB 풀로 사용한다면 이미 추가됐을 것이다. Transaction 모률에서는
C3P0NativeJdbcExtractor에서 시용한다. Native JDBC 오브젝트를 가져외야 히는
특별한 경우에 λF용된다.

• Java Transaction 1.1.0
com. springsource.javax. transaction-l.l.O.jar
부를 B_ 스프링 의존 라이브러리 849


JTA Lob 지원 기능에 사용된다. JTA를 사용한다면 이미 JDBC의 의존모률인
Transaction 모률에서 포함시
켰을 것이므로 신경 쓰지 않아도 된다.

• Derby 10.5
.1
000001.π씨명2
com.springsource.org.apache.derby-1O.5.1000001. 764942.jar
내장형 DB인 Derby를 사용할 경우에 펼요하다. 스프링의 내장형 DB 추상화 기능
에도
시용된다.

• H2 1.0.71
com.springsource.org.h2-1.0.71 껴r
내장형 DB
인 H2를 사용할 경우에 필요하다.

• HSQLDB 1.8.0.9
com.springsource.org.hsqldb-l.8.0.9.jar

내장형 DB
인 HSQLDB를 사용할 경우에 필요하다.

ORM
모률

• iBatis 2.3.4.πE
com.springsource. com. ibatis-2.3.4. 726.jar

iBatis를 이용해 DAO를 만들 때 펼요하다.

• JDO 2.1.0
com.springsource.javax.jdo -2.1 .0.jar
JDO를 이용해 DAO를 만들 때 필요하다.

• Java Persistence API 1.0.0
com. sprmgsource껴vax.persistence-l.0.0.jar

JPA를 이용해 DAO를 만들 때 펼요하다.

• Servlet 2.5.0

com.spnngsource껴vax.seπlet-2.5.0
.jar

서
블
릿 환경에서 하이버네이트의 OpenSessionlnViewFilter
나 JPA
의
OpenEntityManagerlnViewFilter 기능을 이용할 때 필요하다.

• Java Transaction 1.1.0
com
.springsource깨vax
. transaction-l . l . O.jar

Hibemate 3
에서 사용하므로 반드시 추가해야 한다.

• TopLínk Essentíals 2.0.0.b41-beta2
com. springsource. oracle. toplink. essentials-2. O.O. b41 -beta2.jar
JPA 구현 엔진으로 TopLink Essentials를 사용할 때 추가해준다.
• AOP Allíance 1.0.0
com.πl.spr디i띠
ωuπrκce.org.aoφpa…
카1.0.ρ.0.껴r

ngs
Ol
아
외11lianceHibemate나
JPA의 템플릿/콜백을 대신해서 AOP 방식으로 세션과 엔티티 매니저
를 바인딩할 경우에 필요하다. 기본적으로 트랜잭션 매니저를 사용하고 트랜잭션
AOP를 적용하고 있다면 ORM 모율에서는 신경 쓰지 않아도 된다.

• OpenJPA 1.1.0

com.springsource.org.apache.openjpa-l.l.O껴r
JPA 구현 제품의 하나인 OpenJPA를 사용할 경우에 필요하다.

• Eclípse Persístence JPA 1.0.1
com.springsource.org.ec\ ipse.persistence.jpa-l.O.l.jar
이클립스의 JPA 구현 제품인 EclipseLink JPA를 사용할 때 추가한다.
• Híbernate 3.3.1.GA
com. springsource. org. hibemate-3.3.1. GA.jar

스프링이 지원하는 하이버네이트의 최신 버전은 3.3.1.GA
다. 하이버네이트를 이용
한 DAO를 작성하거나 하이버네이트를 JPA 구현으로 사용할 경우에 모두 필요하다.
하이버네이트의 사용 방법에 따라서 추가적인 의존 라이브러리가 펼요할 수 있다.

• Híbernate Annotatíon 3.4.0.GA
com.springsource.org.hibemate
.
annotations-3.4.0.GA껴r
하이버네이트의 애노태이션을 이용한 ORM 설정을 사용하는 경우 필요하다.

• Híbernate EJB 3.4.0.GA
com.springsource.org.hibemate.ejb-3.4.O. GA껴r
하이버네이트를 JPA 엔진으로 사용히는 경우에 펼요하다.
부.
B_ 스프링 의존 라이브러리 851


Web
모률

• Caucho 3.2.1
com.springsource. com. caucho-3 .2.1.jar

Burlap
/Hessian을 이용한 리모팅 기능을 시용할 때 필요하다.

• Java EL 1.0.0
com.springsource.javax.el-l.O.O.jar
Web 모률에서 JSF 지원 기능에 필요하다.

• Java Faces 1.2.0.08
com.springsource.javax. faces-l.2.0.08껴r
JSF를 스프링의 웹 기술로 사용할 때 필요하다.

• Portlet 2.0.0
com.springsource.javax.portlet-2. O. O.jar

포틀릿을 사용할 때 펼요하다.

• Servlet 2.5.0
com. springsource껴vax.servlet-2.5.0.jar

서블릿 기반의 웹 모률의 핵심 API
다. 서블릿 API를 직접 코드에서 사용하지 않는

다면， 서버에서 기본적으로 제공해주므로 신경 쓰지 않아도 좋다.

• JSP 2.1.0

com.spr띠디띠rings잉ou따lπrπc야e껴va없x.s않erπ띠이v
le앙t.펴p-2
.
1.0껴r

스프링의 태그 지원 기능에서 사용한다. 서버에서 지원되므로 대부분의 경우 포함시

키지않아도된다.

• JAX-RPC 1.1.0
com.springsource.javax.xml.rpc-l .l.O.jar

JAX-RPC를 이용한 리모팅 기능을 만들 때 사용한다.

• XML SOAP 1.3.0
com.springsource.javax.xml.soap-l .3.0.jar
JAX-WS를 시용해 리모팅 기능을 만들 때 필요하다.


• JAX.-WS 2.1.1
com.springsource.javax.xml.ws-2.I.l .jar
JAX-WS를 사용해 리모팅 기능을 만들 때 필요하다.

• AOP Alliance 1.0.0
cωom.s얘띠디띠띠
uIfκce.org.aopa…때야카1
ρ

prrnngsOl애따야
아탱
때외11liance-.
0.α.ρ.0.껴r

모든 리모팅 기능에 펼요하다.

• Axis 1.4.0

com.springsource.org.apache.axis-l
.4
.0
껴r

Axis를 이용해 웹 서비스를 구현할 때 필요하다. 하지만 Axis보다는 JAX-WS를 사
용하도록 권장한다. Axis 지원 기능은 앞으로 제거될 예정이다.

• Commons Fileupload 1.2.0
com.springsource.org.apache.commons.fileupload-l.2.O.jar
웹에서 파일 업로드 기능을 시용할 때 필요하다.

• Commons HttpClient 3.1.0
com. springsource.org.apache.commons.httpclient-3.1.O.jar
REST 탱플릿을 시용할 때 펼요하다.

• Log4J 1.2.15

com.springsource
.
org.apache.log4j-I.2.15껴r

Log4jConfigListener를 이용해 애플리케이션 레벨의 Log4J 설정을 해줄 때 펼요

하다.

• Jackson Mapper 1.4.2
com. springsource.org.codehaus껴ckson.mapper-l.4.2껴r
JSON 메시지 컨버터에 사용된다.

Web.Servlet 모률

• iText 2.0.8

com.springsource.com.lowagie.text-2.0.8껴r

iText를 이용한 PDF 뷰를 만들 때 펼요하다.

부를 B_ 스프링 의존 라01브러리 853


• Syndication 1.0.0
com.springsource.com.sun.syndication-1.O. O.jar
RSS/Atom 피드 뷰를 만들 때 필요하다.

• FreeMarker 2.3.15
com. springsource. freemarker-2.3. 15 .jar
FreeMarker 뷰를 만들 때 필요하다.

• Servlet 2.5.0
com. spnngsource.Javax. seπ1et-2.5.0
.j
ar
코드에서 서블릿 API를 직접 사용하는 경우에 필요하다. 배포 패키지에는 포함시키
지않아도된다.

• JSP 2.1.0

com
.s얘
ωulπrκce.Javax.serv띠let.펴p-2.1.0.jar

pnngsOl바야껴
없
않
v
타
JSP/JSTL 뷰(I
n1πt따뻐녕리lRe
urc

띠때ern1
a
없잉S
Ol띠
옹히1뜯는 것이 아니라면 포함시키지 않아도 된다.

• JSTL 1.1.2

c야oom.spr
잉따
껴
없
잉rvvlet.펴p..jst1


아
뼈끼ingsoulπrκce.javax.se띠
띠
“→1.1.2껴r
JSP/JSTL 뷰(I
nternalRe
sourceView. JstlView)와 폼 태그에 사용된다.

• J ExcelApi 2.6.6
com.springsource.jxl-2.6.6.jar
JExce1 API를 이용해 엑셀 뷰를 만들 때 필요하다.
• JasperReports 2.0.5
com.springsource.net
.
s
f.껴
sperreports -2.0.5.jar
)asperReports를 이용한 뷰를 만들 때 필요하다.

• POI 3.0.2.FINAL
com.springsource.org.apache.poi-3.0.2.FINAL.jar
POI를 이용한 엑셀 뷰를 만들 때 필요하다.

• Tiles 2.1.2.osgi
com.springsource.org.apache.ti1es-2.1.2.osgi.jar
Tiles 뷰에 사용된다.


• Tiles Core 2.1.2.osgi
com.springsource.org.apache.tiles.core-2.1.2.osgi.jar
Tiles 뷰에 사용된다.

• Tiles JSP 2.1.2
com. springsource. org.apache. tiles펴p-2.1.2
.j
ar
Tiles 뷰에 사용된다.
• Tiles Servlet 2.1.2
com.springsource.org.apache.tiles.servlet-2.1
.
2
껴r
Tiles 뷰에 사용된다.

• Velocity 1.5.0
com. springsource. org. apache. velocity-l .5.0껴r
Velocity 뷰를 만들 때 멸요하다.

• Velocity Tools View 1.4.0
com. springsource. org.apache. velocity. tools. view-l.4
.
0껴r
Velocity 뷰를 묘띨 때 펼요하다.
• Jackson Mapper 1.4.2
com.springsource.org.codehaus.jackson.mapper-I.4.2.jar
JSON 뷰를 만들 때 필요하다.

Web.Portlet 모률
• Portlet 2.0.0
com. springsource.javax.portlet-2. O. O.jar

포틀릿 API를 사용히는 경우에 필요하다.

• Servlet 2.5.0
com.springsource.javax.servlet-2.5.0껴r
서블릿 API를 사용하는 경우에 필요하다.

• Commons Fileupload 1.2.0
com.springsource.org.apache.commons
.
fileupload-I.2.0깨r
포틀릿에 파일 업로드 기능을 넣을 때 펼요하다.

부특 B_ 스프링 의존 라이브러리 855


Web.Struts 모률

• Commons Beanutils 1.7.0/1.8.0
com.springsource
.
org.apache
.
commons
.
beanutils-I.7.0껴r

스트렷츠 l
과의 연동을 위해 필요하다.

JMS
모률

• JMS 1.1.0

com. springsourcejavaxjms-I. 1.0jar

JMS API를 샤용히는 경우에 필요하다.

• Java Resource 1.5.0
com.springsourcejavax.resource-I.5.0.jar
JMS 메시지 리스너를 등록해서 시용할 때 펼요하다.

• AOP Alliance 1.0.0
com. springsource. org. aopalliance-I. 0.0 .jar
JmslnvokerClientlnterceptor에 사용된다.

Aspects 모률

• AspectJ Weaver 1.6.8
com. springsource. org. aspectj. weaver-l .6.8. RELEASE.jar
AspectJ AOP 기능을 사용하기 위해 반드시 추가해야 한다
.
Instrument 모률
Instrument 모률은 의존 라이브러리가 없다.

Instrument.Tomcat 모률
Instrument. Tomcat 모률은 의존 라이브러 리가 없다.

Test
모률

테스트 모률이 직접 의존하는 것은 JUnit과 같은 테스트 프레임워크뿐이다. 하지만 태

스트 방법에 따라서 OBUnit과 같은 다양한 테스트용 라이브러리가 추가로 필요할 수

있다.


• JUnit 3.8.2
com. springsource.junit-3.8.2
껴r
JUnit 3.8.2를 이용해 태스트를 만들 때 필요하다.

• JUnit 4.7.0
com. springsource. org.junit-4. 7
.
0껴r
JUnit 4
.
7을 이용해 테스트를 만들 때 필요하다.

부.B_ 스프링 의존 라이브러리 857


센끽E찾아봐l

VoL 2 690
&& .... . Vol. 2_689
@ActiveProfile ..... Vol. 2 731
@After VoL 2 683. 695
@AfterRetuming ..... Vol. 2_683, 693
@AfterThrowing ..... Vol. 2_683 , 694
@annotation VoL 2 689
@args ..... Vol. 2_689
@Around ..... Vol. 2_683, 691
@Aspect ... .. Vol. 2_682
@AspectJ ..... Vol. 2_674, 682
@Async ..... Vol. 2_764
@Autowired ..... Vol. 1 671; Vol. 2 122
@Bean VoL 2 94
@Bean(destroyMethod) .…. Vol. 2 187
@Bean(init-method) ... .. Vol. 2_ 186
@Before ..... Vol. 1_180; Vol. 2_683. 693
@Cacheable ... .. Vol. 2 767
@CacheEvict VoL 2 770
@CachePut ..... Vol. 2_770
@Component ..... Vol. 1_675
@ComponentScan ... .. Vol. 2_201
@Configurable ..... Vol. 2_698
@Configuration .. ... Vol. 2_94, 776
@ContextConfiguration ..... Vol. 2_714
@Controller ..... Vol. 2_93 , 482
@CookieValue ..... Vol. 2 489
@DateTimeFormat VoL 2 559

@DirtiesContext ... .. Vol. 1 192
@Enable VoL 2 775
@Enable* 애노테이션 ..... Vol. 1 707
@EnableAspectJAutoProxy .... . Vol. 2_708
@EnableLoadTimeWeaving ..... Vol. 2_709
@EnableTransactionManagement ..... Vol. 2_205
@EnableTransactionManager ..... Vol. 2_345
@EnableWebMvc .... . Vol. 2 659
@Filter ..... Vol. 2 203
@Import .... . Vol. 1_682; Vol. 2_204, 776
@lmportResource ..... Vol. 2_205
@lnitBinder VoL 2 532. 552
@Inject ..... Vol. 2_ 122
@javax.inject.lnject ..... Vol. 2_130
@javax.inject.Qualifier ..... Vol. 2_ 130
@javax.validation. Valid ..... Vol. 2_572
@ModelAttribute ... .. Vol. 2_491
@NumberFormat .. ... Vol. 2 557
@PathVariable . .. VoL 2 487
@PersistenceContext .... . Vol. 2_287
@PersistenceUnit .. .. . Vol. 2_284
@Pointcut .. ... Vol. 2_683
@PostConstruct ..... Vol . 1 578 ; Vol. 2 186
@PreDestroy ..... Vol. 2_ 187
@PropertySource ..... Vol. 1_696; Vol. 2_231
@Qualifier .. .. . Vol. 2_ 126
@Repository ..... Vol. 1_679; Vol. 2_93
@RequestBody ..... Vol. 2_499


@RequestHeader ... .. Vol. 2• 490
@RequestMapping ... .. Vol. 2_466
@RequestMapping 전략 ..... Vol. 2 639
@RequestParam ..... Vol. 2_488
@Resource .. .. . Vol. 2_ 118
@ResponseBody ..... Vol. 2_509
@Rollback ..... Vo l. 1_551
@Scheduled Vol 2 763
@Service ..... Vol . 1 681 ; Vol . 2 93
@SessionAttributes .... Vol 2 510
@target ..... Vol. 2_688
@Transactional ..... Vol. 1 532‘ 549; Vol . 2 315
@Transactional 테
스트 .. ... Vol. 2_722
@TransactionConfìguration .. ... Vol. 1_552
@Valid ..... Vol. 2 501
@Validated .. ... Vol . 2_650
@Value Vol 2 138. 500
@within ..... Vol. 2 688
I I ..... Vol. 2 690
(aop:aspect) ... .. Vol . 2_673
(aop:scoped-proxy) .. ... Vol. 2_ 181
(bean) ..... Vol. 2_86
(constructor-arg) ..... Vol. 2_ 109
(context: annotation -confìg /) ... .. Vol. 2_ "9
(context:component-scan) ... .. Vol. 2_ "9
(context: load-time-weaver) ..... Vol. 2_706
(context: property-placeholder) ... .. Vol. 2_229
(form :checkbox) ... .. y，이 2_602
(form :checkboxes) . .. .. y，이
.
2_602
(form :errors) .... . y，이
. 2_599
(form:hidden) ..... y，이
.2_601
(form:input) ..... Vol. 2_598
(form: label) ..... y，이. 2_599
(form:option) ..... Vol. 2_605
(form: options) ..... y，이 2 605

(form :password) ..... V，이
.2_601
( form: radiobutton) …
y，이
.2_604
(form:radiobuttons) .. .. . y，이 2 604
(form:select) ..... V，이. 2_605
(form:textarea) ..... V，이
.2_601
(Iookup-method) ..... Vol. 2_ 174
(mvc:annotation-driven) ..... Vol. 2 618
(mvc ’ default-servlet-handler/) ... .. Vol. 2_626
(mvc:view -controller) ..... Vol. 2_621
(property) ..... Vo l. 2_ 136. 138
(spring:bind) ..... Vol. 2_590
(task:executor) ..... Vol. 2 762
(task:scheduler) ..... Vol. 2_762
(tx:jta-transaction-manager/) ..... Vol. 2_341
(url :resource/) ..... Vol. 2_630
(uti l:list) ..... Vol. 2_146
(util :map) .. ... Vol. 2_ 147
(util :properties) . .. .. Vol. 2_ 147, 152
(util:set) .. ... Vol. 2_ 146
3
계층 아커텍처 .. .. Vol. 1_784

껴

값 설정 ..... Vol. 2_ 148
값주입 ..... Vol. 1 139
개방 폐쇄 원칙 ... Vol. 1_83
객체지향 설계 원칙 ... .. Vol. 1 84
거대한 서비스 계층 ..... Vol. 1_795 , 797
격리수준 ..... Vol. 1_515
경계값 분석 ..... Vol. 1_206
계충형 아키택처 ... Vol. 1_782 , 784
고립된 단위 태스트 .. ... Vol . 1_413
관계설정 책임 ..... Vol. 1_77
관심사의 분리 .. .. Vol. 1_60, 61
관점 지향 프로그래밍 .... . Vol. 1_506

찾아방
I 859


글로벌세션 스코프 ..... VoI. 2_ 177 런타임 환경 추상화 ..... Vol. 2 210

글로벌 트랜잭션 ..... VoI. 1_366 로드타임 위벼 ..... VoI. 2_280, 706
로드타임 위빙 .... . VoI. 2_280
로컬 클래스 ..... Vol. 1_227
로컬 트랜잭션 ..... VoI. 1 355
롤백 태스트 ..... VoI. 1_547 ; VoI. 2_720

내부 빈 ..... Vol. 2_86 루트 애플리케이션 컨텍스트 ..... VoI. 2 77
내장형 DB .... . VoI. 1 629 루트 애플리케이션 컨텍스트 둥록 ..... VoI. 2_207
내장형 데이터베이
스 .... VoI. 1_629 루트 웹 애플리케이션 컨텍스트 ..... Vol. 2 368

네임
스메이스 ..... VoI. 2_86. 617 리다이렉트 뷰 ..... VoI. 2 654
높은 웅집도와 낮은 결합도 .. . VoI. 1_85 리모팅 ..... Vol. 2_752

리소스 ..... Vol. 1_611
리소스 관리 ..... VoI. 2_626
리소스 로더 .. ... VoI. 1_612
리소스 추상화 ..... Vol. 1_610

다이내믹 프록시 ..... Vol. 1_429, 435

리팩토링 .... Vol. 1_64

단위 테스트 ..... VoI. 1_ 149, 423

리플렉션 ..... Vol. 1 437

단일 책임 원칙 .... Vol. 1_375, 377
대체 ..... Vol. 1_534
대체 정책 ..... VoI. 1_534
데이터 액세스 계층 ..... VoI. 1_785
데코레이터 패턴 ..... VoI. 1 431 마살링 ..... Vol. 1 572
도메인 계충 방식 .. .. . Vol. 1_811 마이크로 DI ..... Vol. 1_224
도메인 오브젝트 ..... VoI. 1_802 매핑따일 ..... VoI. 2 265

동등분할 ..... VoI. 1_206 멀티 티어 아키돼처 ..... VoI. 1_784

디자인 패턴 ..... Vol. 1_69 멀티파트 리졸버 ..... VoI. 2_451
디폴트 값의 사용 ..... Vol. 2_ 139 메소드 레벨 매명 ..... Vol. 2 470
디폴트 의존관계 ..... VoI. 1_590 메소드 주입 .... VoI. 2_173
디폴트 접미어 때턴 ..... VoI. 2_467 메소드추출 ..... VoI. 1_63 , 64
디폴트 프로퍼티 에디터 ..... Vol. 2_528 메시지 컨버터 ..... Vol. 2 608

모텔 바인딩 .... Vol. 2_525
모델 오브젝트 ..... Vol. 2_507
모델의 일생 .... VoI. 2_580
모조 오브젝트 ..... Vol. 2_543

라이브러리 관리 ..... VoI. 1_770

모조 프로퍼티 에디터 ..... VoI. 2 543

런타임 의존관계 ..... VoI. 1 112

목오브젝트 ..... VoI. 1 394


목 프레임워크 ..... Vol. 1_425
미디어 타입 ..... Vol. 2_441

바이트코드 향상 기법 ..... Vol. 2_280

벼그 테스트 ..... Vol. I 205

별청 .... . Vol. 2_ 182

부모 컨텍스트 ..... Vol. 2_67

분리와 확장 ..... Vol. I 61

뷰 ..... Vol. 2_424

뷰 리졸버 ..... Vol. 2_375, 435

비동기 태스크 .. . Vol. 2 763

비침투적 기술 ..... Vol. 1_195

빈 .... . Vol. 1_95: Vo l. 2_55
빈 퉁록 방법 ..... Vol. 2 85

빈 문자열 ..... Vol. 2_ 147

빈 생명주기 메소드 ..... Vol. 2_ 185
빈 설정 메타정보 ..... Vol. 2_83
빈 설정자 .. . Vol. 1_701: Vol. 2_782
빈 스캐너 ..... Vol. 2_89
빈 스캐너를 내장한 애플리케이션 컨텍스트
Vol. 2 93
빈 스캐닝 ..... Vol. 1_671: Vol. 2_89
빈 스코프 ..... Vol. 1_820, 111
빈 식별자 ..... Vol. 2_ 182
빈약한 도메인 오브젝트 ..... Vol. 1_805
빈의 역할 ..... Vol. 2_ 197
빈 의존관계 설정 방법 ..... Vol. 2_ 109
빈 이름 ..... Vol. 2 182
빈 이름 자동와이어링 ..... v.이. 2_ "2
빈 팩토리 ..... Vol. 1_95: Vol. 2_5 1
빈 후처리기 ..... Vol. I 477
빌드 툴 ..... Vol. 1_775 , 777

상태 관리 ..... Vol. 1_820

상태유지 세션빈 .. Vol. 2 289

생성자주입 .. ... Vol. 2_111

서블릿 애플리케이션 컨텍스트 ..... Vol. 2_80

서블릿 웹 애플리케이션 컨텍스트 ..... Vol. 2_371

서블릿 컨텍스트 동록 ... Vol. 2_208

서블릿 컨텍스트 따라미터 ..... Vol. 2_224

서블릿 컨픽 따라미터 ..... Vol. 2 225

서비스 계충 ..... Vol. 1_786

서비스 추상화 ..... Vol. I 317, 375

선언적 트랜잭션 ..... Vol. 1_539, 541

선언적 트랜잭션 경계설정 ..... Vol. 2_311

설정 메타정보 ..... Vol. I 101

설정자 빈 ..... Vol. 2 666

설정따일 .. ... Vol. 2_264

세션 스코프 ..... Vol. 2 177

수통 DI ..... Vol. 1_237

수정자 ..... Vol. 2_ "8

수정자 메소드 ... .. Vol. 1_ 126

수정자주입 ..... Vol. 2 110

수직 계충 .. .. Vol. I 784

스케줄링 ..... Vol. 2_759

스코프 .. ... Vol. 2_ 157, 176

스코프 프록시 .. ... Vol . 2_179

스키마 ..... Vol. 1_ 133

스태틱 꽤토리 메소드 ..... Vol. 2 188

스테레오타입 애노테이션 ..... Vol. 2_89, 90

스프링 AOP ..... Vol. 1_475

스프링 JDBC ..... Vol. 2_244, 261

스프링 MVC ..... Vol. 2_350, 355

스프링 MVC 테스트 ..... Vol. 2 385

스프링 SpEL ..... Vol. 2_586

스프링 모율 ..... Vol. 1_829: Vol. 2_789

스프링 서블릿 ..... Vol. 2 350

찾아'!i!7
1 861


스프링 포툴릿 ... .. Vol. 2_351
시스탱 프로퍼티 ..... VoI. 2_224
싱글톤 레지스트리 ..... VoI. U02. 105, 108
싱글톤 패턴 ..... Vol. 1_106

애스펙트 ..... Vol. 1_504, 509: VoI. 2_671
애스펙트 지향 프로그래밍 ... VoI. 1_505
애플리케이션 로직 빈 ..... Vol. 2_190
애플리케이션 스코프 ..... Vo I. 2 177
애플리케이션 예외 ..... Vol. 1_294
애플리케이션 인프라 빈 ..... VoI. 2_ 190
애플리케이션 정보 아키텍처 .... VoI. 1_791
애플리케이션 컨텍스트 ..... Vol. 1_95; Vol. 2_51
애플리케이션 컨텍스트 캐싱 ... Vol. 2 712
애플리케이션 프레임워크 ..... Vol. 1_714
어드바이스 .. ‘ VoI. 1_464, 465. 508; VoI. 2_683
어드바이스 메소드 ..... Vol. 2_690
어드바이저 ..... VoI. 1_470, 483. 509
언마살령 ..... VoI. 1_572
언체크/런타임 예외 .... . VoI. 1_284
언체크 예외 ..... Vol. 1 284
영리한 도메인 오브젝트 ..... Vo1. 1_807
예외 복구 ..... VoI. 1_285
예외 전환 ..... Vo1. 1 288
예외처리 .... . Vo1. 1_210
예외처리 회피 ..... VoI. 1 286
예외추상화 ..... VoI. 1_306
오브젝트 스코프 ..... VoI. 1 102
오브젝트의 동일성과동둥성 ..... Vo1. 1_103
오브젝트중심 아키택처 ..... VoI. 1_797
오브젝트 팩토리 ..... VoI. 1_88
오푼소스 ..... VoI. I 718
요청 스코프 ..... VoI. 2_ 176

요청 조건 .. Vo1. 2_642
웹 서비스 ..... Vo1. 2_752
웹 프레임워크 ..... Vo1. 2 350
의존관계 ..... Vo1. 1_ 112
의존관계 검색 ..... VoI. 1_ 117
의존관계 주입 ..... VoI. 1_ 126, 111
이벤트 리스너 .. ... Vo1. 2_77
익명 내부 클래스 .... Vo1. 1_229, 230
익스포터 ... Vo I. 2_753
인스턴스 팩토리 메소드 ..... Vo1. 2 188
인터페이스 .... Vo1. 1 74
인터페이스 분리 ..... Vo1. 1_580
인터페이스 분리 원칙 ..... Vol. 1 619
인터페이스 상속 ..... Vol. 1_620
인트로덕션 ..... VoI. 2 697
읽기전용 .. ... Vo1. 1 516

자기참조 빈 .... VoI. 1_568, 585, 589
자통수행 테스트 ..... VoI. 1 151
자통와이어링 ..... Vo1. 1_671 ; VoI. 2_ 109, 112
자동인식을 이용한 빈 동록 ..... VoI. 2_89
자통 프록시 생성 ..... Vo1. 1 475
자동 프록시 생성기 ..... vi이. 1_484; vi이. 2_675
자바빈 ..... Vo1. 1_55
자바 에이전트 ..... VoI. 2 704
자바 코드 메타정보 ..... Vo1. 2_ 198
자바 코드에 의한 빈 퉁록 ..... Vol. 2 94
저장 펑션 .... Vo I. 2_259
저장 프로시저 ..... Vo1. 2_259
전략 패턴 .... Vo1. 1 87
전역 상태 ..... VoI. 1_ 108
전용 태그 ..... VoI. 2_86, 116, 138
제거 메소드 ..... Vo1. 2 187


제거 콜백 인터페이스 ... .. Vol. 2_187
제어의 역전 ..... Vol. 1_88, 92
제한시간 .... Vol. 1 516
조인 포인트 ..... Vol. 1_508
중첩 예외 ..... Vol. 1_289
중첩 클래스 ..... Vol. 1_228
지역정보 ..... Vol. 2_426
지역정보 리졸벼 ..... Vol. 2 450
지역화 .... Vol. 2_426
지역화 메시지 ..... Vol. 2_587

체크 예외 ..... Vol. 1_283
초기화 메소드 ..... Vol. 2 185
초기화 콜백 인터페이스 ..... Vol. 2_ 186
침투적 기술 ..... Vol. 1_195

캐시 매니저 ..... Vol. 2_772
캐시 추상화 ..... Vol. 2_765
캐싱 .... Vol. 2_335
커스텀 UI 태그 ..... Vol. 2 607
커스텀 스코프 ..... Vol. 2_181
커스텀 컨트롤러 인터페이스 ..... Vol. 2_419
커스텀 프로퍼티 에디터 ..... Vol. 2 529
컨테이너 .... Vol. 1_ 102
컨테이너 인프라 빈 .. ... Vol. 2_ 191. 198
컨텍스트 공유 ..... Vol. U86
컨텍스트 로더 ..... Vo1. 2_715
컨트롤러 .... Vol. 2_396
컨트롤러 확장 ..... Vol. 2_417
콜백 ..... Vol. 1 241
클래스 분리 ..... Vol. 1_232

클래스 이름 패턴 ..... Vol. 1_499

타깃 ..... Vol. 1_430, 508

타입 레벨 매핑 ..... Vol. 2 470

타입 패턴 .... Vol. 1_499

태
스크 ..... Vol . 2_759

테스트 ..... Vol. 1 64. 145

태스트 대역 ..... Vol. 1_391

태
스트 우선 개발 ..... Vol. 1_ 176

테스트주도개발 ..... Vol. 1 176

테스트 컨텍스트 프레임워크 ..... Vol. 1_184;
Vol.2 711

댐플릿 ..... Vol . 1_241

템플릿 메소드 ..... Vol. 1_218

댐플릿 메소드 패턴 .... Vol. 1_67, 69

랩플릿/콜백 패턴 ..... Vol. 1 241

통합 테스트 .... Vol. 1_423

트랜잭션 ..... Vol. 2_301

트랜잭션 격 리수준 ..... Vol. 2 327

트랜잭션 경계설정 ..... Vol. 1_353 , 354

트랜잭션 경계설정 전략 ..... Vol. 2_309

트랜잭션 동기화 .. Vol. 1_360, 361; Vol. 2_303

트랜잭션 롤백 ..... Vo1. 1_354

트랜잭션 롤백 예외 ..... Vol. 2_329

트랜잭션 매니저 ..... Vol. 2• 282, 297, 304

트랜잭션 부가기능 ..... Vo1. 1346

트랜잭션 서비스 추상화 ..... Vol. 1_349, 366

트랜잭션 속성 ... Vol. 1_512, 516, 526; Vol. 2_324

트랜잭션 애노테이션 ..... Vol. 1_532

트랜잭션 인터셉터 ..... Vol. 1 516

트랜잭션 전파 ... Vol. 1_513; Vol. 2_325

트랜잭션 지원 태스트 ..... Vol. 1 539; Vol. 2 719

트랜잭션 추상화 ..... Vol. 2_303

찾아보기 863


트랜잭션 커빗 ..... Vol. 1_354
트랜잭션 커빗 예외 ..... VoI. 2_329
트랜잭션 프록시 팩토리 빈 .... VoI. 1_454
트랜잭션의 경계설정 ..... VoI. 1_355

파라미 터 ..... VoI. 2_648
패턴 ..... VoI. 1_83
팩토리 .. ... VoI. 1 88
팩토리 메소드 ..... VoI. 2_187
팩토리 메소드 때턴 ..... VoI. 1_67. 70
팩토리 빈 .. ... Vol. 1_429.449 ; VoI. 2_ 187
포괄적인 테
스트 ..... VoI. 1_ 168
포인트컷 ..... Vol. 1 466. 508 ; VoI. 2 683
포인트컷 지시자 ..... Vol. 2_685
포인트컷 표현식 ..... VoI. 1_489
표준 공통 애노테이션 ..... VoI. 2_186
풍성한 도메인 오브젝트 ..... VoI. 1_807
프레젠테이션 계충 ..... VoI. 1_787
프로그랭에 의한 트랜잭션 ..... Vol . 1_541
프로토타입 빈 ..... Vol. 2_ 169
프로토타입 스코프 ..... VoI. 2_ 157
프로따일 ..... Vol. 1_687; VoI. 2_2 10
프로퍼티 값 설정 ..... VoI. 2_ 137
프로퍼티 소스 ..... Vol. 1_696
프로퍼티 소스 ..... Vol. 2_221
프로퍼티 치환자 ..... VoI. 2_149
프로퍼티 따일 ..... VoI. 2_148
프록시 ..... VoI. 1_430. 509; Vol. 2_755
프록시 모드 ..... Vol. 2_318
프록시 빈 ..... Vol. 2 675
프록시 종류 ..... Vol. 2_680
프록시 클래스 .... . Vol . 1_439
프록시 패턴 ..... Vol. 1 433

프록시 팩토리 빈 ..... Vol . 1_462

프론트 컨트롤러 ..... Vol. 2_357

프론트 컨트롤러 패턴 .... Vol. 2_72. 357

플래시 뱀 ..... Vol . 2_452

플래시 뱀 매니저 ..... Vol. 2_452. 455

플래시 애트리뷰트 ..... Vol. 2 657

플러시 ..... Vol. 2_725

픽스처 ..... Vol. 1_182

필드 주입 .... VoI. 2 120

펼드마커 ..... Vol. 2_566

하이버네이트 ..... Vol. 2_292
하이버네이트 4 ..... Vol. 2_343
학습 태스트 ..... Vol. 1 197
핸들러 매명 ..... Vol . 2_374, 408
핸들러 매명 전략 ..... VoI. 2_359
핸들러 어랩터 ..... Vol. 2_373
핸들러 어랩터 개발 ..... Vol. 2_419
핸들러 예외 리졸버 ..... VoI. 2_446
핸들러 인터셉터 ..... Vol. 2_414
헤더 ..... VoI. 2 648
협력 오브젝트 ..... Vol. 1_392
확장된 퍼시스턴스 컨텍스트 ..... VoI. 2_289
환경변수 ... VoI. 2 223
활성 프로따일 ..... VoI. 2_216

AbstractAtomFeedView ..... Vol. 2_434
AbstractDispatcherServletTest ..... VoI. 2_389
AbstractExcelView .. VoI. 2 432
AbstractJasperReportsView ..... Vol. 2_435


AbstracúExcelView VoL 2 432
AbstractPdfView ..... Vol. 2 432
AbstractRssFeedView .... . Vol. 2_434
Accept 헤더 ..... Vol. 2_649
AcceptHeaderLocaleResolver ..... Vol. 2_450
addAfterO ..... Vol. 2ι
깅

_2
28
addAr땅gume
add뼈Befor댄e
O ..... Vol. 2_228
addFirstO ..... Vol. 2_228
addFormattersO ..... 'ví이
.
2_661
addResourceHandlersO ..... Vol. 2_665
addRetumValueHandlersO ..... Vol. 2_663
addViewControllersO .... . Vol. 2_665
advice ... .. Vol. 1 465
afterCompletion ..... Vol. 2_416
afterPropertiesSetO .... . Vol. 2_186
AJAX .. ‘ •. Vol. 2 608
AJAX 컨트롤러 . .... Vol. 2_611
allowedFields .... . Vol . 2_563
alwaysUseFullPath ..... Vol. 2_413
annotatedClasses ..... Vol. 2 296
AnnotationConfigWebApplicationContext

VoL 2 79. 93
AnnotationMethodHandlerAdapter ..... Vol. 2_406,
618. 622

Annota잉tlon1내
밍야
때비HandlerExceptionResolver

마lMetthod
때


VoL 2 447
AnnotationSessionFactoryBean ..... Vol. 2_296
AOP .... . Vol. 1 500; Vol. 2 671
AOP 네임
스페이스 .... Vol. 1_509
AopContext.currentProxyO ..... Vol. 2_323
application context ..... Vol. 1_95
ApplicationContext ..... Vol. 2_52, 153
applicationContext.xml ..... Vol. 2_368
ApplicationContextlnitializer .... . Vol . 2_232

ApplicationEventPublisher .. .. . Vol. 2_154
args .. ... Vol. 2_687
aspect .. .. . Vol. 1_504
Aspect Oriented Programming ..... Vol. 1_505
AspecúExpressionPointcut ..... Vol. 1_489
assertModel VoL 2 395
assertViewName .... . Vol . 2 395
AutowiredAnnotationBeanPostProcessor

VoL 2 194
autowiring ..... Vol. 2_109

g

BadSqlGrammarException .. ... Vol. 1_301
basePackages .. .. . Vol. 2_203
batchUpdate .... . Vol. 2_254
bean ..... Vol . 1_95; Vol. 2_55, 689
bean factory .. ... Vol . 1_95
bean validation .... . Vol. 2 574
BeanDefinition VoL 2 56. 83
BeanDefinitionReader ..... Vol . 2 56
BeanDefinitionUtils ..... Vol. 2_ 196
BeanFactory .... . Vol. 2_52, 153
BeanFactoryPostProcessor ..... Vol . 2_744, 745
BeanNameUrlHandlerMapping ..... Vol. 2_374, 408
BeanNameViewResolver ..... Vol. 2 438
BeanPostProcessor ..... Vol . 1_477; Vol. 2_744
BeanPropertyBindingResult .. ... Vol. 2_573
BeanPropertySqlParameterSource .. ... Vol . 2_249
BindingResult .. .. . Vol. 2_496, 503 , 568, 576
BindingStatus .... . Vol. 2_590
boundary value analysis ..... Vol. 1_206
bug test ..... Vol. 1_205
byName .. .. . Vol. 2_112
ByteArrayHttpMessageConverter .... . Vol. 2_608

찾아보기 865


c

c3pO ... .. Vol. 2_242
cacheSeconds ... .. Vol. 2 402
caching .... . VoI. 2_335
callback Vol 1 241
Castor .. ... Vol. 1 600;
CciTransactionManager ..... Vol. 2_307
checked exception ..... Vol. 1_283
collaborator ..... VoI. 1 392
CommonAnnotation8eanPostProcessor

. Vol . 2_ 195
CommonJ WorkManager ..... VoI. 2_759
Commons D8CP ..... VoI. 2 241
CommonsMultipartResolver ..... Vo1. 2_451
CompositeCacheManager .... . Vol. 2_774
ConcurrentMapCacheManager ..... VoI. 2_772
Conditiona1GenericConverter ..... VoI. 2 561
Configurab1eDispatcherServlet ..... Vo1. 2_385
ConfigurableWeb8indinglnitializer ..... Vol. 2_553 ,

618
configuration metadata .... . Vol . 1_ 101
ConfigurationC1assPostprocessor .... . Vo1. 2_ 194
configureDefau1tServletHandlingO ..... Vo1. 2_666
configureHandlerExceptionResolversO

Vol2 663
configureMessageConvertersO ..... VoI. 2_662
configurer .... . VoI. 2_782
Connection .... . Vol. 2_245
ConsumesRequestCondition ..... Vo1. 2_648
container Vol 1 102
ContentNegotiatingViewResolver ..... VoI. 2_440
Content-Type 헤더 .. .. . VoI. 2_648
contextClass Vol 2 79
contextConfigLocation ..... Vol. 2_78
contextlnitia1izerC1asses ..... Vo1. 2 234

Controller Vol 2 401
Controller8eanNameHandlerMapping ..... Vo1. 2_409
ControllerClassNameHand1erMapping ..... Vo1. 2_410
ConversionService . Vol 2 14 1. 551
conversion-service ..... Vol. 2_620
Converter .... . VoI. 2_549, 550
cron Vol 2 764

DAO .. Vol 1 54
DAO 패턴 ..... VoI. 2_238
DataAccessException ..... VoI. 1_301 , 303
DataAccessResourceFailureException ..... Vol. 1_301
DatalntegrityViolationException ..... Vol. 1_301
DataSource ..... Vol. 1_136; Vol. 2_240
DataSourceTransactionManager .... . VoI. 1_372 ;

Vol 2 304
D8Unit .... . Vol. 2 727
declarative transaction ..... Vol. 1_541
DEFAULT Vol 2 327
default suffix pattern .... . Vol. 2_467
DefaultAdvisorAutoProxyCreator ..... Vo1. 1_481
DefaultAnnotationHand1erMapping ..... Vo1. 2_412
defau1tHand1er ..... Vo1. 2_413
Defau1tHandlerExceptionResolver .... . Vol. 2_449
deleteO ..... VoI. 2_268
dependency lookup ..... VoI. 1_ 117
dependency relationship ..... Vol . 1_ 112
destroy-method ..... VoI. 2_ 187
destruction method .. ... VoI. 2_ 187
detectHand1erslnAncestorContexts .... . Vo1. 2_414
DI 애스펙트 .... . Vol. 2 700
DI 테스트 ..... Vo1. 1_194
disallowedFields .... . VoI. 2 563


DispatcherServlet ..... VoI. 2_355. 357
DispatcherSeπlet 확장 ..... Vol. 2 383
DisposableBean .... . Vol. 2_ 187
DL 전략 ... .. VoI. 2_ 169
dolnSqlMapClient ..... Vol. 2_271
DTD .... . Vol. 1_ 133
DTO ..... Vol. 1 816
DuplicatedKeyException ..... VoI. 1_301

E
EhCacheCacheManager ..... VoI. 2_773
EJB ..... VoI. 2_752, 758
EL ..... Vol. 2_585
embedded DB Vol 1 629
EmbeddedDatabase .... . Vol. 1 632
EmbeddedDatabaseBuilder . Vol 1 632
EntityManager ..... Vol. 2_282
EntityManagerFactory ..... VoI. 2_273 . 274
Environment.getPropertyO ..... Vol. 2_228
equiva1ence partitioning .... . Vol. 1_206
Error Vol 1 283
Errors .... . VoI. 2_496, 568
event listener Vol 2 77
Exception .. ... Vol . 1_284
exception translation .. .. . VoI. 1_288
excludeFilters Vol 2 204
execute Vol 2 257. 260
executeAndRetumKey ..... Vol. 2_258
executeAndRetumKeyHolder .... . Vol. 2_259
executeFunction ..... Vol. 2 260
execute。이
ect .... . Vol . 2_260
executionO .. .. . VoI. 2_686
exporter .. ... VoI. 2_753
Expression ..... VoI. 2_748

ExpressionParser ... .. Vol. 2_748
extract method ..... VoI. 1 64

F

factory .... . Vol. 1_88
factory method pattem .. .. . Vol . 1_67
FactoryBean ..... Vol. 2_ 187
factory -method ..... VoI. 2_ 188
fake object ..... Vol. 2_543
fallback Vol 1 534
fat service layer ..... VoI. 1_795
field injection ... .. VoI. 2_ 120
fieldDefaultPrefix VoL 2 567
fieldMarkerPrefix ..... Vol. 2 565
FilterType.ASSIGNABLE_TYPE ..... Vol. 2_203
fixedDelay .... . VoI. 2_763
fixedRate VoL 2 764
fixture ..... Vol. 1 182
Flash Map Manager ..... VoI. 2_452
flush Vol 2 725
form 태그 ..... Vol. 2 584
Formatter ..... Vol. 2_549, 555
FormattingConversionService .. .. . Vol. 2_555
FormHttpMessageConverter ..... Vo l. 2_609
FreeMarkerView ..... Vol. 2 428
FreeMarkerViewResolver Vol 2 437
front controller .. ... Vol. 2 357

G

GenericConversionService VoL 2 561
GenericXmlApplicationContext ..... Vol. 2_64
getBeanO ..... Vol. 2_ 131

찾아보기 867


getContentAsStringO ... .. Vol. 2_394
getContextO ..... VoI. 2_395
getLastModifìed .. .. . VoI. 2_406
getModelAndViewO ..... VoI. 2_394
getValidatorO … .. Vol. 2_663
global state .. ... VoI. 1_ 108
global transaction .... . Vol. 1_366

H

HandlerAdapter ..... Vol. 2_363
HandlerExceptionResolver ..... Vol. 2_364
Handlerlnterceptor ..... VoI. 2_415
HandlerMapping ..... Vol. 2_363
HandlerMethod ..... VoI. 2 638
HandlerMethodArgumentResolve ..... Vol. 2_658
HandlerMethodRetumValueHandler ..... Vol. 2_658
HeadersRequestCondition ..... VoI. 2_648
hibemateProperties ..... VoI. 2_295
HibemateTemplate ..... VoI. 2_298
HibemateTransactionManager ..... Vol. 2_297. 307
high coherence and low coupling ..... Vol. 1_85
HTTP lnvoker ..... VoI. 2 754
HTTP 요청 방법 ..... VoI. 2_647
HTTP 헤더 ..... VoI. 2_470
HttpRequestHandler ..... Vol. 2_400
HttpRequestHandlerAdapter ..... VoI. 2_400
HttpServletRequest ..... Vol. 2_486
HttpServletResponse ..... Vol . 2_486
HttpSession ..... Vol. 2_486

iBatis ..... Vol. 2 263
id ..... Vol. 2 182

identifìer ..... VoI. 2 182
ImportAware ..... Vol. 2_779
ImportBeanDefìnitionRegistrar ..... VoI. 2_785. 787
ImportSelector ..... VoI. 2_785
initialization method ..... Vol . 2_185
InitializingBean ..... VoI. 2_ 186
init-method ..... Vol. 2_ 186
inner bean ..... VoI. 2_86
InputStream ..... Vo1. 2_487
insertO ..... Vol. 2_268
InstrumentationLoadTimeWeaver ..... Vo1. 2_281
Interface Segregation Principle ..... Vol. 1_619
Intema1ResourceView ..... VoI. 2_425
IntemalResourceViewResolver .... . VoI. 2_375. 436
introduction ..... Vol. 2_697
Inversion of Contro1 VoL 1 88
InvocationHandler .. .. . Vol . 1 446
IoC 컨테이너 ..... Vol. 1_102; VoI. 2_51
IoC 컨테이너 계충구조 ... .. Vo1. 2_67
IoC 컨테이너 구성 ..... Vo1. 2_72
isolation . VoL 2 327
isolation level ..... VoI. 1_515

Java Transaction API .. VoL 1 366
JavaBean ..... Vol. 1 55
JavaMail VoL 1 380
JAXB ..... VoI. 1_568. 597
Jaxb2RootElementHttpMessageConverter

VoL 2 609
JDBC ..... Vol. 2 243
JdbcTemplate ..... Vol. 1_259
JDNI VoL 2 242
JmsTransactionManager ..... VoI. 2_307


JNDl VoL 2 224
join point ..... Vol. 1_508
JPA VoL 2 271
JPA 예외 변환 ..... Vol. 2 289
JpaTemplate ..... Vol. 2_282. 283
JpaTransactionManager ..... VoI. 2_306
jpaVendorAdapter ..... Vol. 2_278
JSON VoL 2 611
JSP EL ..... VoI. 2 585
JSP 뷰 ..... VoI. 2_584
JSR-250 Common Annotations for the Java Platform

VoL 2 186
JSR-303 VoL 2 501
JSR-303 빈 검증 ... VoI. 2_574
JstlView VoL 2 425
JTA ... .. Vol. 1 366; Vol. 2 336
JTATransactionManager .... . Vol. 1_372
JtaTransactionManager ..... VoI. 2_297, 307
JUnit VoL 1 157. 161

ι

LastModified .... . Vol . 2 406
leaming test ..... Vol . 1_ 197
loadtime weaver VoL 2 280
loadtime weaving ..... Vol. 2_280
loadtimeWeaver ..... VoL 2 279
local transaction ..... VoI. 1_355

Lo야ca외IContainerEntityManagerFactoryBean

VoL 2 275
Locale ..... Vol . 2_426, 487
LocalEntityManagerFactoryBean ..... Vol. 2_273
LocaleResolver VoL 2 365. 450
localization ..... VoI. 2 426
LocalSessionFactoryBean ..... Vol. 2_293, 343

LocalSessionFactoryBuilder ..... Vol. 2_344
local-slsb ..... VoI. 2 758
LTW VoL 2 671

M

MANDATORY . VoL 2 326
Map .... . VoI. 2_490
MappingJacksonHttpMessageConverter

VoL 2 610
MappingJacksonJsonView .. .. . Vol . 2_435
mappingLocations ..... VoI. 2• 295
MapSqlParameterSource ..... VoI. 2_249
Marshaller VoL 2 750
marshalling ..... Vol . 1_572
MarshallingHttpMessageConverter .... . Vol. 2_610
MarshallingView .... . Vol . 2_429
Member VoL 2 336
MessageCodeResolver ..... Vol. 2_576
MessageSource ..... Vol. 2_578
mock 。이
ect ..... Vol . 1 394
MockH ttpServletRequest ..... Vol. 2_380
MockHttpServletResponse ..... Vol. 2_381
MockHttpSession ..... Vol. 2_381
Mockito 프레임워크 ..... VoI. 1 426
MockServletConfig ..... Vol. 2_382
MockServletContext ..... Vol. 2 382
Model .... . Vol. 2_490
ModelAndView VoL 2 504
ModelAndViewResolver .. .. . Vol. 2 625
ModelMap .. .. . Vol. 2_490, 508
MVC 아키택처 ..... Vol. 2 357

잦아'!i!7
1 869


N

name ..... Vol. 2_ 183
NameMatchMethodPointcut ..... Vol. 1_479
NativeWebRequest ..... Vol. 2_486
NESTED Vol 2 326
nested exception ..... VoI. 1_289
NEVER Vol 2 326
F‘loOpCacheManager ... .. Vol. 2_774
noRollbackFor ..... Vol. 2 329
no-rollback-for ..... VoI. 2_329
noRollbackForC lassName ..... Vol. 2_329
NOT SUPPORTED .. .. Vol 2 326
NotTransactional ..... Vol . 1 553
Null ... .. Vol. 2 147

o

ObjectFactory ..... Vol. 2_ 170
ObjectFactoryCreatingFactoryBean ..... Vol. 2_ 170
OC4JJtaTransactionManager ..... Vol. 2_341
OCP(Open-Closed Principle) … Vol. 1_83
order ..... VoI. 2 412
OutputStream ... .. VoI. 2_487
OXM ..... Vo1. 1 597; VoI. 2 749

P

packagesToScan ..... Vo1. 2_297
ParamsRequestCondition ..... Vol. 2_648
PatternsRequestCondition ..... Vol. 2_646
PCD ..... Vo1. 2 685
PerisistentProvider ..... Vol. 2_273
persistence.xml ..... VoI. 2_274
PersistenceContextType. EXTENDED ..... Vo1. 2_289

persistenceUnitName .... . Vo1. 2_277
persistenceXm1Location ..... VoI. 2 277
p1aceholder ..... Vol. 2_ 149
PlatformTransactionManager ..... Vo1. 1_372;

Vol.2 303
Pointcut Designator ... .. VoI. 2_685
pointcut expression ... .. VoI. 1_489
POJO ..... VoI. 1_732 , 734; VoI. 2_53
Post/ Redirect/Get 패턴 .... . Vo1. 2_453
postHandle ..... Vol. 2_415
preHandle ..... Vol. 2_415
printBeanDefinitionsO .. ... Vol. 2_ 196
ProducesRequestCondition ..... Vol. 2_649
programmatic transaction ..... VoI. 1_541
propagation ..... Vol. 2_325
Propagation.NEVER ..... Vol. 1_553
PROPAGATION NOT SUPPORTED

. VoI. 1 515
PROPAGATION_REQUlRED .. ... Vol. 1_514
PROPAGATlON_REQUlRES_NEW ..... VoI. 1_515
PropertyEditor .. .. . VoI. 2_ 141 , 527
PropertyPlaceHolderConfigurer ..... Vol . 2_ 149
PropertySourceConfigurerPlaceholder ... .. Vol. 2_229
PropertySourcesPlaceholderConfigurer

. Vol. 1 699
Provider ..... Vol . 2 175
proxy ..... Vol. 1_430; Vol. 2_755 , 676
ProxyFactoryBean ..... Vol. 1_462
proxy-target-class ..... Vol. 2_181

Quartz ..... Vol. 2 759
query ..... Vol. 1_266; Vol. 2_253
queryForlnt ... .. VoI. 1_262; Vol. 2_251


queηForList ..... Vol. 2 254. 269
queryForLong ..... Vol. 2_252
queryForMap ..... Vol. 2_253 . 270
queryForObject ..... Vol. 1_264; Vol. 2_269. 252
queryWithRowHandler .. .. . Vol . 2_270

R

readonly ..... Vol. 1_516
READ COMMITTED .... . Vol. 2 328
READ UNCOMMITTED Vol 2 327
Reader Vol 2 487
RedirectAttributes ..... Vol. 2 654
RedirectView Vol 2 427
refactoring .... . Vol. 1_64
remote-slsb Vol 2 758
REPEATABLE READ Vol 2 328
request condition ..... Vol. 2_642
RequestMapping 전략 ..... Vol. 2_633
RequestMappingHandlerAdapter ... .. Vol. 2_650
RequestMappingHandlerMapping ..... Vol. 2_64 1
RequestMethod ..... Vol. 2368
RequestMethodsRequestCondition .. ... Vol. 2_647
RequestToViewNameResolver ..... Vol. 2_507
RequestToViewNameTranslator ..... Vol. 2_365. 452
REQUlRED .... . Vol. 2_326
requiredFields ..... Vol. 2_564
REQUIRES_NEW ..... Vol. 2_326
Resource ..... Vol . 1_611.614
ResourceBundleViewResolver ..... Vol. 2 438
ResourceLoader ..... Vol. 1_613; Vol. 2_154
ResponseStatusExceptionResolver ..... Vol. 2_448
RESTful ..... Vol. 2 756
RestTemplate ..... Vol . 2_757
returningResultSet ..... Vol. 2_259

rich domain 。이
ect ..... Vol. 1 807
ROLE APPLlCATlON . Vol 2 197
ROLE IN FRASTRUCTURE .... , Vol. 2 197
ROLE_SUPPORT ..... Vol. 2_ 197
rollbackFor Vol 2 329
rollback-for .. .. . Vol. 2 329
rollbackForClassName . Vol 2 329
RuntimeException ..... Vol. 1_284

s

scanning .... . Vol. 2_89
scope ..... Vol. 1_ 111 ; Vol. 2_ 157
Scoped Proxy ..... Vol. 2_ 179
ScopedProxyMode.INTERFACES ..... Vol , 2_ 180
ScopedProxyMode.TARGET_CLASS ..... Vol. 2_ 180
Separation ofConcerns ..... Vol. 1_61
SERlALlZABLE ..... Vol. 2 328
Service Oriented Front End Architecture

Vol 1 788
ServiceLocatorFactoryBean ..... Vol. 2_ 172
ServletContextListener ..... Vol. 2 77
Session ..... Vol. 2_298
SessionAttributeStore .. ,., Vol. 2 622
SessionFactory .. ... Vol. 2_293
SessionFactory.getCurrentSessionO ..... Vol. 2_300
SessionStatus ..... Vol , 2_499. 510
setter ..... Vol. 2_ 118
SimpleCacheManager ..... Vol. 2_773
SimpleControllerHandlerAdapter ..... Vol. 2_373.

401
SimpleDriverDataSource ..... Vo1. 2_241
SimpleJdbcCall ..... Vol. 2_244. 259
SimpleJdbcInsert .. ... Vol. 2_244. 255
SimpleJdbcTemplate ..... Vol. 2_244. 246

찾아보기 871


SimpleMappingExceptionResolver ..... Vol. 2_449
SimpleServletHandlerAdapter ..... Vol. 2_398
SimpleThreadPoolTaskExecutor ..... Vol. 2_760
SimpleUrlHandlerMapping ..... Vol. 2_410
Single Responsibility Principle ... .. Vol. 1_377
SingleConnectionDataSource ..... Vol. 2_241
Singleton Pattern ..... Vol. 1_106
singleton registry ... .. Vol. 1_ 108
smart domain object ..... Vol. 1_807
SOFEA . . . VoL 1 788
SOLl D ... .. Vol. 1 84
SourceHttpMessageConverter ... .. Vol. 2_609
SpEL ..... Vol. 2_ 151 , 746
SpelExpressionParser ..... Vol. 2_748
Spring Expression Language ..... Vol. 2_ 151
Spring Faces ..... Vol. 2_352
Spring JavaScript .. ... Vol. 2_352
Spring Web Flow ..... Vol. 2_351
Spring Web Service ..... Vol. 2_352
sprmg 태그 .. ... Vol. 2 588
SpringIDE ..... Vol. 1_761
SpringSoruce Tool Suite ..... Vol. 1_759
SQL 따라미터 ... .. Vol. 2_248
SqlMapClient ... .. Vol. 2_264
SqlMapClientCallback ..... Vol. 2_270
SqlMapClientFactoryBean ..... Vol. 2_266
SqlMapClientTemplate .. ... Vol. 2_267
SqlParameterSource ..... Vol. 2_250
StandardServletEnvironment .. .. . Vol . 2_232
stateful session bean VoL 2 289
Statement ., .. , Vol. 2 245
StaticApplicationContext ..... Vol. 2_57, 60
stored function .. ... Vol . 2 259
stored procedure ..... Vol. 2_259
Strategy Pattern ..... Vol. 1_87

StringHttpMessageConverter ..... Vol. 2_608
supportedMethods .... . Vol . 2_402
SUPPORTS .. ... Vol. 2 326
synchronizeOnSession . .... Vol. 2_402
systemEnvironment ..... Vol. 2_ 155
systemProperties .. ... Vol. 2_ 155

target ..... Vol. 1_430; 2_687
task . VoL 2 759
task 네임스페이
스 ..... Vol, 2_762
TaskExecutor ..... Vol. 2 759
TaskScheduler VoL 2 760
tcServer .. ... Vol. 1_756
TDD(Test Driven Development) ... .. Vol. 1_ 176
template .... . Vol. 1_241
template method pattern ..... Vol. 1_67
Test First Development ..... Vol. 1_176
ThemeResolver ..... Vol. 2 365
this VoL 2 687
ThreadPoolExecutor ..... Vol. 2 760
ThreadPoolTaskScheduler .... . VoL 2 761
TilesView .... . Vol. 2_435
timeout ..... Vol. 1 516
TimerManagerTaskScheduler ..... Vol. 2_761
transaction commit ..... Vol. 1 354
transaction demarcation ..... Vol. 1_355
transaction propagation ..... Vol. 1_513
transaction rollback .. ... Vol. 1 354
transaction synchronization ..... Vol. 1_361
TransactionAdvice ... .. Vol. 1 470
TransactionalEssentials ..... Vol. 2 338
TransactionDefinition VoL 2 311
Transactionlnterceptor .. .. . Vol. 1_517


try/catch/fìnally ..... Vol. 1_214
tx 네임
스페이
스 ….. Vo1. 1_520

μ

unchecked exception ..... Vol. 1_284
unit test .. ... Vol. 1 149
Unmarshaller ... .. Vol. 2_750
unmarshalling ..... Vo1. 1_572
updateO ..... vc이 1_260; 'v\이 2 268
UriComponentsBui1der ..... Vol. 2_652
URL VoL 2 626
URL 패턴 .. ... Vo1. 2_467, 646
useCacheContro1Header ..... Vol. 2_402
useCacheContro1NoStore .. ... Vo1. 2 402
useExpiresHeader ..... Vo1. 2_402
usingCo1umns ..... Vo1. 2_257
usingGeneratedKeyCo1urnns ..... Vol. 2_257

validator ..... Vo1. 2_568, 619
Ve10cityView ..... VoL 2_428
Ve1ocityViewReso1ver ..... Vol. 2_437
view ..... Vo1. 2_424
ViewReso1ver ..... Vol. 2_364, 435

WebApp1icationContext ..... Vol. 2_64
WebApp1ication1nitia1izer .. ... Vo1. 2_456
WebArgumentReso1ver ..... Vo1. 2_623, 624
WebBindinglnitia1izer ..... Vo1. 2_537

WebDataBinder VoL 2 563
WebLogicJtaTransactionManager ..... Vol. 2_341
WebMvcConfìgurer .... . Vol. 2_659. 666
WebRequest ..... Vol. 2_486
WebSphereUowTransactionManager ..... Vol. 2_341
withCata10gName ..... Vol. 2_256
withFunctionName ..... Vol. 2_259
withinO .. ... Vol. 2_686
withoutTab1eCo1umnMetaDataAccessO

VoL 2 257
withProcedureName ..... Vol. 2_259
withSchemaName ..... Vo1. 2 256
withTab1eName . VoL 2 256
WorkManagerTaskExecutor .. ... Vol. 2_760
Writer .. . VoL 2 487

XA DataSource ..... VoL 2 339
XML 설정 ... .. Vo1. 1_129
Xm1ViewReso1ver ..... Vo1 . 2 438
Xm1WebApp1icationContext .. ... Vol. 2_79
Xs1tView ..... Vol. 2_435

찾아보기 873


series editor 이일민

짧 에이콘 오픈소스 프로그래밍 시리즈


오픈소스 BSD 룰아온 전설

Michael 니JCaS 지음 | 신웅현， 이정문 옳김
g썼9975360 1584쪽 1200동11
--<l7 128.α)()원

‘오푼소스 BSD 돌아온 전설’은 완벽한 FreeBSD 안내서다. FreeBSD의 설치. 보안. 네트워크 서
비스， 시스탱 성능 튜닝， 커널 설정， 파일시스템
. SMP. 업그레이드， 디버깅 둥 광범한 주제를 다
룬다 이 책은 초보 유닉스 관리자룰 대상으로 한다.


이클립스요슬램프

Java의 마법에 빠져볼까?

David Gal떠rdo 지음 | 김기영 옳김

g웠
9975409 1517쪽 12004--{)4-16 125.α)()원

Eclipse툴 기반으로 한 Java 프로그래밍에 초점을 맞추고 있다-이 책은 Eclipse를 완전히 터득

할 때 반드시 알아야 할 큰 밑그림을 제시하고. 그에 맞최 사실을 설명한다 JUnit. Ant. CVS와 같
이 타lipse에 통합된 오픈소스 톨뿐 아니
라 웹 개발 플러그인의 사용방법도 다루고 있다


톰켓최종분석

Budi Kurniawan 외 지음 l 이태상 옮김
g용997앉5651458쪽 12OO5--<l3--<l2 1 28.000원

‘톰켓 최종분석’은 아파치 톰갯 서블릿 엔진의 정확한 작동원리를 정확하게 설영한다. 톰갯의 사
용 방법
(how to use Tomcat)OI 아닌， 톰갯의 작동 원리
(how Tomcat works)률 설명하는 유일한
책이다. 톰갯 4와 5를 해부해 각 커포넌트의 내부 작동원리를 파헤쳐본다.


서브버전

실무자가 꼭 알아야 할 차세대 버전 관리 시스템

Garrett R，∞ney 지음 | 허영주 옳김

없쨌7강271 정4쪽 12005녁)6-30 119.000원

이 책에서는 실무자가 목 알아야 할 서브버전의 기능과 활용법을 소개하고 여러분의 자산인 소스

코드와 버전을 완벽관리할 수 있는 방법을 파헤쳐줄 것이다.


10
1
7f지 여|제로 정복하는
셀스크립트
Dave Taylα 지음 | 여인춘 옮김 | 강호관 감수
g￥19975735 1352쪽 12005애9-26125.α)()원

셀은 자신의 컴뮤터와 대화할 수 있는 효율적인 방법을 제공한다 딘지 몇 줄의 셀 코드로， 검뮤
터는 사용자가 원하는 일을 정확히 수행할 수 있다 시스템 관리 시간을 절약하거나 시간을 보낼
새로운 방법을 찾고 있다연
， 이 책에 수록된 스크립트들의 매력에 분명 사로잡힐 것이다!


루씬인액션
오푼소스자바검색맨진

Erik Hatcher. Otis Gosα:Jd
netic 지음 | 강철구， 이문호， 주성진 옮김
얹l89975재61480쪽 1200운10-15 130.000원

루씬은 확장성이 출고 빠른 검색엔진이며 성능이 아주 훌륭하고 사용하기도 너무나 간편해서
. 여
러 오푼소스 프로젝트 중에서도 보석 같은 존재이며 루씬을 시용하는 데 목 필요한 필독서다

리녹스 디버깅과 성능튜닝
오푼소스 도구를 사용한 문제 진단 분석과 해결

Steve Best 지음 | 박재호， 이해영 옮김
g꼈9975867 1432쪽 12α)6-02-14 125.000원

리둑스 커널과 응용프로그램 생산성을 극대화하려는 모든 개발자는 물론이고. 리녹스 안정성과
성능 문제를 해결해야 하는 시스템 관리자와 지원 전문가에게 반드시 필요한 책이다.

리불스문제분석과해결
아무도 가르쳐주지 앓댔던 리녹스 실전 노하우

Mark 에Idir빙. Dan Behman 지음 | 박재호， 이해영 옳김
앉쨌1.37딪199 1472쪽 | 잉06-00---28 128.000원

리북스 환경에서 발생하는 문제를 효과적이면서 효율적으로 진단하는 방법을 다룬다-우수한 조
사 기법을 소개하고. 리녹스가 제공하는 가장 중요한 문제 진단 분석과 해결 도구의 사용법을 상
세히다루는책이다.

스프링인액션
오픈소스 자바 Id:;/AOP 프레임워크

Craig Walls. Ryan Breidenbach 지음 | 이태상 옳김
얹췄9975751 1472쪽 12006--11-20 130.αm원

이 책은 스프링울 개념부터 철저하게 파헤치고 차근차근 제대로 배울 수 있으며
. 책을 읽으면서
제어 역행(loC)과 관접지항 프로그래밍
(AOP) 개념을 체득하여 스스로 느끼게끔 이물어 줄 것이
다 또한 예제를 단계별로 확장해 강으로써 실전에서 바로 활용할 수 있는 코드를 배울 수 있다，

리불스실전가이드

Mark G. S。∞11
지음 1 허영주， 한정애 옳김

97æ쳤킷975915 11
.
016쪽 12007키)6-30 135.α)()원

과거는 잊어라. 이보다 더 쉽고 완벽한 리북스 책은 더 이상 없다l 수백 개에 달하는 수준 높은 예
제와 함께 모든 리불스 배포판을 다루는 매우 유용한 리둑스 지침서| 수준 높고 실질적인 예제로
가득한 뛰어난 리녹스 참고서이자 이해하기 쉬운 실용 가이드북으로 80개가 넘는 코어 유틸리
티， 셀 프로그래밍
， 펀집기， 프로그래밍 툴에 대한 내용을 모두 다룬다. 강력한 리녹스 커맨드 라
인을 마스터하여 진짜 리둑스 전문가가 되자.


스트릿츠2
프로그래밍

현철주， 정광선， 민상기 지음

11

9염8æiJ770엉:;' 1
808쪽 | ∞08--01매3140.000원

개발 환경 세팅부터 스트렷츠의 주요 개녕과 아키텍처. 태그뿐만 아니라 다양한 기능돌을 예제를
통해 학습할 수 있도록 구성되었다. 이 책올 통해서 엉게 스트렷츠2 개발 환경올 구촉하고. 다앙
한 스트렷츠2의 기능돌을 활용해 불 수 있올 것이다


초보 시스랩 관리자를 위한
크노픽스

12

신재훈 지음 19πB앉ìOη'04541424쪽 12008-05-19 140.αm원

설치가 필요 없는 라이브 CD 운영체제이자 인기 있는 리불스 배포판 크노픽스률 낱낱이 해부한
국내 최초 크노픽스 서적! 크노믹스 효띨 프로젝트톨 이블어온 저자가 직접 저솔한 초중급 시스
템 관리자를 위한 크노픽스 가이드


리녹스 시스템 관리 완벽 가이드

에비 네메스， 가쓰 스나이더， 트렌트 R 하인 지음

13

강호관， 김성훈， 박재호， 신재훈. 전헤란， 황정동 옮김
9π혔앉ì0771024 11.180쪽 12009-10-21 150.000원

예를 위한 예톨 설명하기보다는， 현장과 실무에서 사용하는 각종 리둑스 시스탱 관리 기업을 소
개하는 완벽 가이드， 대규모 대학과 회사의 리둑스 시스탱 환경에서 사용하는 실제 구성과 환경
설정파일을옳수있다

토비의스프링
3
스프링 프레임워크 3 기초 원리부터 고급 실전활용까지 완벽 가이드(절판)
이일민 지음 19788960η146811쩌6쪽 1201
0-애8애9150‘
000원

:‘、
.‘""
.
’l‘

T'ß'’.•-대한민국 전자정부 표훈 프레임워크 기솔로 선정된 스프링의 국내 최고 권위자 토비 이일민이 저

씨.，
r'.
~ØII
I

‘ ßa . 솔한 스프링 프레임워크 3 프로그래밍 완벽 바이블 스프링을 처음 접하거나 스프링울 경험했지
만 스프링이 어렵게 느껴지는 개발자부터 스프링을 훨용한 아키택처톨 설계하고 프레임워크를
개발하려고 하는 아키텍트에 이르기까지 모두 침고할 수 있는 스프링 종합 안내서다.


Nginx HTTP Server 효펙어판
아파치를 대체할 강력한 차세대 HπP 서버 엔진엑스

15

블레망 네델꾸 지음 | 김득권 옳김 19:;'훌1960π231314잃쪽 12011-10-12 130
.
000원

이 책은 기초적인 리녹스 커맨드라인 인터떼이스에서 시작해 엔진엑스 소스코드를 다운로드. 빌
드. 설치하는 과정뿐만 아니라 주요 모률과 모든 지시어의 상세한 설명
， 구문 용례， 색인 목록까
지 앙라함으로써 엔진엑스 관리자의 필독서로 휠용할 수 있다. 또한 엔진엑스 자체에 관한 설영
외에도 엔진엑스와 기존 HTIP 서버률 병행해 시용하는 법
. FastCGI톨 통해 애풀리케이션과 연
동하는 법， 아파치에서 엔진액스로 서버톨 완전히 교체하기 위한 마이그레이션 가이드 둥이 함께
제공되므로 아파치의 운제접율 극복할 대안을 찾는 모든 웹 관리자에게 꼭 필요한 책이다

깨

관


‘ 악‘스AJ'1
11
5!.f’것 •

'1효리혹스
API

16

""-“““그‘


리‘스AP1~...，혀 _.

고를리혹스
API

17 -’‘‘.....

••
””

A@

19 ~‘
““

1A

잉
-


E

t~ æ1;' ’‘ ~. O
!~
0"'
!!Q
.o‘
::!.ι+

18

토비의스프링
3.
1

''''''~
때l辯

i‘ ” !
@ %A r+

”

토비의스프링
3.
1

，，~~메
l렐

;/lr.ll r’.


리불스 API의 모든 것 Vol. 1 기초 리불스 API
파일， 메모리， 프로세스. 시그널， 타이
머

마이클 커리스크 지음 ! 김기주， 김영주. 우정은， 지영민. 채원석
， 황진호 옳김
9788960η3
1
96
11，
1∞쪽 12012-07-12 150.α)()원

리둑스에서 프로그램을 작성할 때 사용하는 시스템 호출과 라이브러리 함수훌 설명한 책으로. 해
당 힘수를 사용할 수 있는 리놀스 버전. 버전별 차이 둥율 꼼꼼하게 정리했다. 워닉 방대한 내용
이라 1권과 2권으로 나눠 구성했으며
.1권은 기초편으로， 리북스 프로그래밍에서 혼히 쓰이는 파
일 관리
. 메모리 관리
， 프로세스 관리
. 시그널 처리
. 타이머 사용법 등을 다룬다.

리녹스 API의 모든 것 Vol. 2 고릅 리녹스 API
스레드，
IPC， 소켓， 고급 1/0
마이클 커리스크 지음 | 김기주， 김영주， 우정은. 지영민， 채원석， 황진호 옮김
9788960π32021852쪽 12012-07-12 135.000원

리북스에서 프로그램을 작성할 때 사용하는 시스템 호출과 라이브러리 함수훌 설명한 책으로 해
당 함수률 사용할 수 있는 리둑스 버전， 버전별 차이 둥을 몸꼼하게 정리했다. 워냥 방대한 내용
이라 1권과 2권으로 나눠 구성했으며
，
2권은 고급편으로， 좀 더 세련되고 복잡한 리녹스 프로그램
을 만들 때 사용되는 스레드 관리，
IPC 사용법
， 소켓 사용법 등을 다룬다.

토비의 스프링 3.1 Vol. 1 스프링의 이해와 월리

이일민 지음 19자였잊ìOπ3417
1 없O쪽 12012냉9-21 140，α)()원

딘순한 예제톨 스프링 3.0과 스프링 3
.
1의 기술을 적용하며 발전시켜 나가는 과정을 통해 스프링
의 핵심 프로그래밍 모댈인 loC/DI. PSA, AOP의 원리와 이에 적용된 다양한 디자인 때턴. 프로
그래밍 기법울 이해할 수 있게 도와준다 이어지는 (Vol, 2 스프링의 기솔과 선택)에서 상세히 소
개하는 스프링 3.
0과 스프링 3.
1
의 방대한 기솔을 엉게 이해하고 효과적으로 응용하는 데 필요한
기반 지식을 쌓도록 도와준다

토비의 스프링 3.1 Vol. 2 스프링의 기술과 선택

이일민 지음 19788960η경241 없O쪽 12이
2-0뚱21140，
000원

ML 대신 자바 코드률 이용해서 스프링을 개발할 수 있는 최신 빈 설정 기업부터 펀리한 RESTful
스타일의 웹 컨트롤러 작성 기법까지 스프링 3
.
0과 스프링 3
.
1의 최신 기술울 상세하게 소개하고
그중에서 자신에게 맞는 최적의 기솔율 선택하고 조합할 수 있는 기준과 활용전략을 다룬다.


‘* 에이콘출판의 기틀을 마련하신 故
정완재 선생님 (1 935-2004)


토비의 스프링 3.1 I Vol. 11 스프링의 이해와 원리

인 쇄 I 2012년 9월 12일
밭 행 I 2012년 9월 21
일

지은이
|
이일민

펴낸이 | 권성준

엮은이
|
김회정

김경회

황지영

표지디자인 | 그린애플
본문디자인 | 박진회

인 쇄 I (주)갑우문화사
용 지 | 진영지업
(주)

에이콘출판주식회사

경기도 의왕시 내손동 757-3 (437-836)
전화 02-2653-7600, 팩스 02-2653-0433
www.acornpub.co.kr / editor@acornpub.co.kr

Copyright @ 에이콘출핀주식회사，
2012， Printed in Korea .
ISBN 978-89-5077-341-7
ISBN 978-89-5077-103-1 (세트)
http://www.acornpub.co.kr/book/toby-spring3.1-voll

이 도서의 국립중앙도서관 출판시도서목록
(
CIP
)은 e-ClP 홉페이지
(
http
://www 미 gO
.
kr/c
ip.php
)에서

이용하실 수 있습니다 (
CIP제어번호 2012004174)

책값은 뒤표지에 있습니다


Er:JJ; ;

.. -.. '갓부록 CD 소개

1.톨더 및파월설명
, Vol1 -30 폴더: Spring 3.0 ,
Vol1 -31 폴더: Spring 3.1 ,
Vo12-30 폴더: Sp디ng 3.0 ,
Vo12-31 폴더 : Spring 3.1 단계별
Vol.l 예제 프로젝트(총
52
개)
단계별 Vol. 1 예제 프로젝트(총
58
개)
Vol. 2 예제 프로젝트
Vol. 2 예제 프로젝트

'DB 폴더: 예제를 위한 MySQL 데이터베이스 스크립트
, Springusergroup: 스프령 @MVC 예제 프로젝트
, readme.txt: 상세한 예제 설치 방법과 환경 설정 방법이 담긴 따일

2.
프로그램설치방법
책의 예제를 실행하기 위해서는 JDK, MySQL, STS가 준비되어 있어야 한다. 이 세 가지는 CD
에 포함되어 있지 않으므로 다음 웹사이트에서 디운로드 받아서 설치해야 한다.

• JDK 6: htφ://java. sun. com/javase/ downloads/index.jsp에서 사용히는 OS
에 맞는 JDK 최
신 버전올 다운로드 받아서 설치한다. 책의 예제는 JDK6U때ate 35에서 테스트했다.
• MySQL: htφ://www.mysql.
com/downloads/mysql/에서 MySQL 5.1 버전옳 다운로드 받
아서 설치한다. 설치 후 설정 방법과 데이터베이스 퉁록 방법은 readme.txt 따일에 자세히 설명
되어있다.
• STsSpri때없Jr∞ TooI Suite: http://www.springsource.com/products/sts에서 사용하는 OS에 맞
는 SpringSource Tool Suite 최신 버전을 다운로드 받아서 설치한다. 책의 예계는 STS 2.9.2
버전에서테스트했다.
3, 빼채 프로책트 셜치 방법

예제 프로젝트는 하드디스크로 복사한 뒤에 STS의 [File] >[Import] >[Existing Pr，이
ects into
Workspace] 메뉴를 이용해 가져오면 된다. 한 번에 한 개 이상의 프로젝트를 가져올 수도 있다.
프로젝트를 한글 이름으로 된 폴더 아래로 복사할 경우에는 OS에 따라서 일부 예제가 바르게 동
작하지 않을 수 있으므로 가농한 한 영분폴더 밑에 복사한다.


